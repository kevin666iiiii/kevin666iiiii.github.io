;(function () {
  const e = document.createElement('link').relList
  if (e && e.supports && e.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r)
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === 'childList')
        for (const o of s.addedNodes)
          o.tagName === 'LINK' && o.rel === 'modulepreload' && i(o)
  }).observe(document, { childList: !0, subtree: !0 })
  function t(r) {
    const s = {}
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : r.crossOrigin === 'anonymous'
        ? (s.credentials = 'omit')
        : (s.credentials = 'same-origin'),
      s
    )
  }
  function i(r) {
    if (r.ep) return
    r.ep = !0
    const s = t(r)
    fetch(r.href, s)
  }
})()
var Ku =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {}
function Bx(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, 'default')
    ? n.default
    : n
}
function OU(n) {
  if (n.__esModule) return n
  var e = n.default
  if (typeof e == 'function') {
    var t = function i() {
      return this instanceof i
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments)
    }
    t.prototype = e.prototype
  } else t = {}
  return (
    Object.defineProperty(t, '__esModule', { value: !0 }),
    Object.keys(n).forEach(function (i) {
      var r = Object.getOwnPropertyDescriptor(n, i)
      Object.defineProperty(
        t,
        i,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return n[i]
              },
            },
      )
    }),
    t
  )
}
var g1 = { exports: {} },
  Ip = {},
  v1 = { exports: {} },
  Mn = {}
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var pA
function kU() {
  if (pA) return Mn
  pA = 1
  var n = Symbol.for('react.element'),
    e = Symbol.for('react.portal'),
    t = Symbol.for('react.fragment'),
    i = Symbol.for('react.strict_mode'),
    r = Symbol.for('react.profiler'),
    s = Symbol.for('react.provider'),
    o = Symbol.for('react.context'),
    a = Symbol.for('react.forward_ref'),
    c = Symbol.for('react.suspense'),
    u = Symbol.for('react.memo'),
    h = Symbol.for('react.lazy'),
    m = Symbol.iterator
  function g(q) {
    return q === null || typeof q != 'object'
      ? null
      : ((q = (m && q[m]) || q['@@iterator']),
        typeof q == 'function' ? q : null)
  }
  var y = {
      isMounted: function () {
        return !1
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    _ = Object.assign,
    M = {}
  function w(q, oe, _e) {
    ;(this.props = q),
      (this.context = oe),
      (this.refs = M),
      (this.updater = _e || y)
  }
  ;(w.prototype.isReactComponent = {}),
    (w.prototype.setState = function (q, oe) {
      if (typeof q != 'object' && typeof q != 'function' && q != null)
        throw Error(
          'setState(...): takes an object of state variables to update or a function which returns an object of state variables.',
        )
      this.updater.enqueueSetState(this, q, oe, 'setState')
    }),
    (w.prototype.forceUpdate = function (q) {
      this.updater.enqueueForceUpdate(this, q, 'forceUpdate')
    })
  function x() {}
  x.prototype = w.prototype
  function T(q, oe, _e) {
    ;(this.props = q),
      (this.context = oe),
      (this.refs = M),
      (this.updater = _e || y)
  }
  var A = (T.prototype = new x())
  ;(A.constructor = T), _(A, w.prototype), (A.isPureReactComponent = !0)
  var P = Array.isArray,
    D = Object.prototype.hasOwnProperty,
    O = { current: null },
    U = { key: !0, ref: !0, __self: !0, __source: !0 }
  function F(q, oe, _e) {
    var he,
      Ce = {},
      Te = null,
      Pe = null
    if (oe != null)
      for (he in (oe.ref !== void 0 && (Pe = oe.ref),
      oe.key !== void 0 && (Te = '' + oe.key),
      oe))
        D.call(oe, he) && !U.hasOwnProperty(he) && (Ce[he] = oe[he])
    var Be = arguments.length - 2
    if (Be === 1) Ce.children = _e
    else if (1 < Be) {
      for (var et = Array(Be), ft = 0; ft < Be; ft++) et[ft] = arguments[ft + 2]
      Ce.children = et
    }
    if (q && q.defaultProps)
      for (he in ((Be = q.defaultProps), Be))
        Ce[he] === void 0 && (Ce[he] = Be[he])
    return {
      $$typeof: n,
      type: q,
      key: Te,
      ref: Pe,
      props: Ce,
      _owner: O.current,
    }
  }
  function N(q, oe) {
    return {
      $$typeof: n,
      type: q.type,
      key: oe,
      ref: q.ref,
      props: q.props,
      _owner: q._owner,
    }
  }
  function k(q) {
    return typeof q == 'object' && q !== null && q.$$typeof === n
  }
  function z(q) {
    var oe = { '=': '=0', ':': '=2' }
    return (
      '$' +
      q.replace(/[=:]/g, function (_e) {
        return oe[_e]
      })
    )
  }
  var $ = /\/+/g
  function te(q, oe) {
    return typeof q == 'object' && q !== null && q.key != null
      ? z('' + q.key)
      : oe.toString(36)
  }
  function j(q, oe, _e, he, Ce) {
    var Te = typeof q
    ;(Te === 'undefined' || Te === 'boolean') && (q = null)
    var Pe = !1
    if (q === null) Pe = !0
    else
      switch (Te) {
        case 'string':
        case 'number':
          Pe = !0
          break
        case 'object':
          switch (q.$$typeof) {
            case n:
            case e:
              Pe = !0
          }
      }
    if (Pe)
      return (
        (Pe = q),
        (Ce = Ce(Pe)),
        (q = he === '' ? '.' + te(Pe, 0) : he),
        P(Ce)
          ? ((_e = ''),
            q != null && (_e = q.replace($, '$&/') + '/'),
            j(Ce, oe, _e, '', function (ft) {
              return ft
            }))
          : Ce != null &&
            (k(Ce) &&
              (Ce = N(
                Ce,
                _e +
                  (!Ce.key || (Pe && Pe.key === Ce.key)
                    ? ''
                    : ('' + Ce.key).replace($, '$&/') + '/') +
                  q,
              )),
            oe.push(Ce)),
        1
      )
    if (((Pe = 0), (he = he === '' ? '.' : he + ':'), P(q)))
      for (var Be = 0; Be < q.length; Be++) {
        Te = q[Be]
        var et = he + te(Te, Be)
        Pe += j(Te, oe, _e, et, Ce)
      }
    else if (((et = g(q)), typeof et == 'function'))
      for (q = et.call(q), Be = 0; !(Te = q.next()).done; )
        (Te = Te.value), (et = he + te(Te, Be++)), (Pe += j(Te, oe, _e, et, Ce))
    else if (Te === 'object')
      throw (
        ((oe = String(q)),
        Error(
          'Objects are not valid as a React child (found: ' +
            (oe === '[object Object]'
              ? 'object with keys {' + Object.keys(q).join(', ') + '}'
              : oe) +
            '). If you meant to render a collection of children, use an array instead.',
        ))
      )
    return Pe
  }
  function K(q, oe, _e) {
    if (q == null) return q
    var he = [],
      Ce = 0
    return (
      j(q, he, '', '', function (Te) {
        return oe.call(_e, Te, Ce++)
      }),
      he
    )
  }
  function J(q) {
    if (q._status === -1) {
      var oe = q._result
      ;(oe = oe()),
        oe.then(
          function (_e) {
            ;(q._status === 0 || q._status === -1) &&
              ((q._status = 1), (q._result = _e))
          },
          function (_e) {
            ;(q._status === 0 || q._status === -1) &&
              ((q._status = 2), (q._result = _e))
          },
        ),
        q._status === -1 && ((q._status = 0), (q._result = oe))
    }
    if (q._status === 1) return q._result.default
    throw q._result
  }
  var ne = { current: null },
    V = { transition: null },
    Y = {
      ReactCurrentDispatcher: ne,
      ReactCurrentBatchConfig: V,
      ReactCurrentOwner: O,
    }
  function Q() {
    throw Error('act(...) is not supported in production builds of React.')
  }
  return (
    (Mn.Children = {
      map: K,
      forEach: function (q, oe, _e) {
        K(
          q,
          function () {
            oe.apply(this, arguments)
          },
          _e,
        )
      },
      count: function (q) {
        var oe = 0
        return (
          K(q, function () {
            oe++
          }),
          oe
        )
      },
      toArray: function (q) {
        return (
          K(q, function (oe) {
            return oe
          }) || []
        )
      },
      only: function (q) {
        if (!k(q))
          throw Error(
            'React.Children.only expected to receive a single React element child.',
          )
        return q
      },
    }),
    (Mn.Component = w),
    (Mn.Fragment = t),
    (Mn.Profiler = r),
    (Mn.PureComponent = T),
    (Mn.StrictMode = i),
    (Mn.Suspense = c),
    (Mn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y),
    (Mn.act = Q),
    (Mn.cloneElement = function (q, oe, _e) {
      if (q == null)
        throw Error(
          'React.cloneElement(...): The argument must be a React element, but you passed ' +
            q +
            '.',
        )
      var he = _({}, q.props),
        Ce = q.key,
        Te = q.ref,
        Pe = q._owner
      if (oe != null) {
        if (
          (oe.ref !== void 0 && ((Te = oe.ref), (Pe = O.current)),
          oe.key !== void 0 && (Ce = '' + oe.key),
          q.type && q.type.defaultProps)
        )
          var Be = q.type.defaultProps
        for (et in oe)
          D.call(oe, et) &&
            !U.hasOwnProperty(et) &&
            (he[et] = oe[et] === void 0 && Be !== void 0 ? Be[et] : oe[et])
      }
      var et = arguments.length - 2
      if (et === 1) he.children = _e
      else if (1 < et) {
        Be = Array(et)
        for (var ft = 0; ft < et; ft++) Be[ft] = arguments[ft + 2]
        he.children = Be
      }
      return {
        $$typeof: n,
        type: q.type,
        key: Ce,
        ref: Te,
        props: he,
        _owner: Pe,
      }
    }),
    (Mn.createContext = function (q) {
      return (
        (q = {
          $$typeof: o,
          _currentValue: q,
          _currentValue2: q,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        }),
        (q.Provider = { $$typeof: s, _context: q }),
        (q.Consumer = q)
      )
    }),
    (Mn.createElement = F),
    (Mn.createFactory = function (q) {
      var oe = F.bind(null, q)
      return (oe.type = q), oe
    }),
    (Mn.createRef = function () {
      return { current: null }
    }),
    (Mn.forwardRef = function (q) {
      return { $$typeof: a, render: q }
    }),
    (Mn.isValidElement = k),
    (Mn.lazy = function (q) {
      return { $$typeof: h, _payload: { _status: -1, _result: q }, _init: J }
    }),
    (Mn.memo = function (q, oe) {
      return { $$typeof: u, type: q, compare: oe === void 0 ? null : oe }
    }),
    (Mn.startTransition = function (q) {
      var oe = V.transition
      V.transition = {}
      try {
        q()
      } finally {
        V.transition = oe
      }
    }),
    (Mn.unstable_act = Q),
    (Mn.useCallback = function (q, oe) {
      return ne.current.useCallback(q, oe)
    }),
    (Mn.useContext = function (q) {
      return ne.current.useContext(q)
    }),
    (Mn.useDebugValue = function () {}),
    (Mn.useDeferredValue = function (q) {
      return ne.current.useDeferredValue(q)
    }),
    (Mn.useEffect = function (q, oe) {
      return ne.current.useEffect(q, oe)
    }),
    (Mn.useId = function () {
      return ne.current.useId()
    }),
    (Mn.useImperativeHandle = function (q, oe, _e) {
      return ne.current.useImperativeHandle(q, oe, _e)
    }),
    (Mn.useInsertionEffect = function (q, oe) {
      return ne.current.useInsertionEffect(q, oe)
    }),
    (Mn.useLayoutEffect = function (q, oe) {
      return ne.current.useLayoutEffect(q, oe)
    }),
    (Mn.useMemo = function (q, oe) {
      return ne.current.useMemo(q, oe)
    }),
    (Mn.useReducer = function (q, oe, _e) {
      return ne.current.useReducer(q, oe, _e)
    }),
    (Mn.useRef = function (q) {
      return ne.current.useRef(q)
    }),
    (Mn.useState = function (q) {
      return ne.current.useState(q)
    }),
    (Mn.useSyncExternalStore = function (q, oe, _e) {
      return ne.current.useSyncExternalStore(q, oe, _e)
    }),
    (Mn.useTransition = function () {
      return ne.current.useTransition()
    }),
    (Mn.version = '18.3.1'),
    Mn
  )
}
var mA
function Vs() {
  return mA || ((mA = 1), (v1.exports = kU())), v1.exports
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var gA
function FU() {
  if (gA) return Ip
  gA = 1
  var n = Vs(),
    e = Symbol.for('react.element'),
    t = Symbol.for('react.fragment'),
    i = Object.prototype.hasOwnProperty,
    r = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    s = { key: !0, ref: !0, __self: !0, __source: !0 }
  function o(a, c, u) {
    var h,
      m = {},
      g = null,
      y = null
    u !== void 0 && (g = '' + u),
      c.key !== void 0 && (g = '' + c.key),
      c.ref !== void 0 && (y = c.ref)
    for (h in c) i.call(c, h) && !s.hasOwnProperty(h) && (m[h] = c[h])
    if (a && a.defaultProps)
      for (h in ((c = a.defaultProps), c)) m[h] === void 0 && (m[h] = c[h])
    return { $$typeof: e, type: a, key: g, ref: y, props: m, _owner: r.current }
  }
  return (Ip.Fragment = t), (Ip.jsx = o), (Ip.jsxs = o), Ip
}
var vA
function UU() {
  return vA || ((vA = 1), (g1.exports = FU())), g1.exports
}
var b = UU(),
  X = Vs(),
  Zv = {},
  y1 = { exports: {} },
  ps = {},
  x1 = { exports: {} },
  _1 = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var yA
function BU() {
  return (
    yA ||
      ((yA = 1),
      (function (n) {
        function e(V, Y) {
          var Q = V.length
          V.push(Y)
          e: for (; 0 < Q; ) {
            var q = (Q - 1) >>> 1,
              oe = V[q]
            if (0 < r(oe, Y)) (V[q] = Y), (V[Q] = oe), (Q = q)
            else break e
          }
        }
        function t(V) {
          return V.length === 0 ? null : V[0]
        }
        function i(V) {
          if (V.length === 0) return null
          var Y = V[0],
            Q = V.pop()
          if (Q !== Y) {
            V[0] = Q
            e: for (var q = 0, oe = V.length, _e = oe >>> 1; q < _e; ) {
              var he = 2 * (q + 1) - 1,
                Ce = V[he],
                Te = he + 1,
                Pe = V[Te]
              if (0 > r(Ce, Q))
                Te < oe && 0 > r(Pe, Ce)
                  ? ((V[q] = Pe), (V[Te] = Q), (q = Te))
                  : ((V[q] = Ce), (V[he] = Q), (q = he))
              else if (Te < oe && 0 > r(Pe, Q))
                (V[q] = Pe), (V[Te] = Q), (q = Te)
              else break e
            }
          }
          return Y
        }
        function r(V, Y) {
          var Q = V.sortIndex - Y.sortIndex
          return Q !== 0 ? Q : V.id - Y.id
        }
        if (
          typeof performance == 'object' &&
          typeof performance.now == 'function'
        ) {
          var s = performance
          n.unstable_now = function () {
            return s.now()
          }
        } else {
          var o = Date,
            a = o.now()
          n.unstable_now = function () {
            return o.now() - a
          }
        }
        var c = [],
          u = [],
          h = 1,
          m = null,
          g = 3,
          y = !1,
          _ = !1,
          M = !1,
          w = typeof setTimeout == 'function' ? setTimeout : null,
          x = typeof clearTimeout == 'function' ? clearTimeout : null,
          T = typeof setImmediate < 'u' ? setImmediate : null
        typeof navigator < 'u' &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling)
        function A(V) {
          for (var Y = t(u); Y !== null; ) {
            if (Y.callback === null) i(u)
            else if (Y.startTime <= V)
              i(u), (Y.sortIndex = Y.expirationTime), e(c, Y)
            else break
            Y = t(u)
          }
        }
        function P(V) {
          if (((M = !1), A(V), !_))
            if (t(c) !== null) (_ = !0), J(D)
            else {
              var Y = t(u)
              Y !== null && ne(P, Y.startTime - V)
            }
        }
        function D(V, Y) {
          ;(_ = !1), M && ((M = !1), x(F), (F = -1)), (y = !0)
          var Q = g
          try {
            for (
              A(Y), m = t(c);
              m !== null && (!(m.expirationTime > Y) || (V && !z()));

            ) {
              var q = m.callback
              if (typeof q == 'function') {
                ;(m.callback = null), (g = m.priorityLevel)
                var oe = q(m.expirationTime <= Y)
                ;(Y = n.unstable_now()),
                  typeof oe == 'function'
                    ? (m.callback = oe)
                    : m === t(c) && i(c),
                  A(Y)
              } else i(c)
              m = t(c)
            }
            if (m !== null) var _e = !0
            else {
              var he = t(u)
              he !== null && ne(P, he.startTime - Y), (_e = !1)
            }
            return _e
          } finally {
            ;(m = null), (g = Q), (y = !1)
          }
        }
        var O = !1,
          U = null,
          F = -1,
          N = 5,
          k = -1
        function z() {
          return !(n.unstable_now() - k < N)
        }
        function $() {
          if (U !== null) {
            var V = n.unstable_now()
            k = V
            var Y = !0
            try {
              Y = U(!0, V)
            } finally {
              Y ? te() : ((O = !1), (U = null))
            }
          } else O = !1
        }
        var te
        if (typeof T == 'function')
          te = function () {
            T($)
          }
        else if (typeof MessageChannel < 'u') {
          var j = new MessageChannel(),
            K = j.port2
          ;(j.port1.onmessage = $),
            (te = function () {
              K.postMessage(null)
            })
        } else
          te = function () {
            w($, 0)
          }
        function J(V) {
          ;(U = V), O || ((O = !0), te())
        }
        function ne(V, Y) {
          F = w(function () {
            V(n.unstable_now())
          }, Y)
        }
        ;(n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (V) {
            V.callback = null
          }),
          (n.unstable_continueExecution = function () {
            _ || y || ((_ = !0), J(D))
          }),
          (n.unstable_forceFrameRate = function (V) {
            0 > V || 125 < V
              ? console.error(
                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported',
                )
              : (N = 0 < V ? Math.floor(1e3 / V) : 5)
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return g
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(c)
          }),
          (n.unstable_next = function (V) {
            switch (g) {
              case 1:
              case 2:
              case 3:
                var Y = 3
                break
              default:
                Y = g
            }
            var Q = g
            g = Y
            try {
              return V()
            } finally {
              g = Q
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (V, Y) {
            switch (V) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break
              default:
                V = 3
            }
            var Q = g
            g = V
            try {
              return Y()
            } finally {
              g = Q
            }
          }),
          (n.unstable_scheduleCallback = function (V, Y, Q) {
            var q = n.unstable_now()
            switch (
              (typeof Q == 'object' && Q !== null
                ? ((Q = Q.delay),
                  (Q = typeof Q == 'number' && 0 < Q ? q + Q : q))
                : (Q = q),
              V)
            ) {
              case 1:
                var oe = -1
                break
              case 2:
                oe = 250
                break
              case 5:
                oe = 1073741823
                break
              case 4:
                oe = 1e4
                break
              default:
                oe = 5e3
            }
            return (
              (oe = Q + oe),
              (V = {
                id: h++,
                callback: Y,
                priorityLevel: V,
                startTime: Q,
                expirationTime: oe,
                sortIndex: -1,
              }),
              Q > q
                ? ((V.sortIndex = Q),
                  e(u, V),
                  t(c) === null &&
                    V === t(u) &&
                    (M ? (x(F), (F = -1)) : (M = !0), ne(P, Q - q)))
                : ((V.sortIndex = oe), e(c, V), _ || y || ((_ = !0), J(D))),
              V
            )
          }),
          (n.unstable_shouldYield = z),
          (n.unstable_wrapCallback = function (V) {
            var Y = g
            return function () {
              var Q = g
              g = Y
              try {
                return V.apply(this, arguments)
              } finally {
                g = Q
              }
            }
          })
      })(_1)),
    _1
  )
}
var xA
function zU() {
  return xA || ((xA = 1), (x1.exports = BU())), x1.exports
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var _A
function VU() {
  if (_A) return ps
  _A = 1
  var n = Vs(),
    e = zU()
  function t(l) {
    for (
      var d = 'https://reactjs.org/docs/error-decoder.html?invariant=' + l,
        v = 1;
      v < arguments.length;
      v++
    )
      d += '&args[]=' + encodeURIComponent(arguments[v])
    return (
      'Minified React error #' +
      l +
      '; visit ' +
      d +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    )
  }
  var i = new Set(),
    r = {}
  function s(l, d) {
    o(l, d), o(l + 'Capture', d)
  }
  function o(l, d) {
    for (r[l] = d, l = 0; l < d.length; l++) i.add(d[l])
  }
  var a = !(
      typeof window > 'u' ||
      typeof window.document > 'u' ||
      typeof window.document.createElement > 'u'
    ),
    c = Object.prototype.hasOwnProperty,
    u =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    h = {},
    m = {}
  function g(l) {
    return c.call(m, l)
      ? !0
      : c.call(h, l)
      ? !1
      : u.test(l)
      ? (m[l] = !0)
      : ((h[l] = !0), !1)
  }
  function y(l, d, v, E) {
    if (v !== null && v.type === 0) return !1
    switch (typeof d) {
      case 'function':
      case 'symbol':
        return !0
      case 'boolean':
        return E
          ? !1
          : v !== null
          ? !v.acceptsBooleans
          : ((l = l.toLowerCase().slice(0, 5)), l !== 'data-' && l !== 'aria-')
      default:
        return !1
    }
  }
  function _(l, d, v, E) {
    if (d === null || typeof d > 'u' || y(l, d, v, E)) return !0
    if (E) return !1
    if (v !== null)
      switch (v.type) {
        case 3:
          return !d
        case 4:
          return d === !1
        case 5:
          return isNaN(d)
        case 6:
          return isNaN(d) || 1 > d
      }
    return !1
  }
  function M(l, d, v, E, R, L, W) {
    ;(this.acceptsBooleans = d === 2 || d === 3 || d === 4),
      (this.attributeName = E),
      (this.attributeNamespace = R),
      (this.mustUseProperty = v),
      (this.propertyName = l),
      (this.type = d),
      (this.sanitizeURL = L),
      (this.removeEmptyString = W)
  }
  var w = {}
  'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
    .split(' ')
    .forEach(function (l) {
      w[l] = new M(l, 0, !1, l, null, !1, !1)
    }),
    [
      ['acceptCharset', 'accept-charset'],
      ['className', 'class'],
      ['htmlFor', 'for'],
      ['httpEquiv', 'http-equiv'],
    ].forEach(function (l) {
      var d = l[0]
      w[d] = new M(d, 1, !1, l[1], null, !1, !1)
    }),
    ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (
      l,
    ) {
      w[l] = new M(l, 2, !1, l.toLowerCase(), null, !1, !1)
    }),
    [
      'autoReverse',
      'externalResourcesRequired',
      'focusable',
      'preserveAlpha',
    ].forEach(function (l) {
      w[l] = new M(l, 2, !1, l, null, !1, !1)
    }),
    'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
      .split(' ')
      .forEach(function (l) {
        w[l] = new M(l, 3, !1, l.toLowerCase(), null, !1, !1)
      }),
    ['checked', 'multiple', 'muted', 'selected'].forEach(function (l) {
      w[l] = new M(l, 3, !0, l, null, !1, !1)
    }),
    ['capture', 'download'].forEach(function (l) {
      w[l] = new M(l, 4, !1, l, null, !1, !1)
    }),
    ['cols', 'rows', 'size', 'span'].forEach(function (l) {
      w[l] = new M(l, 6, !1, l, null, !1, !1)
    }),
    ['rowSpan', 'start'].forEach(function (l) {
      w[l] = new M(l, 5, !1, l.toLowerCase(), null, !1, !1)
    })
  var x = /[\-:]([a-z])/g
  function T(l) {
    return l[1].toUpperCase()
  }
  'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
    .split(' ')
    .forEach(function (l) {
      var d = l.replace(x, T)
      w[d] = new M(d, 1, !1, l, null, !1, !1)
    }),
    'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
      .split(' ')
      .forEach(function (l) {
        var d = l.replace(x, T)
        w[d] = new M(d, 1, !1, l, 'http://www.w3.org/1999/xlink', !1, !1)
      }),
    ['xml:base', 'xml:lang', 'xml:space'].forEach(function (l) {
      var d = l.replace(x, T)
      w[d] = new M(d, 1, !1, l, 'http://www.w3.org/XML/1998/namespace', !1, !1)
    }),
    ['tabIndex', 'crossOrigin'].forEach(function (l) {
      w[l] = new M(l, 1, !1, l.toLowerCase(), null, !1, !1)
    }),
    (w.xlinkHref = new M(
      'xlinkHref',
      1,
      !1,
      'xlink:href',
      'http://www.w3.org/1999/xlink',
      !0,
      !1,
    )),
    ['src', 'href', 'action', 'formAction'].forEach(function (l) {
      w[l] = new M(l, 1, !1, l.toLowerCase(), null, !0, !0)
    })
  function A(l, d, v, E) {
    var R = w.hasOwnProperty(d) ? w[d] : null
    ;(R !== null
      ? R.type !== 0
      : E ||
        !(2 < d.length) ||
        (d[0] !== 'o' && d[0] !== 'O') ||
        (d[1] !== 'n' && d[1] !== 'N')) &&
      (_(d, v, R, E) && (v = null),
      E || R === null
        ? g(d) &&
          (v === null ? l.removeAttribute(d) : l.setAttribute(d, '' + v))
        : R.mustUseProperty
        ? (l[R.propertyName] = v === null ? (R.type === 3 ? !1 : '') : v)
        : ((d = R.attributeName),
          (E = R.attributeNamespace),
          v === null
            ? l.removeAttribute(d)
            : ((R = R.type),
              (v = R === 3 || (R === 4 && v === !0) ? '' : '' + v),
              E ? l.setAttributeNS(E, d, v) : l.setAttribute(d, v))))
  }
  var P = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    D = Symbol.for('react.element'),
    O = Symbol.for('react.portal'),
    U = Symbol.for('react.fragment'),
    F = Symbol.for('react.strict_mode'),
    N = Symbol.for('react.profiler'),
    k = Symbol.for('react.provider'),
    z = Symbol.for('react.context'),
    $ = Symbol.for('react.forward_ref'),
    te = Symbol.for('react.suspense'),
    j = Symbol.for('react.suspense_list'),
    K = Symbol.for('react.memo'),
    J = Symbol.for('react.lazy'),
    ne = Symbol.for('react.offscreen'),
    V = Symbol.iterator
  function Y(l) {
    return l === null || typeof l != 'object'
      ? null
      : ((l = (V && l[V]) || l['@@iterator']),
        typeof l == 'function' ? l : null)
  }
  var Q = Object.assign,
    q
  function oe(l) {
    if (q === void 0)
      try {
        throw Error()
      } catch (v) {
        var d = v.stack.trim().match(/\n( *(at )?)/)
        q = (d && d[1]) || ''
      }
    return (
      `
` +
      q +
      l
    )
  }
  var _e = !1
  function he(l, d) {
    if (!l || _e) return ''
    _e = !0
    var v = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    try {
      if (d)
        if (
          ((d = function () {
            throw Error()
          }),
          Object.defineProperty(d.prototype, 'props', {
            set: function () {
              throw Error()
            },
          }),
          typeof Reflect == 'object' && Reflect.construct)
        ) {
          try {
            Reflect.construct(d, [])
          } catch (Re) {
            var E = Re
          }
          Reflect.construct(l, [], d)
        } else {
          try {
            d.call()
          } catch (Re) {
            E = Re
          }
          l.call(d.prototype)
        }
      else {
        try {
          throw Error()
        } catch (Re) {
          E = Re
        }
        l()
      }
    } catch (Re) {
      if (Re && E && typeof Re.stack == 'string') {
        for (
          var R = Re.stack.split(`
`),
            L = E.stack.split(`
`),
            W = R.length - 1,
            ue = L.length - 1;
          1 <= W && 0 <= ue && R[W] !== L[ue];

        )
          ue--
        for (; 1 <= W && 0 <= ue; W--, ue--)
          if (R[W] !== L[ue]) {
            if (W !== 1 || ue !== 1)
              do
                if ((W--, ue--, 0 > ue || R[W] !== L[ue])) {
                  var pe =
                    `
` + R[W].replace(' at new ', ' at ')
                  return (
                    l.displayName &&
                      pe.includes('<anonymous>') &&
                      (pe = pe.replace('<anonymous>', l.displayName)),
                    pe
                  )
                }
              while (1 <= W && 0 <= ue)
            break
          }
      }
    } finally {
      ;(_e = !1), (Error.prepareStackTrace = v)
    }
    return (l = l ? l.displayName || l.name : '') ? oe(l) : ''
  }
  function Ce(l) {
    switch (l.tag) {
      case 5:
        return oe(l.type)
      case 16:
        return oe('Lazy')
      case 13:
        return oe('Suspense')
      case 19:
        return oe('SuspenseList')
      case 0:
      case 2:
      case 15:
        return (l = he(l.type, !1)), l
      case 11:
        return (l = he(l.type.render, !1)), l
      case 1:
        return (l = he(l.type, !0)), l
      default:
        return ''
    }
  }
  function Te(l) {
    if (l == null) return null
    if (typeof l == 'function') return l.displayName || l.name || null
    if (typeof l == 'string') return l
    switch (l) {
      case U:
        return 'Fragment'
      case O:
        return 'Portal'
      case N:
        return 'Profiler'
      case F:
        return 'StrictMode'
      case te:
        return 'Suspense'
      case j:
        return 'SuspenseList'
    }
    if (typeof l == 'object')
      switch (l.$$typeof) {
        case z:
          return (l.displayName || 'Context') + '.Consumer'
        case k:
          return (l._context.displayName || 'Context') + '.Provider'
        case $:
          var d = l.render
          return (
            (l = l.displayName),
            l ||
              ((l = d.displayName || d.name || ''),
              (l = l !== '' ? 'ForwardRef(' + l + ')' : 'ForwardRef')),
            l
          )
        case K:
          return (
            (d = l.displayName || null), d !== null ? d : Te(l.type) || 'Memo'
          )
        case J:
          ;(d = l._payload), (l = l._init)
          try {
            return Te(l(d))
          } catch {}
      }
    return null
  }
  function Pe(l) {
    var d = l.type
    switch (l.tag) {
      case 24:
        return 'Cache'
      case 9:
        return (d.displayName || 'Context') + '.Consumer'
      case 10:
        return (d._context.displayName || 'Context') + '.Provider'
      case 18:
        return 'DehydratedFragment'
      case 11:
        return (
          (l = d.render),
          (l = l.displayName || l.name || ''),
          d.displayName || (l !== '' ? 'ForwardRef(' + l + ')' : 'ForwardRef')
        )
      case 7:
        return 'Fragment'
      case 5:
        return d
      case 4:
        return 'Portal'
      case 3:
        return 'Root'
      case 6:
        return 'Text'
      case 16:
        return Te(d)
      case 8:
        return d === F ? 'StrictMode' : 'Mode'
      case 22:
        return 'Offscreen'
      case 12:
        return 'Profiler'
      case 21:
        return 'Scope'
      case 13:
        return 'Suspense'
      case 19:
        return 'SuspenseList'
      case 25:
        return 'TracingMarker'
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof d == 'function') return d.displayName || d.name || null
        if (typeof d == 'string') return d
    }
    return null
  }
  function Be(l) {
    switch (typeof l) {
      case 'boolean':
      case 'number':
      case 'string':
      case 'undefined':
        return l
      case 'object':
        return l
      default:
        return ''
    }
  }
  function et(l) {
    var d = l.type
    return (
      (l = l.nodeName) &&
      l.toLowerCase() === 'input' &&
      (d === 'checkbox' || d === 'radio')
    )
  }
  function ft(l) {
    var d = et(l) ? 'checked' : 'value',
      v = Object.getOwnPropertyDescriptor(l.constructor.prototype, d),
      E = '' + l[d]
    if (
      !l.hasOwnProperty(d) &&
      typeof v < 'u' &&
      typeof v.get == 'function' &&
      typeof v.set == 'function'
    ) {
      var R = v.get,
        L = v.set
      return (
        Object.defineProperty(l, d, {
          configurable: !0,
          get: function () {
            return R.call(this)
          },
          set: function (W) {
            ;(E = '' + W), L.call(this, W)
          },
        }),
        Object.defineProperty(l, d, { enumerable: v.enumerable }),
        {
          getValue: function () {
            return E
          },
          setValue: function (W) {
            E = '' + W
          },
          stopTracking: function () {
            ;(l._valueTracker = null), delete l[d]
          },
        }
      )
    }
  }
  function Vt(l) {
    l._valueTracker || (l._valueTracker = ft(l))
  }
  function je(l) {
    if (!l) return !1
    var d = l._valueTracker
    if (!d) return !0
    var v = d.getValue(),
      E = ''
    return (
      l && (E = et(l) ? (l.checked ? 'true' : 'false') : l.value),
      (l = E),
      l !== v ? (d.setValue(l), !0) : !1
    )
  }
  function $e(l) {
    if (
      ((l = l || (typeof document < 'u' ? document : void 0)), typeof l > 'u')
    )
      return null
    try {
      return l.activeElement || l.body
    } catch {
      return l.body
    }
  }
  function se(l, d) {
    var v = d.checked
    return Q({}, d, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: v ?? l._wrapperState.initialChecked,
    })
  }
  function Rt(l, d) {
    var v = d.defaultValue == null ? '' : d.defaultValue,
      E = d.checked != null ? d.checked : d.defaultChecked
    ;(v = Be(d.value != null ? d.value : v)),
      (l._wrapperState = {
        initialChecked: E,
        initialValue: v,
        controlled:
          d.type === 'checkbox' || d.type === 'radio'
            ? d.checked != null
            : d.value != null,
      })
  }
  function Qe(l, d) {
    ;(d = d.checked), d != null && A(l, 'checked', d, !1)
  }
  function _t(l, d) {
    Qe(l, d)
    var v = Be(d.value),
      E = d.type
    if (v != null)
      E === 'number'
        ? ((v === 0 && l.value === '') || l.value != v) && (l.value = '' + v)
        : l.value !== '' + v && (l.value = '' + v)
    else if (E === 'submit' || E === 'reset') {
      l.removeAttribute('value')
      return
    }
    d.hasOwnProperty('value')
      ? jt(l, d.type, v)
      : d.hasOwnProperty('defaultValue') && jt(l, d.type, Be(d.defaultValue)),
      d.checked == null &&
        d.defaultChecked != null &&
        (l.defaultChecked = !!d.defaultChecked)
  }
  function rt(l, d, v) {
    if (d.hasOwnProperty('value') || d.hasOwnProperty('defaultValue')) {
      var E = d.type
      if (
        !(
          (E !== 'submit' && E !== 'reset') ||
          (d.value !== void 0 && d.value !== null)
        )
      )
        return
      ;(d = '' + l._wrapperState.initialValue),
        v || d === l.value || (l.value = d),
        (l.defaultValue = d)
    }
    ;(v = l.name),
      v !== '' && (l.name = ''),
      (l.defaultChecked = !!l._wrapperState.initialChecked),
      v !== '' && (l.name = v)
  }
  function jt(l, d, v) {
    ;(d !== 'number' || $e(l.ownerDocument) !== l) &&
      (v == null
        ? (l.defaultValue = '' + l._wrapperState.initialValue)
        : l.defaultValue !== '' + v && (l.defaultValue = '' + v))
  }
  var at = Array.isArray
  function ie(l, d, v, E) {
    if (((l = l.options), d)) {
      d = {}
      for (var R = 0; R < v.length; R++) d['$' + v[R]] = !0
      for (v = 0; v < l.length; v++)
        (R = d.hasOwnProperty('$' + l[v].value)),
          l[v].selected !== R && (l[v].selected = R),
          R && E && (l[v].defaultSelected = !0)
    } else {
      for (v = '' + Be(v), d = null, R = 0; R < l.length; R++) {
        if (l[R].value === v) {
          ;(l[R].selected = !0), E && (l[R].defaultSelected = !0)
          return
        }
        d !== null || l[R].disabled || (d = l[R])
      }
      d !== null && (d.selected = !0)
    }
  }
  function Z(l, d) {
    if (d.dangerouslySetInnerHTML != null) throw Error(t(91))
    return Q({}, d, {
      value: void 0,
      defaultValue: void 0,
      children: '' + l._wrapperState.initialValue,
    })
  }
  function Se(l, d) {
    var v = d.value
    if (v == null) {
      if (((v = d.children), (d = d.defaultValue), v != null)) {
        if (d != null) throw Error(t(92))
        if (at(v)) {
          if (1 < v.length) throw Error(t(93))
          v = v[0]
        }
        d = v
      }
      d == null && (d = ''), (v = d)
    }
    l._wrapperState = { initialValue: Be(v) }
  }
  function Ue(l, d) {
    var v = Be(d.value),
      E = Be(d.defaultValue)
    v != null &&
      ((v = '' + v),
      v !== l.value && (l.value = v),
      d.defaultValue == null && l.defaultValue !== v && (l.defaultValue = v)),
      E != null && (l.defaultValue = '' + E)
  }
  function Ge(l) {
    var d = l.textContent
    d === l._wrapperState.initialValue &&
      d !== '' &&
      d !== null &&
      (l.value = d)
  }
  function ze(l) {
    switch (l) {
      case 'svg':
        return 'http://www.w3.org/2000/svg'
      case 'math':
        return 'http://www.w3.org/1998/Math/MathML'
      default:
        return 'http://www.w3.org/1999/xhtml'
    }
  }
  function Ct(l, d) {
    return l == null || l === 'http://www.w3.org/1999/xhtml'
      ? ze(d)
      : l === 'http://www.w3.org/2000/svg' && d === 'foreignObject'
      ? 'http://www.w3.org/1999/xhtml'
      : l
  }
  var ct,
    gt = (function (l) {
      return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
        ? function (d, v, E, R) {
            MSApp.execUnsafeLocalFunction(function () {
              return l(d, v, E, R)
            })
          }
        : l
    })(function (l, d) {
      if (l.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in l)
        l.innerHTML = d
      else {
        for (
          ct = ct || document.createElement('div'),
            ct.innerHTML = '<svg>' + d.valueOf().toString() + '</svg>',
            d = ct.firstChild;
          l.firstChild;

        )
          l.removeChild(l.firstChild)
        for (; d.firstChild; ) l.appendChild(d.firstChild)
      }
    })
  function rn(l, d) {
    if (d) {
      var v = l.firstChild
      if (v && v === l.lastChild && v.nodeType === 3) {
        v.nodeValue = d
        return
      }
    }
    l.textContent = d
  }
  var Je = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    bt = ['Webkit', 'ms', 'Moz', 'O']
  Object.keys(Je).forEach(function (l) {
    bt.forEach(function (d) {
      ;(d = d + l.charAt(0).toUpperCase() + l.substring(1)), (Je[d] = Je[l])
    })
  })
  function Ut(l, d, v) {
    return d == null || typeof d == 'boolean' || d === ''
      ? ''
      : v || typeof d != 'number' || d === 0 || (Je.hasOwnProperty(l) && Je[l])
      ? ('' + d).trim()
      : d + 'px'
  }
  function It(l, d) {
    l = l.style
    for (var v in d)
      if (d.hasOwnProperty(v)) {
        var E = v.indexOf('--') === 0,
          R = Ut(v, d[v], E)
        v === 'float' && (v = 'cssFloat'), E ? l.setProperty(v, R) : (l[v] = R)
      }
  }
  var Mt = Q(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    },
  )
  function en(l, d) {
    if (d) {
      if (Mt[l] && (d.children != null || d.dangerouslySetInnerHTML != null))
        throw Error(t(137, l))
      if (d.dangerouslySetInnerHTML != null) {
        if (d.children != null) throw Error(t(60))
        if (
          typeof d.dangerouslySetInnerHTML != 'object' ||
          !('__html' in d.dangerouslySetInnerHTML)
        )
          throw Error(t(61))
      }
      if (d.style != null && typeof d.style != 'object') throw Error(t(62))
    }
  }
  function Bt(l, d) {
    if (l.indexOf('-') === -1) return typeof d.is == 'string'
    switch (l) {
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return !1
      default:
        return !0
    }
  }
  var Kt = null
  function ve(l) {
    return (
      (l = l.target || l.srcElement || window),
      l.correspondingUseElement && (l = l.correspondingUseElement),
      l.nodeType === 3 ? l.parentNode : l
    )
  }
  var Ie = null,
    Le = null,
    Ve = null
  function vt(l) {
    if ((l = _o(l))) {
      if (typeof Ie != 'function') throw Error(t(280))
      var d = l.stateNode
      d && ((d = rf(d)), Ie(l.stateNode, l.type, d))
    }
  }
  function ht(l) {
    Le ? (Ve ? Ve.push(l) : (Ve = [l])) : (Le = l)
  }
  function Qt() {
    if (Le) {
      var l = Le,
        d = Ve
      if (((Ve = Le = null), vt(l), d)) for (l = 0; l < d.length; l++) vt(d[l])
    }
  }
  function Un(l, d) {
    return l(d)
  }
  function si() {}
  var wn = !1
  function zi(l, d, v) {
    if (wn) return l(d, v)
    wn = !0
    try {
      return Un(l, d, v)
    } finally {
      ;(wn = !1), (Le !== null || Ve !== null) && (si(), Qt())
    }
  }
  function Vi(l, d) {
    var v = l.stateNode
    if (v === null) return null
    var E = rf(v)
    if (E === null) return null
    v = E[d]
    e: switch (d) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
      case 'onMouseEnter':
        ;(E = !E.disabled) ||
          ((l = l.type),
          (E = !(
            l === 'button' ||
            l === 'input' ||
            l === 'select' ||
            l === 'textarea'
          ))),
          (l = !E)
        break e
      default:
        l = !1
    }
    if (l) return null
    if (v && typeof v != 'function') throw Error(t(231, d, typeof v))
    return v
  }
  var Ko = !1
  if (a)
    try {
      var js = {}
      Object.defineProperty(js, 'passive', {
        get: function () {
          Ko = !0
        },
      }),
        window.addEventListener('test', js, js),
        window.removeEventListener('test', js, js)
    } catch {
      Ko = !1
    }
  function ar(l, d, v, E, R, L, W, ue, pe) {
    var Re = Array.prototype.slice.call(arguments, 3)
    try {
      d.apply(v, Re)
    } catch (Ke) {
      this.onError(Ke)
    }
  }
  var kr = !1,
    Fr = null,
    ji = !1,
    sn = null,
    Ia = {
      onError: function (l) {
        ;(kr = !0), (Fr = l)
      },
    }
  function Qo(l, d, v, E, R, L, W, ue, pe) {
    ;(kr = !1), (Fr = null), ar.apply(Ia, arguments)
  }
  function H(l, d, v, E, R, L, W, ue, pe) {
    if ((Qo.apply(this, arguments), kr)) {
      if (kr) {
        var Re = Fr
        ;(kr = !1), (Fr = null)
      } else throw Error(t(198))
      ji || ((ji = !0), (sn = Re))
    }
  }
  function ee(l) {
    var d = l,
      v = l
    if (l.alternate) for (; d.return; ) d = d.return
    else {
      l = d
      do (d = l), d.flags & 4098 && (v = d.return), (l = d.return)
      while (l)
    }
    return d.tag === 3 ? v : null
  }
  function fe(l) {
    if (l.tag === 13) {
      var d = l.memoizedState
      if (
        (d === null && ((l = l.alternate), l !== null && (d = l.memoizedState)),
        d !== null)
      )
        return d.dehydrated
    }
    return null
  }
  function Ae(l) {
    if (ee(l) !== l) throw Error(t(188))
  }
  function De(l) {
    var d = l.alternate
    if (!d) {
      if (((d = ee(l)), d === null)) throw Error(t(188))
      return d !== l ? null : l
    }
    for (var v = l, E = d; ; ) {
      var R = v.return
      if (R === null) break
      var L = R.alternate
      if (L === null) {
        if (((E = R.return), E !== null)) {
          v = E
          continue
        }
        break
      }
      if (R.child === L.child) {
        for (L = R.child; L; ) {
          if (L === v) return Ae(R), l
          if (L === E) return Ae(R), d
          L = L.sibling
        }
        throw Error(t(188))
      }
      if (v.return !== E.return) (v = R), (E = L)
      else {
        for (var W = !1, ue = R.child; ue; ) {
          if (ue === v) {
            ;(W = !0), (v = R), (E = L)
            break
          }
          if (ue === E) {
            ;(W = !0), (E = R), (v = L)
            break
          }
          ue = ue.sibling
        }
        if (!W) {
          for (ue = L.child; ue; ) {
            if (ue === v) {
              ;(W = !0), (v = L), (E = R)
              break
            }
            if (ue === E) {
              ;(W = !0), (E = L), (v = R)
              break
            }
            ue = ue.sibling
          }
          if (!W) throw Error(t(189))
        }
      }
      if (v.alternate !== E) throw Error(t(190))
    }
    if (v.tag !== 3) throw Error(t(188))
    return v.stateNode.current === v ? l : d
  }
  function Oe(l) {
    return (l = De(l)), l !== null ? nt(l) : null
  }
  function nt(l) {
    if (l.tag === 5 || l.tag === 6) return l
    for (l = l.child; l !== null; ) {
      var d = nt(l)
      if (d !== null) return d
      l = l.sibling
    }
    return null
  }
  var Ze = e.unstable_scheduleCallback,
    G = e.unstable_cancelCallback,
    le = e.unstable_shouldYield,
    de = e.unstable_requestPaint,
    ce = e.unstable_now,
    me = e.unstable_getCurrentPriorityLevel,
    Me = e.unstable_ImmediatePriority,
    ke = e.unstable_UserBlockingPriority,
    He = e.unstable_NormalPriority,
    Xe = e.unstable_LowPriority,
    ut = e.unstable_IdlePriority,
    ot = null,
    We = null
  function pt(l) {
    if (We && typeof We.onCommitFiberRoot == 'function')
      try {
        We.onCommitFiberRoot(ot, l, void 0, (l.current.flags & 128) === 128)
      } catch {}
  }
  var mt = Math.clz32 ? Math.clz32 : Ot,
    qt = Math.log,
    Lt = Math.LN2
  function Ot(l) {
    return (l >>>= 0), l === 0 ? 32 : (31 - ((qt(l) / Lt) | 0)) | 0
  }
  var wt = 64,
    fn = 4194304
  function Ht(l) {
    switch (l & -l) {
      case 1:
        return 1
      case 2:
        return 2
      case 4:
        return 4
      case 8:
        return 8
      case 16:
        return 16
      case 32:
        return 32
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 4194240
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return l & 130023424
      case 134217728:
        return 134217728
      case 268435456:
        return 268435456
      case 536870912:
        return 536870912
      case 1073741824:
        return 1073741824
      default:
        return l
    }
  }
  function tn(l, d) {
    var v = l.pendingLanes
    if (v === 0) return 0
    var E = 0,
      R = l.suspendedLanes,
      L = l.pingedLanes,
      W = v & 268435455
    if (W !== 0) {
      var ue = W & ~R
      ue !== 0 ? (E = Ht(ue)) : ((L &= W), L !== 0 && (E = Ht(L)))
    } else (W = v & ~R), W !== 0 ? (E = Ht(W)) : L !== 0 && (E = Ht(L))
    if (E === 0) return 0
    if (
      d !== 0 &&
      d !== E &&
      !(d & R) &&
      ((R = E & -E), (L = d & -d), R >= L || (R === 16 && (L & 4194240) !== 0))
    )
      return d
    if ((E & 4 && (E |= v & 16), (d = l.entangledLanes), d !== 0))
      for (l = l.entanglements, d &= E; 0 < d; )
        (v = 31 - mt(d)), (R = 1 << v), (E |= l[v]), (d &= ~R)
    return E
  }
  function jn(l, d) {
    switch (l) {
      case 1:
      case 2:
      case 4:
        return d + 250
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d + 5e3
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1
      default:
        return -1
    }
  }
  function ln(l, d) {
    for (
      var v = l.suspendedLanes,
        E = l.pingedLanes,
        R = l.expirationTimes,
        L = l.pendingLanes;
      0 < L;

    ) {
      var W = 31 - mt(L),
        ue = 1 << W,
        pe = R[W]
      pe === -1
        ? (!(ue & v) || ue & E) && (R[W] = jn(ue, d))
        : pe <= d && (l.expiredLanes |= ue),
        (L &= ~ue)
    }
  }
  function mn(l) {
    return (
      (l = l.pendingLanes & -1073741825),
      l !== 0 ? l : l & 1073741824 ? 1073741824 : 0
    )
  }
  function Wt() {
    var l = wt
    return (wt <<= 1), !(wt & 4194240) && (wt = 64), l
  }
  function Kn(l) {
    for (var d = [], v = 0; 31 > v; v++) d.push(l)
    return d
  }
  function Tn(l, d, v) {
    ;(l.pendingLanes |= d),
      d !== 536870912 && ((l.suspendedLanes = 0), (l.pingedLanes = 0)),
      (l = l.eventTimes),
      (d = 31 - mt(d)),
      (l[d] = v)
  }
  function Hn(l, d) {
    var v = l.pendingLanes & ~d
    ;(l.pendingLanes = d),
      (l.suspendedLanes = 0),
      (l.pingedLanes = 0),
      (l.expiredLanes &= d),
      (l.mutableReadLanes &= d),
      (l.entangledLanes &= d),
      (d = l.entanglements)
    var E = l.eventTimes
    for (l = l.expirationTimes; 0 < v; ) {
      var R = 31 - mt(v),
        L = 1 << R
      ;(d[R] = 0), (E[R] = -1), (l[R] = -1), (v &= ~L)
    }
  }
  function ui(l, d) {
    var v = (l.entangledLanes |= d)
    for (l = l.entanglements; v; ) {
      var E = 31 - mt(v),
        R = 1 << E
      ;(R & d) | (l[E] & d) && (l[E] |= d), (v &= ~R)
    }
  }
  var Sn = 0
  function xr(l) {
    return (l &= -l), 1 < l ? (4 < l ? (l & 268435455 ? 16 : 536870912) : 4) : 1
  }
  var jc,
    Fh,
    rv,
    bd,
    Td,
    La = !1,
    Ad = [],
    Hs = null,
    yn = null,
    fo = null,
    Na = new Map(),
    Ll = new Map(),
    Jo = [],
    V_ =
      'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
        ' ',
      )
  function bi(l, d) {
    switch (l) {
      case 'focusin':
      case 'focusout':
        Hs = null
        break
      case 'dragenter':
      case 'dragleave':
        yn = null
        break
      case 'mouseover':
      case 'mouseout':
        fo = null
        break
      case 'pointerover':
      case 'pointerout':
        Na.delete(d.pointerId)
        break
      case 'gotpointercapture':
      case 'lostpointercapture':
        Ll.delete(d.pointerId)
    }
  }
  function Da(l, d, v, E, R, L) {
    return l === null || l.nativeEvent !== L
      ? ((l = {
          blockedOn: d,
          domEventName: v,
          eventSystemFlags: E,
          nativeEvent: L,
          targetContainers: [R],
        }),
        d !== null && ((d = _o(d)), d !== null && Fh(d)),
        l)
      : ((l.eventSystemFlags |= E),
        (d = l.targetContainers),
        R !== null && d.indexOf(R) === -1 && d.push(R),
        l)
  }
  function j_(l, d, v, E, R) {
    switch (d) {
      case 'focusin':
        return (Hs = Da(Hs, l, d, v, E, R)), !0
      case 'dragenter':
        return (yn = Da(yn, l, d, v, E, R)), !0
      case 'mouseover':
        return (fo = Da(fo, l, d, v, E, R)), !0
      case 'pointerover':
        var L = R.pointerId
        return Na.set(L, Da(Na.get(L) || null, l, d, v, E, R)), !0
      case 'gotpointercapture':
        return (
          (L = R.pointerId), Ll.set(L, Da(Ll.get(L) || null, l, d, v, E, R)), !0
        )
    }
    return !1
  }
  function Cd(l) {
    var d = oa(l.target)
    if (d !== null) {
      var v = ee(d)
      if (v !== null) {
        if (((d = v.tag), d === 13)) {
          if (((d = fe(v)), d !== null)) {
            ;(l.blockedOn = d),
              Td(l.priority, function () {
                rv(v)
              })
            return
          }
        } else if (d === 3 && v.stateNode.current.memoizedState.isDehydrated) {
          l.blockedOn = v.tag === 3 ? v.stateNode.containerInfo : null
          return
        }
      }
    }
    l.blockedOn = null
  }
  function Pd(l) {
    if (l.blockedOn !== null) return !1
    for (var d = l.targetContainers; 0 < d.length; ) {
      var v = rs(l.domEventName, l.eventSystemFlags, d[0], l.nativeEvent)
      if (v === null) {
        v = l.nativeEvent
        var E = new v.constructor(v.type, v)
        ;(Kt = E), v.target.dispatchEvent(E), (Kt = null)
      } else return (d = _o(v)), d !== null && Fh(d), (l.blockedOn = v), !1
      d.shift()
    }
    return !0
  }
  function Hc(l, d, v) {
    Pd(l) && v.delete(d)
  }
  function Gs() {
    ;(La = !1),
      Hs !== null && Pd(Hs) && (Hs = null),
      yn !== null && Pd(yn) && (yn = null),
      fo !== null && Pd(fo) && (fo = null),
      Na.forEach(Hc),
      Ll.forEach(Hc)
  }
  function Gc(l, d) {
    l.blockedOn === d &&
      ((l.blockedOn = null),
      La ||
        ((La = !0), e.unstable_scheduleCallback(e.unstable_NormalPriority, Gs)))
  }
  function Wc(l) {
    function d(R) {
      return Gc(R, l)
    }
    if (0 < Ad.length) {
      Gc(Ad[0], l)
      for (var v = 1; v < Ad.length; v++) {
        var E = Ad[v]
        E.blockedOn === l && (E.blockedOn = null)
      }
    }
    for (
      Hs !== null && Gc(Hs, l),
        yn !== null && Gc(yn, l),
        fo !== null && Gc(fo, l),
        Na.forEach(d),
        Ll.forEach(d),
        v = 0;
      v < Jo.length;
      v++
    )
      (E = Jo[v]), E.blockedOn === l && (E.blockedOn = null)
    for (; 0 < Jo.length && ((v = Jo[0]), v.blockedOn === null); )
      Cd(v), v.blockedOn === null && Jo.shift()
  }
  var lr = P.ReactCurrentBatchConfig,
    is = !0
  function Rd(l, d, v, E) {
    var R = Sn,
      L = lr.transition
    lr.transition = null
    try {
      ;(Sn = 1), Id(l, d, v, E)
    } finally {
      ;(Sn = R), (lr.transition = L)
    }
  }
  function Uh(l, d, v, E) {
    var R = Sn,
      L = lr.transition
    lr.transition = null
    try {
      ;(Sn = 4), Id(l, d, v, E)
    } finally {
      ;(Sn = R), (lr.transition = L)
    }
  }
  function Id(l, d, v, E) {
    if (is) {
      var R = rs(l, d, v, E)
      if (R === null) Kd(l, d, E, Ld, v), bi(l, E)
      else if (j_(R, l, d, v, E)) E.stopPropagation()
      else if ((bi(l, E), d & 4 && -1 < V_.indexOf(l))) {
        for (; R !== null; ) {
          var L = _o(R)
          if (
            (L !== null && jc(L),
            (L = rs(l, d, v, E)),
            L === null && Kd(l, d, E, Ld, v),
            L === R)
          )
            break
          R = L
        }
        R !== null && E.stopPropagation()
      } else Kd(l, d, E, null, v)
    }
  }
  var Ld = null
  function rs(l, d, v, E) {
    if (((Ld = null), (l = ve(E)), (l = oa(l)), l !== null))
      if (((d = ee(l)), d === null)) l = null
      else if (((v = d.tag), v === 13)) {
        if (((l = fe(d)), l !== null)) return l
        l = null
      } else if (v === 3) {
        if (d.stateNode.current.memoizedState.isDehydrated)
          return d.tag === 3 ? d.stateNode.containerInfo : null
        l = null
      } else d !== l && (l = null)
    return (Ld = l), null
  }
  function sv(l) {
    switch (l) {
      case 'cancel':
      case 'click':
      case 'close':
      case 'contextmenu':
      case 'copy':
      case 'cut':
      case 'auxclick':
      case 'dblclick':
      case 'dragend':
      case 'dragstart':
      case 'drop':
      case 'focusin':
      case 'focusout':
      case 'input':
      case 'invalid':
      case 'keydown':
      case 'keypress':
      case 'keyup':
      case 'mousedown':
      case 'mouseup':
      case 'paste':
      case 'pause':
      case 'play':
      case 'pointercancel':
      case 'pointerdown':
      case 'pointerup':
      case 'ratechange':
      case 'reset':
      case 'resize':
      case 'seeked':
      case 'submit':
      case 'touchcancel':
      case 'touchend':
      case 'touchstart':
      case 'volumechange':
      case 'change':
      case 'selectionchange':
      case 'textInput':
      case 'compositionstart':
      case 'compositionend':
      case 'compositionupdate':
      case 'beforeblur':
      case 'afterblur':
      case 'beforeinput':
      case 'blur':
      case 'fullscreenchange':
      case 'focus':
      case 'hashchange':
      case 'popstate':
      case 'select':
      case 'selectstart':
        return 1
      case 'drag':
      case 'dragenter':
      case 'dragexit':
      case 'dragleave':
      case 'dragover':
      case 'mousemove':
      case 'mouseout':
      case 'mouseover':
      case 'pointermove':
      case 'pointerout':
      case 'pointerover':
      case 'scroll':
      case 'toggle':
      case 'touchmove':
      case 'wheel':
      case 'mouseenter':
      case 'mouseleave':
      case 'pointerenter':
      case 'pointerleave':
        return 4
      case 'message':
        switch (me()) {
          case Me:
            return 1
          case ke:
            return 4
          case He:
          case Xe:
            return 16
          case ut:
            return 536870912
          default:
            return 16
        }
      default:
        return 16
    }
  }
  var Ss = null,
    Bh = null,
    _r = null
  function $c() {
    if (_r) return _r
    var l,
      d = Bh,
      v = d.length,
      E,
      R = 'value' in Ss ? Ss.value : Ss.textContent,
      L = R.length
    for (l = 0; l < v && d[l] === R[l]; l++);
    var W = v - l
    for (E = 1; E <= W && d[v - E] === R[L - E]; E++);
    return (_r = R.slice(l, 1 < E ? 1 - E : void 0))
  }
  function Oa(l) {
    var d = l.keyCode
    return (
      'charCode' in l
        ? ((l = l.charCode), l === 0 && d === 13 && (l = 13))
        : (l = d),
      l === 10 && (l = 13),
      32 <= l || l === 13 ? l : 0
    )
  }
  function ho() {
    return !0
  }
  function Nd() {
    return !1
  }
  function cr(l) {
    function d(v, E, R, L, W) {
      ;(this._reactName = v),
        (this._targetInst = R),
        (this.type = E),
        (this.nativeEvent = L),
        (this.target = W),
        (this.currentTarget = null)
      for (var ue in l)
        l.hasOwnProperty(ue) && ((v = l[ue]), (this[ue] = v ? v(L) : L[ue]))
      return (
        (this.isDefaultPrevented = (
          L.defaultPrevented != null ? L.defaultPrevented : L.returnValue === !1
        )
          ? ho
          : Nd),
        (this.isPropagationStopped = Nd),
        this
      )
    }
    return (
      Q(d.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0
          var v = this.nativeEvent
          v &&
            (v.preventDefault
              ? v.preventDefault()
              : typeof v.returnValue != 'unknown' && (v.returnValue = !1),
            (this.isDefaultPrevented = ho))
        },
        stopPropagation: function () {
          var v = this.nativeEvent
          v &&
            (v.stopPropagation
              ? v.stopPropagation()
              : typeof v.cancelBubble != 'unknown' && (v.cancelBubble = !0),
            (this.isPropagationStopped = ho))
        },
        persist: function () {},
        isPersistent: ho,
      }),
      d
    )
  }
  var ka = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (l) {
        return l.timeStamp || Date.now()
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    Xc = cr(ka),
    Fa = Q({}, ka, { view: 0, detail: 0 }),
    Nl = cr(Fa),
    wr,
    ss,
    os,
    Dl = Q({}, Fa, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: ta,
      button: 0,
      buttons: 0,
      relatedTarget: function (l) {
        return l.relatedTarget === void 0
          ? l.fromElement === l.srcElement
            ? l.toElement
            : l.fromElement
          : l.relatedTarget
      },
      movementX: function (l) {
        return 'movementX' in l
          ? l.movementX
          : (l !== os &&
              (os && l.type === 'mousemove'
                ? ((wr = l.screenX - os.screenX), (ss = l.screenY - os.screenY))
                : (ss = wr = 0),
              (os = l)),
            wr)
      },
      movementY: function (l) {
        return 'movementY' in l ? l.movementY : ss
      },
    }),
    zh = cr(Dl),
    po = Q({}, Dl, { dataTransfer: 0 }),
    ea = cr(po),
    Dd = Q({}, Fa, { relatedTarget: 0 }),
    Od = cr(Dd),
    kd = Q({}, ka, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    ov = cr(kd),
    av = Q({}, ka, {
      clipboardData: function (l) {
        return 'clipboardData' in l ? l.clipboardData : window.clipboardData
      },
    }),
    Vh = cr(av),
    Fd = Q({}, ka, { data: 0 }),
    jh = cr(Fd),
    lv = {
      Esc: 'Escape',
      Spacebar: ' ',
      Left: 'ArrowLeft',
      Up: 'ArrowUp',
      Right: 'ArrowRight',
      Down: 'ArrowDown',
      Del: 'Delete',
      Win: 'OS',
      Menu: 'ContextMenu',
      Apps: 'ContextMenu',
      Scroll: 'ScrollLock',
      MozPrintableKey: 'Unidentified',
    },
    cv = {
      8: 'Backspace',
      9: 'Tab',
      12: 'Clear',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Escape',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      45: 'Insert',
      46: 'Delete',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'NumLock',
      145: 'ScrollLock',
      224: 'Meta',
    },
    Hh = {
      Alt: 'altKey',
      Control: 'ctrlKey',
      Meta: 'metaKey',
      Shift: 'shiftKey',
    }
  function Ol(l) {
    var d = this.nativeEvent
    return d.getModifierState
      ? d.getModifierState(l)
      : (l = Hh[l])
      ? !!d[l]
      : !1
  }
  function ta() {
    return Ol
  }
  var Ud = Q({}, Fa, {
      key: function (l) {
        if (l.key) {
          var d = lv[l.key] || l.key
          if (d !== 'Unidentified') return d
        }
        return l.type === 'keypress'
          ? ((l = Oa(l)), l === 13 ? 'Enter' : String.fromCharCode(l))
          : l.type === 'keydown' || l.type === 'keyup'
          ? cv[l.keyCode] || 'Unidentified'
          : ''
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: ta,
      charCode: function (l) {
        return l.type === 'keypress' ? Oa(l) : 0
      },
      keyCode: function (l) {
        return l.type === 'keydown' || l.type === 'keyup' ? l.keyCode : 0
      },
      which: function (l) {
        return l.type === 'keypress'
          ? Oa(l)
          : l.type === 'keydown' || l.type === 'keyup'
          ? l.keyCode
          : 0
      },
    }),
    Bd = cr(Ud),
    as = Q({}, Dl, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    Ur = cr(as),
    Ua = Q({}, Fa, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: ta,
    }),
    mo = cr(Ua),
    go = Q({}, ka, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Ba = cr(go),
    uv = Q({}, Dl, {
      deltaX: function (l) {
        return 'deltaX' in l
          ? l.deltaX
          : 'wheelDeltaX' in l
          ? -l.wheelDeltaX
          : 0
      },
      deltaY: function (l) {
        return 'deltaY' in l
          ? l.deltaY
          : 'wheelDeltaY' in l
          ? -l.wheelDeltaY
          : 'wheelDelta' in l
          ? -l.wheelDelta
          : 0
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    Gh = cr(uv),
    Wh = [9, 13, 27, 32],
    ur = a && 'CompositionEvent' in window,
    Hi = null
  a && 'documentMode' in document && (Hi = document.documentMode)
  var Qn = a && 'TextEvent' in window && !Hi,
    kl = a && (!ur || (Hi && 8 < Hi && 11 >= Hi)),
    ls = ' ',
    $h = !1
  function Xh(l, d) {
    switch (l) {
      case 'keyup':
        return Wh.indexOf(d.keyCode) !== -1
      case 'keydown':
        return d.keyCode !== 229
      case 'keypress':
      case 'mousedown':
      case 'focusout':
        return !0
      default:
        return !1
    }
  }
  function zd(l) {
    return (l = l.detail), typeof l == 'object' && 'data' in l ? l.data : null
  }
  var na = !1
  function dv(l, d) {
    switch (l) {
      case 'compositionend':
        return zd(d)
      case 'keypress':
        return d.which !== 32 ? null : (($h = !0), ls)
      case 'textInput':
        return (l = d.data), l === ls && $h ? null : l
      default:
        return null
    }
  }
  function qc(l, d) {
    if (na)
      return l === 'compositionend' || (!ur && Xh(l, d))
        ? ((l = $c()), (_r = Bh = Ss = null), (na = !1), l)
        : null
    switch (l) {
      case 'paste':
        return null
      case 'keypress':
        if (!(d.ctrlKey || d.altKey || d.metaKey) || (d.ctrlKey && d.altKey)) {
          if (d.char && 1 < d.char.length) return d.char
          if (d.which) return String.fromCharCode(d.which)
        }
        return null
      case 'compositionend':
        return kl && d.locale !== 'ko' ? null : d.data
      default:
        return null
    }
  }
  var Fl = {
    color: !0,
    date: !0,
    datetime: !0,
    'datetime-local': !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  }
  function Vd(l) {
    var d = l && l.nodeName && l.nodeName.toLowerCase()
    return d === 'input' ? !!Fl[l.type] : d === 'textarea'
  }
  function Ul(l, d, v, E) {
    ht(E),
      (d = Qd(d, 'onChange')),
      0 < d.length &&
        ((v = new Xc('onChange', 'change', null, v, E)),
        l.push({ event: v, listeners: d }))
  }
  var ia = null,
    Bl = null
  function fv(l) {
    Hl(l, 0)
  }
  function vo(l) {
    var d = di(l)
    if (je(d)) return l
  }
  function hv(l, d) {
    if (l === 'change') return d
  }
  var zl = !1
  if (a) {
    var Sr
    if (a) {
      var za = 'oninput' in document
      if (!za) {
        var Va = document.createElement('div')
        Va.setAttribute('oninput', 'return;'),
          (za = typeof Va.oninput == 'function')
      }
      Sr = za
    } else Sr = !1
    zl = Sr && (!document.documentMode || 9 < document.documentMode)
  }
  function Ms() {
    ia && (ia.detachEvent('onpropertychange', jd), (Bl = ia = null))
  }
  function jd(l) {
    if (l.propertyName === 'value' && vo(Bl)) {
      var d = []
      Ul(d, Bl, l, ve(l)), zi(fv, d)
    }
  }
  function Vl(l, d, v) {
    l === 'focusin'
      ? (Ms(), (ia = d), (Bl = v), ia.attachEvent('onpropertychange', jd))
      : l === 'focusout' && Ms()
  }
  function pv(l) {
    if (l === 'selectionchange' || l === 'keyup' || l === 'keydown')
      return vo(Bl)
  }
  function qh(l, d) {
    if (l === 'click') return vo(d)
  }
  function ti(l, d) {
    if (l === 'input' || l === 'change') return vo(d)
  }
  function Hd(l, d) {
    return (l === d && (l !== 0 || 1 / l === 1 / d)) || (l !== l && d !== d)
  }
  var Br = typeof Object.is == 'function' ? Object.is : Hd
  function ja(l, d) {
    if (Br(l, d)) return !0
    if (
      typeof l != 'object' ||
      l === null ||
      typeof d != 'object' ||
      d === null
    )
      return !1
    var v = Object.keys(l),
      E = Object.keys(d)
    if (v.length !== E.length) return !1
    for (E = 0; E < v.length; E++) {
      var R = v[E]
      if (!c.call(d, R) || !Br(l[R], d[R])) return !1
    }
    return !0
  }
  function Yc(l) {
    for (; l && l.firstChild; ) l = l.firstChild
    return l
  }
  function zr(l, d) {
    var v = Yc(l)
    l = 0
    for (var E; v; ) {
      if (v.nodeType === 3) {
        if (((E = l + v.textContent.length), l <= d && E >= d))
          return { node: v, offset: d - l }
        l = E
      }
      e: {
        for (; v; ) {
          if (v.nextSibling) {
            v = v.nextSibling
            break e
          }
          v = v.parentNode
        }
        v = void 0
      }
      v = Yc(v)
    }
  }
  function Ha(l, d) {
    return l && d
      ? l === d
        ? !0
        : l && l.nodeType === 3
        ? !1
        : d && d.nodeType === 3
        ? Ha(l, d.parentNode)
        : 'contains' in l
        ? l.contains(d)
        : l.compareDocumentPosition
        ? !!(l.compareDocumentPosition(d) & 16)
        : !1
      : !1
  }
  function ni() {
    for (var l = window, d = $e(); d instanceof l.HTMLIFrameElement; ) {
      try {
        var v = typeof d.contentWindow.location.href == 'string'
      } catch {
        v = !1
      }
      if (v) l = d.contentWindow
      else break
      d = $e(l.document)
    }
    return d
  }
  function Li(l) {
    var d = l && l.nodeName && l.nodeName.toLowerCase()
    return (
      d &&
      ((d === 'input' &&
        (l.type === 'text' ||
          l.type === 'search' ||
          l.type === 'tel' ||
          l.type === 'url' ||
          l.type === 'password')) ||
        d === 'textarea' ||
        l.contentEditable === 'true')
    )
  }
  function Ni(l) {
    var d = ni(),
      v = l.focusedElem,
      E = l.selectionRange
    if (
      d !== v &&
      v &&
      v.ownerDocument &&
      Ha(v.ownerDocument.documentElement, v)
    ) {
      if (E !== null && Li(v)) {
        if (
          ((d = E.start),
          (l = E.end),
          l === void 0 && (l = d),
          'selectionStart' in v)
        )
          (v.selectionStart = d), (v.selectionEnd = Math.min(l, v.value.length))
        else if (
          ((l = ((d = v.ownerDocument || document) && d.defaultView) || window),
          l.getSelection)
        ) {
          l = l.getSelection()
          var R = v.textContent.length,
            L = Math.min(E.start, R)
          ;(E = E.end === void 0 ? L : Math.min(E.end, R)),
            !l.extend && L > E && ((R = E), (E = L), (L = R)),
            (R = zr(v, L))
          var W = zr(v, E)
          R &&
            W &&
            (l.rangeCount !== 1 ||
              l.anchorNode !== R.node ||
              l.anchorOffset !== R.offset ||
              l.focusNode !== W.node ||
              l.focusOffset !== W.offset) &&
            ((d = d.createRange()),
            d.setStart(R.node, R.offset),
            l.removeAllRanges(),
            L > E
              ? (l.addRange(d), l.extend(W.node, W.offset))
              : (d.setEnd(W.node, W.offset), l.addRange(d)))
        }
      }
      for (d = [], l = v; (l = l.parentNode); )
        l.nodeType === 1 &&
          d.push({ element: l, left: l.scrollLeft, top: l.scrollTop })
      for (typeof v.focus == 'function' && v.focus(), v = 0; v < d.length; v++)
        (l = d[v]),
          (l.element.scrollLeft = l.left),
          (l.element.scrollTop = l.top)
    }
  }
  var Gd = a && 'documentMode' in document && 11 >= document.documentMode,
    Ws = null,
    Ga = null,
    Zc = null,
    Di = !1
  function Wd(l, d, v) {
    var E = v.window === v ? v.document : v.nodeType === 9 ? v : v.ownerDocument
    Di ||
      Ws == null ||
      Ws !== $e(E) ||
      ((E = Ws),
      'selectionStart' in E && Li(E)
        ? (E = { start: E.selectionStart, end: E.selectionEnd })
        : ((E = (
            (E.ownerDocument && E.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (E = {
            anchorNode: E.anchorNode,
            anchorOffset: E.anchorOffset,
            focusNode: E.focusNode,
            focusOffset: E.focusOffset,
          })),
      (Zc && ja(Zc, E)) ||
        ((Zc = E),
        (E = Qd(Ga, 'onSelect')),
        0 < E.length &&
          ((d = new Xc('onSelect', 'select', null, d, v)),
          l.push({ event: d, listeners: E }),
          (d.target = Ws))))
  }
  function jl(l, d) {
    var v = {}
    return (
      (v[l.toLowerCase()] = d.toLowerCase()),
      (v['Webkit' + l] = 'webkit' + d),
      (v['Moz' + l] = 'moz' + d),
      v
    )
  }
  var ra = {
      animationend: jl('Animation', 'AnimationEnd'),
      animationiteration: jl('Animation', 'AnimationIteration'),
      animationstart: jl('Animation', 'AnimationStart'),
      transitionend: jl('Transition', 'TransitionEnd'),
    },
    Es = {},
    bs = {}
  a &&
    ((bs = document.createElement('div').style),
    'AnimationEvent' in window ||
      (delete ra.animationend.animation,
      delete ra.animationiteration.animation,
      delete ra.animationstart.animation),
    'TransitionEvent' in window || delete ra.transitionend.transition)
  function $s(l) {
    if (Es[l]) return Es[l]
    if (!ra[l]) return l
    var d = ra[l],
      v
    for (v in d) if (d.hasOwnProperty(v) && v in bs) return (Es[l] = d[v])
    return l
  }
  var Kc = $s('animationend'),
    Qc = $s('animationiteration'),
    Yh = $s('animationstart'),
    Zh = $s('transitionend'),
    Kh = new Map(),
    Qh =
      'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
        ' ',
      )
  function yo(l, d) {
    Kh.set(l, d), s(d, [l])
  }
  for (var $d = 0; $d < Qh.length; $d++) {
    var Jc = Qh[$d],
      eu = Jc.toLowerCase(),
      mv = Jc[0].toUpperCase() + Jc.slice(1)
    yo(eu, 'on' + mv)
  }
  yo(Kc, 'onAnimationEnd'),
    yo(Qc, 'onAnimationIteration'),
    yo(Yh, 'onAnimationStart'),
    yo('dblclick', 'onDoubleClick'),
    yo('focusin', 'onFocus'),
    yo('focusout', 'onBlur'),
    yo(Zh, 'onTransitionEnd'),
    o('onMouseEnter', ['mouseout', 'mouseover']),
    o('onMouseLeave', ['mouseout', 'mouseover']),
    o('onPointerEnter', ['pointerout', 'pointerover']),
    o('onPointerLeave', ['pointerout', 'pointerover']),
    s(
      'onChange',
      'change click focusin focusout input keydown keyup selectionchange'.split(
        ' ',
      ),
    ),
    s(
      'onSelect',
      'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
        ' ',
      ),
    ),
    s('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']),
    s(
      'onCompositionEnd',
      'compositionend focusout keydown keypress keyup mousedown'.split(' '),
    ),
    s(
      'onCompositionStart',
      'compositionstart focusout keydown keypress keyup mousedown'.split(' '),
    ),
    s(
      'onCompositionUpdate',
      'compositionupdate focusout keydown keypress keyup mousedown'.split(' '),
    )
  var sa =
      'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
        ' ',
      ),
    Xd = new Set(
      'cancel close invalid load scroll toggle'.split(' ').concat(sa),
    )
  function qd(l, d, v) {
    var E = l.type || 'unknown-event'
    ;(l.currentTarget = v), H(E, d, void 0, l), (l.currentTarget = null)
  }
  function Hl(l, d) {
    d = (d & 4) !== 0
    for (var v = 0; v < l.length; v++) {
      var E = l[v],
        R = E.event
      E = E.listeners
      e: {
        var L = void 0
        if (d)
          for (var W = E.length - 1; 0 <= W; W--) {
            var ue = E[W],
              pe = ue.instance,
              Re = ue.currentTarget
            if (((ue = ue.listener), pe !== L && R.isPropagationStopped()))
              break e
            qd(R, ue, Re), (L = pe)
          }
        else
          for (W = 0; W < E.length; W++) {
            if (
              ((ue = E[W]),
              (pe = ue.instance),
              (Re = ue.currentTarget),
              (ue = ue.listener),
              pe !== L && R.isPropagationStopped())
            )
              break e
            qd(R, ue, Re), (L = pe)
          }
      }
    }
    if (ji) throw ((l = sn), (ji = !1), (sn = null), l)
  }
  function Gn(l, d) {
    var v = d[Xa]
    v === void 0 && (v = d[Xa] = new Set())
    var E = l + '__bubble'
    v.has(E) || (Zd(d, l, 2, !1), v.add(E))
  }
  function Yd(l, d, v) {
    var E = 0
    d && (E |= 4), Zd(v, l, E, d)
  }
  var tu = '_reactListening' + Math.random().toString(36).slice(2)
  function Gl(l) {
    if (!l[tu]) {
      ;(l[tu] = !0),
        i.forEach(function (v) {
          v !== 'selectionchange' && (Xd.has(v) || Yd(v, !1, l), Yd(v, !0, l))
        })
      var d = l.nodeType === 9 ? l : l.ownerDocument
      d === null || d[tu] || ((d[tu] = !0), Yd('selectionchange', !1, d))
    }
  }
  function Zd(l, d, v, E) {
    switch (sv(d)) {
      case 1:
        var R = Rd
        break
      case 4:
        R = Uh
        break
      default:
        R = Id
    }
    ;(v = R.bind(null, d, v, l)),
      (R = void 0),
      !Ko ||
        (d !== 'touchstart' && d !== 'touchmove' && d !== 'wheel') ||
        (R = !0),
      E
        ? R !== void 0
          ? l.addEventListener(d, v, { capture: !0, passive: R })
          : l.addEventListener(d, v, !0)
        : R !== void 0
        ? l.addEventListener(d, v, { passive: R })
        : l.addEventListener(d, v, !1)
  }
  function Kd(l, d, v, E, R) {
    var L = E
    if (!(d & 1) && !(d & 2) && E !== null)
      e: for (;;) {
        if (E === null) return
        var W = E.tag
        if (W === 3 || W === 4) {
          var ue = E.stateNode.containerInfo
          if (ue === R || (ue.nodeType === 8 && ue.parentNode === R)) break
          if (W === 4)
            for (W = E.return; W !== null; ) {
              var pe = W.tag
              if (
                (pe === 3 || pe === 4) &&
                ((pe = W.stateNode.containerInfo),
                pe === R || (pe.nodeType === 8 && pe.parentNode === R))
              )
                return
              W = W.return
            }
          for (; ue !== null; ) {
            if (((W = oa(ue)), W === null)) return
            if (((pe = W.tag), pe === 5 || pe === 6)) {
              E = L = W
              continue e
            }
            ue = ue.parentNode
          }
        }
        E = E.return
      }
    zi(function () {
      var Re = L,
        Ke = ve(v),
        tt = []
      e: {
        var Ye = Kh.get(l)
        if (Ye !== void 0) {
          var Et = Xc,
            Nt = l
          switch (l) {
            case 'keypress':
              if (Oa(v) === 0) break e
            case 'keydown':
            case 'keyup':
              Et = Bd
              break
            case 'focusin':
              ;(Nt = 'focus'), (Et = Od)
              break
            case 'focusout':
              ;(Nt = 'blur'), (Et = Od)
              break
            case 'beforeblur':
            case 'afterblur':
              Et = Od
              break
            case 'click':
              if (v.button === 2) break e
            case 'auxclick':
            case 'dblclick':
            case 'mousedown':
            case 'mousemove':
            case 'mouseup':
            case 'mouseout':
            case 'mouseover':
            case 'contextmenu':
              Et = zh
              break
            case 'drag':
            case 'dragend':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'dragstart':
            case 'drop':
              Et = ea
              break
            case 'touchcancel':
            case 'touchend':
            case 'touchmove':
            case 'touchstart':
              Et = mo
              break
            case Kc:
            case Qc:
            case Yh:
              Et = ov
              break
            case Zh:
              Et = Ba
              break
            case 'scroll':
              Et = Nl
              break
            case 'wheel':
              Et = Gh
              break
            case 'copy':
            case 'cut':
            case 'paste':
              Et = Vh
              break
            case 'gotpointercapture':
            case 'lostpointercapture':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'pointerup':
              Et = Ur
          }
          var Dt = (d & 4) !== 0,
            Ai = !Dt && l === 'scroll',
            we = Dt ? (Ye !== null ? Ye + 'Capture' : null) : Ye
          Dt = []
          for (var ge = Re, Ee; ge !== null; ) {
            Ee = ge
            var st = Ee.stateNode
            if (
              (Ee.tag === 5 &&
                st !== null &&
                ((Ee = st),
                we !== null &&
                  ((st = Vi(ge, we)), st != null && Dt.push(Wl(ge, st, Ee)))),
              Ai)
            )
              break
            ge = ge.return
          }
          0 < Dt.length &&
            ((Ye = new Et(Ye, Nt, null, v, Ke)),
            tt.push({ event: Ye, listeners: Dt }))
        }
      }
      if (!(d & 7)) {
        e: {
          if (
            ((Ye = l === 'mouseover' || l === 'pointerover'),
            (Et = l === 'mouseout' || l === 'pointerout'),
            Ye &&
              v !== Kt &&
              (Nt = v.relatedTarget || v.fromElement) &&
              (oa(Nt) || Nt[Vr]))
          )
            break e
          if (
            (Et || Ye) &&
            ((Ye =
              Ke.window === Ke
                ? Ke
                : (Ye = Ke.ownerDocument)
                ? Ye.defaultView || Ye.parentWindow
                : window),
            Et
              ? ((Nt = v.relatedTarget || v.toElement),
                (Et = Re),
                (Nt = Nt ? oa(Nt) : null),
                Nt !== null &&
                  ((Ai = ee(Nt)),
                  Nt !== Ai || (Nt.tag !== 5 && Nt.tag !== 6)) &&
                  (Nt = null))
              : ((Et = null), (Nt = Re)),
            Et !== Nt)
          ) {
            if (
              ((Dt = zh),
              (st = 'onMouseLeave'),
              (we = 'onMouseEnter'),
              (ge = 'mouse'),
              (l === 'pointerout' || l === 'pointerover') &&
                ((Dt = Ur),
                (st = 'onPointerLeave'),
                (we = 'onPointerEnter'),
                (ge = 'pointer')),
              (Ai = Et == null ? Ye : di(Et)),
              (Ee = Nt == null ? Ye : di(Nt)),
              (Ye = new Dt(st, ge + 'leave', Et, v, Ke)),
              (Ye.target = Ai),
              (Ye.relatedTarget = Ee),
              (st = null),
              oa(Ke) === Re &&
                ((Dt = new Dt(we, ge + 'enter', Nt, v, Ke)),
                (Dt.target = Ee),
                (Dt.relatedTarget = Ai),
                (st = Dt)),
              (Ai = st),
              Et && Nt)
            )
              t: {
                for (Dt = Et, we = Nt, ge = 0, Ee = Dt; Ee; Ee = Wa(Ee)) ge++
                for (Ee = 0, st = we; st; st = Wa(st)) Ee++
                for (; 0 < ge - Ee; ) (Dt = Wa(Dt)), ge--
                for (; 0 < Ee - ge; ) (we = Wa(we)), Ee--
                for (; ge--; ) {
                  if (Dt === we || (we !== null && Dt === we.alternate)) break t
                  ;(Dt = Wa(Dt)), (we = Wa(we))
                }
                Dt = null
              }
            else Dt = null
            Et !== null && gv(tt, Ye, Et, Dt, !1),
              Nt !== null && Ai !== null && gv(tt, Ai, Nt, Dt, !0)
          }
        }
        e: {
          if (
            ((Ye = Re ? di(Re) : window),
            (Et = Ye.nodeName && Ye.nodeName.toLowerCase()),
            Et === 'select' || (Et === 'input' && Ye.type === 'file'))
          )
            var zt = hv
          else if (Vd(Ye))
            if (zl) zt = ti
            else {
              zt = pv
              var $t = Vl
            }
          else
            (Et = Ye.nodeName) &&
              Et.toLowerCase() === 'input' &&
              (Ye.type === 'checkbox' || Ye.type === 'radio') &&
              (zt = qh)
          if (zt && (zt = zt(l, Re))) {
            Ul(tt, zt, v, Ke)
            break e
          }
          $t && $t(l, Ye, Re),
            l === 'focusout' &&
              ($t = Ye._wrapperState) &&
              $t.controlled &&
              Ye.type === 'number' &&
              jt(Ye, 'number', Ye.value)
        }
        switch ((($t = Re ? di(Re) : window), l)) {
          case 'focusin':
            ;(Vd($t) || $t.contentEditable === 'true') &&
              ((Ws = $t), (Ga = Re), (Zc = null))
            break
          case 'focusout':
            Zc = Ga = Ws = null
            break
          case 'mousedown':
            Di = !0
            break
          case 'contextmenu':
          case 'mouseup':
          case 'dragend':
            ;(Di = !1), Wd(tt, v, Ke)
            break
          case 'selectionchange':
            if (Gd) break
          case 'keydown':
          case 'keyup':
            Wd(tt, v, Ke)
        }
        var Xt
        if (ur)
          e: {
            switch (l) {
              case 'compositionstart':
                var nn = 'onCompositionStart'
                break e
              case 'compositionend':
                nn = 'onCompositionEnd'
                break e
              case 'compositionupdate':
                nn = 'onCompositionUpdate'
                break e
            }
            nn = void 0
          }
        else
          na
            ? Xh(l, v) && (nn = 'onCompositionEnd')
            : l === 'keydown' &&
              v.keyCode === 229 &&
              (nn = 'onCompositionStart')
        nn &&
          (kl &&
            v.locale !== 'ko' &&
            (na || nn !== 'onCompositionStart'
              ? nn === 'onCompositionEnd' && na && (Xt = $c())
              : ((Ss = Ke),
                (Bh = 'value' in Ss ? Ss.value : Ss.textContent),
                (na = !0))),
          ($t = Qd(Re, nn)),
          0 < $t.length &&
            ((nn = new jh(nn, l, null, v, Ke)),
            tt.push({ event: nn, listeners: $t }),
            Xt
              ? (nn.data = Xt)
              : ((Xt = zd(v)), Xt !== null && (nn.data = Xt)))),
          (Xt = Qn ? dv(l, v) : qc(l, v)) &&
            ((Re = Qd(Re, 'onBeforeInput')),
            0 < Re.length &&
              ((Ke = new jh('onBeforeInput', 'beforeinput', null, v, Ke)),
              tt.push({ event: Ke, listeners: Re }),
              (Ke.data = Xt)))
      }
      Hl(tt, d)
    })
  }
  function Wl(l, d, v) {
    return { instance: l, listener: d, currentTarget: v }
  }
  function Qd(l, d) {
    for (var v = d + 'Capture', E = []; l !== null; ) {
      var R = l,
        L = R.stateNode
      R.tag === 5 &&
        L !== null &&
        ((R = L),
        (L = Vi(l, v)),
        L != null && E.unshift(Wl(l, L, R)),
        (L = Vi(l, d)),
        L != null && E.push(Wl(l, L, R))),
        (l = l.return)
    }
    return E
  }
  function Wa(l) {
    if (l === null) return null
    do l = l.return
    while (l && l.tag !== 5)
    return l || null
  }
  function gv(l, d, v, E, R) {
    for (var L = d._reactName, W = []; v !== null && v !== E; ) {
      var ue = v,
        pe = ue.alternate,
        Re = ue.stateNode
      if (pe !== null && pe === E) break
      ue.tag === 5 &&
        Re !== null &&
        ((ue = Re),
        R
          ? ((pe = Vi(v, L)), pe != null && W.unshift(Wl(v, pe, ue)))
          : R || ((pe = Vi(v, L)), pe != null && W.push(Wl(v, pe, ue)))),
        (v = v.return)
    }
    W.length !== 0 && l.push({ event: d, listeners: W })
  }
  var H_ = /\r\n?/g,
    vv = /\u0000|\uFFFD/g
  function Jh(l) {
    return (typeof l == 'string' ? l : '' + l)
      .replace(
        H_,
        `
`,
      )
      .replace(vv, '')
  }
  function nu(l, d, v) {
    if (((d = Jh(d)), Jh(l) !== d && v)) throw Error(t(425))
  }
  function iu() {}
  var $l = null,
    ep = null
  function tp(l, d) {
    return (
      l === 'textarea' ||
      l === 'noscript' ||
      typeof d.children == 'string' ||
      typeof d.children == 'number' ||
      (typeof d.dangerouslySetInnerHTML == 'object' &&
        d.dangerouslySetInnerHTML !== null &&
        d.dangerouslySetInnerHTML.__html != null)
    )
  }
  var np = typeof setTimeout == 'function' ? setTimeout : void 0,
    ip = typeof clearTimeout == 'function' ? clearTimeout : void 0,
    Jd = typeof Promise == 'function' ? Promise : void 0,
    G_ =
      typeof queueMicrotask == 'function'
        ? queueMicrotask
        : typeof Jd < 'u'
        ? function (l) {
            return Jd.resolve(null).then(l).catch(yv)
          }
        : np
  function yv(l) {
    setTimeout(function () {
      throw l
    })
  }
  function ef(l, d) {
    var v = d,
      E = 0
    do {
      var R = v.nextSibling
      if ((l.removeChild(v), R && R.nodeType === 8))
        if (((v = R.data), v === '/$')) {
          if (E === 0) {
            l.removeChild(R), Wc(d)
            return
          }
          E--
        } else (v !== '$' && v !== '$?' && v !== '$!') || E++
      v = R
    } while (v)
    Wc(d)
  }
  function xo(l) {
    for (; l != null; l = l.nextSibling) {
      var d = l.nodeType
      if (d === 1 || d === 3) break
      if (d === 8) {
        if (((d = l.data), d === '$' || d === '$!' || d === '$?')) break
        if (d === '/$') return null
      }
    }
    return l
  }
  function rp(l) {
    l = l.previousSibling
    for (var d = 0; l; ) {
      if (l.nodeType === 8) {
        var v = l.data
        if (v === '$' || v === '$!' || v === '$?') {
          if (d === 0) return l
          d--
        } else v === '/$' && d++
      }
      l = l.previousSibling
    }
    return null
  }
  var $a = Math.random().toString(36).slice(2),
    Ti = '__reactFiber$' + $a,
    Xl = '__reactProps$' + $a,
    Vr = '__reactContainer$' + $a,
    Xa = '__reactEvents$' + $a,
    tf = '__reactListeners$' + $a,
    nf = '__reactHandles$' + $a
  function oa(l) {
    var d = l[Ti]
    if (d) return d
    for (var v = l.parentNode; v; ) {
      if ((d = v[Vr] || v[Ti])) {
        if (
          ((v = d.alternate),
          d.child !== null || (v !== null && v.child !== null))
        )
          for (l = rp(l); l !== null; ) {
            if ((v = l[Ti])) return v
            l = rp(l)
          }
        return d
      }
      ;(l = v), (v = l.parentNode)
    }
    return null
  }
  function _o(l) {
    return (
      (l = l[Ti] || l[Vr]),
      !l || (l.tag !== 5 && l.tag !== 6 && l.tag !== 13 && l.tag !== 3)
        ? null
        : l
    )
  }
  function di(l) {
    if (l.tag === 5 || l.tag === 6) return l.stateNode
    throw Error(t(33))
  }
  function rf(l) {
    return l[Xl] || null
  }
  var sp = [],
    Oi = -1
  function oi(l) {
    return { current: l }
  }
  function Wn(l) {
    0 > Oi || ((l.current = sp[Oi]), (sp[Oi] = null), Oi--)
  }
  function Bn(l, d) {
    Oi++, (sp[Oi] = l.current), (l.current = d)
  }
  var wo = {},
    Gi = oi(wo),
    dr = oi(!1),
    So = wo
  function qa(l, d) {
    var v = l.type.contextTypes
    if (!v) return wo
    var E = l.stateNode
    if (E && E.__reactInternalMemoizedUnmaskedChildContext === d)
      return E.__reactInternalMemoizedMaskedChildContext
    var R = {},
      L
    for (L in v) R[L] = d[L]
    return (
      E &&
        ((l = l.stateNode),
        (l.__reactInternalMemoizedUnmaskedChildContext = d),
        (l.__reactInternalMemoizedMaskedChildContext = R)),
      R
    )
  }
  function Qi(l) {
    return (l = l.childContextTypes), l != null
  }
  function ru() {
    Wn(dr), Wn(Gi)
  }
  function op(l, d, v) {
    if (Gi.current !== wo) throw Error(t(168))
    Bn(Gi, d), Bn(dr, v)
  }
  function su(l, d, v) {
    var E = l.stateNode
    if (((d = d.childContextTypes), typeof E.getChildContext != 'function'))
      return v
    E = E.getChildContext()
    for (var R in E) if (!(R in d)) throw Error(t(108, Pe(l) || 'Unknown', R))
    return Q({}, v, E)
  }
  function Ya(l) {
    return (
      (l =
        ((l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext) ||
        wo),
      (So = Gi.current),
      Bn(Gi, l),
      Bn(dr, dr.current),
      !0
    )
  }
  function ap(l, d, v) {
    var E = l.stateNode
    if (!E) throw Error(t(169))
    v
      ? ((l = su(l, d, So)),
        (E.__reactInternalMemoizedMergedChildContext = l),
        Wn(dr),
        Wn(Gi),
        Bn(Gi, l))
      : Wn(dr),
      Bn(dr, v)
  }
  var Ts = null,
    ou = !1,
    sf = !1
  function au(l) {
    Ts === null ? (Ts = [l]) : Ts.push(l)
  }
  function xv(l) {
    ;(ou = !0), au(l)
  }
  function Xs() {
    if (!sf && Ts !== null) {
      sf = !0
      var l = 0,
        d = Sn
      try {
        var v = Ts
        for (Sn = 1; l < v.length; l++) {
          var E = v[l]
          do E = E(!0)
          while (E !== null)
        }
        ;(Ts = null), (ou = !1)
      } catch (R) {
        throw (Ts !== null && (Ts = Ts.slice(l + 1)), Ze(Me, Xs), R)
      } finally {
        ;(Sn = d), (sf = !1)
      }
    }
    return null
  }
  var Za = [],
    Mr = 0,
    of = null,
    af = 0,
    fr = [],
    ki = 0,
    Ka = null,
    lt = 1,
    cs = ''
  function Mo(l, d) {
    ;(Za[Mr++] = af), (Za[Mr++] = of), (of = l), (af = d)
  }
  function lp(l, d, v) {
    ;(fr[ki++] = lt), (fr[ki++] = cs), (fr[ki++] = Ka), (Ka = l)
    var E = lt
    l = cs
    var R = 32 - mt(E) - 1
    ;(E &= ~(1 << R)), (v += 1)
    var L = 32 - mt(d) + R
    if (30 < L) {
      var W = R - (R % 5)
      ;(L = (E & ((1 << W) - 1)).toString(32)),
        (E >>= W),
        (R -= W),
        (lt = (1 << (32 - mt(d) + R)) | (v << R) | E),
        (cs = L + l)
    } else (lt = (1 << L) | (v << R) | E), (cs = l)
  }
  function cp(l) {
    l.return !== null && (Mo(l, 1), lp(l, 1, 0))
  }
  function Eo(l) {
    for (; l === of; )
      (of = Za[--Mr]), (Za[Mr] = null), (af = Za[--Mr]), (Za[Mr] = null)
    for (; l === Ka; )
      (Ka = fr[--ki]),
        (fr[ki] = null),
        (cs = fr[--ki]),
        (fr[ki] = null),
        (lt = fr[--ki]),
        (fr[ki] = null)
  }
  var Wi = null,
    hr = null,
    Yn = !1,
    us = null
  function up(l, d) {
    var v = Qs(5, null, null, 0)
    ;(v.elementType = 'DELETED'),
      (v.stateNode = d),
      (v.return = l),
      (d = l.deletions),
      d === null ? ((l.deletions = [v]), (l.flags |= 16)) : d.push(v)
  }
  function dp(l, d) {
    switch (l.tag) {
      case 5:
        var v = l.type
        return (
          (d =
            d.nodeType !== 1 || v.toLowerCase() !== d.nodeName.toLowerCase()
              ? null
              : d),
          d !== null
            ? ((l.stateNode = d), (Wi = l), (hr = xo(d.firstChild)), !0)
            : !1
        )
      case 6:
        return (
          (d = l.pendingProps === '' || d.nodeType !== 3 ? null : d),
          d !== null ? ((l.stateNode = d), (Wi = l), (hr = null), !0) : !1
        )
      case 13:
        return (
          (d = d.nodeType !== 8 ? null : d),
          d !== null
            ? ((v = Ka !== null ? { id: lt, overflow: cs } : null),
              (l.memoizedState = {
                dehydrated: d,
                treeContext: v,
                retryLane: 1073741824,
              }),
              (v = Qs(18, null, null, 0)),
              (v.stateNode = d),
              (v.return = l),
              (l.child = v),
              (Wi = l),
              (hr = null),
              !0)
            : !1
        )
      default:
        return !1
    }
  }
  function lf(l) {
    return (l.mode & 1) !== 0 && (l.flags & 128) === 0
  }
  function cf(l) {
    if (Yn) {
      var d = hr
      if (d) {
        var v = d
        if (!dp(l, d)) {
          if (lf(l)) throw Error(t(418))
          d = xo(v.nextSibling)
          var E = Wi
          d && dp(l, d)
            ? up(E, v)
            : ((l.flags = (l.flags & -4097) | 2), (Yn = !1), (Wi = l))
        }
      } else {
        if (lf(l)) throw Error(t(418))
        ;(l.flags = (l.flags & -4097) | 2), (Yn = !1), (Wi = l)
      }
    }
  }
  function uf(l) {
    for (
      l = l.return;
      l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13;

    )
      l = l.return
    Wi = l
  }
  function ql(l) {
    if (l !== Wi) return !1
    if (!Yn) return uf(l), (Yn = !0), !1
    var d
    if (
      ((d = l.tag !== 3) &&
        !(d = l.tag !== 5) &&
        ((d = l.type),
        (d = d !== 'head' && d !== 'body' && !tp(l.type, l.memoizedProps))),
      d && (d = hr))
    ) {
      if (lf(l)) throw (fp(), Error(t(418)))
      for (; d; ) up(l, d), (d = xo(d.nextSibling))
    }
    if ((uf(l), l.tag === 13)) {
      if (((l = l.memoizedState), (l = l !== null ? l.dehydrated : null), !l))
        throw Error(t(317))
      e: {
        for (l = l.nextSibling, d = 0; l; ) {
          if (l.nodeType === 8) {
            var v = l.data
            if (v === '/$') {
              if (d === 0) {
                hr = xo(l.nextSibling)
                break e
              }
              d--
            } else (v !== '$' && v !== '$!' && v !== '$?') || d++
          }
          l = l.nextSibling
        }
        hr = null
      }
    } else hr = Wi ? xo(l.stateNode.nextSibling) : null
    return !0
  }
  function fp() {
    for (var l = hr; l; ) l = xo(l.nextSibling)
  }
  function aa() {
    ;(hr = Wi = null), (Yn = !1)
  }
  function Yl(l) {
    us === null ? (us = [l]) : us.push(l)
  }
  var W_ = P.ReactCurrentBatchConfig
  function lu(l, d, v) {
    if (
      ((l = v.ref),
      l !== null && typeof l != 'function' && typeof l != 'object')
    ) {
      if (v._owner) {
        if (((v = v._owner), v)) {
          if (v.tag !== 1) throw Error(t(309))
          var E = v.stateNode
        }
        if (!E) throw Error(t(147, l))
        var R = E,
          L = '' + l
        return d !== null &&
          d.ref !== null &&
          typeof d.ref == 'function' &&
          d.ref._stringRef === L
          ? d.ref
          : ((d = function (W) {
              var ue = R.refs
              W === null ? delete ue[L] : (ue[L] = W)
            }),
            (d._stringRef = L),
            d)
      }
      if (typeof l != 'string') throw Error(t(284))
      if (!v._owner) throw Error(t(290, l))
    }
    return l
  }
  function cu(l, d) {
    throw (
      ((l = Object.prototype.toString.call(d)),
      Error(
        t(
          31,
          l === '[object Object]'
            ? 'object with keys {' + Object.keys(d).join(', ') + '}'
            : l,
        ),
      ))
    )
  }
  function hp(l) {
    var d = l._init
    return d(l._payload)
  }
  function pp(l) {
    function d(we, ge) {
      if (l) {
        var Ee = we.deletions
        Ee === null ? ((we.deletions = [ge]), (we.flags |= 16)) : Ee.push(ge)
      }
    }
    function v(we, ge) {
      if (!l) return null
      for (; ge !== null; ) d(we, ge), (ge = ge.sibling)
      return null
    }
    function E(we, ge) {
      for (we = new Map(); ge !== null; )
        ge.key !== null ? we.set(ge.key, ge) : we.set(ge.index, ge),
          (ge = ge.sibling)
      return we
    }
    function R(we, ge) {
      return (we = oc(we, ge)), (we.index = 0), (we.sibling = null), we
    }
    function L(we, ge, Ee) {
      return (
        (we.index = Ee),
        l
          ? ((Ee = we.alternate),
            Ee !== null
              ? ((Ee = Ee.index), Ee < ge ? ((we.flags |= 2), ge) : Ee)
              : ((we.flags |= 2), ge))
          : ((we.flags |= 1048576), ge)
      )
    }
    function W(we) {
      return l && we.alternate === null && (we.flags |= 2), we
    }
    function ue(we, ge, Ee, st) {
      return ge === null || ge.tag !== 6
        ? ((ge = u1(Ee, we.mode, st)), (ge.return = we), ge)
        : ((ge = R(ge, Ee)), (ge.return = we), ge)
    }
    function pe(we, ge, Ee, st) {
      var zt = Ee.type
      return zt === U
        ? Ke(we, ge, Ee.props.children, st, Ee.key)
        : ge !== null &&
          (ge.elementType === zt ||
            (typeof zt == 'object' &&
              zt !== null &&
              zt.$$typeof === J &&
              hp(zt) === ge.type))
        ? ((st = R(ge, Ee.props)),
          (st.ref = lu(we, ge, Ee)),
          (st.return = we),
          st)
        : ((st = jv(Ee.type, Ee.key, Ee.props, null, we.mode, st)),
          (st.ref = lu(we, ge, Ee)),
          (st.return = we),
          st)
    }
    function Re(we, ge, Ee, st) {
      return ge === null ||
        ge.tag !== 4 ||
        ge.stateNode.containerInfo !== Ee.containerInfo ||
        ge.stateNode.implementation !== Ee.implementation
        ? ((ge = d1(Ee, we.mode, st)), (ge.return = we), ge)
        : ((ge = R(ge, Ee.children || [])), (ge.return = we), ge)
    }
    function Ke(we, ge, Ee, st, zt) {
      return ge === null || ge.tag !== 7
        ? ((ge = Tu(Ee, we.mode, st, zt)), (ge.return = we), ge)
        : ((ge = R(ge, Ee)), (ge.return = we), ge)
    }
    function tt(we, ge, Ee) {
      if ((typeof ge == 'string' && ge !== '') || typeof ge == 'number')
        return (ge = u1('' + ge, we.mode, Ee)), (ge.return = we), ge
      if (typeof ge == 'object' && ge !== null) {
        switch (ge.$$typeof) {
          case D:
            return (
              (Ee = jv(ge.type, ge.key, ge.props, null, we.mode, Ee)),
              (Ee.ref = lu(we, null, ge)),
              (Ee.return = we),
              Ee
            )
          case O:
            return (ge = d1(ge, we.mode, Ee)), (ge.return = we), ge
          case J:
            var st = ge._init
            return tt(we, st(ge._payload), Ee)
        }
        if (at(ge) || Y(ge))
          return (ge = Tu(ge, we.mode, Ee, null)), (ge.return = we), ge
        cu(we, ge)
      }
      return null
    }
    function Ye(we, ge, Ee, st) {
      var zt = ge !== null ? ge.key : null
      if ((typeof Ee == 'string' && Ee !== '') || typeof Ee == 'number')
        return zt !== null ? null : ue(we, ge, '' + Ee, st)
      if (typeof Ee == 'object' && Ee !== null) {
        switch (Ee.$$typeof) {
          case D:
            return Ee.key === zt ? pe(we, ge, Ee, st) : null
          case O:
            return Ee.key === zt ? Re(we, ge, Ee, st) : null
          case J:
            return (zt = Ee._init), Ye(we, ge, zt(Ee._payload), st)
        }
        if (at(Ee) || Y(Ee))
          return zt !== null ? null : Ke(we, ge, Ee, st, null)
        cu(we, Ee)
      }
      return null
    }
    function Et(we, ge, Ee, st, zt) {
      if ((typeof st == 'string' && st !== '') || typeof st == 'number')
        return (we = we.get(Ee) || null), ue(ge, we, '' + st, zt)
      if (typeof st == 'object' && st !== null) {
        switch (st.$$typeof) {
          case D:
            return (
              (we = we.get(st.key === null ? Ee : st.key) || null),
              pe(ge, we, st, zt)
            )
          case O:
            return (
              (we = we.get(st.key === null ? Ee : st.key) || null),
              Re(ge, we, st, zt)
            )
          case J:
            var $t = st._init
            return Et(we, ge, Ee, $t(st._payload), zt)
        }
        if (at(st) || Y(st))
          return (we = we.get(Ee) || null), Ke(ge, we, st, zt, null)
        cu(ge, st)
      }
      return null
    }
    function Nt(we, ge, Ee, st) {
      for (
        var zt = null, $t = null, Xt = ge, nn = (ge = 0), nr = null;
        Xt !== null && nn < Ee.length;
        nn++
      ) {
        Xt.index > nn ? ((nr = Xt), (Xt = null)) : (nr = Xt.sibling)
        var Nn = Ye(we, Xt, Ee[nn], st)
        if (Nn === null) {
          Xt === null && (Xt = nr)
          break
        }
        l && Xt && Nn.alternate === null && d(we, Xt),
          (ge = L(Nn, ge, nn)),
          $t === null ? (zt = Nn) : ($t.sibling = Nn),
          ($t = Nn),
          (Xt = nr)
      }
      if (nn === Ee.length) return v(we, Xt), Yn && Mo(we, nn), zt
      if (Xt === null) {
        for (; nn < Ee.length; nn++)
          (Xt = tt(we, Ee[nn], st)),
            Xt !== null &&
              ((ge = L(Xt, ge, nn)),
              $t === null ? (zt = Xt) : ($t.sibling = Xt),
              ($t = Xt))
        return Yn && Mo(we, nn), zt
      }
      for (Xt = E(we, Xt); nn < Ee.length; nn++)
        (nr = Et(Xt, we, nn, Ee[nn], st)),
          nr !== null &&
            (l &&
              nr.alternate !== null &&
              Xt.delete(nr.key === null ? nn : nr.key),
            (ge = L(nr, ge, nn)),
            $t === null ? (zt = nr) : ($t.sibling = nr),
            ($t = nr))
      return (
        l &&
          Xt.forEach(function (ac) {
            return d(we, ac)
          }),
        Yn && Mo(we, nn),
        zt
      )
    }
    function Dt(we, ge, Ee, st) {
      var zt = Y(Ee)
      if (typeof zt != 'function') throw Error(t(150))
      if (((Ee = zt.call(Ee)), Ee == null)) throw Error(t(151))
      for (
        var $t = (zt = null), Xt = ge, nn = (ge = 0), nr = null, Nn = Ee.next();
        Xt !== null && !Nn.done;
        nn++, Nn = Ee.next()
      ) {
        Xt.index > nn ? ((nr = Xt), (Xt = null)) : (nr = Xt.sibling)
        var ac = Ye(we, Xt, Nn.value, st)
        if (ac === null) {
          Xt === null && (Xt = nr)
          break
        }
        l && Xt && ac.alternate === null && d(we, Xt),
          (ge = L(ac, ge, nn)),
          $t === null ? (zt = ac) : ($t.sibling = ac),
          ($t = ac),
          (Xt = nr)
      }
      if (Nn.done) return v(we, Xt), Yn && Mo(we, nn), zt
      if (Xt === null) {
        for (; !Nn.done; nn++, Nn = Ee.next())
          (Nn = tt(we, Nn.value, st)),
            Nn !== null &&
              ((ge = L(Nn, ge, nn)),
              $t === null ? (zt = Nn) : ($t.sibling = Nn),
              ($t = Nn))
        return Yn && Mo(we, nn), zt
      }
      for (Xt = E(we, Xt); !Nn.done; nn++, Nn = Ee.next())
        (Nn = Et(Xt, we, nn, Nn.value, st)),
          Nn !== null &&
            (l &&
              Nn.alternate !== null &&
              Xt.delete(Nn.key === null ? nn : Nn.key),
            (ge = L(Nn, ge, nn)),
            $t === null ? (zt = Nn) : ($t.sibling = Nn),
            ($t = Nn))
      return (
        l &&
          Xt.forEach(function (DU) {
            return d(we, DU)
          }),
        Yn && Mo(we, nn),
        zt
      )
    }
    function Ai(we, ge, Ee, st) {
      if (
        (typeof Ee == 'object' &&
          Ee !== null &&
          Ee.type === U &&
          Ee.key === null &&
          (Ee = Ee.props.children),
        typeof Ee == 'object' && Ee !== null)
      ) {
        switch (Ee.$$typeof) {
          case D:
            e: {
              for (var zt = Ee.key, $t = ge; $t !== null; ) {
                if ($t.key === zt) {
                  if (((zt = Ee.type), zt === U)) {
                    if ($t.tag === 7) {
                      v(we, $t.sibling),
                        (ge = R($t, Ee.props.children)),
                        (ge.return = we),
                        (we = ge)
                      break e
                    }
                  } else if (
                    $t.elementType === zt ||
                    (typeof zt == 'object' &&
                      zt !== null &&
                      zt.$$typeof === J &&
                      hp(zt) === $t.type)
                  ) {
                    v(we, $t.sibling),
                      (ge = R($t, Ee.props)),
                      (ge.ref = lu(we, $t, Ee)),
                      (ge.return = we),
                      (we = ge)
                    break e
                  }
                  v(we, $t)
                  break
                } else d(we, $t)
                $t = $t.sibling
              }
              Ee.type === U
                ? ((ge = Tu(Ee.props.children, we.mode, st, Ee.key)),
                  (ge.return = we),
                  (we = ge))
                : ((st = jv(Ee.type, Ee.key, Ee.props, null, we.mode, st)),
                  (st.ref = lu(we, ge, Ee)),
                  (st.return = we),
                  (we = st))
            }
            return W(we)
          case O:
            e: {
              for ($t = Ee.key; ge !== null; ) {
                if (ge.key === $t)
                  if (
                    ge.tag === 4 &&
                    ge.stateNode.containerInfo === Ee.containerInfo &&
                    ge.stateNode.implementation === Ee.implementation
                  ) {
                    v(we, ge.sibling),
                      (ge = R(ge, Ee.children || [])),
                      (ge.return = we),
                      (we = ge)
                    break e
                  } else {
                    v(we, ge)
                    break
                  }
                else d(we, ge)
                ge = ge.sibling
              }
              ;(ge = d1(Ee, we.mode, st)), (ge.return = we), (we = ge)
            }
            return W(we)
          case J:
            return ($t = Ee._init), Ai(we, ge, $t(Ee._payload), st)
        }
        if (at(Ee)) return Nt(we, ge, Ee, st)
        if (Y(Ee)) return Dt(we, ge, Ee, st)
        cu(we, Ee)
      }
      return (typeof Ee == 'string' && Ee !== '') || typeof Ee == 'number'
        ? ((Ee = '' + Ee),
          ge !== null && ge.tag === 6
            ? (v(we, ge.sibling), (ge = R(ge, Ee)), (ge.return = we), (we = ge))
            : (v(we, ge),
              (ge = u1(Ee, we.mode, st)),
              (ge.return = we),
              (we = ge)),
          W(we))
        : v(we, ge)
    }
    return Ai
  }
  var Qa = pp(!0),
    uu = pp(!1),
    Ja = oi(null),
    el = null,
    bo = null,
    Zl = null
  function tl() {
    Zl = bo = el = null
  }
  function du(l) {
    var d = Ja.current
    Wn(Ja), (l._currentValue = d)
  }
  function fu(l, d, v) {
    for (; l !== null; ) {
      var E = l.alternate
      if (
        ((l.childLanes & d) !== d
          ? ((l.childLanes |= d), E !== null && (E.childLanes |= d))
          : E !== null && (E.childLanes & d) !== d && (E.childLanes |= d),
        l === v)
      )
        break
      l = l.return
    }
  }
  function la(l, d) {
    ;(el = l),
      (Zl = bo = null),
      (l = l.dependencies),
      l !== null &&
        l.firstContext !== null &&
        (l.lanes & d && (gn = !0), (l.firstContext = null))
  }
  function jr(l) {
    var d = l._currentValue
    if (Zl !== l)
      if (((l = { context: l, memoizedValue: d, next: null }), bo === null)) {
        if (el === null) throw Error(t(308))
        ;(bo = l), (el.dependencies = { lanes: 0, firstContext: l })
      } else bo = bo.next = l
    return d
  }
  var To = null
  function mp(l) {
    To === null ? (To = [l]) : To.push(l)
  }
  function hu(l, d, v, E) {
    var R = d.interleaved
    return (
      R === null ? ((v.next = v), mp(d)) : ((v.next = R.next), (R.next = v)),
      (d.interleaved = v),
      As(l, E)
    )
  }
  function As(l, d) {
    l.lanes |= d
    var v = l.alternate
    for (v !== null && (v.lanes |= d), v = l, l = l.return; l !== null; )
      (l.childLanes |= d),
        (v = l.alternate),
        v !== null && (v.childLanes |= d),
        (v = l),
        (l = l.return)
    return v.tag === 3 ? v.stateNode : null
  }
  var On = !1
  function hn(l) {
    l.updateQueue = {
      baseState: l.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    }
  }
  function fi(l, d) {
    ;(l = l.updateQueue),
      d.updateQueue === l &&
        (d.updateQueue = {
          baseState: l.baseState,
          firstBaseUpdate: l.firstBaseUpdate,
          lastBaseUpdate: l.lastBaseUpdate,
          shared: l.shared,
          effects: l.effects,
        })
  }
  function kn(l, d) {
    return {
      eventTime: l,
      lane: d,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    }
  }
  function Jn(l, d, v) {
    var E = l.updateQueue
    if (E === null) return null
    if (((E = E.shared), Pn & 2)) {
      var R = E.pending
      return (
        R === null ? (d.next = d) : ((d.next = R.next), (R.next = d)),
        (E.pending = d),
        As(l, v)
      )
    }
    return (
      (R = E.interleaved),
      R === null ? ((d.next = d), mp(E)) : ((d.next = R.next), (R.next = d)),
      (E.interleaved = d),
      As(l, v)
    )
  }
  function Ji(l, d, v) {
    if (
      ((d = d.updateQueue), d !== null && ((d = d.shared), (v & 4194240) !== 0))
    ) {
      var E = d.lanes
      ;(E &= l.pendingLanes), (v |= E), (d.lanes = v), ui(l, v)
    }
  }
  function nl(l, d) {
    var v = l.updateQueue,
      E = l.alternate
    if (E !== null && ((E = E.updateQueue), v === E)) {
      var R = null,
        L = null
      if (((v = v.firstBaseUpdate), v !== null)) {
        do {
          var W = {
            eventTime: v.eventTime,
            lane: v.lane,
            tag: v.tag,
            payload: v.payload,
            callback: v.callback,
            next: null,
          }
          L === null ? (R = L = W) : (L = L.next = W), (v = v.next)
        } while (v !== null)
        L === null ? (R = L = d) : (L = L.next = d)
      } else R = L = d
      ;(v = {
        baseState: E.baseState,
        firstBaseUpdate: R,
        lastBaseUpdate: L,
        shared: E.shared,
        effects: E.effects,
      }),
        (l.updateQueue = v)
      return
    }
    ;(l = v.lastBaseUpdate),
      l === null ? (v.firstBaseUpdate = d) : (l.next = d),
      (v.lastBaseUpdate = d)
  }
  function ai(l, d, v, E) {
    var R = l.updateQueue
    On = !1
    var L = R.firstBaseUpdate,
      W = R.lastBaseUpdate,
      ue = R.shared.pending
    if (ue !== null) {
      R.shared.pending = null
      var pe = ue,
        Re = pe.next
      ;(pe.next = null), W === null ? (L = Re) : (W.next = Re), (W = pe)
      var Ke = l.alternate
      Ke !== null &&
        ((Ke = Ke.updateQueue),
        (ue = Ke.lastBaseUpdate),
        ue !== W &&
          (ue === null ? (Ke.firstBaseUpdate = Re) : (ue.next = Re),
          (Ke.lastBaseUpdate = pe)))
    }
    if (L !== null) {
      var tt = R.baseState
      ;(W = 0), (Ke = Re = pe = null), (ue = L)
      do {
        var Ye = ue.lane,
          Et = ue.eventTime
        if ((E & Ye) === Ye) {
          Ke !== null &&
            (Ke = Ke.next =
              {
                eventTime: Et,
                lane: 0,
                tag: ue.tag,
                payload: ue.payload,
                callback: ue.callback,
                next: null,
              })
          e: {
            var Nt = l,
              Dt = ue
            switch (((Ye = d), (Et = v), Dt.tag)) {
              case 1:
                if (((Nt = Dt.payload), typeof Nt == 'function')) {
                  tt = Nt.call(Et, tt, Ye)
                  break e
                }
                tt = Nt
                break e
              case 3:
                Nt.flags = (Nt.flags & -65537) | 128
              case 0:
                if (
                  ((Nt = Dt.payload),
                  (Ye = typeof Nt == 'function' ? Nt.call(Et, tt, Ye) : Nt),
                  Ye == null)
                )
                  break e
                tt = Q({}, tt, Ye)
                break e
              case 2:
                On = !0
            }
          }
          ue.callback !== null &&
            ue.lane !== 0 &&
            ((l.flags |= 64),
            (Ye = R.effects),
            Ye === null ? (R.effects = [ue]) : Ye.push(ue))
        } else
          (Et = {
            eventTime: Et,
            lane: Ye,
            tag: ue.tag,
            payload: ue.payload,
            callback: ue.callback,
            next: null,
          }),
            Ke === null ? ((Re = Ke = Et), (pe = tt)) : (Ke = Ke.next = Et),
            (W |= Ye)
        if (((ue = ue.next), ue === null)) {
          if (((ue = R.shared.pending), ue === null)) break
          ;(Ye = ue),
            (ue = Ye.next),
            (Ye.next = null),
            (R.lastBaseUpdate = Ye),
            (R.shared.pending = null)
        }
      } while (!0)
      if (
        (Ke === null && (pe = tt),
        (R.baseState = pe),
        (R.firstBaseUpdate = Re),
        (R.lastBaseUpdate = Ke),
        (d = R.shared.interleaved),
        d !== null)
      ) {
        R = d
        do (W |= R.lane), (R = R.next)
        while (R !== d)
      } else L === null && (R.shared.lanes = 0)
      ;(Su |= W), (l.lanes = W), (l.memoizedState = tt)
    }
  }
  function Kl(l, d, v) {
    if (((l = d.effects), (d.effects = null), l !== null))
      for (d = 0; d < l.length; d++) {
        var E = l[d],
          R = E.callback
        if (R !== null) {
          if (((E.callback = null), (E = v), typeof R != 'function'))
            throw Error(t(191, R))
          R.call(E)
        }
      }
  }
  var qs = {},
    Hr = oi(qs),
    il = oi(qs),
    Ao = oi(qs)
  function xi(l) {
    if (l === qs) throw Error(t(174))
    return l
  }
  function pu(l, d) {
    switch ((Bn(Ao, d), Bn(il, l), Bn(Hr, qs), (l = d.nodeType), l)) {
      case 9:
      case 11:
        d = (d = d.documentElement) ? d.namespaceURI : Ct(null, '')
        break
      default:
        ;(l = l === 8 ? d.parentNode : d),
          (d = l.namespaceURI || null),
          (l = l.tagName),
          (d = Ct(d, l))
    }
    Wn(Hr), Bn(Hr, d)
  }
  function ca() {
    Wn(Hr), Wn(il), Wn(Ao)
  }
  function rl(l) {
    xi(Ao.current)
    var d = xi(Hr.current),
      v = Ct(d, l.type)
    d !== v && (Bn(il, l), Bn(Hr, v))
  }
  function Ql(l) {
    il.current === l && (Wn(Hr), Wn(il))
  }
  var Zn = oi(0)
  function Cs(l) {
    for (var d = l; d !== null; ) {
      if (d.tag === 13) {
        var v = d.memoizedState
        if (
          v !== null &&
          ((v = v.dehydrated), v === null || v.data === '$?' || v.data === '$!')
        )
          return d
      } else if (d.tag === 19 && d.memoizedProps.revealOrder !== void 0) {
        if (d.flags & 128) return d
      } else if (d.child !== null) {
        ;(d.child.return = d), (d = d.child)
        continue
      }
      if (d === l) break
      for (; d.sibling === null; ) {
        if (d.return === null || d.return === l) return null
        d = d.return
      }
      ;(d.sibling.return = d.return), (d = d.sibling)
    }
    return null
  }
  var Jl = []
  function Ys() {
    for (var l = 0; l < Jl.length; l++)
      Jl[l]._workInProgressVersionPrimary = null
    Jl.length = 0
  }
  var sl = P.ReactCurrentDispatcher,
    ol = P.ReactCurrentBatchConfig,
    Co = 0,
    $n = null,
    li = null,
    An = null,
    Ps = !1,
    er = !1,
    ua = 0,
    Er = 0
  function $i() {
    throw Error(t(321))
  }
  function mu(l, d) {
    if (d === null) return !1
    for (var v = 0; v < d.length && v < l.length; v++)
      if (!Br(l[v], d[v])) return !1
    return !0
  }
  function gu(l, d, v, E, R, L) {
    if (
      ((Co = L),
      ($n = d),
      (d.memoizedState = null),
      (d.updateQueue = null),
      (d.lanes = 0),
      (sl.current = l === null || l.memoizedState === null ? Tv : Av),
      (l = v(E, R)),
      er)
    ) {
      L = 0
      do {
        if (((er = !1), (ua = 0), 25 <= L)) throw Error(t(301))
        ;(L += 1),
          (An = li = null),
          (d.updateQueue = null),
          (sl.current = Cv),
          (l = v(E, R))
      } while (er)
    }
    if (
      ((sl.current = vf),
      (d = li !== null && li.next !== null),
      (Co = 0),
      (An = li = $n = null),
      (Ps = !1),
      d)
    )
      throw Error(t(300))
    return l
  }
  function gp() {
    var l = ua !== 0
    return (ua = 0), l
  }
  function Xi() {
    var l = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    }
    return An === null ? ($n.memoizedState = An = l) : (An = An.next = l), An
  }
  function Gr() {
    if (li === null) {
      var l = $n.alternate
      l = l !== null ? l.memoizedState : null
    } else l = li.next
    var d = An === null ? $n.memoizedState : An.next
    if (d !== null) (An = d), (li = l)
    else {
      if (l === null) throw Error(t(310))
      ;(li = l),
        (l = {
          memoizedState: li.memoizedState,
          baseState: li.baseState,
          baseQueue: li.baseQueue,
          queue: li.queue,
          next: null,
        }),
        An === null ? ($n.memoizedState = An = l) : (An = An.next = l)
    }
    return An
  }
  function ec(l, d) {
    return typeof d == 'function' ? d(l) : d
  }
  function vu(l) {
    var d = Gr(),
      v = d.queue
    if (v === null) throw Error(t(311))
    v.lastRenderedReducer = l
    var E = li,
      R = E.baseQueue,
      L = v.pending
    if (L !== null) {
      if (R !== null) {
        var W = R.next
        ;(R.next = L.next), (L.next = W)
      }
      ;(E.baseQueue = R = L), (v.pending = null)
    }
    if (R !== null) {
      ;(L = R.next), (E = E.baseState)
      var ue = (W = null),
        pe = null,
        Re = L
      do {
        var Ke = Re.lane
        if ((Co & Ke) === Ke)
          pe !== null &&
            (pe = pe.next =
              {
                lane: 0,
                action: Re.action,
                hasEagerState: Re.hasEagerState,
                eagerState: Re.eagerState,
                next: null,
              }),
            (E = Re.hasEagerState ? Re.eagerState : l(E, Re.action))
        else {
          var tt = {
            lane: Ke,
            action: Re.action,
            hasEagerState: Re.hasEagerState,
            eagerState: Re.eagerState,
            next: null,
          }
          pe === null ? ((ue = pe = tt), (W = E)) : (pe = pe.next = tt),
            ($n.lanes |= Ke),
            (Su |= Ke)
        }
        Re = Re.next
      } while (Re !== null && Re !== L)
      pe === null ? (W = E) : (pe.next = ue),
        Br(E, d.memoizedState) || (gn = !0),
        (d.memoizedState = E),
        (d.baseState = W),
        (d.baseQueue = pe),
        (v.lastRenderedState = E)
    }
    if (((l = v.interleaved), l !== null)) {
      R = l
      do (L = R.lane), ($n.lanes |= L), (Su |= L), (R = R.next)
      while (R !== l)
    } else R === null && (v.lanes = 0)
    return [d.memoizedState, v.dispatch]
  }
  function Po(l) {
    var d = Gr(),
      v = d.queue
    if (v === null) throw Error(t(311))
    v.lastRenderedReducer = l
    var E = v.dispatch,
      R = v.pending,
      L = d.memoizedState
    if (R !== null) {
      v.pending = null
      var W = (R = R.next)
      do (L = l(L, W.action)), (W = W.next)
      while (W !== R)
      Br(L, d.memoizedState) || (gn = !0),
        (d.memoizedState = L),
        d.baseQueue === null && (d.baseState = L),
        (v.lastRenderedState = L)
    }
    return [L, E]
  }
  function vp() {}
  function yp(l, d) {
    var v = $n,
      E = Gr(),
      R = d(),
      L = !Br(E.memoizedState, R)
    if (
      (L && ((E.memoizedState = R), (gn = !0)),
      (E = E.queue),
      wp(_v.bind(null, v, E, l), [l]),
      E.getSnapshot !== d || L || (An !== null && An.memoizedState.tag & 1))
    ) {
      if (
        ((v.flags |= 2048),
        Rs(9, yu.bind(null, v, E, R, d), void 0, null),
        tr === null)
      )
        throw Error(t(349))
      Co & 30 || df(v, d, R)
    }
    return R
  }
  function df(l, d, v) {
    ;(l.flags |= 16384),
      (l = { getSnapshot: d, value: v }),
      (d = $n.updateQueue),
      d === null
        ? ((d = { lastEffect: null, stores: null }),
          ($n.updateQueue = d),
          (d.stores = [l]))
        : ((v = d.stores), v === null ? (d.stores = [l]) : v.push(l))
  }
  function yu(l, d, v, E) {
    ;(d.value = v), (d.getSnapshot = E), wv(d) && xp(l)
  }
  function _v(l, d, v) {
    return v(function () {
      wv(d) && xp(l)
    })
  }
  function wv(l) {
    var d = l.getSnapshot
    l = l.value
    try {
      var v = d()
      return !Br(l, v)
    } catch {
      return !0
    }
  }
  function xp(l) {
    var d = As(l, 1)
    d !== null && Do(d, l, 1, -1)
  }
  function _p(l) {
    var d = Xi()
    return (
      typeof l == 'function' && (l = l()),
      (d.memoizedState = d.baseState = l),
      (l = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ec,
        lastRenderedState: l,
      }),
      (d.queue = l),
      (l = l.dispatch = al.bind(null, $n, l)),
      [d.memoizedState, l]
    )
  }
  function Rs(l, d, v, E) {
    return (
      (l = { tag: l, create: d, destroy: v, deps: E, next: null }),
      (d = $n.updateQueue),
      d === null
        ? ((d = { lastEffect: null, stores: null }),
          ($n.updateQueue = d),
          (d.lastEffect = l.next = l))
        : ((v = d.lastEffect),
          v === null
            ? (d.lastEffect = l.next = l)
            : ((E = v.next), (v.next = l), (l.next = E), (d.lastEffect = l))),
      l
    )
  }
  function Sv() {
    return Gr().memoizedState
  }
  function Zs(l, d, v, E) {
    var R = Xi()
    ;($n.flags |= l),
      (R.memoizedState = Rs(1 | d, v, void 0, E === void 0 ? null : E))
  }
  function xu(l, d, v, E) {
    var R = Gr()
    E = E === void 0 ? null : E
    var L = void 0
    if (li !== null) {
      var W = li.memoizedState
      if (((L = W.destroy), E !== null && mu(E, W.deps))) {
        R.memoizedState = Rs(d, v, L, E)
        return
      }
    }
    ;($n.flags |= l), (R.memoizedState = Rs(1 | d, v, L, E))
  }
  function pr(l, d) {
    return Zs(8390656, 8, l, d)
  }
  function wp(l, d) {
    return xu(2048, 8, l, d)
  }
  function Sp(l, d) {
    return xu(4, 2, l, d)
  }
  function Mv(l, d) {
    return xu(4, 4, l, d)
  }
  function Ev(l, d) {
    if (typeof d == 'function')
      return (
        (l = l()),
        d(l),
        function () {
          d(null)
        }
      )
    if (d != null)
      return (
        (l = l()),
        (d.current = l),
        function () {
          d.current = null
        }
      )
  }
  function Mp(l, d, v) {
    return (
      (v = v != null ? v.concat([l]) : null), xu(4, 4, Ev.bind(null, d, l), v)
    )
  }
  function ff() {}
  function bv(l, d) {
    var v = Gr()
    d = d === void 0 ? null : d
    var E = v.memoizedState
    return E !== null && d !== null && mu(d, E[1])
      ? E[0]
      : ((v.memoizedState = [l, d]), l)
  }
  function Wr(l, d) {
    var v = Gr()
    d = d === void 0 ? null : d
    var E = v.memoizedState
    return E !== null && d !== null && mu(d, E[1])
      ? E[0]
      : ((l = l()), (v.memoizedState = [l, d]), l)
  }
  function hf(l, d, v) {
    return Co & 21
      ? (Br(v, d) ||
          ((v = Wt()), ($n.lanes |= v), (Su |= v), (l.baseState = !0)),
        d)
      : (l.baseState && ((l.baseState = !1), (gn = !0)), (l.memoizedState = v))
  }
  function $_(l, d) {
    var v = Sn
    ;(Sn = v !== 0 && 4 > v ? v : 4), l(!0)
    var E = ol.transition
    ol.transition = {}
    try {
      l(!1), d()
    } finally {
      ;(Sn = v), (ol.transition = E)
    }
  }
  function Ro() {
    return Gr().memoizedState
  }
  function pf(l, d, v) {
    var E = rc(l)
    if (
      ((v = {
        lane: E,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      _u(l))
    )
      mf(d, v)
    else if (((v = hu(l, d, v, E)), v !== null)) {
      var R = Xr()
      Do(v, l, E, R), gf(v, d, E)
    }
  }
  function al(l, d, v) {
    var E = rc(l),
      R = {
        lane: E,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }
    if (_u(l)) mf(d, R)
    else {
      var L = l.alternate
      if (
        l.lanes === 0 &&
        (L === null || L.lanes === 0) &&
        ((L = d.lastRenderedReducer), L !== null)
      )
        try {
          var W = d.lastRenderedState,
            ue = L(W, v)
          if (((R.hasEagerState = !0), (R.eagerState = ue), Br(ue, W))) {
            var pe = d.interleaved
            pe === null
              ? ((R.next = R), mp(d))
              : ((R.next = pe.next), (pe.next = R)),
              (d.interleaved = R)
            return
          }
        } catch {
        } finally {
        }
      ;(v = hu(l, d, R, E)),
        v !== null && ((R = Xr()), Do(v, l, E, R), gf(v, d, E))
    }
  }
  function _u(l) {
    var d = l.alternate
    return l === $n || (d !== null && d === $n)
  }
  function mf(l, d) {
    er = Ps = !0
    var v = l.pending
    v === null ? (d.next = d) : ((d.next = v.next), (v.next = d)),
      (l.pending = d)
  }
  function gf(l, d, v) {
    if (v & 4194240) {
      var E = d.lanes
      ;(E &= l.pendingLanes), (v |= E), (d.lanes = v), ui(l, v)
    }
  }
  var vf = {
      readContext: jr,
      useCallback: $i,
      useContext: $i,
      useEffect: $i,
      useImperativeHandle: $i,
      useInsertionEffect: $i,
      useLayoutEffect: $i,
      useMemo: $i,
      useReducer: $i,
      useRef: $i,
      useState: $i,
      useDebugValue: $i,
      useDeferredValue: $i,
      useTransition: $i,
      useMutableSource: $i,
      useSyncExternalStore: $i,
      useId: $i,
      unstable_isNewReconciler: !1,
    },
    Tv = {
      readContext: jr,
      useCallback: function (l, d) {
        return (Xi().memoizedState = [l, d === void 0 ? null : d]), l
      },
      useContext: jr,
      useEffect: pr,
      useImperativeHandle: function (l, d, v) {
        return (
          (v = v != null ? v.concat([l]) : null),
          Zs(4194308, 4, Ev.bind(null, d, l), v)
        )
      },
      useLayoutEffect: function (l, d) {
        return Zs(4194308, 4, l, d)
      },
      useInsertionEffect: function (l, d) {
        return Zs(4, 2, l, d)
      },
      useMemo: function (l, d) {
        var v = Xi()
        return (
          (d = d === void 0 ? null : d),
          (l = l()),
          (v.memoizedState = [l, d]),
          l
        )
      },
      useReducer: function (l, d, v) {
        var E = Xi()
        return (
          (d = v !== void 0 ? v(d) : d),
          (E.memoizedState = E.baseState = d),
          (l = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: l,
            lastRenderedState: d,
          }),
          (E.queue = l),
          (l = l.dispatch = pf.bind(null, $n, l)),
          [E.memoizedState, l]
        )
      },
      useRef: function (l) {
        var d = Xi()
        return (l = { current: l }), (d.memoizedState = l)
      },
      useState: _p,
      useDebugValue: ff,
      useDeferredValue: function (l) {
        return (Xi().memoizedState = l)
      },
      useTransition: function () {
        var l = _p(!1),
          d = l[0]
        return (l = $_.bind(null, l[1])), (Xi().memoizedState = l), [d, l]
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (l, d, v) {
        var E = $n,
          R = Xi()
        if (Yn) {
          if (v === void 0) throw Error(t(407))
          v = v()
        } else {
          if (((v = d()), tr === null)) throw Error(t(349))
          Co & 30 || df(E, d, v)
        }
        R.memoizedState = v
        var L = { value: v, getSnapshot: d }
        return (
          (R.queue = L),
          pr(_v.bind(null, E, L, l), [l]),
          (E.flags |= 2048),
          Rs(9, yu.bind(null, E, L, v, d), void 0, null),
          v
        )
      },
      useId: function () {
        var l = Xi(),
          d = tr.identifierPrefix
        if (Yn) {
          var v = cs,
            E = lt
          ;(v = (E & ~(1 << (32 - mt(E) - 1))).toString(32) + v),
            (d = ':' + d + 'R' + v),
            (v = ua++),
            0 < v && (d += 'H' + v.toString(32)),
            (d += ':')
        } else (v = Er++), (d = ':' + d + 'r' + v.toString(32) + ':')
        return (l.memoizedState = d)
      },
      unstable_isNewReconciler: !1,
    },
    Av = {
      readContext: jr,
      useCallback: bv,
      useContext: jr,
      useEffect: wp,
      useImperativeHandle: Mp,
      useInsertionEffect: Sp,
      useLayoutEffect: Mv,
      useMemo: Wr,
      useReducer: vu,
      useRef: Sv,
      useState: function () {
        return vu(ec)
      },
      useDebugValue: ff,
      useDeferredValue: function (l) {
        var d = Gr()
        return hf(d, li.memoizedState, l)
      },
      useTransition: function () {
        var l = vu(ec)[0],
          d = Gr().memoizedState
        return [l, d]
      },
      useMutableSource: vp,
      useSyncExternalStore: yp,
      useId: Ro,
      unstable_isNewReconciler: !1,
    },
    Cv = {
      readContext: jr,
      useCallback: bv,
      useContext: jr,
      useEffect: wp,
      useImperativeHandle: Mp,
      useInsertionEffect: Sp,
      useLayoutEffect: Mv,
      useMemo: Wr,
      useReducer: Po,
      useRef: Sv,
      useState: function () {
        return Po(ec)
      },
      useDebugValue: ff,
      useDeferredValue: function (l) {
        var d = Gr()
        return li === null ? (d.memoizedState = l) : hf(d, li.memoizedState, l)
      },
      useTransition: function () {
        var l = Po(ec)[0],
          d = Gr().memoizedState
        return [l, d]
      },
      useMutableSource: vp,
      useSyncExternalStore: yp,
      useId: Ro,
      unstable_isNewReconciler: !1,
    }
  function ds(l, d) {
    if (l && l.defaultProps) {
      ;(d = Q({}, d)), (l = l.defaultProps)
      for (var v in l) d[v] === void 0 && (d[v] = l[v])
      return d
    }
    return d
  }
  function wu(l, d, v, E) {
    ;(d = l.memoizedState),
      (v = v(E, d)),
      (v = v == null ? d : Q({}, d, v)),
      (l.memoizedState = v),
      l.lanes === 0 && (l.updateQueue.baseState = v)
  }
  var yf = {
    isMounted: function (l) {
      return (l = l._reactInternals) ? ee(l) === l : !1
    },
    enqueueSetState: function (l, d, v) {
      l = l._reactInternals
      var E = Xr(),
        R = rc(l),
        L = kn(E, R)
      ;(L.payload = d),
        v != null && (L.callback = v),
        (d = Jn(l, L, R)),
        d !== null && (Do(d, l, R, E), Ji(d, l, R))
    },
    enqueueReplaceState: function (l, d, v) {
      l = l._reactInternals
      var E = Xr(),
        R = rc(l),
        L = kn(E, R)
      ;(L.tag = 1),
        (L.payload = d),
        v != null && (L.callback = v),
        (d = Jn(l, L, R)),
        d !== null && (Do(d, l, R, E), Ji(d, l, R))
    },
    enqueueForceUpdate: function (l, d) {
      l = l._reactInternals
      var v = Xr(),
        E = rc(l),
        R = kn(v, E)
      ;(R.tag = 2),
        d != null && (R.callback = d),
        (d = Jn(l, R, E)),
        d !== null && (Do(d, l, E, v), Ji(d, l, E))
    },
  }
  function Pv(l, d, v, E, R, L, W) {
    return (
      (l = l.stateNode),
      typeof l.shouldComponentUpdate == 'function'
        ? l.shouldComponentUpdate(E, L, W)
        : d.prototype && d.prototype.isPureReactComponent
        ? !ja(v, E) || !ja(R, L)
        : !0
    )
  }
  function f(l, d, v) {
    var E = !1,
      R = wo,
      L = d.contextType
    return (
      typeof L == 'object' && L !== null
        ? (L = jr(L))
        : ((R = Qi(d) ? So : Gi.current),
          (E = d.contextTypes),
          (L = (E = E != null) ? qa(l, R) : wo)),
      (d = new d(v, L)),
      (l.memoizedState =
        d.state !== null && d.state !== void 0 ? d.state : null),
      (d.updater = yf),
      (l.stateNode = d),
      (d._reactInternals = l),
      E &&
        ((l = l.stateNode),
        (l.__reactInternalMemoizedUnmaskedChildContext = R),
        (l.__reactInternalMemoizedMaskedChildContext = L)),
      d
    )
  }
  function p(l, d, v, E) {
    ;(l = d.state),
      typeof d.componentWillReceiveProps == 'function' &&
        d.componentWillReceiveProps(v, E),
      typeof d.UNSAFE_componentWillReceiveProps == 'function' &&
        d.UNSAFE_componentWillReceiveProps(v, E),
      d.state !== l && yf.enqueueReplaceState(d, d.state, null)
  }
  function S(l, d, v, E) {
    var R = l.stateNode
    ;(R.props = v), (R.state = l.memoizedState), (R.refs = {}), hn(l)
    var L = d.contextType
    typeof L == 'object' && L !== null
      ? (R.context = jr(L))
      : ((L = Qi(d) ? So : Gi.current), (R.context = qa(l, L))),
      (R.state = l.memoizedState),
      (L = d.getDerivedStateFromProps),
      typeof L == 'function' && (wu(l, d, L, v), (R.state = l.memoizedState)),
      typeof d.getDerivedStateFromProps == 'function' ||
        typeof R.getSnapshotBeforeUpdate == 'function' ||
        (typeof R.UNSAFE_componentWillMount != 'function' &&
          typeof R.componentWillMount != 'function') ||
        ((d = R.state),
        typeof R.componentWillMount == 'function' && R.componentWillMount(),
        typeof R.UNSAFE_componentWillMount == 'function' &&
          R.UNSAFE_componentWillMount(),
        d !== R.state && yf.enqueueReplaceState(R, R.state, null),
        ai(l, v, R, E),
        (R.state = l.memoizedState)),
      typeof R.componentDidMount == 'function' && (l.flags |= 4194308)
  }
  function C(l, d) {
    try {
      var v = '',
        E = d
      do (v += Ce(E)), (E = E.return)
      while (E)
      var R = v
    } catch (L) {
      R =
        `
Error generating stack: ` +
        L.message +
        `
` +
        L.stack
    }
    return { value: l, source: d, stack: R, digest: null }
  }
  function I(l, d, v) {
    return { value: l, source: null, stack: v ?? null, digest: d ?? null }
  }
  function B(l, d) {
    try {
      console.error(d.value)
    } catch (v) {
      setTimeout(function () {
        throw v
      })
    }
  }
  var ae = typeof WeakMap == 'function' ? WeakMap : Map
  function ye(l, d, v) {
    ;(v = kn(-1, v)), (v.tag = 3), (v.payload = { element: null })
    var E = d.value
    return (
      (v.callback = function () {
        kv || ((kv = !0), (n1 = E)), B(l, d)
      }),
      v
    )
  }
  function Fe(l, d, v) {
    ;(v = kn(-1, v)), (v.tag = 3)
    var E = l.type.getDerivedStateFromError
    if (typeof E == 'function') {
      var R = d.value
      ;(v.payload = function () {
        return E(R)
      }),
        (v.callback = function () {
          B(l, d)
        })
    }
    var L = l.stateNode
    return (
      L !== null &&
        typeof L.componentDidCatch == 'function' &&
        (v.callback = function () {
          B(l, d),
            typeof E != 'function' &&
              (nc === null ? (nc = new Set([this])) : nc.add(this))
          var W = d.stack
          this.componentDidCatch(d.value, {
            componentStack: W !== null ? W : '',
          })
        }),
      v
    )
  }
  function it(l, d, v) {
    var E = l.pingCache
    if (E === null) {
      E = l.pingCache = new ae()
      var R = new Set()
      E.set(d, R)
    } else (R = E.get(d)), R === void 0 && ((R = new Set()), E.set(d, R))
    R.has(v) || (R.add(v), (l = EU.bind(null, l, d, v)), d.then(l, l))
  }
  function At(l) {
    do {
      var d
      if (
        ((d = l.tag === 13) &&
          ((d = l.memoizedState),
          (d = d !== null ? d.dehydrated !== null : !0)),
        d)
      )
        return l
      l = l.return
    } while (l !== null)
    return null
  }
  function on(l, d, v, E, R) {
    return l.mode & 1
      ? ((l.flags |= 65536), (l.lanes = R), l)
      : (l === d
          ? (l.flags |= 65536)
          : ((l.flags |= 128),
            (v.flags |= 131072),
            (v.flags &= -52805),
            v.tag === 1 &&
              (v.alternate === null
                ? (v.tag = 17)
                : ((d = kn(-1, 1)), (d.tag = 2), Jn(v, d, 1))),
            (v.lanes |= 1)),
        l)
  }
  var Gt = P.ReactCurrentOwner,
    gn = !1
  function St(l, d, v, E) {
    d.child = l === null ? uu(d, null, v, E) : Qa(d, l.child, v, E)
  }
  function qi(l, d, v, E, R) {
    v = v.render
    var L = d.ref
    return (
      la(d, R),
      (E = gu(l, d, v, E, L, R)),
      (v = gp()),
      l !== null && !gn
        ? ((d.updateQueue = l.updateQueue),
          (d.flags &= -2053),
          (l.lanes &= ~R),
          ll(l, d, R))
        : (Yn && v && cp(d), (d.flags |= 1), St(l, d, E, R), d.child)
    )
  }
  function $r(l, d, v, E, R) {
    if (l === null) {
      var L = v.type
      return typeof L == 'function' &&
        !c1(L) &&
        L.defaultProps === void 0 &&
        v.compare === null &&
        v.defaultProps === void 0
        ? ((d.tag = 15), (d.type = L), be(l, d, L, E, R))
        : ((l = jv(v.type, null, E, d, d.mode, R)),
          (l.ref = d.ref),
          (l.return = d),
          (d.child = l))
    }
    if (((L = l.child), !(l.lanes & R))) {
      var W = L.memoizedProps
      if (
        ((v = v.compare), (v = v !== null ? v : ja), v(W, E) && l.ref === d.ref)
      )
        return ll(l, d, R)
    }
    return (
      (d.flags |= 1),
      (l = oc(L, E)),
      (l.ref = d.ref),
      (l.return = d),
      (d.child = l)
    )
  }
  function be(l, d, v, E, R) {
    if (l !== null) {
      var L = l.memoizedProps
      if (ja(L, E) && l.ref === d.ref)
        if (((gn = !1), (d.pendingProps = E = L), (l.lanes & R) !== 0))
          l.flags & 131072 && (gn = !0)
        else return (d.lanes = l.lanes), ll(l, d, R)
    }
    return yt(l, d, v, E, R)
  }
  function xe(l, d, v) {
    var E = d.pendingProps,
      R = E.children,
      L = l !== null ? l.memoizedState : null
    if (E.mode === 'hidden')
      if (!(d.mode & 1))
        (d.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          Bn(_f, Is),
          (Is |= v)
      else {
        if (!(v & 1073741824))
          return (
            (l = L !== null ? L.baseLanes | v : v),
            (d.lanes = d.childLanes = 1073741824),
            (d.memoizedState = {
              baseLanes: l,
              cachePool: null,
              transitions: null,
            }),
            (d.updateQueue = null),
            Bn(_f, Is),
            (Is |= l),
            null
          )
        ;(d.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          (E = L !== null ? L.baseLanes : v),
          Bn(_f, Is),
          (Is |= E)
      }
    else
      L !== null ? ((E = L.baseLanes | v), (d.memoizedState = null)) : (E = v),
        Bn(_f, Is),
        (Is |= E)
    return St(l, d, R, v), d.child
  }
  function Ne(l, d) {
    var v = d.ref
    ;((l === null && v !== null) || (l !== null && l.ref !== v)) &&
      ((d.flags |= 512), (d.flags |= 2097152))
  }
  function yt(l, d, v, E, R) {
    var L = Qi(v) ? So : Gi.current
    return (
      (L = qa(d, L)),
      la(d, R),
      (v = gu(l, d, v, E, L, R)),
      (E = gp()),
      l !== null && !gn
        ? ((d.updateQueue = l.updateQueue),
          (d.flags &= -2053),
          (l.lanes &= ~R),
          ll(l, d, R))
        : (Yn && E && cp(d), (d.flags |= 1), St(l, d, v, R), d.child)
    )
  }
  function kt(l, d, v, E, R) {
    if (Qi(v)) {
      var L = !0
      Ya(d)
    } else L = !1
    if ((la(d, R), d.stateNode === null))
      Iv(l, d), f(d, v, E), S(d, v, E, R), (E = !0)
    else if (l === null) {
      var W = d.stateNode,
        ue = d.memoizedProps
      W.props = ue
      var pe = W.context,
        Re = v.contextType
      typeof Re == 'object' && Re !== null
        ? (Re = jr(Re))
        : ((Re = Qi(v) ? So : Gi.current), (Re = qa(d, Re)))
      var Ke = v.getDerivedStateFromProps,
        tt =
          typeof Ke == 'function' ||
          typeof W.getSnapshotBeforeUpdate == 'function'
      tt ||
        (typeof W.UNSAFE_componentWillReceiveProps != 'function' &&
          typeof W.componentWillReceiveProps != 'function') ||
        ((ue !== E || pe !== Re) && p(d, W, E, Re)),
        (On = !1)
      var Ye = d.memoizedState
      ;(W.state = Ye),
        ai(d, E, W, R),
        (pe = d.memoizedState),
        ue !== E || Ye !== pe || dr.current || On
          ? (typeof Ke == 'function' &&
              (wu(d, v, Ke, E), (pe = d.memoizedState)),
            (ue = On || Pv(d, v, ue, E, Ye, pe, Re))
              ? (tt ||
                  (typeof W.UNSAFE_componentWillMount != 'function' &&
                    typeof W.componentWillMount != 'function') ||
                  (typeof W.componentWillMount == 'function' &&
                    W.componentWillMount(),
                  typeof W.UNSAFE_componentWillMount == 'function' &&
                    W.UNSAFE_componentWillMount()),
                typeof W.componentDidMount == 'function' &&
                  (d.flags |= 4194308))
              : (typeof W.componentDidMount == 'function' &&
                  (d.flags |= 4194308),
                (d.memoizedProps = E),
                (d.memoizedState = pe)),
            (W.props = E),
            (W.state = pe),
            (W.context = Re),
            (E = ue))
          : (typeof W.componentDidMount == 'function' && (d.flags |= 4194308),
            (E = !1))
    } else {
      ;(W = d.stateNode),
        fi(l, d),
        (ue = d.memoizedProps),
        (Re = d.type === d.elementType ? ue : ds(d.type, ue)),
        (W.props = Re),
        (tt = d.pendingProps),
        (Ye = W.context),
        (pe = v.contextType),
        typeof pe == 'object' && pe !== null
          ? (pe = jr(pe))
          : ((pe = Qi(v) ? So : Gi.current), (pe = qa(d, pe)))
      var Et = v.getDerivedStateFromProps
      ;(Ke =
        typeof Et == 'function' ||
        typeof W.getSnapshotBeforeUpdate == 'function') ||
        (typeof W.UNSAFE_componentWillReceiveProps != 'function' &&
          typeof W.componentWillReceiveProps != 'function') ||
        ((ue !== tt || Ye !== pe) && p(d, W, E, pe)),
        (On = !1),
        (Ye = d.memoizedState),
        (W.state = Ye),
        ai(d, E, W, R)
      var Nt = d.memoizedState
      ue !== tt || Ye !== Nt || dr.current || On
        ? (typeof Et == 'function' && (wu(d, v, Et, E), (Nt = d.memoizedState)),
          (Re = On || Pv(d, v, Re, E, Ye, Nt, pe) || !1)
            ? (Ke ||
                (typeof W.UNSAFE_componentWillUpdate != 'function' &&
                  typeof W.componentWillUpdate != 'function') ||
                (typeof W.componentWillUpdate == 'function' &&
                  W.componentWillUpdate(E, Nt, pe),
                typeof W.UNSAFE_componentWillUpdate == 'function' &&
                  W.UNSAFE_componentWillUpdate(E, Nt, pe)),
              typeof W.componentDidUpdate == 'function' && (d.flags |= 4),
              typeof W.getSnapshotBeforeUpdate == 'function' &&
                (d.flags |= 1024))
            : (typeof W.componentDidUpdate != 'function' ||
                (ue === l.memoizedProps && Ye === l.memoizedState) ||
                (d.flags |= 4),
              typeof W.getSnapshotBeforeUpdate != 'function' ||
                (ue === l.memoizedProps && Ye === l.memoizedState) ||
                (d.flags |= 1024),
              (d.memoizedProps = E),
              (d.memoizedState = Nt)),
          (W.props = E),
          (W.state = Nt),
          (W.context = pe),
          (E = Re))
        : (typeof W.componentDidUpdate != 'function' ||
            (ue === l.memoizedProps && Ye === l.memoizedState) ||
            (d.flags |= 4),
          typeof W.getSnapshotBeforeUpdate != 'function' ||
            (ue === l.memoizedProps && Ye === l.memoizedState) ||
            (d.flags |= 1024),
          (E = !1))
    }
    return cn(l, d, v, E, L, R)
  }
  function cn(l, d, v, E, R, L) {
    Ne(l, d)
    var W = (d.flags & 128) !== 0
    if (!E && !W) return R && ap(d, v, !1), ll(l, d, L)
    ;(E = d.stateNode), (Gt.current = d)
    var ue =
      W && typeof v.getDerivedStateFromError != 'function' ? null : E.render()
    return (
      (d.flags |= 1),
      l !== null && W
        ? ((d.child = Qa(d, l.child, null, L)), (d.child = Qa(d, null, ue, L)))
        : St(l, d, ue, L),
      (d.memoizedState = E.state),
      R && ap(d, v, !0),
      d.child
    )
  }
  function an(l) {
    var d = l.stateNode
    d.pendingContext
      ? op(l, d.pendingContext, d.pendingContext !== d.context)
      : d.context && op(l, d.context, !1),
      pu(l, d.containerInfo)
  }
  function bn(l, d, v, E, R) {
    return aa(), Yl(R), (d.flags |= 256), St(l, d, v, E), d.child
  }
  var _i = { dehydrated: null, treeContext: null, retryLane: 0 }
  function En(l) {
    return { baseLanes: l, cachePool: null, transitions: null }
  }
  function Io(l, d, v) {
    var E = d.pendingProps,
      R = Zn.current,
      L = !1,
      W = (d.flags & 128) !== 0,
      ue
    if (
      ((ue = W) ||
        (ue = l !== null && l.memoizedState === null ? !1 : (R & 2) !== 0),
      ue
        ? ((L = !0), (d.flags &= -129))
        : (l === null || l.memoizedState !== null) && (R |= 1),
      Bn(Zn, R & 1),
      l === null)
    )
      return (
        cf(d),
        (l = d.memoizedState),
        l !== null && ((l = l.dehydrated), l !== null)
          ? (d.mode & 1
              ? l.data === '$!'
                ? (d.lanes = 8)
                : (d.lanes = 1073741824)
              : (d.lanes = 1),
            null)
          : ((W = E.children),
            (l = E.fallback),
            L
              ? ((E = d.mode),
                (L = d.child),
                (W = { mode: 'hidden', children: W }),
                !(E & 1) && L !== null
                  ? ((L.childLanes = 0), (L.pendingProps = W))
                  : (L = Hv(W, E, 0, null)),
                (l = Tu(l, E, v, null)),
                (L.return = d),
                (l.return = d),
                (L.sibling = l),
                (d.child = L),
                (d.child.memoizedState = En(v)),
                (d.memoizedState = _i),
                l)
              : Ep(d, W))
      )
    if (
      ((R = l.memoizedState), R !== null && ((ue = R.dehydrated), ue !== null))
    )
      return fU(l, d, W, E, ue, R, v)
    if (L) {
      ;(L = E.fallback), (W = d.mode), (R = l.child), (ue = R.sibling)
      var pe = { mode: 'hidden', children: E.children }
      return (
        !(W & 1) && d.child !== R
          ? ((E = d.child),
            (E.childLanes = 0),
            (E.pendingProps = pe),
            (d.deletions = null))
          : ((E = oc(R, pe)), (E.subtreeFlags = R.subtreeFlags & 14680064)),
        ue !== null
          ? (L = oc(ue, L))
          : ((L = Tu(L, W, v, null)), (L.flags |= 2)),
        (L.return = d),
        (E.return = d),
        (E.sibling = L),
        (d.child = E),
        (E = L),
        (L = d.child),
        (W = l.child.memoizedState),
        (W =
          W === null
            ? En(v)
            : {
                baseLanes: W.baseLanes | v,
                cachePool: null,
                transitions: W.transitions,
              }),
        (L.memoizedState = W),
        (L.childLanes = l.childLanes & ~v),
        (d.memoizedState = _i),
        E
      )
    }
    return (
      (L = l.child),
      (l = L.sibling),
      (E = oc(L, { mode: 'visible', children: E.children })),
      !(d.mode & 1) && (E.lanes = v),
      (E.return = d),
      (E.sibling = null),
      l !== null &&
        ((v = d.deletions),
        v === null ? ((d.deletions = [l]), (d.flags |= 16)) : v.push(l)),
      (d.child = E),
      (d.memoizedState = null),
      E
    )
  }
  function Ep(l, d) {
    return (
      (d = Hv({ mode: 'visible', children: d }, l.mode, 0, null)),
      (d.return = l),
      (l.child = d)
    )
  }
  function Rv(l, d, v, E) {
    return (
      E !== null && Yl(E),
      Qa(d, l.child, null, v),
      (l = Ep(d, d.pendingProps.children)),
      (l.flags |= 2),
      (d.memoizedState = null),
      l
    )
  }
  function fU(l, d, v, E, R, L, W) {
    if (v)
      return d.flags & 256
        ? ((d.flags &= -257), (E = I(Error(t(422)))), Rv(l, d, W, E))
        : d.memoizedState !== null
        ? ((d.child = l.child), (d.flags |= 128), null)
        : ((L = E.fallback),
          (R = d.mode),
          (E = Hv({ mode: 'visible', children: E.children }, R, 0, null)),
          (L = Tu(L, R, W, null)),
          (L.flags |= 2),
          (E.return = d),
          (L.return = d),
          (E.sibling = L),
          (d.child = E),
          d.mode & 1 && Qa(d, l.child, null, W),
          (d.child.memoizedState = En(W)),
          (d.memoizedState = _i),
          L)
    if (!(d.mode & 1)) return Rv(l, d, W, null)
    if (R.data === '$!') {
      if (((E = R.nextSibling && R.nextSibling.dataset), E)) var ue = E.dgst
      return (
        (E = ue), (L = Error(t(419))), (E = I(L, E, void 0)), Rv(l, d, W, E)
      )
    }
    if (((ue = (W & l.childLanes) !== 0), gn || ue)) {
      if (((E = tr), E !== null)) {
        switch (W & -W) {
          case 4:
            R = 2
            break
          case 16:
            R = 8
            break
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            R = 32
            break
          case 536870912:
            R = 268435456
            break
          default:
            R = 0
        }
        ;(R = R & (E.suspendedLanes | W) ? 0 : R),
          R !== 0 &&
            R !== L.retryLane &&
            ((L.retryLane = R), As(l, R), Do(E, l, R, -1))
      }
      return l1(), (E = I(Error(t(421)))), Rv(l, d, W, E)
    }
    return R.data === '$?'
      ? ((d.flags |= 128),
        (d.child = l.child),
        (d = bU.bind(null, l)),
        (R._reactRetry = d),
        null)
      : ((l = L.treeContext),
        (hr = xo(R.nextSibling)),
        (Wi = d),
        (Yn = !0),
        (us = null),
        l !== null &&
          ((fr[ki++] = lt),
          (fr[ki++] = cs),
          (fr[ki++] = Ka),
          (lt = l.id),
          (cs = l.overflow),
          (Ka = d)),
        (d = Ep(d, E.children)),
        (d.flags |= 4096),
        d)
  }
  function FT(l, d, v) {
    l.lanes |= d
    var E = l.alternate
    E !== null && (E.lanes |= d), fu(l.return, d, v)
  }
  function X_(l, d, v, E, R) {
    var L = l.memoizedState
    L === null
      ? (l.memoizedState = {
          isBackwards: d,
          rendering: null,
          renderingStartTime: 0,
          last: E,
          tail: v,
          tailMode: R,
        })
      : ((L.isBackwards = d),
        (L.rendering = null),
        (L.renderingStartTime = 0),
        (L.last = E),
        (L.tail = v),
        (L.tailMode = R))
  }
  function UT(l, d, v) {
    var E = d.pendingProps,
      R = E.revealOrder,
      L = E.tail
    if ((St(l, d, E.children, v), (E = Zn.current), E & 2))
      (E = (E & 1) | 2), (d.flags |= 128)
    else {
      if (l !== null && l.flags & 128)
        e: for (l = d.child; l !== null; ) {
          if (l.tag === 13) l.memoizedState !== null && FT(l, v, d)
          else if (l.tag === 19) FT(l, v, d)
          else if (l.child !== null) {
            ;(l.child.return = l), (l = l.child)
            continue
          }
          if (l === d) break e
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === d) break e
            l = l.return
          }
          ;(l.sibling.return = l.return), (l = l.sibling)
        }
      E &= 1
    }
    if ((Bn(Zn, E), !(d.mode & 1))) d.memoizedState = null
    else
      switch (R) {
        case 'forwards':
          for (v = d.child, R = null; v !== null; )
            (l = v.alternate),
              l !== null && Cs(l) === null && (R = v),
              (v = v.sibling)
          ;(v = R),
            v === null
              ? ((R = d.child), (d.child = null))
              : ((R = v.sibling), (v.sibling = null)),
            X_(d, !1, R, v, L)
          break
        case 'backwards':
          for (v = null, R = d.child, d.child = null; R !== null; ) {
            if (((l = R.alternate), l !== null && Cs(l) === null)) {
              d.child = R
              break
            }
            ;(l = R.sibling), (R.sibling = v), (v = R), (R = l)
          }
          X_(d, !0, v, null, L)
          break
        case 'together':
          X_(d, !1, null, null, void 0)
          break
        default:
          d.memoizedState = null
      }
    return d.child
  }
  function Iv(l, d) {
    !(d.mode & 1) &&
      l !== null &&
      ((l.alternate = null), (d.alternate = null), (d.flags |= 2))
  }
  function ll(l, d, v) {
    if (
      (l !== null && (d.dependencies = l.dependencies),
      (Su |= d.lanes),
      !(v & d.childLanes))
    )
      return null
    if (l !== null && d.child !== l.child) throw Error(t(153))
    if (d.child !== null) {
      for (
        l = d.child, v = oc(l, l.pendingProps), d.child = v, v.return = d;
        l.sibling !== null;

      )
        (l = l.sibling), (v = v.sibling = oc(l, l.pendingProps)), (v.return = d)
      v.sibling = null
    }
    return d.child
  }
  function hU(l, d, v) {
    switch (d.tag) {
      case 3:
        an(d), aa()
        break
      case 5:
        rl(d)
        break
      case 1:
        Qi(d.type) && Ya(d)
        break
      case 4:
        pu(d, d.stateNode.containerInfo)
        break
      case 10:
        var E = d.type._context,
          R = d.memoizedProps.value
        Bn(Ja, E._currentValue), (E._currentValue = R)
        break
      case 13:
        if (((E = d.memoizedState), E !== null))
          return E.dehydrated !== null
            ? (Bn(Zn, Zn.current & 1), (d.flags |= 128), null)
            : v & d.child.childLanes
            ? Io(l, d, v)
            : (Bn(Zn, Zn.current & 1),
              (l = ll(l, d, v)),
              l !== null ? l.sibling : null)
        Bn(Zn, Zn.current & 1)
        break
      case 19:
        if (((E = (v & d.childLanes) !== 0), l.flags & 128)) {
          if (E) return UT(l, d, v)
          d.flags |= 128
        }
        if (
          ((R = d.memoizedState),
          R !== null &&
            ((R.rendering = null), (R.tail = null), (R.lastEffect = null)),
          Bn(Zn, Zn.current),
          E)
        )
          break
        return null
      case 22:
      case 23:
        return (d.lanes = 0), xe(l, d, v)
    }
    return ll(l, d, v)
  }
  var BT, q_, zT, VT
  ;(BT = function (l, d) {
    for (var v = d.child; v !== null; ) {
      if (v.tag === 5 || v.tag === 6) l.appendChild(v.stateNode)
      else if (v.tag !== 4 && v.child !== null) {
        ;(v.child.return = v), (v = v.child)
        continue
      }
      if (v === d) break
      for (; v.sibling === null; ) {
        if (v.return === null || v.return === d) return
        v = v.return
      }
      ;(v.sibling.return = v.return), (v = v.sibling)
    }
  }),
    (q_ = function () {}),
    (zT = function (l, d, v, E) {
      var R = l.memoizedProps
      if (R !== E) {
        ;(l = d.stateNode), xi(Hr.current)
        var L = null
        switch (v) {
          case 'input':
            ;(R = se(l, R)), (E = se(l, E)), (L = [])
            break
          case 'select':
            ;(R = Q({}, R, { value: void 0 })),
              (E = Q({}, E, { value: void 0 })),
              (L = [])
            break
          case 'textarea':
            ;(R = Z(l, R)), (E = Z(l, E)), (L = [])
            break
          default:
            typeof R.onClick != 'function' &&
              typeof E.onClick == 'function' &&
              (l.onclick = iu)
        }
        en(v, E)
        var W
        v = null
        for (Re in R)
          if (!E.hasOwnProperty(Re) && R.hasOwnProperty(Re) && R[Re] != null)
            if (Re === 'style') {
              var ue = R[Re]
              for (W in ue) ue.hasOwnProperty(W) && (v || (v = {}), (v[W] = ''))
            } else
              Re !== 'dangerouslySetInnerHTML' &&
                Re !== 'children' &&
                Re !== 'suppressContentEditableWarning' &&
                Re !== 'suppressHydrationWarning' &&
                Re !== 'autoFocus' &&
                (r.hasOwnProperty(Re)
                  ? L || (L = [])
                  : (L = L || []).push(Re, null))
        for (Re in E) {
          var pe = E[Re]
          if (
            ((ue = R != null ? R[Re] : void 0),
            E.hasOwnProperty(Re) && pe !== ue && (pe != null || ue != null))
          )
            if (Re === 'style')
              if (ue) {
                for (W in ue)
                  !ue.hasOwnProperty(W) ||
                    (pe && pe.hasOwnProperty(W)) ||
                    (v || (v = {}), (v[W] = ''))
                for (W in pe)
                  pe.hasOwnProperty(W) &&
                    ue[W] !== pe[W] &&
                    (v || (v = {}), (v[W] = pe[W]))
              } else v || (L || (L = []), L.push(Re, v)), (v = pe)
            else
              Re === 'dangerouslySetInnerHTML'
                ? ((pe = pe ? pe.__html : void 0),
                  (ue = ue ? ue.__html : void 0),
                  pe != null && ue !== pe && (L = L || []).push(Re, pe))
                : Re === 'children'
                ? (typeof pe != 'string' && typeof pe != 'number') ||
                  (L = L || []).push(Re, '' + pe)
                : Re !== 'suppressContentEditableWarning' &&
                  Re !== 'suppressHydrationWarning' &&
                  (r.hasOwnProperty(Re)
                    ? (pe != null && Re === 'onScroll' && Gn('scroll', l),
                      L || ue === pe || (L = []))
                    : (L = L || []).push(Re, pe))
        }
        v && (L = L || []).push('style', v)
        var Re = L
        ;(d.updateQueue = Re) && (d.flags |= 4)
      }
    }),
    (VT = function (l, d, v, E) {
      v !== E && (d.flags |= 4)
    })
  function bp(l, d) {
    if (!Yn)
      switch (l.tailMode) {
        case 'hidden':
          d = l.tail
          for (var v = null; d !== null; )
            d.alternate !== null && (v = d), (d = d.sibling)
          v === null ? (l.tail = null) : (v.sibling = null)
          break
        case 'collapsed':
          v = l.tail
          for (var E = null; v !== null; )
            v.alternate !== null && (E = v), (v = v.sibling)
          E === null
            ? d || l.tail === null
              ? (l.tail = null)
              : (l.tail.sibling = null)
            : (E.sibling = null)
      }
  }
  function br(l) {
    var d = l.alternate !== null && l.alternate.child === l.child,
      v = 0,
      E = 0
    if (d)
      for (var R = l.child; R !== null; )
        (v |= R.lanes | R.childLanes),
          (E |= R.subtreeFlags & 14680064),
          (E |= R.flags & 14680064),
          (R.return = l),
          (R = R.sibling)
    else
      for (R = l.child; R !== null; )
        (v |= R.lanes | R.childLanes),
          (E |= R.subtreeFlags),
          (E |= R.flags),
          (R.return = l),
          (R = R.sibling)
    return (l.subtreeFlags |= E), (l.childLanes = v), d
  }
  function pU(l, d, v) {
    var E = d.pendingProps
    switch ((Eo(d), d.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return br(d), null
      case 1:
        return Qi(d.type) && ru(), br(d), null
      case 3:
        return (
          (E = d.stateNode),
          ca(),
          Wn(dr),
          Wn(Gi),
          Ys(),
          E.pendingContext &&
            ((E.context = E.pendingContext), (E.pendingContext = null)),
          (l === null || l.child === null) &&
            (ql(d)
              ? (d.flags |= 4)
              : l === null ||
                (l.memoizedState.isDehydrated && !(d.flags & 256)) ||
                ((d.flags |= 1024), us !== null && (s1(us), (us = null)))),
          q_(l, d),
          br(d),
          null
        )
      case 5:
        Ql(d)
        var R = xi(Ao.current)
        if (((v = d.type), l !== null && d.stateNode != null))
          zT(l, d, v, E, R),
            l.ref !== d.ref && ((d.flags |= 512), (d.flags |= 2097152))
        else {
          if (!E) {
            if (d.stateNode === null) throw Error(t(166))
            return br(d), null
          }
          if (((l = xi(Hr.current)), ql(d))) {
            ;(E = d.stateNode), (v = d.type)
            var L = d.memoizedProps
            switch (((E[Ti] = d), (E[Xl] = L), (l = (d.mode & 1) !== 0), v)) {
              case 'dialog':
                Gn('cancel', E), Gn('close', E)
                break
              case 'iframe':
              case 'object':
              case 'embed':
                Gn('load', E)
                break
              case 'video':
              case 'audio':
                for (R = 0; R < sa.length; R++) Gn(sa[R], E)
                break
              case 'source':
                Gn('error', E)
                break
              case 'img':
              case 'image':
              case 'link':
                Gn('error', E), Gn('load', E)
                break
              case 'details':
                Gn('toggle', E)
                break
              case 'input':
                Rt(E, L), Gn('invalid', E)
                break
              case 'select':
                ;(E._wrapperState = { wasMultiple: !!L.multiple }),
                  Gn('invalid', E)
                break
              case 'textarea':
                Se(E, L), Gn('invalid', E)
            }
            en(v, L), (R = null)
            for (var W in L)
              if (L.hasOwnProperty(W)) {
                var ue = L[W]
                W === 'children'
                  ? typeof ue == 'string'
                    ? E.textContent !== ue &&
                      (L.suppressHydrationWarning !== !0 &&
                        nu(E.textContent, ue, l),
                      (R = ['children', ue]))
                    : typeof ue == 'number' &&
                      E.textContent !== '' + ue &&
                      (L.suppressHydrationWarning !== !0 &&
                        nu(E.textContent, ue, l),
                      (R = ['children', '' + ue]))
                  : r.hasOwnProperty(W) &&
                    ue != null &&
                    W === 'onScroll' &&
                    Gn('scroll', E)
              }
            switch (v) {
              case 'input':
                Vt(E), rt(E, L, !0)
                break
              case 'textarea':
                Vt(E), Ge(E)
                break
              case 'select':
              case 'option':
                break
              default:
                typeof L.onClick == 'function' && (E.onclick = iu)
            }
            ;(E = R), (d.updateQueue = E), E !== null && (d.flags |= 4)
          } else {
            ;(W = R.nodeType === 9 ? R : R.ownerDocument),
              l === 'http://www.w3.org/1999/xhtml' && (l = ze(v)),
              l === 'http://www.w3.org/1999/xhtml'
                ? v === 'script'
                  ? ((l = W.createElement('div')),
                    (l.innerHTML = '<script></script>'),
                    (l = l.removeChild(l.firstChild)))
                  : typeof E.is == 'string'
                  ? (l = W.createElement(v, { is: E.is }))
                  : ((l = W.createElement(v)),
                    v === 'select' &&
                      ((W = l),
                      E.multiple
                        ? (W.multiple = !0)
                        : E.size && (W.size = E.size)))
                : (l = W.createElementNS(l, v)),
              (l[Ti] = d),
              (l[Xl] = E),
              BT(l, d, !1, !1),
              (d.stateNode = l)
            e: {
              switch (((W = Bt(v, E)), v)) {
                case 'dialog':
                  Gn('cancel', l), Gn('close', l), (R = E)
                  break
                case 'iframe':
                case 'object':
                case 'embed':
                  Gn('load', l), (R = E)
                  break
                case 'video':
                case 'audio':
                  for (R = 0; R < sa.length; R++) Gn(sa[R], l)
                  R = E
                  break
                case 'source':
                  Gn('error', l), (R = E)
                  break
                case 'img':
                case 'image':
                case 'link':
                  Gn('error', l), Gn('load', l), (R = E)
                  break
                case 'details':
                  Gn('toggle', l), (R = E)
                  break
                case 'input':
                  Rt(l, E), (R = se(l, E)), Gn('invalid', l)
                  break
                case 'option':
                  R = E
                  break
                case 'select':
                  ;(l._wrapperState = { wasMultiple: !!E.multiple }),
                    (R = Q({}, E, { value: void 0 })),
                    Gn('invalid', l)
                  break
                case 'textarea':
                  Se(l, E), (R = Z(l, E)), Gn('invalid', l)
                  break
                default:
                  R = E
              }
              en(v, R), (ue = R)
              for (L in ue)
                if (ue.hasOwnProperty(L)) {
                  var pe = ue[L]
                  L === 'style'
                    ? It(l, pe)
                    : L === 'dangerouslySetInnerHTML'
                    ? ((pe = pe ? pe.__html : void 0), pe != null && gt(l, pe))
                    : L === 'children'
                    ? typeof pe == 'string'
                      ? (v !== 'textarea' || pe !== '') && rn(l, pe)
                      : typeof pe == 'number' && rn(l, '' + pe)
                    : L !== 'suppressContentEditableWarning' &&
                      L !== 'suppressHydrationWarning' &&
                      L !== 'autoFocus' &&
                      (r.hasOwnProperty(L)
                        ? pe != null && L === 'onScroll' && Gn('scroll', l)
                        : pe != null && A(l, L, pe, W))
                }
              switch (v) {
                case 'input':
                  Vt(l), rt(l, E, !1)
                  break
                case 'textarea':
                  Vt(l), Ge(l)
                  break
                case 'option':
                  E.value != null && l.setAttribute('value', '' + Be(E.value))
                  break
                case 'select':
                  ;(l.multiple = !!E.multiple),
                    (L = E.value),
                    L != null
                      ? ie(l, !!E.multiple, L, !1)
                      : E.defaultValue != null &&
                        ie(l, !!E.multiple, E.defaultValue, !0)
                  break
                default:
                  typeof R.onClick == 'function' && (l.onclick = iu)
              }
              switch (v) {
                case 'button':
                case 'input':
                case 'select':
                case 'textarea':
                  E = !!E.autoFocus
                  break e
                case 'img':
                  E = !0
                  break e
                default:
                  E = !1
              }
            }
            E && (d.flags |= 4)
          }
          d.ref !== null && ((d.flags |= 512), (d.flags |= 2097152))
        }
        return br(d), null
      case 6:
        if (l && d.stateNode != null) VT(l, d, l.memoizedProps, E)
        else {
          if (typeof E != 'string' && d.stateNode === null) throw Error(t(166))
          if (((v = xi(Ao.current)), xi(Hr.current), ql(d))) {
            if (
              ((E = d.stateNode),
              (v = d.memoizedProps),
              (E[Ti] = d),
              (L = E.nodeValue !== v) && ((l = Wi), l !== null))
            )
              switch (l.tag) {
                case 3:
                  nu(E.nodeValue, v, (l.mode & 1) !== 0)
                  break
                case 5:
                  l.memoizedProps.suppressHydrationWarning !== !0 &&
                    nu(E.nodeValue, v, (l.mode & 1) !== 0)
              }
            L && (d.flags |= 4)
          } else
            (E = (v.nodeType === 9 ? v : v.ownerDocument).createTextNode(E)),
              (E[Ti] = d),
              (d.stateNode = E)
        }
        return br(d), null
      case 13:
        if (
          (Wn(Zn),
          (E = d.memoizedState),
          l === null ||
            (l.memoizedState !== null && l.memoizedState.dehydrated !== null))
        ) {
          if (Yn && hr !== null && d.mode & 1 && !(d.flags & 128))
            fp(), aa(), (d.flags |= 98560), (L = !1)
          else if (((L = ql(d)), E !== null && E.dehydrated !== null)) {
            if (l === null) {
              if (!L) throw Error(t(318))
              if (
                ((L = d.memoizedState),
                (L = L !== null ? L.dehydrated : null),
                !L)
              )
                throw Error(t(317))
              L[Ti] = d
            } else
              aa(), !(d.flags & 128) && (d.memoizedState = null), (d.flags |= 4)
            br(d), (L = !1)
          } else us !== null && (s1(us), (us = null)), (L = !0)
          if (!L) return d.flags & 65536 ? d : null
        }
        return d.flags & 128
          ? ((d.lanes = v), d)
          : ((E = E !== null),
            E !== (l !== null && l.memoizedState !== null) &&
              E &&
              ((d.child.flags |= 8192),
              d.mode & 1 &&
                (l === null || Zn.current & 1 ? Yi === 0 && (Yi = 3) : l1())),
            d.updateQueue !== null && (d.flags |= 4),
            br(d),
            null)
      case 4:
        return (
          ca(),
          q_(l, d),
          l === null && Gl(d.stateNode.containerInfo),
          br(d),
          null
        )
      case 10:
        return du(d.type._context), br(d), null
      case 17:
        return Qi(d.type) && ru(), br(d), null
      case 19:
        if ((Wn(Zn), (L = d.memoizedState), L === null)) return br(d), null
        if (((E = (d.flags & 128) !== 0), (W = L.rendering), W === null))
          if (E) bp(L, !1)
          else {
            if (Yi !== 0 || (l !== null && l.flags & 128))
              for (l = d.child; l !== null; ) {
                if (((W = Cs(l)), W !== null)) {
                  for (
                    d.flags |= 128,
                      bp(L, !1),
                      E = W.updateQueue,
                      E !== null && ((d.updateQueue = E), (d.flags |= 4)),
                      d.subtreeFlags = 0,
                      E = v,
                      v = d.child;
                    v !== null;

                  )
                    (L = v),
                      (l = E),
                      (L.flags &= 14680066),
                      (W = L.alternate),
                      W === null
                        ? ((L.childLanes = 0),
                          (L.lanes = l),
                          (L.child = null),
                          (L.subtreeFlags = 0),
                          (L.memoizedProps = null),
                          (L.memoizedState = null),
                          (L.updateQueue = null),
                          (L.dependencies = null),
                          (L.stateNode = null))
                        : ((L.childLanes = W.childLanes),
                          (L.lanes = W.lanes),
                          (L.child = W.child),
                          (L.subtreeFlags = 0),
                          (L.deletions = null),
                          (L.memoizedProps = W.memoizedProps),
                          (L.memoizedState = W.memoizedState),
                          (L.updateQueue = W.updateQueue),
                          (L.type = W.type),
                          (l = W.dependencies),
                          (L.dependencies =
                            l === null
                              ? null
                              : {
                                  lanes: l.lanes,
                                  firstContext: l.firstContext,
                                })),
                      (v = v.sibling)
                  return Bn(Zn, (Zn.current & 1) | 2), d.child
                }
                l = l.sibling
              }
            L.tail !== null &&
              ce() > wf &&
              ((d.flags |= 128), (E = !0), bp(L, !1), (d.lanes = 4194304))
          }
        else {
          if (!E)
            if (((l = Cs(W)), l !== null)) {
              if (
                ((d.flags |= 128),
                (E = !0),
                (v = l.updateQueue),
                v !== null && ((d.updateQueue = v), (d.flags |= 4)),
                bp(L, !0),
                L.tail === null &&
                  L.tailMode === 'hidden' &&
                  !W.alternate &&
                  !Yn)
              )
                return br(d), null
            } else
              2 * ce() - L.renderingStartTime > wf &&
                v !== 1073741824 &&
                ((d.flags |= 128), (E = !0), bp(L, !1), (d.lanes = 4194304))
          L.isBackwards
            ? ((W.sibling = d.child), (d.child = W))
            : ((v = L.last),
              v !== null ? (v.sibling = W) : (d.child = W),
              (L.last = W))
        }
        return L.tail !== null
          ? ((d = L.tail),
            (L.rendering = d),
            (L.tail = d.sibling),
            (L.renderingStartTime = ce()),
            (d.sibling = null),
            (v = Zn.current),
            Bn(Zn, E ? (v & 1) | 2 : v & 1),
            d)
          : (br(d), null)
      case 22:
      case 23:
        return (
          a1(),
          (E = d.memoizedState !== null),
          l !== null && (l.memoizedState !== null) !== E && (d.flags |= 8192),
          E && d.mode & 1
            ? Is & 1073741824 &&
              (br(d), d.subtreeFlags & 6 && (d.flags |= 8192))
            : br(d),
          null
        )
      case 24:
        return null
      case 25:
        return null
    }
    throw Error(t(156, d.tag))
  }
  function mU(l, d) {
    switch ((Eo(d), d.tag)) {
      case 1:
        return (
          Qi(d.type) && ru(),
          (l = d.flags),
          l & 65536 ? ((d.flags = (l & -65537) | 128), d) : null
        )
      case 3:
        return (
          ca(),
          Wn(dr),
          Wn(Gi),
          Ys(),
          (l = d.flags),
          l & 65536 && !(l & 128) ? ((d.flags = (l & -65537) | 128), d) : null
        )
      case 5:
        return Ql(d), null
      case 13:
        if (
          (Wn(Zn), (l = d.memoizedState), l !== null && l.dehydrated !== null)
        ) {
          if (d.alternate === null) throw Error(t(340))
          aa()
        }
        return (
          (l = d.flags), l & 65536 ? ((d.flags = (l & -65537) | 128), d) : null
        )
      case 19:
        return Wn(Zn), null
      case 4:
        return ca(), null
      case 10:
        return du(d.type._context), null
      case 22:
      case 23:
        return a1(), null
      case 24:
        return null
      default:
        return null
    }
  }
  var Lv = !1,
    Tr = !1,
    gU = typeof WeakSet == 'function' ? WeakSet : Set,
    Pt = null
  function xf(l, d) {
    var v = l.ref
    if (v !== null)
      if (typeof v == 'function')
        try {
          v(null)
        } catch (E) {
          wi(l, d, E)
        }
      else v.current = null
  }
  function Y_(l, d, v) {
    try {
      v()
    } catch (E) {
      wi(l, d, E)
    }
  }
  var jT = !1
  function vU(l, d) {
    if ((($l = is), (l = ni()), Li(l))) {
      if ('selectionStart' in l)
        var v = { start: l.selectionStart, end: l.selectionEnd }
      else
        e: {
          v = ((v = l.ownerDocument) && v.defaultView) || window
          var E = v.getSelection && v.getSelection()
          if (E && E.rangeCount !== 0) {
            v = E.anchorNode
            var R = E.anchorOffset,
              L = E.focusNode
            E = E.focusOffset
            try {
              v.nodeType, L.nodeType
            } catch {
              v = null
              break e
            }
            var W = 0,
              ue = -1,
              pe = -1,
              Re = 0,
              Ke = 0,
              tt = l,
              Ye = null
            t: for (;;) {
              for (
                var Et;
                tt !== v || (R !== 0 && tt.nodeType !== 3) || (ue = W + R),
                  tt !== L || (E !== 0 && tt.nodeType !== 3) || (pe = W + E),
                  tt.nodeType === 3 && (W += tt.nodeValue.length),
                  (Et = tt.firstChild) !== null;

              )
                (Ye = tt), (tt = Et)
              for (;;) {
                if (tt === l) break t
                if (
                  (Ye === v && ++Re === R && (ue = W),
                  Ye === L && ++Ke === E && (pe = W),
                  (Et = tt.nextSibling) !== null)
                )
                  break
                ;(tt = Ye), (Ye = tt.parentNode)
              }
              tt = Et
            }
            v = ue === -1 || pe === -1 ? null : { start: ue, end: pe }
          } else v = null
        }
      v = v || { start: 0, end: 0 }
    } else v = null
    for (
      ep = { focusedElem: l, selectionRange: v }, is = !1, Pt = d;
      Pt !== null;

    )
      if (
        ((d = Pt), (l = d.child), (d.subtreeFlags & 1028) !== 0 && l !== null)
      )
        (l.return = d), (Pt = l)
      else
        for (; Pt !== null; ) {
          d = Pt
          try {
            var Nt = d.alternate
            if (d.flags & 1024)
              switch (d.tag) {
                case 0:
                case 11:
                case 15:
                  break
                case 1:
                  if (Nt !== null) {
                    var Dt = Nt.memoizedProps,
                      Ai = Nt.memoizedState,
                      we = d.stateNode,
                      ge = we.getSnapshotBeforeUpdate(
                        d.elementType === d.type ? Dt : ds(d.type, Dt),
                        Ai,
                      )
                    we.__reactInternalSnapshotBeforeUpdate = ge
                  }
                  break
                case 3:
                  var Ee = d.stateNode.containerInfo
                  Ee.nodeType === 1
                    ? (Ee.textContent = '')
                    : Ee.nodeType === 9 &&
                      Ee.documentElement &&
                      Ee.removeChild(Ee.documentElement)
                  break
                case 5:
                case 6:
                case 4:
                case 17:
                  break
                default:
                  throw Error(t(163))
              }
          } catch (st) {
            wi(d, d.return, st)
          }
          if (((l = d.sibling), l !== null)) {
            ;(l.return = d.return), (Pt = l)
            break
          }
          Pt = d.return
        }
    return (Nt = jT), (jT = !1), Nt
  }
  function Tp(l, d, v) {
    var E = d.updateQueue
    if (((E = E !== null ? E.lastEffect : null), E !== null)) {
      var R = (E = E.next)
      do {
        if ((R.tag & l) === l) {
          var L = R.destroy
          ;(R.destroy = void 0), L !== void 0 && Y_(d, v, L)
        }
        R = R.next
      } while (R !== E)
    }
  }
  function Nv(l, d) {
    if (
      ((d = d.updateQueue), (d = d !== null ? d.lastEffect : null), d !== null)
    ) {
      var v = (d = d.next)
      do {
        if ((v.tag & l) === l) {
          var E = v.create
          v.destroy = E()
        }
        v = v.next
      } while (v !== d)
    }
  }
  function Z_(l) {
    var d = l.ref
    if (d !== null) {
      var v = l.stateNode
      switch (l.tag) {
        case 5:
          l = v
          break
        default:
          l = v
      }
      typeof d == 'function' ? d(l) : (d.current = l)
    }
  }
  function HT(l) {
    var d = l.alternate
    d !== null && ((l.alternate = null), HT(d)),
      (l.child = null),
      (l.deletions = null),
      (l.sibling = null),
      l.tag === 5 &&
        ((d = l.stateNode),
        d !== null &&
          (delete d[Ti],
          delete d[Xl],
          delete d[Xa],
          delete d[tf],
          delete d[nf])),
      (l.stateNode = null),
      (l.return = null),
      (l.dependencies = null),
      (l.memoizedProps = null),
      (l.memoizedState = null),
      (l.pendingProps = null),
      (l.stateNode = null),
      (l.updateQueue = null)
  }
  function GT(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 4
  }
  function WT(l) {
    e: for (;;) {
      for (; l.sibling === null; ) {
        if (l.return === null || GT(l.return)) return null
        l = l.return
      }
      for (
        l.sibling.return = l.return, l = l.sibling;
        l.tag !== 5 && l.tag !== 6 && l.tag !== 18;

      ) {
        if (l.flags & 2 || l.child === null || l.tag === 4) continue e
        ;(l.child.return = l), (l = l.child)
      }
      if (!(l.flags & 2)) return l.stateNode
    }
  }
  function K_(l, d, v) {
    var E = l.tag
    if (E === 5 || E === 6)
      (l = l.stateNode),
        d
          ? v.nodeType === 8
            ? v.parentNode.insertBefore(l, d)
            : v.insertBefore(l, d)
          : (v.nodeType === 8
              ? ((d = v.parentNode), d.insertBefore(l, v))
              : ((d = v), d.appendChild(l)),
            (v = v._reactRootContainer),
            v != null || d.onclick !== null || (d.onclick = iu))
    else if (E !== 4 && ((l = l.child), l !== null))
      for (K_(l, d, v), l = l.sibling; l !== null; )
        K_(l, d, v), (l = l.sibling)
  }
  function Q_(l, d, v) {
    var E = l.tag
    if (E === 5 || E === 6)
      (l = l.stateNode), d ? v.insertBefore(l, d) : v.appendChild(l)
    else if (E !== 4 && ((l = l.child), l !== null))
      for (Q_(l, d, v), l = l.sibling; l !== null; )
        Q_(l, d, v), (l = l.sibling)
  }
  var mr = null,
    Lo = !1
  function tc(l, d, v) {
    for (v = v.child; v !== null; ) $T(l, d, v), (v = v.sibling)
  }
  function $T(l, d, v) {
    if (We && typeof We.onCommitFiberUnmount == 'function')
      try {
        We.onCommitFiberUnmount(ot, v)
      } catch {}
    switch (v.tag) {
      case 5:
        Tr || xf(v, d)
      case 6:
        var E = mr,
          R = Lo
        ;(mr = null),
          tc(l, d, v),
          (mr = E),
          (Lo = R),
          mr !== null &&
            (Lo
              ? ((l = mr),
                (v = v.stateNode),
                l.nodeType === 8
                  ? l.parentNode.removeChild(v)
                  : l.removeChild(v))
              : mr.removeChild(v.stateNode))
        break
      case 18:
        mr !== null &&
          (Lo
            ? ((l = mr),
              (v = v.stateNode),
              l.nodeType === 8
                ? ef(l.parentNode, v)
                : l.nodeType === 1 && ef(l, v),
              Wc(l))
            : ef(mr, v.stateNode))
        break
      case 4:
        ;(E = mr),
          (R = Lo),
          (mr = v.stateNode.containerInfo),
          (Lo = !0),
          tc(l, d, v),
          (mr = E),
          (Lo = R)
        break
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !Tr &&
          ((E = v.updateQueue), E !== null && ((E = E.lastEffect), E !== null))
        ) {
          R = E = E.next
          do {
            var L = R,
              W = L.destroy
            ;(L = L.tag),
              W !== void 0 && (L & 2 || L & 4) && Y_(v, d, W),
              (R = R.next)
          } while (R !== E)
        }
        tc(l, d, v)
        break
      case 1:
        if (
          !Tr &&
          (xf(v, d),
          (E = v.stateNode),
          typeof E.componentWillUnmount == 'function')
        )
          try {
            ;(E.props = v.memoizedProps),
              (E.state = v.memoizedState),
              E.componentWillUnmount()
          } catch (ue) {
            wi(v, d, ue)
          }
        tc(l, d, v)
        break
      case 21:
        tc(l, d, v)
        break
      case 22:
        v.mode & 1
          ? ((Tr = (E = Tr) || v.memoizedState !== null), tc(l, d, v), (Tr = E))
          : tc(l, d, v)
        break
      default:
        tc(l, d, v)
    }
  }
  function XT(l) {
    var d = l.updateQueue
    if (d !== null) {
      l.updateQueue = null
      var v = l.stateNode
      v === null && (v = l.stateNode = new gU()),
        d.forEach(function (E) {
          var R = TU.bind(null, l, E)
          v.has(E) || (v.add(E), E.then(R, R))
        })
    }
  }
  function No(l, d) {
    var v = d.deletions
    if (v !== null)
      for (var E = 0; E < v.length; E++) {
        var R = v[E]
        try {
          var L = l,
            W = d,
            ue = W
          e: for (; ue !== null; ) {
            switch (ue.tag) {
              case 5:
                ;(mr = ue.stateNode), (Lo = !1)
                break e
              case 3:
                ;(mr = ue.stateNode.containerInfo), (Lo = !0)
                break e
              case 4:
                ;(mr = ue.stateNode.containerInfo), (Lo = !0)
                break e
            }
            ue = ue.return
          }
          if (mr === null) throw Error(t(160))
          $T(L, W, R), (mr = null), (Lo = !1)
          var pe = R.alternate
          pe !== null && (pe.return = null), (R.return = null)
        } catch (Re) {
          wi(R, d, Re)
        }
      }
    if (d.subtreeFlags & 12854)
      for (d = d.child; d !== null; ) qT(d, l), (d = d.sibling)
  }
  function qT(l, d) {
    var v = l.alternate,
      E = l.flags
    switch (l.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ((No(d, l), da(l), E & 4)) {
          try {
            Tp(3, l, l.return), Nv(3, l)
          } catch (Dt) {
            wi(l, l.return, Dt)
          }
          try {
            Tp(5, l, l.return)
          } catch (Dt) {
            wi(l, l.return, Dt)
          }
        }
        break
      case 1:
        No(d, l), da(l), E & 512 && v !== null && xf(v, v.return)
        break
      case 5:
        if (
          (No(d, l),
          da(l),
          E & 512 && v !== null && xf(v, v.return),
          l.flags & 32)
        ) {
          var R = l.stateNode
          try {
            rn(R, '')
          } catch (Dt) {
            wi(l, l.return, Dt)
          }
        }
        if (E & 4 && ((R = l.stateNode), R != null)) {
          var L = l.memoizedProps,
            W = v !== null ? v.memoizedProps : L,
            ue = l.type,
            pe = l.updateQueue
          if (((l.updateQueue = null), pe !== null))
            try {
              ue === 'input' &&
                L.type === 'radio' &&
                L.name != null &&
                Qe(R, L),
                Bt(ue, W)
              var Re = Bt(ue, L)
              for (W = 0; W < pe.length; W += 2) {
                var Ke = pe[W],
                  tt = pe[W + 1]
                Ke === 'style'
                  ? It(R, tt)
                  : Ke === 'dangerouslySetInnerHTML'
                  ? gt(R, tt)
                  : Ke === 'children'
                  ? rn(R, tt)
                  : A(R, Ke, tt, Re)
              }
              switch (ue) {
                case 'input':
                  _t(R, L)
                  break
                case 'textarea':
                  Ue(R, L)
                  break
                case 'select':
                  var Ye = R._wrapperState.wasMultiple
                  R._wrapperState.wasMultiple = !!L.multiple
                  var Et = L.value
                  Et != null
                    ? ie(R, !!L.multiple, Et, !1)
                    : Ye !== !!L.multiple &&
                      (L.defaultValue != null
                        ? ie(R, !!L.multiple, L.defaultValue, !0)
                        : ie(R, !!L.multiple, L.multiple ? [] : '', !1))
              }
              R[Xl] = L
            } catch (Dt) {
              wi(l, l.return, Dt)
            }
        }
        break
      case 6:
        if ((No(d, l), da(l), E & 4)) {
          if (l.stateNode === null) throw Error(t(162))
          ;(R = l.stateNode), (L = l.memoizedProps)
          try {
            R.nodeValue = L
          } catch (Dt) {
            wi(l, l.return, Dt)
          }
        }
        break
      case 3:
        if (
          (No(d, l), da(l), E & 4 && v !== null && v.memoizedState.isDehydrated)
        )
          try {
            Wc(d.containerInfo)
          } catch (Dt) {
            wi(l, l.return, Dt)
          }
        break
      case 4:
        No(d, l), da(l)
        break
      case 13:
        No(d, l),
          da(l),
          (R = l.child),
          R.flags & 8192 &&
            ((L = R.memoizedState !== null),
            (R.stateNode.isHidden = L),
            !L ||
              (R.alternate !== null && R.alternate.memoizedState !== null) ||
              (t1 = ce())),
          E & 4 && XT(l)
        break
      case 22:
        if (
          ((Ke = v !== null && v.memoizedState !== null),
          l.mode & 1 ? ((Tr = (Re = Tr) || Ke), No(d, l), (Tr = Re)) : No(d, l),
          da(l),
          E & 8192)
        ) {
          if (
            ((Re = l.memoizedState !== null),
            (l.stateNode.isHidden = Re) && !Ke && l.mode & 1)
          )
            for (Pt = l, Ke = l.child; Ke !== null; ) {
              for (tt = Pt = Ke; Pt !== null; ) {
                switch (((Ye = Pt), (Et = Ye.child), Ye.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Tp(4, Ye, Ye.return)
                    break
                  case 1:
                    xf(Ye, Ye.return)
                    var Nt = Ye.stateNode
                    if (typeof Nt.componentWillUnmount == 'function') {
                      ;(E = Ye), (v = Ye.return)
                      try {
                        ;(d = E),
                          (Nt.props = d.memoizedProps),
                          (Nt.state = d.memoizedState),
                          Nt.componentWillUnmount()
                      } catch (Dt) {
                        wi(E, v, Dt)
                      }
                    }
                    break
                  case 5:
                    xf(Ye, Ye.return)
                    break
                  case 22:
                    if (Ye.memoizedState !== null) {
                      KT(tt)
                      continue
                    }
                }
                Et !== null ? ((Et.return = Ye), (Pt = Et)) : KT(tt)
              }
              Ke = Ke.sibling
            }
          e: for (Ke = null, tt = l; ; ) {
            if (tt.tag === 5) {
              if (Ke === null) {
                Ke = tt
                try {
                  ;(R = tt.stateNode),
                    Re
                      ? ((L = R.style),
                        typeof L.setProperty == 'function'
                          ? L.setProperty('display', 'none', 'important')
                          : (L.display = 'none'))
                      : ((ue = tt.stateNode),
                        (pe = tt.memoizedProps.style),
                        (W =
                          pe != null && pe.hasOwnProperty('display')
                            ? pe.display
                            : null),
                        (ue.style.display = Ut('display', W)))
                } catch (Dt) {
                  wi(l, l.return, Dt)
                }
              }
            } else if (tt.tag === 6) {
              if (Ke === null)
                try {
                  tt.stateNode.nodeValue = Re ? '' : tt.memoizedProps
                } catch (Dt) {
                  wi(l, l.return, Dt)
                }
            } else if (
              ((tt.tag !== 22 && tt.tag !== 23) ||
                tt.memoizedState === null ||
                tt === l) &&
              tt.child !== null
            ) {
              ;(tt.child.return = tt), (tt = tt.child)
              continue
            }
            if (tt === l) break e
            for (; tt.sibling === null; ) {
              if (tt.return === null || tt.return === l) break e
              Ke === tt && (Ke = null), (tt = tt.return)
            }
            Ke === tt && (Ke = null),
              (tt.sibling.return = tt.return),
              (tt = tt.sibling)
          }
        }
        break
      case 19:
        No(d, l), da(l), E & 4 && XT(l)
        break
      case 21:
        break
      default:
        No(d, l), da(l)
    }
  }
  function da(l) {
    var d = l.flags
    if (d & 2) {
      try {
        e: {
          for (var v = l.return; v !== null; ) {
            if (GT(v)) {
              var E = v
              break e
            }
            v = v.return
          }
          throw Error(t(160))
        }
        switch (E.tag) {
          case 5:
            var R = E.stateNode
            E.flags & 32 && (rn(R, ''), (E.flags &= -33))
            var L = WT(l)
            Q_(l, L, R)
            break
          case 3:
          case 4:
            var W = E.stateNode.containerInfo,
              ue = WT(l)
            K_(l, ue, W)
            break
          default:
            throw Error(t(161))
        }
      } catch (pe) {
        wi(l, l.return, pe)
      }
      l.flags &= -3
    }
    d & 4096 && (l.flags &= -4097)
  }
  function yU(l, d, v) {
    ;(Pt = l), YT(l)
  }
  function YT(l, d, v) {
    for (var E = (l.mode & 1) !== 0; Pt !== null; ) {
      var R = Pt,
        L = R.child
      if (R.tag === 22 && E) {
        var W = R.memoizedState !== null || Lv
        if (!W) {
          var ue = R.alternate,
            pe = (ue !== null && ue.memoizedState !== null) || Tr
          ue = Lv
          var Re = Tr
          if (((Lv = W), (Tr = pe) && !Re))
            for (Pt = R; Pt !== null; )
              (W = Pt),
                (pe = W.child),
                W.tag === 22 && W.memoizedState !== null
                  ? QT(R)
                  : pe !== null
                  ? ((pe.return = W), (Pt = pe))
                  : QT(R)
          for (; L !== null; ) (Pt = L), YT(L), (L = L.sibling)
          ;(Pt = R), (Lv = ue), (Tr = Re)
        }
        ZT(l)
      } else
        R.subtreeFlags & 8772 && L !== null ? ((L.return = R), (Pt = L)) : ZT(l)
    }
  }
  function ZT(l) {
    for (; Pt !== null; ) {
      var d = Pt
      if (d.flags & 8772) {
        var v = d.alternate
        try {
          if (d.flags & 8772)
            switch (d.tag) {
              case 0:
              case 11:
              case 15:
                Tr || Nv(5, d)
                break
              case 1:
                var E = d.stateNode
                if (d.flags & 4 && !Tr)
                  if (v === null) E.componentDidMount()
                  else {
                    var R =
                      d.elementType === d.type
                        ? v.memoizedProps
                        : ds(d.type, v.memoizedProps)
                    E.componentDidUpdate(
                      R,
                      v.memoizedState,
                      E.__reactInternalSnapshotBeforeUpdate,
                    )
                  }
                var L = d.updateQueue
                L !== null && Kl(d, L, E)
                break
              case 3:
                var W = d.updateQueue
                if (W !== null) {
                  if (((v = null), d.child !== null))
                    switch (d.child.tag) {
                      case 5:
                        v = d.child.stateNode
                        break
                      case 1:
                        v = d.child.stateNode
                    }
                  Kl(d, W, v)
                }
                break
              case 5:
                var ue = d.stateNode
                if (v === null && d.flags & 4) {
                  v = ue
                  var pe = d.memoizedProps
                  switch (d.type) {
                    case 'button':
                    case 'input':
                    case 'select':
                    case 'textarea':
                      pe.autoFocus && v.focus()
                      break
                    case 'img':
                      pe.src && (v.src = pe.src)
                  }
                }
                break
              case 6:
                break
              case 4:
                break
              case 12:
                break
              case 13:
                if (d.memoizedState === null) {
                  var Re = d.alternate
                  if (Re !== null) {
                    var Ke = Re.memoizedState
                    if (Ke !== null) {
                      var tt = Ke.dehydrated
                      tt !== null && Wc(tt)
                    }
                  }
                }
                break
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break
              default:
                throw Error(t(163))
            }
          Tr || (d.flags & 512 && Z_(d))
        } catch (Ye) {
          wi(d, d.return, Ye)
        }
      }
      if (d === l) {
        Pt = null
        break
      }
      if (((v = d.sibling), v !== null)) {
        ;(v.return = d.return), (Pt = v)
        break
      }
      Pt = d.return
    }
  }
  function KT(l) {
    for (; Pt !== null; ) {
      var d = Pt
      if (d === l) {
        Pt = null
        break
      }
      var v = d.sibling
      if (v !== null) {
        ;(v.return = d.return), (Pt = v)
        break
      }
      Pt = d.return
    }
  }
  function QT(l) {
    for (; Pt !== null; ) {
      var d = Pt
      try {
        switch (d.tag) {
          case 0:
          case 11:
          case 15:
            var v = d.return
            try {
              Nv(4, d)
            } catch (pe) {
              wi(d, v, pe)
            }
            break
          case 1:
            var E = d.stateNode
            if (typeof E.componentDidMount == 'function') {
              var R = d.return
              try {
                E.componentDidMount()
              } catch (pe) {
                wi(d, R, pe)
              }
            }
            var L = d.return
            try {
              Z_(d)
            } catch (pe) {
              wi(d, L, pe)
            }
            break
          case 5:
            var W = d.return
            try {
              Z_(d)
            } catch (pe) {
              wi(d, W, pe)
            }
        }
      } catch (pe) {
        wi(d, d.return, pe)
      }
      if (d === l) {
        Pt = null
        break
      }
      var ue = d.sibling
      if (ue !== null) {
        ;(ue.return = d.return), (Pt = ue)
        break
      }
      Pt = d.return
    }
  }
  var xU = Math.ceil,
    Dv = P.ReactCurrentDispatcher,
    J_ = P.ReactCurrentOwner,
    Ks = P.ReactCurrentBatchConfig,
    Pn = 0,
    tr = null,
    Fi = null,
    gr = 0,
    Is = 0,
    _f = oi(0),
    Yi = 0,
    Ap = null,
    Su = 0,
    Ov = 0,
    e1 = 0,
    Cp = null,
    fs = null,
    t1 = 0,
    wf = 1 / 0,
    cl = null,
    kv = !1,
    n1 = null,
    nc = null,
    Fv = !1,
    ic = null,
    Uv = 0,
    Pp = 0,
    i1 = null,
    Bv = -1,
    zv = 0
  function Xr() {
    return Pn & 6 ? ce() : Bv !== -1 ? Bv : (Bv = ce())
  }
  function rc(l) {
    return l.mode & 1
      ? Pn & 2 && gr !== 0
        ? gr & -gr
        : W_.transition !== null
        ? (zv === 0 && (zv = Wt()), zv)
        : ((l = Sn),
          l !== 0 || ((l = window.event), (l = l === void 0 ? 16 : sv(l.type))),
          l)
      : 1
  }
  function Do(l, d, v, E) {
    if (50 < Pp) throw ((Pp = 0), (i1 = null), Error(t(185)))
    Tn(l, v, E),
      (!(Pn & 2) || l !== tr) &&
        (l === tr && (!(Pn & 2) && (Ov |= v), Yi === 4 && sc(l, gr)),
        hs(l, E),
        v === 1 && Pn === 0 && !(d.mode & 1) && ((wf = ce() + 500), ou && Xs()))
  }
  function hs(l, d) {
    var v = l.callbackNode
    ln(l, d)
    var E = tn(l, l === tr ? gr : 0)
    if (E === 0)
      v !== null && G(v), (l.callbackNode = null), (l.callbackPriority = 0)
    else if (((d = E & -E), l.callbackPriority !== d)) {
      if ((v != null && G(v), d === 1))
        l.tag === 0 ? xv(eA.bind(null, l)) : au(eA.bind(null, l)),
          G_(function () {
            !(Pn & 6) && Xs()
          }),
          (v = null)
      else {
        switch (xr(E)) {
          case 1:
            v = Me
            break
          case 4:
            v = ke
            break
          case 16:
            v = He
            break
          case 536870912:
            v = ut
            break
          default:
            v = He
        }
        v = lA(v, JT.bind(null, l))
      }
      ;(l.callbackPriority = d), (l.callbackNode = v)
    }
  }
  function JT(l, d) {
    if (((Bv = -1), (zv = 0), Pn & 6)) throw Error(t(327))
    var v = l.callbackNode
    if (Sf() && l.callbackNode !== v) return null
    var E = tn(l, l === tr ? gr : 0)
    if (E === 0) return null
    if (E & 30 || E & l.expiredLanes || d) d = Vv(l, E)
    else {
      d = E
      var R = Pn
      Pn |= 2
      var L = nA()
      ;(tr !== l || gr !== d) && ((cl = null), (wf = ce() + 500), Eu(l, d))
      do
        try {
          SU()
          break
        } catch (ue) {
          tA(l, ue)
        }
      while (!0)
      tl(),
        (Dv.current = L),
        (Pn = R),
        Fi !== null ? (d = 0) : ((tr = null), (gr = 0), (d = Yi))
    }
    if (d !== 0) {
      if (
        (d === 2 && ((R = mn(l)), R !== 0 && ((E = R), (d = r1(l, R)))),
        d === 1)
      )
        throw ((v = Ap), Eu(l, 0), sc(l, E), hs(l, ce()), v)
      if (d === 6) sc(l, E)
      else {
        if (
          ((R = l.current.alternate),
          !(E & 30) &&
            !_U(R) &&
            ((d = Vv(l, E)),
            d === 2 && ((L = mn(l)), L !== 0 && ((E = L), (d = r1(l, L)))),
            d === 1))
        )
          throw ((v = Ap), Eu(l, 0), sc(l, E), hs(l, ce()), v)
        switch (((l.finishedWork = R), (l.finishedLanes = E), d)) {
          case 0:
          case 1:
            throw Error(t(345))
          case 2:
            bu(l, fs, cl)
            break
          case 3:
            if (
              (sc(l, E),
              (E & 130023424) === E && ((d = t1 + 500 - ce()), 10 < d))
            ) {
              if (tn(l, 0) !== 0) break
              if (((R = l.suspendedLanes), (R & E) !== E)) {
                Xr(), (l.pingedLanes |= l.suspendedLanes & R)
                break
              }
              l.timeoutHandle = np(bu.bind(null, l, fs, cl), d)
              break
            }
            bu(l, fs, cl)
            break
          case 4:
            if ((sc(l, E), (E & 4194240) === E)) break
            for (d = l.eventTimes, R = -1; 0 < E; ) {
              var W = 31 - mt(E)
              ;(L = 1 << W), (W = d[W]), W > R && (R = W), (E &= ~L)
            }
            if (
              ((E = R),
              (E = ce() - E),
              (E =
                (120 > E
                  ? 120
                  : 480 > E
                  ? 480
                  : 1080 > E
                  ? 1080
                  : 1920 > E
                  ? 1920
                  : 3e3 > E
                  ? 3e3
                  : 4320 > E
                  ? 4320
                  : 1960 * xU(E / 1960)) - E),
              10 < E)
            ) {
              l.timeoutHandle = np(bu.bind(null, l, fs, cl), E)
              break
            }
            bu(l, fs, cl)
            break
          case 5:
            bu(l, fs, cl)
            break
          default:
            throw Error(t(329))
        }
      }
    }
    return hs(l, ce()), l.callbackNode === v ? JT.bind(null, l) : null
  }
  function r1(l, d) {
    var v = Cp
    return (
      l.current.memoizedState.isDehydrated && (Eu(l, d).flags |= 256),
      (l = Vv(l, d)),
      l !== 2 && ((d = fs), (fs = v), d !== null && s1(d)),
      l
    )
  }
  function s1(l) {
    fs === null ? (fs = l) : fs.push.apply(fs, l)
  }
  function _U(l) {
    for (var d = l; ; ) {
      if (d.flags & 16384) {
        var v = d.updateQueue
        if (v !== null && ((v = v.stores), v !== null))
          for (var E = 0; E < v.length; E++) {
            var R = v[E],
              L = R.getSnapshot
            R = R.value
            try {
              if (!Br(L(), R)) return !1
            } catch {
              return !1
            }
          }
      }
      if (((v = d.child), d.subtreeFlags & 16384 && v !== null))
        (v.return = d), (d = v)
      else {
        if (d === l) break
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === l) return !0
          d = d.return
        }
        ;(d.sibling.return = d.return), (d = d.sibling)
      }
    }
    return !0
  }
  function sc(l, d) {
    for (
      d &= ~e1,
        d &= ~Ov,
        l.suspendedLanes |= d,
        l.pingedLanes &= ~d,
        l = l.expirationTimes;
      0 < d;

    ) {
      var v = 31 - mt(d),
        E = 1 << v
      ;(l[v] = -1), (d &= ~E)
    }
  }
  function eA(l) {
    if (Pn & 6) throw Error(t(327))
    Sf()
    var d = tn(l, 0)
    if (!(d & 1)) return hs(l, ce()), null
    var v = Vv(l, d)
    if (l.tag !== 0 && v === 2) {
      var E = mn(l)
      E !== 0 && ((d = E), (v = r1(l, E)))
    }
    if (v === 1) throw ((v = Ap), Eu(l, 0), sc(l, d), hs(l, ce()), v)
    if (v === 6) throw Error(t(345))
    return (
      (l.finishedWork = l.current.alternate),
      (l.finishedLanes = d),
      bu(l, fs, cl),
      hs(l, ce()),
      null
    )
  }
  function o1(l, d) {
    var v = Pn
    Pn |= 1
    try {
      return l(d)
    } finally {
      ;(Pn = v), Pn === 0 && ((wf = ce() + 500), ou && Xs())
    }
  }
  function Mu(l) {
    ic !== null && ic.tag === 0 && !(Pn & 6) && Sf()
    var d = Pn
    Pn |= 1
    var v = Ks.transition,
      E = Sn
    try {
      if (((Ks.transition = null), (Sn = 1), l)) return l()
    } finally {
      ;(Sn = E), (Ks.transition = v), (Pn = d), !(Pn & 6) && Xs()
    }
  }
  function a1() {
    ;(Is = _f.current), Wn(_f)
  }
  function Eu(l, d) {
    ;(l.finishedWork = null), (l.finishedLanes = 0)
    var v = l.timeoutHandle
    if ((v !== -1 && ((l.timeoutHandle = -1), ip(v)), Fi !== null))
      for (v = Fi.return; v !== null; ) {
        var E = v
        switch ((Eo(E), E.tag)) {
          case 1:
            ;(E = E.type.childContextTypes), E != null && ru()
            break
          case 3:
            ca(), Wn(dr), Wn(Gi), Ys()
            break
          case 5:
            Ql(E)
            break
          case 4:
            ca()
            break
          case 13:
            Wn(Zn)
            break
          case 19:
            Wn(Zn)
            break
          case 10:
            du(E.type._context)
            break
          case 22:
          case 23:
            a1()
        }
        v = v.return
      }
    if (
      ((tr = l),
      (Fi = l = oc(l.current, null)),
      (gr = Is = d),
      (Yi = 0),
      (Ap = null),
      (e1 = Ov = Su = 0),
      (fs = Cp = null),
      To !== null)
    ) {
      for (d = 0; d < To.length; d++)
        if (((v = To[d]), (E = v.interleaved), E !== null)) {
          v.interleaved = null
          var R = E.next,
            L = v.pending
          if (L !== null) {
            var W = L.next
            ;(L.next = R), (E.next = W)
          }
          v.pending = E
        }
      To = null
    }
    return l
  }
  function tA(l, d) {
    do {
      var v = Fi
      try {
        if ((tl(), (sl.current = vf), Ps)) {
          for (var E = $n.memoizedState; E !== null; ) {
            var R = E.queue
            R !== null && (R.pending = null), (E = E.next)
          }
          Ps = !1
        }
        if (
          ((Co = 0),
          (An = li = $n = null),
          (er = !1),
          (ua = 0),
          (J_.current = null),
          v === null || v.return === null)
        ) {
          ;(Yi = 1), (Ap = d), (Fi = null)
          break
        }
        e: {
          var L = l,
            W = v.return,
            ue = v,
            pe = d
          if (
            ((d = gr),
            (ue.flags |= 32768),
            pe !== null &&
              typeof pe == 'object' &&
              typeof pe.then == 'function')
          ) {
            var Re = pe,
              Ke = ue,
              tt = Ke.tag
            if (!(Ke.mode & 1) && (tt === 0 || tt === 11 || tt === 15)) {
              var Ye = Ke.alternate
              Ye
                ? ((Ke.updateQueue = Ye.updateQueue),
                  (Ke.memoizedState = Ye.memoizedState),
                  (Ke.lanes = Ye.lanes))
                : ((Ke.updateQueue = null), (Ke.memoizedState = null))
            }
            var Et = At(W)
            if (Et !== null) {
              ;(Et.flags &= -257),
                on(Et, W, ue, L, d),
                Et.mode & 1 && it(L, Re, d),
                (d = Et),
                (pe = Re)
              var Nt = d.updateQueue
              if (Nt === null) {
                var Dt = new Set()
                Dt.add(pe), (d.updateQueue = Dt)
              } else Nt.add(pe)
              break e
            } else {
              if (!(d & 1)) {
                it(L, Re, d), l1()
                break e
              }
              pe = Error(t(426))
            }
          } else if (Yn && ue.mode & 1) {
            var Ai = At(W)
            if (Ai !== null) {
              !(Ai.flags & 65536) && (Ai.flags |= 256),
                on(Ai, W, ue, L, d),
                Yl(C(pe, ue))
              break e
            }
          }
          ;(L = pe = C(pe, ue)),
            Yi !== 4 && (Yi = 2),
            Cp === null ? (Cp = [L]) : Cp.push(L),
            (L = W)
          do {
            switch (L.tag) {
              case 3:
                ;(L.flags |= 65536), (d &= -d), (L.lanes |= d)
                var we = ye(L, pe, d)
                nl(L, we)
                break e
              case 1:
                ue = pe
                var ge = L.type,
                  Ee = L.stateNode
                if (
                  !(L.flags & 128) &&
                  (typeof ge.getDerivedStateFromError == 'function' ||
                    (Ee !== null &&
                      typeof Ee.componentDidCatch == 'function' &&
                      (nc === null || !nc.has(Ee))))
                ) {
                  ;(L.flags |= 65536), (d &= -d), (L.lanes |= d)
                  var st = Fe(L, ue, d)
                  nl(L, st)
                  break e
                }
            }
            L = L.return
          } while (L !== null)
        }
        rA(v)
      } catch (zt) {
        ;(d = zt), Fi === v && v !== null && (Fi = v = v.return)
        continue
      }
      break
    } while (!0)
  }
  function nA() {
    var l = Dv.current
    return (Dv.current = vf), l === null ? vf : l
  }
  function l1() {
    ;(Yi === 0 || Yi === 3 || Yi === 2) && (Yi = 4),
      tr === null || (!(Su & 268435455) && !(Ov & 268435455)) || sc(tr, gr)
  }
  function Vv(l, d) {
    var v = Pn
    Pn |= 2
    var E = nA()
    ;(tr !== l || gr !== d) && ((cl = null), Eu(l, d))
    do
      try {
        wU()
        break
      } catch (R) {
        tA(l, R)
      }
    while (!0)
    if ((tl(), (Pn = v), (Dv.current = E), Fi !== null)) throw Error(t(261))
    return (tr = null), (gr = 0), Yi
  }
  function wU() {
    for (; Fi !== null; ) iA(Fi)
  }
  function SU() {
    for (; Fi !== null && !le(); ) iA(Fi)
  }
  function iA(l) {
    var d = aA(l.alternate, l, Is)
    ;(l.memoizedProps = l.pendingProps),
      d === null ? rA(l) : (Fi = d),
      (J_.current = null)
  }
  function rA(l) {
    var d = l
    do {
      var v = d.alternate
      if (((l = d.return), d.flags & 32768)) {
        if (((v = mU(v, d)), v !== null)) {
          ;(v.flags &= 32767), (Fi = v)
          return
        }
        if (l !== null)
          (l.flags |= 32768), (l.subtreeFlags = 0), (l.deletions = null)
        else {
          ;(Yi = 6), (Fi = null)
          return
        }
      } else if (((v = pU(v, d, Is)), v !== null)) {
        Fi = v
        return
      }
      if (((d = d.sibling), d !== null)) {
        Fi = d
        return
      }
      Fi = d = l
    } while (d !== null)
    Yi === 0 && (Yi = 5)
  }
  function bu(l, d, v) {
    var E = Sn,
      R = Ks.transition
    try {
      ;(Ks.transition = null), (Sn = 1), MU(l, d, v, E)
    } finally {
      ;(Ks.transition = R), (Sn = E)
    }
    return null
  }
  function MU(l, d, v, E) {
    do Sf()
    while (ic !== null)
    if (Pn & 6) throw Error(t(327))
    v = l.finishedWork
    var R = l.finishedLanes
    if (v === null) return null
    if (((l.finishedWork = null), (l.finishedLanes = 0), v === l.current))
      throw Error(t(177))
    ;(l.callbackNode = null), (l.callbackPriority = 0)
    var L = v.lanes | v.childLanes
    if (
      (Hn(l, L),
      l === tr && ((Fi = tr = null), (gr = 0)),
      (!(v.subtreeFlags & 2064) && !(v.flags & 2064)) ||
        Fv ||
        ((Fv = !0),
        lA(He, function () {
          return Sf(), null
        })),
      (L = (v.flags & 15990) !== 0),
      v.subtreeFlags & 15990 || L)
    ) {
      ;(L = Ks.transition), (Ks.transition = null)
      var W = Sn
      Sn = 1
      var ue = Pn
      ;(Pn |= 4),
        (J_.current = null),
        vU(l, v),
        qT(v, l),
        Ni(ep),
        (is = !!$l),
        (ep = $l = null),
        (l.current = v),
        yU(v),
        de(),
        (Pn = ue),
        (Sn = W),
        (Ks.transition = L)
    } else l.current = v
    if (
      (Fv && ((Fv = !1), (ic = l), (Uv = R)),
      (L = l.pendingLanes),
      L === 0 && (nc = null),
      pt(v.stateNode),
      hs(l, ce()),
      d !== null)
    )
      for (E = l.onRecoverableError, v = 0; v < d.length; v++)
        (R = d[v]), E(R.value, { componentStack: R.stack, digest: R.digest })
    if (kv) throw ((kv = !1), (l = n1), (n1 = null), l)
    return (
      Uv & 1 && l.tag !== 0 && Sf(),
      (L = l.pendingLanes),
      L & 1 ? (l === i1 ? Pp++ : ((Pp = 0), (i1 = l))) : (Pp = 0),
      Xs(),
      null
    )
  }
  function Sf() {
    if (ic !== null) {
      var l = xr(Uv),
        d = Ks.transition,
        v = Sn
      try {
        if (((Ks.transition = null), (Sn = 16 > l ? 16 : l), ic === null))
          var E = !1
        else {
          if (((l = ic), (ic = null), (Uv = 0), Pn & 6)) throw Error(t(331))
          var R = Pn
          for (Pn |= 4, Pt = l.current; Pt !== null; ) {
            var L = Pt,
              W = L.child
            if (Pt.flags & 16) {
              var ue = L.deletions
              if (ue !== null) {
                for (var pe = 0; pe < ue.length; pe++) {
                  var Re = ue[pe]
                  for (Pt = Re; Pt !== null; ) {
                    var Ke = Pt
                    switch (Ke.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Tp(8, Ke, L)
                    }
                    var tt = Ke.child
                    if (tt !== null) (tt.return = Ke), (Pt = tt)
                    else
                      for (; Pt !== null; ) {
                        Ke = Pt
                        var Ye = Ke.sibling,
                          Et = Ke.return
                        if ((HT(Ke), Ke === Re)) {
                          Pt = null
                          break
                        }
                        if (Ye !== null) {
                          ;(Ye.return = Et), (Pt = Ye)
                          break
                        }
                        Pt = Et
                      }
                  }
                }
                var Nt = L.alternate
                if (Nt !== null) {
                  var Dt = Nt.child
                  if (Dt !== null) {
                    Nt.child = null
                    do {
                      var Ai = Dt.sibling
                      ;(Dt.sibling = null), (Dt = Ai)
                    } while (Dt !== null)
                  }
                }
                Pt = L
              }
            }
            if (L.subtreeFlags & 2064 && W !== null) (W.return = L), (Pt = W)
            else
              e: for (; Pt !== null; ) {
                if (((L = Pt), L.flags & 2048))
                  switch (L.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Tp(9, L, L.return)
                  }
                var we = L.sibling
                if (we !== null) {
                  ;(we.return = L.return), (Pt = we)
                  break e
                }
                Pt = L.return
              }
          }
          var ge = l.current
          for (Pt = ge; Pt !== null; ) {
            W = Pt
            var Ee = W.child
            if (W.subtreeFlags & 2064 && Ee !== null) (Ee.return = W), (Pt = Ee)
            else
              e: for (W = ge; Pt !== null; ) {
                if (((ue = Pt), ue.flags & 2048))
                  try {
                    switch (ue.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Nv(9, ue)
                    }
                  } catch (zt) {
                    wi(ue, ue.return, zt)
                  }
                if (ue === W) {
                  Pt = null
                  break e
                }
                var st = ue.sibling
                if (st !== null) {
                  ;(st.return = ue.return), (Pt = st)
                  break e
                }
                Pt = ue.return
              }
          }
          if (
            ((Pn = R),
            Xs(),
            We && typeof We.onPostCommitFiberRoot == 'function')
          )
            try {
              We.onPostCommitFiberRoot(ot, l)
            } catch {}
          E = !0
        }
        return E
      } finally {
        ;(Sn = v), (Ks.transition = d)
      }
    }
    return !1
  }
  function sA(l, d, v) {
    ;(d = C(v, d)),
      (d = ye(l, d, 1)),
      (l = Jn(l, d, 1)),
      (d = Xr()),
      l !== null && (Tn(l, 1, d), hs(l, d))
  }
  function wi(l, d, v) {
    if (l.tag === 3) sA(l, l, v)
    else
      for (; d !== null; ) {
        if (d.tag === 3) {
          sA(d, l, v)
          break
        } else if (d.tag === 1) {
          var E = d.stateNode
          if (
            typeof d.type.getDerivedStateFromError == 'function' ||
            (typeof E.componentDidCatch == 'function' &&
              (nc === null || !nc.has(E)))
          ) {
            ;(l = C(v, l)),
              (l = Fe(d, l, 1)),
              (d = Jn(d, l, 1)),
              (l = Xr()),
              d !== null && (Tn(d, 1, l), hs(d, l))
            break
          }
        }
        d = d.return
      }
  }
  function EU(l, d, v) {
    var E = l.pingCache
    E !== null && E.delete(d),
      (d = Xr()),
      (l.pingedLanes |= l.suspendedLanes & v),
      tr === l &&
        (gr & v) === v &&
        (Yi === 4 || (Yi === 3 && (gr & 130023424) === gr && 500 > ce() - t1)
          ? Eu(l, 0)
          : (e1 |= v)),
      hs(l, d)
  }
  function oA(l, d) {
    d === 0 &&
      (l.mode & 1
        ? ((d = fn), (fn <<= 1), !(fn & 130023424) && (fn = 4194304))
        : (d = 1))
    var v = Xr()
    ;(l = As(l, d)), l !== null && (Tn(l, d, v), hs(l, v))
  }
  function bU(l) {
    var d = l.memoizedState,
      v = 0
    d !== null && (v = d.retryLane), oA(l, v)
  }
  function TU(l, d) {
    var v = 0
    switch (l.tag) {
      case 13:
        var E = l.stateNode,
          R = l.memoizedState
        R !== null && (v = R.retryLane)
        break
      case 19:
        E = l.stateNode
        break
      default:
        throw Error(t(314))
    }
    E !== null && E.delete(d), oA(l, v)
  }
  var aA
  aA = function (l, d, v) {
    if (l !== null)
      if (l.memoizedProps !== d.pendingProps || dr.current) gn = !0
      else {
        if (!(l.lanes & v) && !(d.flags & 128)) return (gn = !1), hU(l, d, v)
        gn = !!(l.flags & 131072)
      }
    else (gn = !1), Yn && d.flags & 1048576 && lp(d, af, d.index)
    switch (((d.lanes = 0), d.tag)) {
      case 2:
        var E = d.type
        Iv(l, d), (l = d.pendingProps)
        var R = qa(d, Gi.current)
        la(d, v), (R = gu(null, d, E, l, R, v))
        var L = gp()
        return (
          (d.flags |= 1),
          typeof R == 'object' &&
          R !== null &&
          typeof R.render == 'function' &&
          R.$$typeof === void 0
            ? ((d.tag = 1),
              (d.memoizedState = null),
              (d.updateQueue = null),
              Qi(E) ? ((L = !0), Ya(d)) : (L = !1),
              (d.memoizedState =
                R.state !== null && R.state !== void 0 ? R.state : null),
              hn(d),
              (R.updater = yf),
              (d.stateNode = R),
              (R._reactInternals = d),
              S(d, E, l, v),
              (d = cn(null, d, E, !0, L, v)))
            : ((d.tag = 0), Yn && L && cp(d), St(null, d, R, v), (d = d.child)),
          d
        )
      case 16:
        E = d.elementType
        e: {
          switch (
            (Iv(l, d),
            (l = d.pendingProps),
            (R = E._init),
            (E = R(E._payload)),
            (d.type = E),
            (R = d.tag = CU(E)),
            (l = ds(E, l)),
            R)
          ) {
            case 0:
              d = yt(null, d, E, l, v)
              break e
            case 1:
              d = kt(null, d, E, l, v)
              break e
            case 11:
              d = qi(null, d, E, l, v)
              break e
            case 14:
              d = $r(null, d, E, ds(E.type, l), v)
              break e
          }
          throw Error(t(306, E, ''))
        }
        return d
      case 0:
        return (
          (E = d.type),
          (R = d.pendingProps),
          (R = d.elementType === E ? R : ds(E, R)),
          yt(l, d, E, R, v)
        )
      case 1:
        return (
          (E = d.type),
          (R = d.pendingProps),
          (R = d.elementType === E ? R : ds(E, R)),
          kt(l, d, E, R, v)
        )
      case 3:
        e: {
          if ((an(d), l === null)) throw Error(t(387))
          ;(E = d.pendingProps),
            (L = d.memoizedState),
            (R = L.element),
            fi(l, d),
            ai(d, E, null, v)
          var W = d.memoizedState
          if (((E = W.element), L.isDehydrated))
            if (
              ((L = {
                element: E,
                isDehydrated: !1,
                cache: W.cache,
                pendingSuspenseBoundaries: W.pendingSuspenseBoundaries,
                transitions: W.transitions,
              }),
              (d.updateQueue.baseState = L),
              (d.memoizedState = L),
              d.flags & 256)
            ) {
              ;(R = C(Error(t(423)), d)), (d = bn(l, d, E, v, R))
              break e
            } else if (E !== R) {
              ;(R = C(Error(t(424)), d)), (d = bn(l, d, E, v, R))
              break e
            } else
              for (
                hr = xo(d.stateNode.containerInfo.firstChild),
                  Wi = d,
                  Yn = !0,
                  us = null,
                  v = uu(d, null, E, v),
                  d.child = v;
                v;

              )
                (v.flags = (v.flags & -3) | 4096), (v = v.sibling)
          else {
            if ((aa(), E === R)) {
              d = ll(l, d, v)
              break e
            }
            St(l, d, E, v)
          }
          d = d.child
        }
        return d
      case 5:
        return (
          rl(d),
          l === null && cf(d),
          (E = d.type),
          (R = d.pendingProps),
          (L = l !== null ? l.memoizedProps : null),
          (W = R.children),
          tp(E, R) ? (W = null) : L !== null && tp(E, L) && (d.flags |= 32),
          Ne(l, d),
          St(l, d, W, v),
          d.child
        )
      case 6:
        return l === null && cf(d), null
      case 13:
        return Io(l, d, v)
      case 4:
        return (
          pu(d, d.stateNode.containerInfo),
          (E = d.pendingProps),
          l === null ? (d.child = Qa(d, null, E, v)) : St(l, d, E, v),
          d.child
        )
      case 11:
        return (
          (E = d.type),
          (R = d.pendingProps),
          (R = d.elementType === E ? R : ds(E, R)),
          qi(l, d, E, R, v)
        )
      case 7:
        return St(l, d, d.pendingProps, v), d.child
      case 8:
        return St(l, d, d.pendingProps.children, v), d.child
      case 12:
        return St(l, d, d.pendingProps.children, v), d.child
      case 10:
        e: {
          if (
            ((E = d.type._context),
            (R = d.pendingProps),
            (L = d.memoizedProps),
            (W = R.value),
            Bn(Ja, E._currentValue),
            (E._currentValue = W),
            L !== null)
          )
            if (Br(L.value, W)) {
              if (L.children === R.children && !dr.current) {
                d = ll(l, d, v)
                break e
              }
            } else
              for (L = d.child, L !== null && (L.return = d); L !== null; ) {
                var ue = L.dependencies
                if (ue !== null) {
                  W = L.child
                  for (var pe = ue.firstContext; pe !== null; ) {
                    if (pe.context === E) {
                      if (L.tag === 1) {
                        ;(pe = kn(-1, v & -v)), (pe.tag = 2)
                        var Re = L.updateQueue
                        if (Re !== null) {
                          Re = Re.shared
                          var Ke = Re.pending
                          Ke === null
                            ? (pe.next = pe)
                            : ((pe.next = Ke.next), (Ke.next = pe)),
                            (Re.pending = pe)
                        }
                      }
                      ;(L.lanes |= v),
                        (pe = L.alternate),
                        pe !== null && (pe.lanes |= v),
                        fu(L.return, v, d),
                        (ue.lanes |= v)
                      break
                    }
                    pe = pe.next
                  }
                } else if (L.tag === 10) W = L.type === d.type ? null : L.child
                else if (L.tag === 18) {
                  if (((W = L.return), W === null)) throw Error(t(341))
                  ;(W.lanes |= v),
                    (ue = W.alternate),
                    ue !== null && (ue.lanes |= v),
                    fu(W, v, d),
                    (W = L.sibling)
                } else W = L.child
                if (W !== null) W.return = L
                else
                  for (W = L; W !== null; ) {
                    if (W === d) {
                      W = null
                      break
                    }
                    if (((L = W.sibling), L !== null)) {
                      ;(L.return = W.return), (W = L)
                      break
                    }
                    W = W.return
                  }
                L = W
              }
          St(l, d, R.children, v), (d = d.child)
        }
        return d
      case 9:
        return (
          (R = d.type),
          (E = d.pendingProps.children),
          la(d, v),
          (R = jr(R)),
          (E = E(R)),
          (d.flags |= 1),
          St(l, d, E, v),
          d.child
        )
      case 14:
        return (
          (E = d.type),
          (R = ds(E, d.pendingProps)),
          (R = ds(E.type, R)),
          $r(l, d, E, R, v)
        )
      case 15:
        return be(l, d, d.type, d.pendingProps, v)
      case 17:
        return (
          (E = d.type),
          (R = d.pendingProps),
          (R = d.elementType === E ? R : ds(E, R)),
          Iv(l, d),
          (d.tag = 1),
          Qi(E) ? ((l = !0), Ya(d)) : (l = !1),
          la(d, v),
          f(d, E, R),
          S(d, E, R, v),
          cn(null, d, E, !0, l, v)
        )
      case 19:
        return UT(l, d, v)
      case 22:
        return xe(l, d, v)
    }
    throw Error(t(156, d.tag))
  }
  function lA(l, d) {
    return Ze(l, d)
  }
  function AU(l, d, v, E) {
    ;(this.tag = l),
      (this.key = v),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = d),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = E),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null)
  }
  function Qs(l, d, v, E) {
    return new AU(l, d, v, E)
  }
  function c1(l) {
    return (l = l.prototype), !(!l || !l.isReactComponent)
  }
  function CU(l) {
    if (typeof l == 'function') return c1(l) ? 1 : 0
    if (l != null) {
      if (((l = l.$$typeof), l === $)) return 11
      if (l === K) return 14
    }
    return 2
  }
  function oc(l, d) {
    var v = l.alternate
    return (
      v === null
        ? ((v = Qs(l.tag, d, l.key, l.mode)),
          (v.elementType = l.elementType),
          (v.type = l.type),
          (v.stateNode = l.stateNode),
          (v.alternate = l),
          (l.alternate = v))
        : ((v.pendingProps = d),
          (v.type = l.type),
          (v.flags = 0),
          (v.subtreeFlags = 0),
          (v.deletions = null)),
      (v.flags = l.flags & 14680064),
      (v.childLanes = l.childLanes),
      (v.lanes = l.lanes),
      (v.child = l.child),
      (v.memoizedProps = l.memoizedProps),
      (v.memoizedState = l.memoizedState),
      (v.updateQueue = l.updateQueue),
      (d = l.dependencies),
      (v.dependencies =
        d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }),
      (v.sibling = l.sibling),
      (v.index = l.index),
      (v.ref = l.ref),
      v
    )
  }
  function jv(l, d, v, E, R, L) {
    var W = 2
    if (((E = l), typeof l == 'function')) c1(l) && (W = 1)
    else if (typeof l == 'string') W = 5
    else
      e: switch (l) {
        case U:
          return Tu(v.children, R, L, d)
        case F:
          ;(W = 8), (R |= 8)
          break
        case N:
          return (
            (l = Qs(12, v, d, R | 2)), (l.elementType = N), (l.lanes = L), l
          )
        case te:
          return (l = Qs(13, v, d, R)), (l.elementType = te), (l.lanes = L), l
        case j:
          return (l = Qs(19, v, d, R)), (l.elementType = j), (l.lanes = L), l
        case ne:
          return Hv(v, R, L, d)
        default:
          if (typeof l == 'object' && l !== null)
            switch (l.$$typeof) {
              case k:
                W = 10
                break e
              case z:
                W = 9
                break e
              case $:
                W = 11
                break e
              case K:
                W = 14
                break e
              case J:
                ;(W = 16), (E = null)
                break e
            }
          throw Error(t(130, l == null ? l : typeof l, ''))
      }
    return (
      (d = Qs(W, v, d, R)), (d.elementType = l), (d.type = E), (d.lanes = L), d
    )
  }
  function Tu(l, d, v, E) {
    return (l = Qs(7, l, E, d)), (l.lanes = v), l
  }
  function Hv(l, d, v, E) {
    return (
      (l = Qs(22, l, E, d)),
      (l.elementType = ne),
      (l.lanes = v),
      (l.stateNode = { isHidden: !1 }),
      l
    )
  }
  function u1(l, d, v) {
    return (l = Qs(6, l, null, d)), (l.lanes = v), l
  }
  function d1(l, d, v) {
    return (
      (d = Qs(4, l.children !== null ? l.children : [], l.key, d)),
      (d.lanes = v),
      (d.stateNode = {
        containerInfo: l.containerInfo,
        pendingChildren: null,
        implementation: l.implementation,
      }),
      d
    )
  }
  function PU(l, d, v, E, R) {
    ;(this.tag = d),
      (this.containerInfo = l),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Kn(0)),
      (this.expirationTimes = Kn(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Kn(0)),
      (this.identifierPrefix = E),
      (this.onRecoverableError = R),
      (this.mutableSourceEagerHydrationData = null)
  }
  function f1(l, d, v, E, R, L, W, ue, pe) {
    return (
      (l = new PU(l, d, v, ue, pe)),
      d === 1 ? ((d = 1), L === !0 && (d |= 8)) : (d = 0),
      (L = Qs(3, null, null, d)),
      (l.current = L),
      (L.stateNode = l),
      (L.memoizedState = {
        element: E,
        isDehydrated: v,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      hn(L),
      l
    )
  }
  function RU(l, d, v) {
    var E =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
    return {
      $$typeof: O,
      key: E == null ? null : '' + E,
      children: l,
      containerInfo: d,
      implementation: v,
    }
  }
  function cA(l) {
    if (!l) return wo
    l = l._reactInternals
    e: {
      if (ee(l) !== l || l.tag !== 1) throw Error(t(170))
      var d = l
      do {
        switch (d.tag) {
          case 3:
            d = d.stateNode.context
            break e
          case 1:
            if (Qi(d.type)) {
              d = d.stateNode.__reactInternalMemoizedMergedChildContext
              break e
            }
        }
        d = d.return
      } while (d !== null)
      throw Error(t(171))
    }
    if (l.tag === 1) {
      var v = l.type
      if (Qi(v)) return su(l, v, d)
    }
    return d
  }
  function uA(l, d, v, E, R, L, W, ue, pe) {
    return (
      (l = f1(v, E, !0, l, R, L, W, ue, pe)),
      (l.context = cA(null)),
      (v = l.current),
      (E = Xr()),
      (R = rc(v)),
      (L = kn(E, R)),
      (L.callback = d ?? null),
      Jn(v, L, R),
      (l.current.lanes = R),
      Tn(l, R, E),
      hs(l, E),
      l
    )
  }
  function Gv(l, d, v, E) {
    var R = d.current,
      L = Xr(),
      W = rc(R)
    return (
      (v = cA(v)),
      d.context === null ? (d.context = v) : (d.pendingContext = v),
      (d = kn(L, W)),
      (d.payload = { element: l }),
      (E = E === void 0 ? null : E),
      E !== null && (d.callback = E),
      (l = Jn(R, d, W)),
      l !== null && (Do(l, R, W, L), Ji(l, R, W)),
      W
    )
  }
  function Wv(l) {
    if (((l = l.current), !l.child)) return null
    switch (l.child.tag) {
      case 5:
        return l.child.stateNode
      default:
        return l.child.stateNode
    }
  }
  function dA(l, d) {
    if (((l = l.memoizedState), l !== null && l.dehydrated !== null)) {
      var v = l.retryLane
      l.retryLane = v !== 0 && v < d ? v : d
    }
  }
  function h1(l, d) {
    dA(l, d), (l = l.alternate) && dA(l, d)
  }
  var fA =
    typeof reportError == 'function'
      ? reportError
      : function (l) {
          console.error(l)
        }
  function p1(l) {
    this._internalRoot = l
  }
  ;($v.prototype.render = p1.prototype.render =
    function (l) {
      var d = this._internalRoot
      if (d === null) throw Error(t(409))
      Gv(l, d, null, null)
    }),
    ($v.prototype.unmount = p1.prototype.unmount =
      function () {
        var l = this._internalRoot
        if (l !== null) {
          this._internalRoot = null
          var d = l.containerInfo
          Mu(function () {
            Gv(null, l, null, null)
          }),
            (d[Vr] = null)
        }
      })
  function $v(l) {
    this._internalRoot = l
  }
  $v.prototype.unstable_scheduleHydration = function (l) {
    if (l) {
      var d = bd()
      l = { blockedOn: null, target: l, priority: d }
      for (var v = 0; v < Jo.length && d !== 0 && d < Jo[v].priority; v++);
      Jo.splice(v, 0, l), v === 0 && Cd(l)
    }
  }
  function m1(l) {
    return !(!l || (l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11))
  }
  function Xv(l) {
    return !(
      !l ||
      (l.nodeType !== 1 &&
        l.nodeType !== 9 &&
        l.nodeType !== 11 &&
        (l.nodeType !== 8 || l.nodeValue !== ' react-mount-point-unstable '))
    )
  }
  function hA() {}
  function IU(l, d, v, E, R) {
    if (R) {
      if (typeof E == 'function') {
        var L = E
        E = function () {
          var Re = Wv(W)
          L.call(Re)
        }
      }
      var W = uA(d, E, l, 0, null, !1, !1, '', hA)
      return (
        (l._reactRootContainer = W),
        (l[Vr] = W.current),
        Gl(l.nodeType === 8 ? l.parentNode : l),
        Mu(),
        W
      )
    }
    for (; (R = l.lastChild); ) l.removeChild(R)
    if (typeof E == 'function') {
      var ue = E
      E = function () {
        var Re = Wv(pe)
        ue.call(Re)
      }
    }
    var pe = f1(l, 0, !1, null, null, !1, !1, '', hA)
    return (
      (l._reactRootContainer = pe),
      (l[Vr] = pe.current),
      Gl(l.nodeType === 8 ? l.parentNode : l),
      Mu(function () {
        Gv(d, pe, v, E)
      }),
      pe
    )
  }
  function qv(l, d, v, E, R) {
    var L = v._reactRootContainer
    if (L) {
      var W = L
      if (typeof R == 'function') {
        var ue = R
        R = function () {
          var pe = Wv(W)
          ue.call(pe)
        }
      }
      Gv(d, W, l, R)
    } else W = IU(v, d, l, R, E)
    return Wv(W)
  }
  ;(jc = function (l) {
    switch (l.tag) {
      case 3:
        var d = l.stateNode
        if (d.current.memoizedState.isDehydrated) {
          var v = Ht(d.pendingLanes)
          v !== 0 &&
            (ui(d, v | 1), hs(d, ce()), !(Pn & 6) && ((wf = ce() + 500), Xs()))
        }
        break
      case 13:
        Mu(function () {
          var E = As(l, 1)
          if (E !== null) {
            var R = Xr()
            Do(E, l, 1, R)
          }
        }),
          h1(l, 1)
    }
  }),
    (Fh = function (l) {
      if (l.tag === 13) {
        var d = As(l, 134217728)
        if (d !== null) {
          var v = Xr()
          Do(d, l, 134217728, v)
        }
        h1(l, 134217728)
      }
    }),
    (rv = function (l) {
      if (l.tag === 13) {
        var d = rc(l),
          v = As(l, d)
        if (v !== null) {
          var E = Xr()
          Do(v, l, d, E)
        }
        h1(l, d)
      }
    }),
    (bd = function () {
      return Sn
    }),
    (Td = function (l, d) {
      var v = Sn
      try {
        return (Sn = l), d()
      } finally {
        Sn = v
      }
    }),
    (Ie = function (l, d, v) {
      switch (d) {
        case 'input':
          if ((_t(l, v), (d = v.name), v.type === 'radio' && d != null)) {
            for (v = l; v.parentNode; ) v = v.parentNode
            for (
              v = v.querySelectorAll(
                'input[name=' + JSON.stringify('' + d) + '][type="radio"]',
              ),
                d = 0;
              d < v.length;
              d++
            ) {
              var E = v[d]
              if (E !== l && E.form === l.form) {
                var R = rf(E)
                if (!R) throw Error(t(90))
                je(E), _t(E, R)
              }
            }
          }
          break
        case 'textarea':
          Ue(l, v)
          break
        case 'select':
          ;(d = v.value), d != null && ie(l, !!v.multiple, d, !1)
      }
    }),
    (Un = o1),
    (si = Mu)
  var LU = { usingClientEntryPoint: !1, Events: [_o, di, rf, ht, Qt, o1] },
    Rp = {
      findFiberByHostInstance: oa,
      bundleType: 0,
      version: '18.3.1',
      rendererPackageName: 'react-dom',
    },
    NU = {
      bundleType: Rp.bundleType,
      version: Rp.version,
      rendererPackageName: Rp.rendererPackageName,
      rendererConfig: Rp.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: P.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (l) {
        return (l = Oe(l)), l === null ? null : l.stateNode
      },
      findFiberByHostInstance: Rp.findFiberByHostInstance,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: '18.3.1-next-f1338f8080-20240426',
    }
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
    var Yv = __REACT_DEVTOOLS_GLOBAL_HOOK__
    if (!Yv.isDisabled && Yv.supportsFiber)
      try {
        ;(ot = Yv.inject(NU)), (We = Yv)
      } catch {}
  }
  return (
    (ps.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = LU),
    (ps.createPortal = function (l, d) {
      var v =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
      if (!m1(d)) throw Error(t(200))
      return RU(l, d, null, v)
    }),
    (ps.createRoot = function (l, d) {
      if (!m1(l)) throw Error(t(299))
      var v = !1,
        E = '',
        R = fA
      return (
        d != null &&
          (d.unstable_strictMode === !0 && (v = !0),
          d.identifierPrefix !== void 0 && (E = d.identifierPrefix),
          d.onRecoverableError !== void 0 && (R = d.onRecoverableError)),
        (d = f1(l, 1, !1, null, null, v, !1, E, R)),
        (l[Vr] = d.current),
        Gl(l.nodeType === 8 ? l.parentNode : l),
        new p1(d)
      )
    }),
    (ps.findDOMNode = function (l) {
      if (l == null) return null
      if (l.nodeType === 1) return l
      var d = l._reactInternals
      if (d === void 0)
        throw typeof l.render == 'function'
          ? Error(t(188))
          : ((l = Object.keys(l).join(',')), Error(t(268, l)))
      return (l = Oe(d)), (l = l === null ? null : l.stateNode), l
    }),
    (ps.flushSync = function (l) {
      return Mu(l)
    }),
    (ps.hydrate = function (l, d, v) {
      if (!Xv(d)) throw Error(t(200))
      return qv(null, l, d, !0, v)
    }),
    (ps.hydrateRoot = function (l, d, v) {
      if (!m1(l)) throw Error(t(405))
      var E = (v != null && v.hydratedSources) || null,
        R = !1,
        L = '',
        W = fA
      if (
        (v != null &&
          (v.unstable_strictMode === !0 && (R = !0),
          v.identifierPrefix !== void 0 && (L = v.identifierPrefix),
          v.onRecoverableError !== void 0 && (W = v.onRecoverableError)),
        (d = uA(d, null, l, 1, v ?? null, R, !1, L, W)),
        (l[Vr] = d.current),
        Gl(l),
        E)
      )
        for (l = 0; l < E.length; l++)
          (v = E[l]),
            (R = v._getVersion),
            (R = R(v._source)),
            d.mutableSourceEagerHydrationData == null
              ? (d.mutableSourceEagerHydrationData = [v, R])
              : d.mutableSourceEagerHydrationData.push(v, R)
      return new $v(d)
    }),
    (ps.render = function (l, d, v) {
      if (!Xv(d)) throw Error(t(200))
      return qv(null, l, d, !1, v)
    }),
    (ps.unmountComponentAtNode = function (l) {
      if (!Xv(l)) throw Error(t(40))
      return l._reactRootContainer
        ? (Mu(function () {
            qv(null, null, l, !1, function () {
              ;(l._reactRootContainer = null), (l[Vr] = null)
            })
          }),
          !0)
        : !1
    }),
    (ps.unstable_batchedUpdates = o1),
    (ps.unstable_renderSubtreeIntoContainer = function (l, d, v, E) {
      if (!Xv(v)) throw Error(t(200))
      if (l == null || l._reactInternals === void 0) throw Error(t(38))
      return qv(l, d, v, !1, E)
    }),
    (ps.version = '18.3.1-next-f1338f8080-20240426'),
    ps
  )
}
var wA
function GM() {
  if (wA) return y1.exports
  wA = 1
  function n() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
      } catch (e) {
        console.error(e)
      }
  }
  return n(), (y1.exports = VU()), y1.exports
}
var SA
function jU() {
  if (SA) return Zv
  SA = 1
  var n = GM()
  return (Zv.createRoot = n.createRoot), (Zv.hydrateRoot = n.hydrateRoot), Zv
}
var HU = jU(),
  Lp = {},
  MA
function GU() {
  if (MA) return Lp
  ;(MA = 1),
    Object.defineProperty(Lp, '__esModule', { value: !0 }),
    (Lp.parse = o),
    (Lp.serialize = u)
  const n = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
    e = /^[\u0021-\u003A\u003C-\u007E]*$/,
    t =
      /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    i = /^[\u0020-\u003A\u003D-\u007E]*$/,
    r = Object.prototype.toString,
    s = (() => {
      const g = function () {}
      return (g.prototype = Object.create(null)), g
    })()
  function o(g, y) {
    const _ = new s(),
      M = g.length
    if (M < 2) return _
    const w = (y == null ? void 0 : y.decode) || h
    let x = 0
    do {
      const T = g.indexOf('=', x)
      if (T === -1) break
      const A = g.indexOf(';', x),
        P = A === -1 ? M : A
      if (T > P) {
        x = g.lastIndexOf(';', T - 1) + 1
        continue
      }
      const D = a(g, x, T),
        O = c(g, T, D),
        U = g.slice(D, O)
      if (_[U] === void 0) {
        let F = a(g, T + 1, P),
          N = c(g, P, F)
        const k = w(g.slice(F, N))
        _[U] = k
      }
      x = P + 1
    } while (x < M)
    return _
  }
  function a(g, y, _) {
    do {
      const M = g.charCodeAt(y)
      if (M !== 32 && M !== 9) return y
    } while (++y < _)
    return _
  }
  function c(g, y, _) {
    for (; y > _; ) {
      const M = g.charCodeAt(--y)
      if (M !== 32 && M !== 9) return y + 1
    }
    return _
  }
  function u(g, y, _) {
    const M = (_ == null ? void 0 : _.encode) || encodeURIComponent
    if (!n.test(g)) throw new TypeError(`argument name is invalid: ${g}`)
    const w = M(y)
    if (!e.test(w)) throw new TypeError(`argument val is invalid: ${y}`)
    let x = g + '=' + w
    if (!_) return x
    if (_.maxAge !== void 0) {
      if (!Number.isInteger(_.maxAge))
        throw new TypeError(`option maxAge is invalid: ${_.maxAge}`)
      x += '; Max-Age=' + _.maxAge
    }
    if (_.domain) {
      if (!t.test(_.domain))
        throw new TypeError(`option domain is invalid: ${_.domain}`)
      x += '; Domain=' + _.domain
    }
    if (_.path) {
      if (!i.test(_.path))
        throw new TypeError(`option path is invalid: ${_.path}`)
      x += '; Path=' + _.path
    }
    if (_.expires) {
      if (!m(_.expires) || !Number.isFinite(_.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${_.expires}`)
      x += '; Expires=' + _.expires.toUTCString()
    }
    if (
      (_.httpOnly && (x += '; HttpOnly'),
      _.secure && (x += '; Secure'),
      _.partitioned && (x += '; Partitioned'),
      _.priority)
    )
      switch (
        typeof _.priority == 'string' ? _.priority.toLowerCase() : void 0
      ) {
        case 'low':
          x += '; Priority=Low'
          break
        case 'medium':
          x += '; Priority=Medium'
          break
        case 'high':
          x += '; Priority=High'
          break
        default:
          throw new TypeError(`option priority is invalid: ${_.priority}`)
      }
    if (_.sameSite)
      switch (
        typeof _.sameSite == 'string' ? _.sameSite.toLowerCase() : _.sameSite
      ) {
        case !0:
        case 'strict':
          x += '; SameSite=Strict'
          break
        case 'lax':
          x += '; SameSite=Lax'
          break
        case 'none':
          x += '; SameSite=None'
          break
        default:
          throw new TypeError(`option sameSite is invalid: ${_.sameSite}`)
      }
    return x
  }
  function h(g) {
    if (g.indexOf('%') === -1) return g
    try {
      return decodeURIComponent(g)
    } catch {
      return g
    }
  }
  function m(g) {
    return r.call(g) === '[object Date]'
  }
  return Lp
}
GU()
/**
 * react-router v7.1.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ var EA = 'popstate'
function WU(n = {}) {
  function e(i, r) {
    let { pathname: s, search: o, hash: a } = i.location
    return PS(
      '',
      { pathname: s, search: o, hash: a },
      (r.state && r.state.usr) || null,
      (r.state && r.state.key) || 'default',
    )
  }
  function t(i, r) {
    return typeof r == 'string' ? r : Bm(r)
  }
  return XU(e, t, null, n)
}
function yi(n, e) {
  if (n === !1 || n === null || typeof n > 'u') throw new Error(e)
}
function Ea(n, e) {
  if (!n) {
    typeof console < 'u' && console.warn(e)
    try {
      throw new Error(e)
    } catch {}
  }
}
function $U() {
  return Math.random().toString(36).substring(2, 10)
}
function bA(n, e) {
  return { usr: n.state, key: n.key, idx: e }
}
function PS(n, e, t = null, i) {
  return {
    pathname: typeof n == 'string' ? n : n.pathname,
    search: '',
    hash: '',
    ...(typeof e == 'string' ? Ch(e) : e),
    state: t,
    key: (e && e.key) || i || $U(),
  }
}
function Bm({ pathname: n = '/', search: e = '', hash: t = '' }) {
  return (
    e && e !== '?' && (n += e.charAt(0) === '?' ? e : '?' + e),
    t && t !== '#' && (n += t.charAt(0) === '#' ? t : '#' + t),
    n
  )
}
function Ch(n) {
  let e = {}
  if (n) {
    let t = n.indexOf('#')
    t >= 0 && ((e.hash = n.substring(t)), (n = n.substring(0, t)))
    let i = n.indexOf('?')
    i >= 0 && ((e.search = n.substring(i)), (n = n.substring(0, i))),
      n && (e.pathname = n)
  }
  return e
}
function XU(n, e, t, i = {}) {
  let { window: r = document.defaultView, v5Compat: s = !1 } = i,
    o = r.history,
    a = 'POP',
    c = null,
    u = h()
  u == null && ((u = 0), o.replaceState({ ...o.state, idx: u }, ''))
  function h() {
    return (o.state || { idx: null }).idx
  }
  function m() {
    a = 'POP'
    let w = h(),
      x = w == null ? null : w - u
    ;(u = w), c && c({ action: a, location: M.location, delta: x })
  }
  function g(w, x) {
    a = 'PUSH'
    let T = PS(M.location, w, x)
    u = h() + 1
    let A = bA(T, u),
      P = M.createHref(T)
    try {
      o.pushState(A, '', P)
    } catch (D) {
      if (D instanceof DOMException && D.name === 'DataCloneError') throw D
      r.location.assign(P)
    }
    s && c && c({ action: a, location: M.location, delta: 1 })
  }
  function y(w, x) {
    a = 'REPLACE'
    let T = PS(M.location, w, x)
    u = h()
    let A = bA(T, u),
      P = M.createHref(T)
    o.replaceState(A, '', P),
      s && c && c({ action: a, location: M.location, delta: 0 })
  }
  function _(w) {
    let x = r.location.origin !== 'null' ? r.location.origin : r.location.href,
      T = typeof w == 'string' ? w : Bm(w)
    return (
      (T = T.replace(/ $/, '%20')),
      yi(
        x,
        `No window.location.(origin|href) available to create URL for href: ${T}`,
      ),
      new URL(T, x)
    )
  }
  let M = {
    get action() {
      return a
    },
    get location() {
      return n(r, o)
    },
    listen(w) {
      if (c) throw new Error('A history only accepts one active listener')
      return (
        r.addEventListener(EA, m),
        (c = w),
        () => {
          r.removeEventListener(EA, m), (c = null)
        }
      )
    },
    createHref(w) {
      return e(r, w)
    },
    createURL: _,
    encodeLocation(w) {
      let x = _(w)
      return { pathname: x.pathname, search: x.search, hash: x.hash }
    },
    push: g,
    replace: y,
    go(w) {
      return o.go(w)
    },
  }
  return M
}
function EI(n, e, t = '/') {
  return qU(n, e, t, !1)
}
function qU(n, e, t, i) {
  let r = typeof e == 'string' ? Ch(e) : e,
    s = Ac(r.pathname || '/', t)
  if (s == null) return null
  let o = bI(n)
  YU(o)
  let a = null
  for (let c = 0; a == null && c < o.length; ++c) {
    let u = o4(s)
    a = r4(o[c], u, i)
  }
  return a
}
function bI(n, e = [], t = [], i = '') {
  let r = (s, o, a) => {
    let c = {
      relativePath: a === void 0 ? s.path || '' : a,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: o,
      route: s,
    }
    c.relativePath.startsWith('/') &&
      (yi(
        c.relativePath.startsWith(i),
        `Absolute route path "${c.relativePath}" nested under path "${i}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`,
      ),
      (c.relativePath = c.relativePath.slice(i.length)))
    let u = _l([i, c.relativePath]),
      h = t.concat(c)
    s.children &&
      s.children.length > 0 &&
      (yi(
        s.index !== !0,
        `Index routes must not have child routes. Please remove all child routes from route path "${u}".`,
      ),
      bI(s.children, e, h, u)),
      !(s.path == null && !s.index) &&
        e.push({ path: u, score: n4(u, s.index), routesMeta: h })
  }
  return (
    n.forEach((s, o) => {
      var a
      if (s.path === '' || !((a = s.path) != null && a.includes('?'))) r(s, o)
      else for (let c of TI(s.path)) r(s, o, c)
    }),
    e
  )
}
function TI(n) {
  let e = n.split('/')
  if (e.length === 0) return []
  let [t, ...i] = e,
    r = t.endsWith('?'),
    s = t.replace(/\?$/, '')
  if (i.length === 0) return r ? [s, ''] : [s]
  let o = TI(i.join('/')),
    a = []
  return (
    a.push(...o.map((c) => (c === '' ? s : [s, c].join('/')))),
    r && a.push(...o),
    a.map((c) => (n.startsWith('/') && c === '' ? '/' : c))
  )
}
function YU(n) {
  n.sort((e, t) =>
    e.score !== t.score
      ? t.score - e.score
      : i4(
          e.routesMeta.map((i) => i.childrenIndex),
          t.routesMeta.map((i) => i.childrenIndex),
        ),
  )
}
var ZU = /^:[\w-]+$/,
  KU = 3,
  QU = 2,
  JU = 1,
  e4 = 10,
  t4 = -2,
  TA = (n) => n === '*'
function n4(n, e) {
  let t = n.split('/'),
    i = t.length
  return (
    t.some(TA) && (i += t4),
    e && (i += QU),
    t
      .filter((r) => !TA(r))
      .reduce((r, s) => r + (ZU.test(s) ? KU : s === '' ? JU : e4), i)
  )
}
function i4(n, e) {
  return n.length === e.length && n.slice(0, -1).every((i, r) => i === e[r])
    ? n[n.length - 1] - e[e.length - 1]
    : 0
}
function r4(n, e, t = !1) {
  let { routesMeta: i } = n,
    r = {},
    s = '/',
    o = []
  for (let a = 0; a < i.length; ++a) {
    let c = i[a],
      u = a === i.length - 1,
      h = s === '/' ? e : e.slice(s.length) || '/',
      m = Iy(
        { path: c.relativePath, caseSensitive: c.caseSensitive, end: u },
        h,
      ),
      g = c.route
    if (
      (!m &&
        u &&
        t &&
        !i[i.length - 1].route.index &&
        (m = Iy(
          { path: c.relativePath, caseSensitive: c.caseSensitive, end: !1 },
          h,
        )),
      !m)
    )
      return null
    Object.assign(r, m.params),
      o.push({
        params: r,
        pathname: _l([s, m.pathname]),
        pathnameBase: u4(_l([s, m.pathnameBase])),
        route: g,
      }),
      m.pathnameBase !== '/' && (s = _l([s, m.pathnameBase]))
  }
  return o
}
function Iy(n, e) {
  typeof n == 'string' && (n = { path: n, caseSensitive: !1, end: !0 })
  let [t, i] = s4(n.path, n.caseSensitive, n.end),
    r = e.match(t)
  if (!r) return null
  let s = r[0],
    o = s.replace(/(.)\/+$/, '$1'),
    a = r.slice(1)
  return {
    params: i.reduce((u, { paramName: h, isOptional: m }, g) => {
      if (h === '*') {
        let _ = a[g] || ''
        o = s.slice(0, s.length - _.length).replace(/(.)\/+$/, '$1')
      }
      const y = a[g]
      return (
        m && !y ? (u[h] = void 0) : (u[h] = (y || '').replace(/%2F/g, '/')), u
      )
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: n,
  }
}
function s4(n, e = !1, t = !0) {
  Ea(
    n === '*' || !n.endsWith('*') || n.endsWith('/*'),
    `Route path "${n}" will be treated as if it were "${n.replace(
      /\*$/,
      '/*',
    )}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(
      /\*$/,
      '/*',
    )}".`,
  )
  let i = [],
    r =
      '^' +
      n
        .replace(/\/*\*?$/, '')
        .replace(/^\/*/, '/')
        .replace(/[\\.*+^${}|()[\]]/g, '\\$&')
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (o, a, c) => (
            i.push({ paramName: a, isOptional: c != null }),
            c ? '/?([^\\/]+)?' : '/([^\\/]+)'
          ),
        )
  return (
    n.endsWith('*')
      ? (i.push({ paramName: '*' }),
        (r += n === '*' || n === '/*' ? '(.*)$' : '(?:\\/(.+)|\\/*)$'))
      : t
      ? (r += '\\/*$')
      : n !== '' && n !== '/' && (r += '(?:(?=\\/|$))'),
    [new RegExp(r, e ? void 0 : 'i'), i]
  )
}
function o4(n) {
  try {
    return n
      .split('/')
      .map((e) => decodeURIComponent(e).replace(/\//g, '%2F'))
      .join('/')
  } catch (e) {
    return (
      Ea(
        !1,
        `The URL path "${n}" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`,
      ),
      n
    )
  }
}
function Ac(n, e) {
  if (e === '/') return n
  if (!n.toLowerCase().startsWith(e.toLowerCase())) return null
  let t = e.endsWith('/') ? e.length - 1 : e.length,
    i = n.charAt(t)
  return i && i !== '/' ? null : n.slice(t) || '/'
}
function a4(n, e = '/') {
  let {
    pathname: t,
    search: i = '',
    hash: r = '',
  } = typeof n == 'string' ? Ch(n) : n
  return {
    pathname: t ? (t.startsWith('/') ? t : l4(t, e)) : e,
    search: d4(i),
    hash: f4(r),
  }
}
function l4(n, e) {
  let t = e.replace(/\/+$/, '').split('/')
  return (
    n.split('/').forEach((r) => {
      r === '..' ? t.length > 1 && t.pop() : r !== '.' && t.push(r)
    }),
    t.length > 1 ? t.join('/') : '/'
  )
}
function w1(n, e, t, i) {
  return `Cannot include a '${n}' character in a manually specified \`to.${e}\` field [${JSON.stringify(
    i,
  )}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function c4(n) {
  return n.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0),
  )
}
function AI(n) {
  let e = c4(n)
  return e.map((t, i) => (i === e.length - 1 ? t.pathname : t.pathnameBase))
}
function CI(n, e, t, i = !1) {
  let r
  typeof n == 'string'
    ? (r = Ch(n))
    : ((r = { ...n }),
      yi(
        !r.pathname || !r.pathname.includes('?'),
        w1('?', 'pathname', 'search', r),
      ),
      yi(
        !r.pathname || !r.pathname.includes('#'),
        w1('#', 'pathname', 'hash', r),
      ),
      yi(!r.search || !r.search.includes('#'), w1('#', 'search', 'hash', r)))
  let s = n === '' || r.pathname === '',
    o = s ? '/' : r.pathname,
    a
  if (o == null) a = t
  else {
    let m = e.length - 1
    if (!i && o.startsWith('..')) {
      let g = o.split('/')
      for (; g[0] === '..'; ) g.shift(), (m -= 1)
      r.pathname = g.join('/')
    }
    a = m >= 0 ? e[m] : '/'
  }
  let c = a4(r, a),
    u = o && o !== '/' && o.endsWith('/'),
    h = (s || o === '.') && t.endsWith('/')
  return !c.pathname.endsWith('/') && (u || h) && (c.pathname += '/'), c
}
var _l = (n) => n.join('/').replace(/\/\/+/g, '/'),
  u4 = (n) => n.replace(/\/+$/, '').replace(/^\/*/, '/'),
  d4 = (n) => (!n || n === '?' ? '' : n.startsWith('?') ? n : '?' + n),
  f4 = (n) => (!n || n === '#' ? '' : n.startsWith('#') ? n : '#' + n)
function h4(n) {
  return (
    n != null &&
    typeof n.status == 'number' &&
    typeof n.statusText == 'string' &&
    typeof n.internal == 'boolean' &&
    'data' in n
  )
}
var PI = ['POST', 'PUT', 'PATCH', 'DELETE']
new Set(PI)
var p4 = ['GET', ...PI]
new Set(p4)
var Ph = X.createContext(null)
Ph.displayName = 'DataRouter'
var zx = X.createContext(null)
zx.displayName = 'DataRouterState'
var RI = X.createContext({ isTransitioning: !1 })
RI.displayName = 'ViewTransition'
var m4 = X.createContext(new Map())
m4.displayName = 'Fetchers'
var g4 = X.createContext(null)
g4.displayName = 'Await'
var Ca = X.createContext(null)
Ca.displayName = 'Navigation'
var wg = X.createContext(null)
wg.displayName = 'Location'
var Rl = X.createContext({ outlet: null, matches: [], isDataRoute: !1 })
Rl.displayName = 'Route'
var WM = X.createContext(null)
WM.displayName = 'RouteError'
function v4(n, { relative: e } = {}) {
  yi(Sg(), 'useHref() may be used only in the context of a <Router> component.')
  let { basename: t, navigator: i } = X.useContext(Ca),
    { hash: r, pathname: s, search: o } = Mg(n, { relative: e }),
    a = s
  return (
    t !== '/' && (a = s === '/' ? t : _l([t, s])),
    i.createHref({ pathname: a, search: o, hash: r })
  )
}
function Sg() {
  return X.useContext(wg) != null
}
function Oc() {
  return (
    yi(
      Sg(),
      'useLocation() may be used only in the context of a <Router> component.',
    ),
    X.useContext(wg).location
  )
}
var II =
  'You should call navigate() in a React.useEffect(), not when your component is first rendered.'
function LI(n) {
  X.useContext(Ca).static || X.useLayoutEffect(n)
}
function y4() {
  let { isDataRoute: n } = X.useContext(Rl)
  return n ? I4() : x4()
}
function x4() {
  yi(
    Sg(),
    'useNavigate() may be used only in the context of a <Router> component.',
  )
  let n = X.useContext(Ph),
    { basename: e, navigator: t } = X.useContext(Ca),
    { matches: i } = X.useContext(Rl),
    { pathname: r } = Oc(),
    s = JSON.stringify(AI(i)),
    o = X.useRef(!1)
  return (
    LI(() => {
      o.current = !0
    }),
    X.useCallback(
      (c, u = {}) => {
        if ((Ea(o.current, II), !o.current)) return
        if (typeof c == 'number') {
          t.go(c)
          return
        }
        let h = CI(c, JSON.parse(s), r, u.relative === 'path')
        n == null &&
          e !== '/' &&
          (h.pathname = h.pathname === '/' ? e : _l([e, h.pathname])),
          (u.replace ? t.replace : t.push)(h, u.state, u)
      },
      [e, t, s, r, n],
    )
  )
}
X.createContext(null)
function Mg(n, { relative: e } = {}) {
  let { matches: t } = X.useContext(Rl),
    { pathname: i } = Oc(),
    r = JSON.stringify(AI(t))
  return X.useMemo(() => CI(n, JSON.parse(r), i, e === 'path'), [n, r, i, e])
}
function _4(n, e) {
  return NI(n, e)
}
function NI(n, e, t, i) {
  var x
  yi(
    Sg(),
    'useRoutes() may be used only in the context of a <Router> component.',
  )
  let { navigator: r } = X.useContext(Ca),
    { matches: s } = X.useContext(Rl),
    o = s[s.length - 1],
    a = o ? o.params : {},
    c = o ? o.pathname : '/',
    u = o ? o.pathnameBase : '/',
    h = o && o.route
  {
    let T = (h && h.path) || ''
    DI(
      c,
      !h || T.endsWith('*') || T.endsWith('*?'),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${c}" (under <Route path="${T}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${T}"> to <Route path="${
        T === '/' ? '*' : `${T}/*`
      }">.`,
    )
  }
  let m = Oc(),
    g
  if (e) {
    let T = typeof e == 'string' ? Ch(e) : e
    yi(
      u === '/' || ((x = T.pathname) == null ? void 0 : x.startsWith(u)),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${u}" but pathname "${T.pathname}" was given in the \`location\` prop.`,
    ),
      (g = T)
  } else g = m
  let y = g.pathname || '/',
    _ = y
  if (u !== '/') {
    let T = u.replace(/^\//, '').split('/')
    _ = '/' + y.replace(/^\//, '').split('/').slice(T.length).join('/')
  }
  let M = EI(n, { pathname: _ })
  Ea(
    h || M != null,
    `No routes matched location "${g.pathname}${g.search}${g.hash}" `,
  ),
    Ea(
      M == null ||
        M[M.length - 1].route.element !== void 0 ||
        M[M.length - 1].route.Component !== void 0 ||
        M[M.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`,
    )
  let w = b4(
    M &&
      M.map((T) =>
        Object.assign({}, T, {
          params: Object.assign({}, a, T.params),
          pathname: _l([
            u,
            r.encodeLocation
              ? r.encodeLocation(T.pathname).pathname
              : T.pathname,
          ]),
          pathnameBase:
            T.pathnameBase === '/'
              ? u
              : _l([
                  u,
                  r.encodeLocation
                    ? r.encodeLocation(T.pathnameBase).pathname
                    : T.pathnameBase,
                ]),
        }),
      ),
    s,
    t,
    i,
  )
  return e && w
    ? X.createElement(
        wg.Provider,
        {
          value: {
            location: {
              pathname: '/',
              search: '',
              hash: '',
              state: null,
              key: 'default',
              ...g,
            },
            navigationType: 'POP',
          },
        },
        w,
      )
    : w
}
function w4() {
  let n = R4(),
    e = h4(n)
      ? `${n.status} ${n.statusText}`
      : n instanceof Error
      ? n.message
      : JSON.stringify(n),
    t = n instanceof Error ? n.stack : null,
    i = 'rgba(200,200,200, 0.5)',
    r = { padding: '0.5rem', backgroundColor: i },
    s = { padding: '2px 4px', backgroundColor: i },
    o = null
  return (
    console.error('Error handled by React Router default ErrorBoundary:', n),
    (o = X.createElement(
      X.Fragment,
      null,
      X.createElement('p', null, '💿 Hey developer 👋'),
      X.createElement(
        'p',
        null,
        'You can provide a way better UX than this when your app throws errors by providing your own ',
        X.createElement('code', { style: s }, 'ErrorBoundary'),
        ' or',
        ' ',
        X.createElement('code', { style: s }, 'errorElement'),
        ' prop on your route.',
      ),
    )),
    X.createElement(
      X.Fragment,
      null,
      X.createElement('h2', null, 'Unexpected Application Error!'),
      X.createElement('h3', { style: { fontStyle: 'italic' } }, e),
      t ? X.createElement('pre', { style: r }, t) : null,
      o,
    )
  )
}
var S4 = X.createElement(w4, null),
  M4 = class extends X.Component {
    constructor(n) {
      super(n),
        (this.state = {
          location: n.location,
          revalidation: n.revalidation,
          error: n.error,
        })
    }
    static getDerivedStateFromError(n) {
      return { error: n }
    }
    static getDerivedStateFromProps(n, e) {
      return e.location !== n.location ||
        (e.revalidation !== 'idle' && n.revalidation === 'idle')
        ? { error: n.error, location: n.location, revalidation: n.revalidation }
        : {
            error: n.error !== void 0 ? n.error : e.error,
            location: e.location,
            revalidation: n.revalidation || e.revalidation,
          }
    }
    componentDidCatch(n, e) {
      console.error(
        'React Router caught the following error during render',
        n,
        e,
      )
    }
    render() {
      return this.state.error !== void 0
        ? X.createElement(
            Rl.Provider,
            { value: this.props.routeContext },
            X.createElement(WM.Provider, {
              value: this.state.error,
              children: this.props.component,
            }),
          )
        : this.props.children
    }
  }
function E4({ routeContext: n, match: e, children: t }) {
  let i = X.useContext(Ph)
  return (
    i &&
      i.static &&
      i.staticContext &&
      (e.route.errorElement || e.route.ErrorBoundary) &&
      (i.staticContext._deepestRenderedBoundaryId = e.route.id),
    X.createElement(Rl.Provider, { value: n }, t)
  )
}
function b4(n, e = [], t = null, i = null) {
  if (n == null) {
    if (!t) return null
    if (t.errors) n = t.matches
    else if (e.length === 0 && !t.initialized && t.matches.length > 0)
      n = t.matches
    else return null
  }
  let r = n,
    s = t == null ? void 0 : t.errors
  if (s != null) {
    let c = r.findIndex(
      (u) => u.route.id && (s == null ? void 0 : s[u.route.id]) !== void 0,
    )
    yi(
      c >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        s,
      ).join(',')}`,
    ),
      (r = r.slice(0, Math.min(r.length, c + 1)))
  }
  let o = !1,
    a = -1
  if (t)
    for (let c = 0; c < r.length; c++) {
      let u = r[c]
      if (
        ((u.route.HydrateFallback || u.route.hydrateFallbackElement) && (a = c),
        u.route.id)
      ) {
        let { loaderData: h, errors: m } = t,
          g =
            u.route.loader &&
            !h.hasOwnProperty(u.route.id) &&
            (!m || m[u.route.id] === void 0)
        if (u.route.lazy || g) {
          ;(o = !0), a >= 0 ? (r = r.slice(0, a + 1)) : (r = [r[0]])
          break
        }
      }
    }
  return r.reduceRight((c, u, h) => {
    let m,
      g = !1,
      y = null,
      _ = null
    t &&
      ((m = s && u.route.id ? s[u.route.id] : void 0),
      (y = u.route.errorElement || S4),
      o &&
        (a < 0 && h === 0
          ? (DI(
              'route-fallback',
              !1,
              'No `HydrateFallback` element provided to render during initial hydration',
            ),
            (g = !0),
            (_ = null))
          : a === h &&
            ((g = !0), (_ = u.route.hydrateFallbackElement || null))))
    let M = e.concat(r.slice(0, h + 1)),
      w = () => {
        let x
        return (
          m
            ? (x = y)
            : g
            ? (x = _)
            : u.route.Component
            ? (x = X.createElement(u.route.Component, null))
            : u.route.element
            ? (x = u.route.element)
            : (x = c),
          X.createElement(E4, {
            match: u,
            routeContext: { outlet: c, matches: M, isDataRoute: t != null },
            children: x,
          })
        )
      }
    return t && (u.route.ErrorBoundary || u.route.errorElement || h === 0)
      ? X.createElement(M4, {
          location: t.location,
          revalidation: t.revalidation,
          component: y,
          error: m,
          children: w(),
          routeContext: { outlet: null, matches: M, isDataRoute: !0 },
        })
      : w()
  }, null)
}
function $M(n) {
  return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function T4(n) {
  let e = X.useContext(Ph)
  return yi(e, $M(n)), e
}
function A4(n) {
  let e = X.useContext(zx)
  return yi(e, $M(n)), e
}
function C4(n) {
  let e = X.useContext(Rl)
  return yi(e, $M(n)), e
}
function XM(n) {
  let e = C4(n),
    t = e.matches[e.matches.length - 1]
  return (
    yi(
      t.route.id,
      `${n} can only be used on routes that contain a unique "id"`,
    ),
    t.route.id
  )
}
function P4() {
  return XM('useRouteId')
}
function R4() {
  var i
  let n = X.useContext(WM),
    e = A4('useRouteError'),
    t = XM('useRouteError')
  return n !== void 0 ? n : (i = e.errors) == null ? void 0 : i[t]
}
function I4() {
  let { router: n } = T4('useNavigate'),
    e = XM('useNavigate'),
    t = X.useRef(!1)
  return (
    LI(() => {
      t.current = !0
    }),
    X.useCallback(
      async (r, s = {}) => {
        Ea(t.current, II),
          t.current &&
            (typeof r == 'number'
              ? n.navigate(r)
              : await n.navigate(r, { fromRouteId: e, ...s }))
      },
      [n, e],
    )
  )
}
var AA = {}
function DI(n, e, t) {
  !e && !AA[n] && ((AA[n] = !0), Ea(!1, t))
}
X.memo(L4)
function L4({ routes: n, future: e, state: t }) {
  return NI(n, void 0, t, e)
}
function Hf(n) {
  yi(
    !1,
    'A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.',
  )
}
function N4({
  basename: n = '/',
  children: e = null,
  location: t,
  navigationType: i = 'POP',
  navigator: r,
  static: s = !1,
}) {
  yi(
    !Sg(),
    'You cannot render a <Router> inside another <Router>. You should never have more than one in your app.',
  )
  let o = n.replace(/^\/*/, '/'),
    a = X.useMemo(
      () => ({ basename: o, navigator: r, static: s, future: {} }),
      [o, r, s],
    )
  typeof t == 'string' && (t = Ch(t))
  let {
      pathname: c = '/',
      search: u = '',
      hash: h = '',
      state: m = null,
      key: g = 'default',
    } = t,
    y = X.useMemo(() => {
      let _ = Ac(c, o)
      return _ == null
        ? null
        : {
            location: { pathname: _, search: u, hash: h, state: m, key: g },
            navigationType: i,
          }
    }, [o, c, u, h, m, g, i])
  return (
    Ea(
      y != null,
      `<Router basename="${o}"> is not able to match the URL "${c}${u}${h}" because it does not start with the basename, so the <Router> won't render anything.`,
    ),
    y == null
      ? null
      : X.createElement(
          Ca.Provider,
          { value: a },
          X.createElement(wg.Provider, { children: e, value: y }),
        )
  )
}
function D4({ children: n, location: e }) {
  return _4(RS(n), e)
}
function RS(n, e = []) {
  let t = []
  return (
    X.Children.forEach(n, (i, r) => {
      if (!X.isValidElement(i)) return
      let s = [...e, r]
      if (i.type === X.Fragment) {
        t.push.apply(t, RS(i.props.children, s))
        return
      }
      yi(
        i.type === Hf,
        `[${
          typeof i.type == 'string' ? i.type : i.type.name
        }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`,
      ),
        yi(
          !i.props.index || !i.props.children,
          'An index route cannot have child routes.',
        )
      let o = {
        id: i.props.id || s.join('-'),
        caseSensitive: i.props.caseSensitive,
        element: i.props.element,
        Component: i.props.Component,
        index: i.props.index,
        path: i.props.path,
        loader: i.props.loader,
        action: i.props.action,
        hydrateFallbackElement: i.props.hydrateFallbackElement,
        HydrateFallback: i.props.HydrateFallback,
        errorElement: i.props.errorElement,
        ErrorBoundary: i.props.ErrorBoundary,
        hasErrorBoundary:
          i.props.hasErrorBoundary === !0 ||
          i.props.ErrorBoundary != null ||
          i.props.errorElement != null,
        shouldRevalidate: i.props.shouldRevalidate,
        handle: i.props.handle,
        lazy: i.props.lazy,
      }
      i.props.children && (o.children = RS(i.props.children, s)), t.push(o)
    }),
    t
  )
}
var vy = 'get',
  yy = 'application/x-www-form-urlencoded'
function Vx(n) {
  return n != null && typeof n.tagName == 'string'
}
function O4(n) {
  return Vx(n) && n.tagName.toLowerCase() === 'button'
}
function k4(n) {
  return Vx(n) && n.tagName.toLowerCase() === 'form'
}
function F4(n) {
  return Vx(n) && n.tagName.toLowerCase() === 'input'
}
function U4(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey)
}
function B4(n, e) {
  return n.button === 0 && (!e || e === '_self') && !U4(n)
}
var Kv = null
function z4() {
  if (Kv === null)
    try {
      new FormData(document.createElement('form'), 0), (Kv = !1)
    } catch {
      Kv = !0
    }
  return Kv
}
var V4 = new Set([
  'application/x-www-form-urlencoded',
  'multipart/form-data',
  'text/plain',
])
function S1(n) {
  return n != null && !V4.has(n)
    ? (Ea(
        !1,
        `"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${yy}"`,
      ),
      null)
    : n
}
function j4(n, e) {
  let t, i, r, s, o
  if (k4(n)) {
    let a = n.getAttribute('action')
    ;(i = a ? Ac(a, e) : null),
      (t = n.getAttribute('method') || vy),
      (r = S1(n.getAttribute('enctype')) || yy),
      (s = new FormData(n))
  } else if (O4(n) || (F4(n) && (n.type === 'submit' || n.type === 'image'))) {
    let a = n.form
    if (a == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>',
      )
    let c = n.getAttribute('formaction') || a.getAttribute('action')
    if (
      ((i = c ? Ac(c, e) : null),
      (t = n.getAttribute('formmethod') || a.getAttribute('method') || vy),
      (r =
        S1(n.getAttribute('formenctype')) ||
        S1(a.getAttribute('enctype')) ||
        yy),
      (s = new FormData(a, n)),
      !z4())
    ) {
      let { name: u, type: h, value: m } = n
      if (h === 'image') {
        let g = u ? `${u}.` : ''
        s.append(`${g}x`, '0'), s.append(`${g}y`, '0')
      } else u && s.append(u, m)
    }
  } else {
    if (Vx(n))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">',
      )
    ;(t = vy), (i = null), (r = yy), (o = n)
  }
  return (
    s && r === 'text/plain' && ((o = s), (s = void 0)),
    { action: i, method: t.toLowerCase(), encType: r, formData: s, body: o }
  )
}
function qM(n, e) {
  if (n === !1 || n === null || typeof n > 'u') throw new Error(e)
}
async function H4(n, e) {
  if (n.id in e) return e[n.id]
  try {
    let t = await import(n.module)
    return (e[n.id] = t), t
  } catch (t) {
    return (
      console.error(
        `Error loading route module \`${n.module}\`, reloading page...`,
      ),
      console.error(t),
      window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
      window.location.reload(),
      new Promise(() => {})
    )
  }
}
function G4(n) {
  return n == null
    ? !1
    : n.href == null
    ? n.rel === 'preload' &&
      typeof n.imageSrcSet == 'string' &&
      typeof n.imageSizes == 'string'
    : typeof n.rel == 'string' && typeof n.href == 'string'
}
async function W4(n, e, t) {
  let i = await Promise.all(
    n.map(async (r) => {
      let s = e.routes[r.route.id]
      if (s) {
        let o = await H4(s, t)
        return o.links ? o.links() : []
      }
      return []
    }),
  )
  return Y4(
    i
      .flat(1)
      .filter(G4)
      .filter((r) => r.rel === 'stylesheet' || r.rel === 'preload')
      .map((r) =>
        r.rel === 'stylesheet'
          ? { ...r, rel: 'prefetch', as: 'style' }
          : { ...r, rel: 'prefetch' },
      ),
  )
}
function CA(n, e, t, i, r, s) {
  let o = (c, u) => (t[u] ? c.route.id !== t[u].route.id : !0),
    a = (c, u) => {
      var h
      return (
        t[u].pathname !== c.pathname ||
        (((h = t[u].route.path) == null ? void 0 : h.endsWith('*')) &&
          t[u].params['*'] !== c.params['*'])
      )
    }
  return s === 'assets'
    ? e.filter((c, u) => o(c, u) || a(c, u))
    : s === 'data'
    ? e.filter((c, u) => {
        var m
        let h = i.routes[c.route.id]
        if (!h || !h.hasLoader) return !1
        if (o(c, u) || a(c, u)) return !0
        if (c.route.shouldRevalidate) {
          let g = c.route.shouldRevalidate({
            currentUrl: new URL(r.pathname + r.search + r.hash, window.origin),
            currentParams: ((m = t[0]) == null ? void 0 : m.params) || {},
            nextUrl: new URL(n, window.origin),
            nextParams: c.params,
            defaultShouldRevalidate: !0,
          })
          if (typeof g == 'boolean') return g
        }
        return !0
      })
    : []
}
function $4(n, e) {
  return X4(
    n
      .map((t) => {
        let i = e.routes[t.route.id]
        if (!i) return []
        let r = [i.module]
        return i.imports && (r = r.concat(i.imports)), r
      })
      .flat(1),
  )
}
function X4(n) {
  return [...new Set(n)]
}
function q4(n) {
  let e = {},
    t = Object.keys(n).sort()
  for (let i of t) e[i] = n[i]
  return e
}
function Y4(n, e) {
  let t = new Set()
  return (
    new Set(e),
    n.reduce((i, r) => {
      let s = JSON.stringify(q4(r))
      return t.has(s) || (t.add(s), i.push({ key: s, link: r })), i
    }, [])
  )
}
function Z4(n) {
  let e =
    typeof n == 'string'
      ? new URL(
          n,
          typeof window > 'u'
            ? 'server://singlefetch/'
            : window.location.origin,
        )
      : n
  return (
    e.pathname === '/'
      ? (e.pathname = '_root.data')
      : (e.pathname = `${e.pathname.replace(/\/$/, '')}.data`),
    e
  )
}
function K4() {
  let n = X.useContext(Ph)
  return (
    qM(
      n,
      'You must render this element inside a <DataRouterContext.Provider> element',
    ),
    n
  )
}
function Q4() {
  let n = X.useContext(zx)
  return (
    qM(
      n,
      'You must render this element inside a <DataRouterStateContext.Provider> element',
    ),
    n
  )
}
var YM = X.createContext(void 0)
YM.displayName = 'FrameworkContext'
function OI() {
  let n = X.useContext(YM)
  return (
    qM(n, 'You must render this element inside a <HydratedRouter> element'), n
  )
}
function J4(n, e) {
  let t = X.useContext(YM),
    [i, r] = X.useState(!1),
    [s, o] = X.useState(!1),
    {
      onFocus: a,
      onBlur: c,
      onMouseEnter: u,
      onMouseLeave: h,
      onTouchStart: m,
    } = e,
    g = X.useRef(null)
  X.useEffect(() => {
    if ((n === 'render' && o(!0), n === 'viewport')) {
      let M = (x) => {
          x.forEach((T) => {
            o(T.isIntersecting)
          })
        },
        w = new IntersectionObserver(M, { threshold: 0.5 })
      return (
        g.current && w.observe(g.current),
        () => {
          w.disconnect()
        }
      )
    }
  }, [n]),
    X.useEffect(() => {
      if (i) {
        let M = setTimeout(() => {
          o(!0)
        }, 100)
        return () => {
          clearTimeout(M)
        }
      }
    }, [i])
  let y = () => {
      r(!0)
    },
    _ = () => {
      r(!1), o(!1)
    }
  return t
    ? n !== 'intent'
      ? [s, g, {}]
      : [
          s,
          g,
          {
            onFocus: Np(a, y),
            onBlur: Np(c, _),
            onMouseEnter: Np(u, y),
            onMouseLeave: Np(h, _),
            onTouchStart: Np(m, y),
          },
        ]
    : [!1, g, {}]
}
function Np(n, e) {
  return (t) => {
    n && n(t), t.defaultPrevented || e(t)
  }
}
function e5({ page: n, ...e }) {
  let { router: t } = K4(),
    i = X.useMemo(() => EI(t.routes, n, t.basename), [t.routes, n, t.basename])
  return i ? X.createElement(n5, { page: n, matches: i, ...e }) : null
}
function t5(n) {
  let { manifest: e, routeModules: t } = OI(),
    [i, r] = X.useState([])
  return (
    X.useEffect(() => {
      let s = !1
      return (
        W4(n, e, t).then((o) => {
          s || r(o)
        }),
        () => {
          s = !0
        }
      )
    }, [n, e, t]),
    i
  )
}
function n5({ page: n, matches: e, ...t }) {
  let i = Oc(),
    { manifest: r, routeModules: s } = OI(),
    { loaderData: o, matches: a } = Q4(),
    c = X.useMemo(() => CA(n, e, a, r, i, 'data'), [n, e, a, r, i]),
    u = X.useMemo(() => CA(n, e, a, r, i, 'assets'), [n, e, a, r, i]),
    h = X.useMemo(() => {
      if (n === i.pathname + i.search + i.hash) return []
      let y = new Set(),
        _ = !1
      if (
        (e.forEach((w) => {
          var T
          let x = r.routes[w.route.id]
          !x ||
            !x.hasLoader ||
            ((!c.some((A) => A.route.id === w.route.id) &&
              w.route.id in o &&
              (T = s[w.route.id]) != null &&
              T.shouldRevalidate) ||
            x.hasClientLoader
              ? (_ = !0)
              : y.add(w.route.id))
        }),
        y.size === 0)
      )
        return []
      let M = Z4(n)
      return (
        _ &&
          y.size > 0 &&
          M.searchParams.set(
            '_routes',
            e
              .filter((w) => y.has(w.route.id))
              .map((w) => w.route.id)
              .join(','),
          ),
        [M.pathname + M.search]
      )
    }, [o, i, r, c, e, n, s]),
    m = X.useMemo(() => $4(u, r), [u, r]),
    g = t5(u)
  return X.createElement(
    X.Fragment,
    null,
    h.map((y) =>
      X.createElement('link', {
        key: y,
        rel: 'prefetch',
        as: 'fetch',
        href: y,
        ...t,
      }),
    ),
    m.map((y) =>
      X.createElement('link', { key: y, rel: 'modulepreload', href: y, ...t }),
    ),
    g.map(({ key: y, link: _ }) => X.createElement('link', { key: y, ..._ })),
  )
}
function i5(...n) {
  return (e) => {
    n.forEach((t) => {
      typeof t == 'function' ? t(e) : t != null && (t.current = e)
    })
  }
}
var kI =
  typeof window < 'u' &&
  typeof window.document < 'u' &&
  typeof window.document.createElement < 'u'
try {
  kI && (window.__reactRouterVersion = '7.1.1')
} catch {}
function r5({ basename: n, children: e, window: t }) {
  let i = X.useRef()
  i.current == null && (i.current = WU({ window: t, v5Compat: !0 }))
  let r = i.current,
    [s, o] = X.useState({ action: r.action, location: r.location }),
    a = X.useCallback(
      (c) => {
        X.startTransition(() => o(c))
      },
      [o],
    )
  return (
    X.useLayoutEffect(() => r.listen(a), [r, a]),
    X.createElement(N4, {
      basename: n,
      children: e,
      location: s.location,
      navigationType: s.action,
      navigator: r,
    })
  )
}
var FI = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  Fs = X.forwardRef(function (
    {
      onClick: e,
      discover: t = 'render',
      prefetch: i = 'none',
      relative: r,
      reloadDocument: s,
      replace: o,
      state: a,
      target: c,
      to: u,
      preventScrollReset: h,
      viewTransition: m,
      ...g
    },
    y,
  ) {
    let { basename: _ } = X.useContext(Ca),
      M = typeof u == 'string' && FI.test(u),
      w,
      x = !1
    if (typeof u == 'string' && M && ((w = u), kI))
      try {
        let N = new URL(window.location.href),
          k = u.startsWith('//') ? new URL(N.protocol + u) : new URL(u),
          z = Ac(k.pathname, _)
        k.origin === N.origin && z != null
          ? (u = z + k.search + k.hash)
          : (x = !0)
      } catch {
        Ea(
          !1,
          `<Link to="${u}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`,
        )
      }
    let T = v4(u, { relative: r }),
      [A, P, D] = J4(i, g),
      O = l5(u, {
        replace: o,
        state: a,
        target: c,
        preventScrollReset: h,
        relative: r,
        viewTransition: m,
      })
    function U(N) {
      e && e(N), N.defaultPrevented || O(N)
    }
    let F = X.createElement('a', {
      ...g,
      ...D,
      href: w || T,
      onClick: x || s ? e : U,
      ref: i5(y, P),
      target: c,
      'data-discover': !M && t === 'render' ? 'true' : void 0,
    })
    return A && !M
      ? X.createElement(X.Fragment, null, F, X.createElement(e5, { page: T }))
      : F
  })
Fs.displayName = 'Link'
var s5 = X.forwardRef(function (
  {
    'aria-current': e = 'page',
    caseSensitive: t = !1,
    className: i = '',
    end: r = !1,
    style: s,
    to: o,
    viewTransition: a,
    children: c,
    ...u
  },
  h,
) {
  let m = Mg(o, { relative: u.relative }),
    g = Oc(),
    y = X.useContext(zx),
    { navigator: _, basename: M } = X.useContext(Ca),
    w = y != null && h5(m) && a === !0,
    x = _.encodeLocation ? _.encodeLocation(m).pathname : m.pathname,
    T = g.pathname,
    A =
      y && y.navigation && y.navigation.location
        ? y.navigation.location.pathname
        : null
  t ||
    ((T = T.toLowerCase()),
    (A = A ? A.toLowerCase() : null),
    (x = x.toLowerCase())),
    A && M && (A = Ac(A, M) || A)
  const P = x !== '/' && x.endsWith('/') ? x.length - 1 : x.length
  let D = T === x || (!r && T.startsWith(x) && T.charAt(P) === '/'),
    O =
      A != null &&
      (A === x || (!r && A.startsWith(x) && A.charAt(x.length) === '/')),
    U = { isActive: D, isPending: O, isTransitioning: w },
    F = D ? e : void 0,
    N
  typeof i == 'function'
    ? (N = i(U))
    : (N = [
        i,
        D ? 'active' : null,
        O ? 'pending' : null,
        w ? 'transitioning' : null,
      ]
        .filter(Boolean)
        .join(' '))
  let k = typeof s == 'function' ? s(U) : s
  return X.createElement(
    Fs,
    {
      ...u,
      'aria-current': F,
      className: N,
      ref: h,
      style: k,
      to: o,
      viewTransition: a,
    },
    typeof c == 'function' ? c(U) : c,
  )
})
s5.displayName = 'NavLink'
var o5 = X.forwardRef(
  (
    {
      discover: n = 'render',
      fetcherKey: e,
      navigate: t,
      reloadDocument: i,
      replace: r,
      state: s,
      method: o = vy,
      action: a,
      onSubmit: c,
      relative: u,
      preventScrollReset: h,
      viewTransition: m,
      ...g
    },
    y,
  ) => {
    let _ = d5(),
      M = f5(a, { relative: u }),
      w = o.toLowerCase() === 'get' ? 'get' : 'post',
      x = typeof a == 'string' && FI.test(a),
      T = (A) => {
        if ((c && c(A), A.defaultPrevented)) return
        A.preventDefault()
        let P = A.nativeEvent.submitter,
          D = (P == null ? void 0 : P.getAttribute('formmethod')) || o
        _(P || A.currentTarget, {
          fetcherKey: e,
          method: D,
          navigate: t,
          replace: r,
          state: s,
          relative: u,
          preventScrollReset: h,
          viewTransition: m,
        })
      }
    return X.createElement('form', {
      ref: y,
      method: w,
      action: M,
      onSubmit: i ? c : T,
      ...g,
      'data-discover': !x && n === 'render' ? 'true' : void 0,
    })
  },
)
o5.displayName = 'Form'
function a5(n) {
  return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function UI(n) {
  let e = X.useContext(Ph)
  return yi(e, a5(n)), e
}
function l5(
  n,
  {
    target: e,
    replace: t,
    state: i,
    preventScrollReset: r,
    relative: s,
    viewTransition: o,
  } = {},
) {
  let a = y4(),
    c = Oc(),
    u = Mg(n, { relative: s })
  return X.useCallback(
    (h) => {
      if (B4(h, e)) {
        h.preventDefault()
        let m = t !== void 0 ? t : Bm(c) === Bm(u)
        a(n, {
          replace: m,
          state: i,
          preventScrollReset: r,
          relative: s,
          viewTransition: o,
        })
      }
    },
    [c, a, u, t, i, e, n, r, s, o],
  )
}
var c5 = 0,
  u5 = () => `__${String(++c5)}__`
function d5() {
  let { router: n } = UI('useSubmit'),
    { basename: e } = X.useContext(Ca),
    t = P4()
  return X.useCallback(
    async (i, r = {}) => {
      let { action: s, method: o, encType: a, formData: c, body: u } = j4(i, e)
      if (r.navigate === !1) {
        let h = r.fetcherKey || u5()
        await n.fetch(h, t, r.action || s, {
          preventScrollReset: r.preventScrollReset,
          formData: c,
          body: u,
          formMethod: r.method || o,
          formEncType: r.encType || a,
          flushSync: r.flushSync,
        })
      } else
        await n.navigate(r.action || s, {
          preventScrollReset: r.preventScrollReset,
          formData: c,
          body: u,
          formMethod: r.method || o,
          formEncType: r.encType || a,
          replace: r.replace,
          state: r.state,
          fromRouteId: t,
          flushSync: r.flushSync,
          viewTransition: r.viewTransition,
        })
    },
    [n, e, t],
  )
}
function f5(n, { relative: e } = {}) {
  let { basename: t } = X.useContext(Ca),
    i = X.useContext(Rl)
  yi(i, 'useFormAction must be used inside a RouteContext')
  let [r] = i.matches.slice(-1),
    s = { ...Mg(n || '.', { relative: e }) },
    o = Oc()
  if (n == null) {
    s.search = o.search
    let a = new URLSearchParams(s.search),
      c = a.getAll('index')
    if (c.some((h) => h === '')) {
      a.delete('index'), c.filter((m) => m).forEach((m) => a.append('index', m))
      let h = a.toString()
      s.search = h ? `?${h}` : ''
    }
  }
  return (
    (!n || n === '.') &&
      r.route.index &&
      (s.search = s.search ? s.search.replace(/^\?/, '?index&') : '?index'),
    t !== '/' && (s.pathname = s.pathname === '/' ? t : _l([t, s.pathname])),
    Bm(s)
  )
}
function h5(n, e = {}) {
  let t = X.useContext(RI)
  yi(
    t != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?",
  )
  let { basename: i } = UI('useViewTransitionState'),
    r = Mg(n, { relative: e.relative })
  if (!t.isTransitioning) return !1
  let s = Ac(t.currentLocation.pathname, i) || t.currentLocation.pathname,
    o = Ac(t.nextLocation.pathname, i) || t.nextLocation.pathname
  return Iy(r.pathname, o) != null || Iy(r.pathname, s) != null
}
new TextEncoder()
const p5 = () => {
  const n = Oc()
  return (
    X.useEffect(() => {
      const { hash: e } = n
      if (e) {
        const t = document.getElementById(e.slice(1))
        t && t.scrollIntoView({ behavior: 'smooth' })
      } else window.scrollTo({ top: 0, behavior: 'instant' })
    }, [n]),
    null
  )
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Eg = '172',
  m5 = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  g5 = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  BI = 0,
  IS = 1,
  zI = 2,
  v5 = 3,
  VI = 0,
  jx = 1,
  mm = 2,
  Vo = 3,
  Tl = 0,
  Qr = 1,
  oo = 2,
  va = 0,
  od = 1,
  LS = 2,
  NS = 3,
  DS = 4,
  jI = 5,
  Sc = 100,
  HI = 101,
  GI = 102,
  WI = 103,
  $I = 104,
  XI = 200,
  qI = 201,
  YI = 202,
  ZI = 203,
  Ly = 204,
  Ny = 205,
  KI = 206,
  QI = 207,
  JI = 208,
  eL = 209,
  tL = 210,
  nL = 211,
  iL = 212,
  rL = 213,
  sL = 214,
  Dy = 0,
  Oy = 1,
  ky = 2,
  hd = 3,
  Fy = 4,
  Uy = 5,
  By = 6,
  zy = 7,
  bg = 0,
  oL = 1,
  aL = 2,
  ya = 0,
  lL = 1,
  cL = 2,
  uL = 3,
  ZM = 4,
  dL = 5,
  fL = 6,
  hL = 7,
  OS = 'attached',
  pL = 'detached',
  Cc = 300,
  ba = 301,
  Pc = 302,
  hh = 303,
  zm = 304,
  Rh = 306,
  Vm = 1e3,
  Bi = 1001,
  jm = 1002,
  yr = 1003,
  KM = 1004,
  y5 = 1004,
  Xf = 1005,
  x5 = 1005,
  Vn = 1006,
  gm = 1007,
  _5 = 1007,
  ma = 1008,
  kS = 1008,
  _s = 1009,
  Hx = 1010,
  Gx = 1011,
  ph = 1012,
  Tg = 1013,
  Ta = 1014,
  gi = 1015,
  or = 1016,
  Wx = 1017,
  $x = 1018,
  pd = 1020,
  QM = 35902,
  JM = 1021,
  eE = 1022,
  Ii = 1023,
  tE = 1024,
  nE = 1025,
  ad = 1026,
  md = 1027,
  Ag = 1028,
  Cg = 1029,
  iE = 1030,
  Xx = 1031,
  w5 = 1032,
  qx = 1033,
  vm = 33776,
  ym = 33777,
  xm = 33778,
  _m = 33779,
  Vy = 35840,
  jy = 35841,
  Hy = 35842,
  Gy = 35843,
  Wy = 36196,
  $y = 37492,
  Xy = 37496,
  qy = 37808,
  Yy = 37809,
  Zy = 37810,
  Ky = 37811,
  Qy = 37812,
  Jy = 37813,
  ex = 37814,
  tx = 37815,
  nx = 37816,
  ix = 37817,
  rx = 37818,
  sx = 37819,
  ox = 37820,
  ax = 37821,
  wm = 36492,
  lx = 36494,
  cx = 36495,
  rE = 36283,
  ux = 36284,
  dx = 36285,
  fx = 36286,
  mL = 2200,
  gL = 2201,
  vL = 2202,
  Hm = 2300,
  hx = 2301,
  xy = 2302,
  Qu = 2400,
  Ju = 2401,
  Gm = 2402,
  Yx = 2500,
  sE = 2501,
  S5 = 0,
  M5 = 1,
  E5 = 2,
  yL = 3200,
  xL = 3201,
  b5 = 3202,
  T5 = 3203,
  kc = 0,
  _L = 1,
  vl = '',
  Zr = 'srgb',
  Aa = 'srgb-linear',
  Wm = 'linear',
  zn = 'srgb',
  A5 = 0,
  Hu = 7680,
  C5 = 7681,
  P5 = 7682,
  R5 = 7683,
  I5 = 34055,
  L5 = 34056,
  N5 = 5386,
  D5 = 512,
  O5 = 513,
  k5 = 514,
  F5 = 515,
  U5 = 516,
  B5 = 517,
  z5 = 518,
  FS = 519,
  wL = 512,
  SL = 513,
  ML = 514,
  oE = 515,
  EL = 516,
  bL = 517,
  TL = 518,
  AL = 519,
  $m = 35044,
  V5 = 35048,
  j5 = 35040,
  H5 = 35045,
  G5 = 35049,
  W5 = 35041,
  $5 = 35046,
  X5 = 35050,
  q5 = 35042,
  Y5 = '100',
  US = '300 es',
  Go = 2e3,
  Xm = 2001
class Pa {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {})
    const i = this._listeners
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t)
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1
    const i = this._listeners
    return i[e] !== void 0 && i[e].indexOf(t) !== -1
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return
    const r = this._listeners[e]
    if (r !== void 0) {
      const s = r.indexOf(t)
      s !== -1 && r.splice(s, 1)
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return
    const i = this._listeners[e.type]
    if (i !== void 0) {
      e.target = this
      const r = i.slice(0)
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e)
      e.target = null
    }
  }
}
const Ar = [
  '00',
  '01',
  '02',
  '03',
  '04',
  '05',
  '06',
  '07',
  '08',
  '09',
  '0a',
  '0b',
  '0c',
  '0d',
  '0e',
  '0f',
  '10',
  '11',
  '12',
  '13',
  '14',
  '15',
  '16',
  '17',
  '18',
  '19',
  '1a',
  '1b',
  '1c',
  '1d',
  '1e',
  '1f',
  '20',
  '21',
  '22',
  '23',
  '24',
  '25',
  '26',
  '27',
  '28',
  '29',
  '2a',
  '2b',
  '2c',
  '2d',
  '2e',
  '2f',
  '30',
  '31',
  '32',
  '33',
  '34',
  '35',
  '36',
  '37',
  '38',
  '39',
  '3a',
  '3b',
  '3c',
  '3d',
  '3e',
  '3f',
  '40',
  '41',
  '42',
  '43',
  '44',
  '45',
  '46',
  '47',
  '48',
  '49',
  '4a',
  '4b',
  '4c',
  '4d',
  '4e',
  '4f',
  '50',
  '51',
  '52',
  '53',
  '54',
  '55',
  '56',
  '57',
  '58',
  '59',
  '5a',
  '5b',
  '5c',
  '5d',
  '5e',
  '5f',
  '60',
  '61',
  '62',
  '63',
  '64',
  '65',
  '66',
  '67',
  '68',
  '69',
  '6a',
  '6b',
  '6c',
  '6d',
  '6e',
  '6f',
  '70',
  '71',
  '72',
  '73',
  '74',
  '75',
  '76',
  '77',
  '78',
  '79',
  '7a',
  '7b',
  '7c',
  '7d',
  '7e',
  '7f',
  '80',
  '81',
  '82',
  '83',
  '84',
  '85',
  '86',
  '87',
  '88',
  '89',
  '8a',
  '8b',
  '8c',
  '8d',
  '8e',
  '8f',
  '90',
  '91',
  '92',
  '93',
  '94',
  '95',
  '96',
  '97',
  '98',
  '99',
  '9a',
  '9b',
  '9c',
  '9d',
  '9e',
  '9f',
  'a0',
  'a1',
  'a2',
  'a3',
  'a4',
  'a5',
  'a6',
  'a7',
  'a8',
  'a9',
  'aa',
  'ab',
  'ac',
  'ad',
  'ae',
  'af',
  'b0',
  'b1',
  'b2',
  'b3',
  'b4',
  'b5',
  'b6',
  'b7',
  'b8',
  'b9',
  'ba',
  'bb',
  'bc',
  'bd',
  'be',
  'bf',
  'c0',
  'c1',
  'c2',
  'c3',
  'c4',
  'c5',
  'c6',
  'c7',
  'c8',
  'c9',
  'ca',
  'cb',
  'cc',
  'cd',
  'ce',
  'cf',
  'd0',
  'd1',
  'd2',
  'd3',
  'd4',
  'd5',
  'd6',
  'd7',
  'd8',
  'd9',
  'da',
  'db',
  'dc',
  'dd',
  'de',
  'df',
  'e0',
  'e1',
  'e2',
  'e3',
  'e4',
  'e5',
  'e6',
  'e7',
  'e8',
  'e9',
  'ea',
  'eb',
  'ec',
  'ed',
  'ee',
  'ef',
  'f0',
  'f1',
  'f2',
  'f3',
  'f4',
  'f5',
  'f6',
  'f7',
  'f8',
  'f9',
  'fa',
  'fb',
  'fc',
  'fd',
  'fe',
  'ff',
]
let PA = 1234567
const ld = Math.PI / 180,
  mh = 180 / Math.PI
function Ds() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0
  return (
    Ar[n & 255] +
    Ar[(n >> 8) & 255] +
    Ar[(n >> 16) & 255] +
    Ar[(n >> 24) & 255] +
    '-' +
    Ar[e & 255] +
    Ar[(e >> 8) & 255] +
    '-' +
    Ar[((e >> 16) & 15) | 64] +
    Ar[(e >> 24) & 255] +
    '-' +
    Ar[(t & 63) | 128] +
    Ar[(t >> 8) & 255] +
    '-' +
    Ar[(t >> 16) & 255] +
    Ar[(t >> 24) & 255] +
    Ar[i & 255] +
    Ar[(i >> 8) & 255] +
    Ar[(i >> 16) & 255] +
    Ar[(i >> 24) & 255]
  ).toLowerCase()
}
function un(n, e, t) {
  return Math.max(e, Math.min(t, n))
}
function aE(n, e) {
  return ((n % e) + e) % e
}
function Z5(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e)
}
function K5(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0
}
function Sm(n, e, t) {
  return (1 - t) * n + t * e
}
function Q5(n, e, t, i) {
  return Sm(n, e, 1 - Math.exp(-t * i))
}
function J5(n, e = 1) {
  return e - Math.abs(aE(n, e * 2) - e)
}
function eB(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n))
}
function tB(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10))
}
function nB(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1))
}
function iB(n, e) {
  return n + Math.random() * (e - n)
}
function rB(n) {
  return n * (0.5 - Math.random())
}
function sB(n) {
  n !== void 0 && (PA = n)
  let e = (PA += 1831565813)
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  )
}
function oB(n) {
  return n * ld
}
function aB(n) {
  return n * mh
}
function lB(n) {
  return (n & (n - 1)) === 0 && n !== 0
}
function cB(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function uB(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function dB(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    c = o(t / 2),
    u = s((e + i) / 2),
    h = o((e + i) / 2),
    m = s((e - i) / 2),
    g = o((e - i) / 2),
    y = s((i - e) / 2),
    _ = o((i - e) / 2)
  switch (r) {
    case 'XYX':
      n.set(a * h, c * m, c * g, a * u)
      break
    case 'YZY':
      n.set(c * g, a * h, c * m, a * u)
      break
    case 'ZXZ':
      n.set(c * m, c * g, a * h, a * u)
      break
    case 'XZX':
      n.set(a * h, c * _, c * y, a * u)
      break
    case 'YXY':
      n.set(c * y, a * h, c * _, a * u)
      break
    case 'ZYZ':
      n.set(c * _, c * y, a * h, a * u)
      break
    default:
      console.warn(
        'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
          r,
      )
  }
}
function Kr(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n
    case Uint32Array:
      return n / 4294967295
    case Uint16Array:
      return n / 65535
    case Uint8Array:
      return n / 255
    case Int32Array:
      return Math.max(n / 2147483647, -1)
    case Int16Array:
      return Math.max(n / 32767, -1)
    case Int8Array:
      return Math.max(n / 127, -1)
    default:
      throw new Error('Invalid component type.')
  }
}
function vn(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n
    case Uint32Array:
      return Math.round(n * 4294967295)
    case Uint16Array:
      return Math.round(n * 65535)
    case Uint8Array:
      return Math.round(n * 255)
    case Int32Array:
      return Math.round(n * 2147483647)
    case Int16Array:
      return Math.round(n * 32767)
    case Int8Array:
      return Math.round(n * 127)
    default:
      throw new Error('Invalid component type.')
  }
}
const fB = {
  DEG2RAD: ld,
  RAD2DEG: mh,
  generateUUID: Ds,
  clamp: un,
  euclideanModulo: aE,
  mapLinear: Z5,
  inverseLerp: K5,
  lerp: Sm,
  damp: Q5,
  pingpong: J5,
  smoothstep: eB,
  smootherstep: tB,
  randInt: nB,
  randFloat: iB,
  randFloatSpread: rB,
  seededRandom: sB,
  degToRad: oB,
  radToDeg: aB,
  isPowerOfTwo: lB,
  ceilPowerOfTwo: cB,
  floorPowerOfTwo: uB,
  setQuaternionFromProperEuler: dB,
  normalize: vn,
  denormalize: Kr,
}
class qe {
  constructor(e = 0, t = 0) {
    ;(qe.prototype.isVector2 = !0), (this.x = e), (this.y = t)
  }
  get width() {
    return this.x
  }
  set width(e) {
    this.x = e
  }
  get height() {
    return this.y
  }
  set height(e) {
    this.y = e
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this
  }
  setX(e) {
    return (this.x = e), this
  }
  setY(e) {
    return (this.y = e), this
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t
        break
      case 1:
        this.y = t
        break
      default:
        throw new Error('index is out of range: ' + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      default:
        throw new Error('index is out of range: ' + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y)
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    )
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    )
  }
  clamp(e, t) {
    return (
      (this.x = un(this.x, e.x, t.x)), (this.y = un(this.y, e.y, t.y)), this
    )
  }
  clampScalar(e, t) {
    return (this.x = un(this.x, e, t)), (this.y = un(this.y, e, t)), this
  }
  clampLength(e, t) {
    const i = this.length()
    return this.divideScalar(i || 1).multiplyScalar(un(i, e, t))
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this
  }
  dot(e) {
    return this.x * e.x + this.y * e.y
  }
  cross(e) {
    return this.x * e.y - this.y * e.x
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq())
    if (t === 0) return Math.PI / 2
    const i = this.dot(e) / t
    return Math.acos(un(i, -1, 1))
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e))
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y
    return t * t + i * i
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    )
  }
  equals(e) {
    return e.x === this.x && e.y === this.y
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y
    return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y
  }
}
class pn {
  constructor(e, t, i, r, s, o, a, c, u) {
    ;(pn.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, c, u)
  }
  set(e, t, i, r, s, o, a, c, u) {
    const h = this.elements
    return (
      (h[0] = e),
      (h[1] = r),
      (h[2] = a),
      (h[3] = t),
      (h[4] = s),
      (h[5] = c),
      (h[6] = i),
      (h[7] = o),
      (h[8] = u),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
  }
  copy(e) {
    const t = this.elements,
      i = e.elements
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    )
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    )
  }
  setFromMatrix4(e) {
    const t = e.elements
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
  }
  multiply(e) {
    return this.multiplyMatrices(this, e)
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this)
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      c = i[6],
      u = i[1],
      h = i[4],
      m = i[7],
      g = i[2],
      y = i[5],
      _ = i[8],
      M = r[0],
      w = r[3],
      x = r[6],
      T = r[1],
      A = r[4],
      P = r[7],
      D = r[2],
      O = r[5],
      U = r[8]
    return (
      (s[0] = o * M + a * T + c * D),
      (s[3] = o * w + a * A + c * O),
      (s[6] = o * x + a * P + c * U),
      (s[1] = u * M + h * T + m * D),
      (s[4] = u * w + h * A + m * O),
      (s[7] = u * x + h * P + m * U),
      (s[2] = g * M + y * T + _ * D),
      (s[5] = g * w + y * A + _ * O),
      (s[8] = g * x + y * P + _ * U),
      this
    )
  }
  multiplyScalar(e) {
    const t = this.elements
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    )
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      c = e[6],
      u = e[7],
      h = e[8]
    return t * o * h - t * a * u - i * s * h + i * a * c + r * s * u - r * o * c
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      c = e[6],
      u = e[7],
      h = e[8],
      m = h * o - a * u,
      g = a * c - h * s,
      y = u * s - o * c,
      _ = t * m + i * g + r * y
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
    const M = 1 / _
    return (
      (e[0] = m * M),
      (e[1] = (r * u - h * i) * M),
      (e[2] = (a * i - r * o) * M),
      (e[3] = g * M),
      (e[4] = (h * t - r * c) * M),
      (e[5] = (r * s - a * t) * M),
      (e[6] = y * M),
      (e[7] = (i * c - u * t) * M),
      (e[8] = (o * t - i * s) * M),
      this
    )
  }
  transpose() {
    let e
    const t = this.elements
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    )
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose()
  }
  transposeIntoArray(e) {
    const t = this.elements
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    )
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const c = Math.cos(s),
      u = Math.sin(s)
    return (
      this.set(
        i * c,
        i * u,
        -i * (c * o + u * a) + o + e,
        -r * u,
        r * c,
        -r * (-u * o + c * a) + a + t,
        0,
        0,
        1,
      ),
      this
    )
  }
  scale(e, t) {
    return this.premultiply(M1.makeScale(e, t)), this
  }
  rotate(e) {
    return this.premultiply(M1.makeRotation(-e)), this
  }
  translate(e, t) {
    return this.premultiply(M1.makeTranslation(e, t)), this
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    )
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
  }
  equals(e) {
    const t = this.elements,
      i = e.elements
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1
    return !0
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t]
    return this
  }
  toArray(e = [], t = 0) {
    const i = this.elements
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    )
  }
  clone() {
    return new this.constructor().fromArray(this.elements)
  }
}
const M1 = new pn()
function CL(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0
  return !1
}
const hB = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
}
function qf(n, e) {
  return new hB[n](e)
}
function qm(n) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', n)
}
function PL() {
  const n = qm('canvas')
  return (n.style.display = 'block'), n
}
const RA = {}
function Gf(n) {
  n in RA || ((RA[n] = !0), console.warn(n))
}
function pB(n, e, t) {
  return new Promise(function (i, r) {
    function s() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          r()
          break
        case n.TIMEOUT_EXPIRED:
          setTimeout(s, t)
          break
        default:
          i()
      }
    }
    setTimeout(s, t)
  })
}
function mB(n) {
  const e = n.elements
  ;(e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15])
}
function gB(n) {
  const e = n.elements
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1))
}
const IA = new pn().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322,
  ),
  LA = new pn().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715,
  )
function vB() {
  const n = {
      enabled: !0,
      workingColorSpace: Aa,
      spaces: {},
      convert: function (r, s, o) {
        return (
          this.enabled === !1 ||
            s === o ||
            !s ||
            !o ||
            (this.spaces[s].transfer === zn &&
              ((r.r = wl(r.r)), (r.g = wl(r.g)), (r.b = wl(r.b))),
            this.spaces[s].primaries !== this.spaces[o].primaries &&
              (r.applyMatrix3(this.spaces[s].toXYZ),
              r.applyMatrix3(this.spaces[o].fromXYZ)),
            this.spaces[o].transfer === zn &&
              ((r.r = ch(r.r)), (r.g = ch(r.g)), (r.b = ch(r.b)))),
          r
        )
      },
      fromWorkingColorSpace: function (r, s) {
        return this.convert(r, this.workingColorSpace, s)
      },
      toWorkingColorSpace: function (r, s) {
        return this.convert(r, s, this.workingColorSpace)
      },
      getPrimaries: function (r) {
        return this.spaces[r].primaries
      },
      getTransfer: function (r) {
        return r === vl ? Wm : this.spaces[r].transfer
      },
      getLuminanceCoefficients: function (r, s = this.workingColorSpace) {
        return r.fromArray(this.spaces[s].luminanceCoefficients)
      },
      define: function (r) {
        Object.assign(this.spaces, r)
      },
      _getMatrix: function (r, s, o) {
        return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ)
      },
      _getDrawingBufferColorSpace: function (r) {
        return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace
      },
      _getUnpackColorSpace: function (r = this.workingColorSpace) {
        return this.spaces[r].workingColorSpaceConfig.unpackColorSpace
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    i = [0.3127, 0.329]
  return (
    n.define({
      [Aa]: {
        primaries: e,
        whitePoint: i,
        transfer: Wm,
        toXYZ: IA,
        fromXYZ: LA,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: Zr },
        outputColorSpaceConfig: { drawingBufferColorSpace: Zr },
      },
      [Zr]: {
        primaries: e,
        whitePoint: i,
        transfer: zn,
        toXYZ: IA,
        fromXYZ: LA,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: Zr },
      },
    }),
    n
  )
}
const Cn = vB()
function wl(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4)
}
function ch(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055
}
let Mf
class RL {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > 'u') return e.src
    let t
    if (e instanceof HTMLCanvasElement) t = e
    else {
      Mf === void 0 && (Mf = qm('canvas')),
        (Mf.width = e.width),
        (Mf.height = e.height)
      const i = Mf.getContext('2d')
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = Mf)
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
          e,
        ),
        t.toDataURL('image/jpeg', 0.6))
      : t.toDataURL('image/png')
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < 'u' && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < 'u' && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < 'u' && e instanceof ImageBitmap)
    ) {
      const t = qm('canvas')
      ;(t.width = e.width), (t.height = e.height)
      const i = t.getContext('2d')
      i.drawImage(e, 0, 0, e.width, e.height)
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data
      for (let o = 0; o < s.length; o++) s[o] = wl(s[o] / 255) * 255
      return i.putImageData(r, 0, 0), t
    } else if (e.data) {
      const t = e.data.slice(0)
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(wl(t[i] / 255) * 255))
          : (t[i] = wl(t[i]))
      return { data: t, width: e.width, height: e.height }
    } else
      return (
        console.warn(
          'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.',
        ),
        e
      )
  }
}
let yB = 0
class ed {
  constructor(e = null) {
    ;(this.isSource = !0),
      Object.defineProperty(this, 'id', { value: yB++ }),
      (this.uuid = Ds()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0)
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string'
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid]
    const i = { uuid: this.uuid, url: '' },
      r = this.data
    if (r !== null) {
      let s
      if (Array.isArray(r)) {
        s = []
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(E1(r[o].image)) : s.push(E1(r[o]))
      } else s = E1(r)
      i.url = s
    }
    return t || (e.images[this.uuid] = i), i
  }
}
function E1(n) {
  return (typeof HTMLImageElement < 'u' && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < 'u' && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < 'u' && n instanceof ImageBitmap)
    ? RL.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn('THREE.Texture: Unable to serialize Texture.'), {})
}
let xB = 0
class Xn extends Pa {
  constructor(
    e = Xn.DEFAULT_IMAGE,
    t = Xn.DEFAULT_MAPPING,
    i = Bi,
    r = Bi,
    s = Vn,
    o = ma,
    a = Ii,
    c = _s,
    u = Xn.DEFAULT_ANISOTROPY,
    h = vl,
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, 'id', { value: xB++ }),
      (this.uuid = Ds()),
      (this.name = ''),
      (this.source = new ed(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = u),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = c),
      (this.offset = new qe(0, 0)),
      (this.repeat = new qe(1, 1)),
      (this.center = new qe(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new pn()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = h),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0)
  }
  get image() {
    return this.source.data
  }
  set image(e = null) {
    this.source.data = e
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    )
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string'
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]
    const i = {
      metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    }
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  transformUv(e) {
    if (this.mapping !== Cc) return e
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Vm:
          e.x = e.x - Math.floor(e.x)
          break
        case Bi:
          e.x = e.x < 0 ? 0 : 1
          break
        case jm:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x))
          break
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Vm:
          e.y = e.y - Math.floor(e.y)
          break
        case Bi:
          e.y = e.y < 0 ? 0 : 1
          break
        case jm:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y))
          break
      }
    return this.flipY && (e.y = 1 - e.y), e
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0))
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++
  }
}
Xn.DEFAULT_IMAGE = null
Xn.DEFAULT_MAPPING = Cc
Xn.DEFAULT_ANISOTROPY = 1
class In {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ;(In.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r)
  }
  get width() {
    return this.z
  }
  set width(e) {
    this.z = e
  }
  get height() {
    return this.w
  }
  set height(e) {
    this.w = e
  }
  set(e, t, i, r) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this
  }
  setX(e) {
    return (this.x = e), this
  }
  setY(e) {
    return (this.y = e), this
  }
  setZ(e) {
    return (this.z = e), this
  }
  setW(e) {
    return (this.w = e), this
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t
        break
      case 1:
        this.y = t
        break
      case 2:
        this.z = t
        break
      case 3:
        this.w = t
        break
      default:
        throw new Error('index is out of range: ' + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      case 3:
        return this.w
      default:
        throw new Error('index is out of range: ' + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w)
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    )
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    )
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    )
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    )
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    )
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    )
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    )
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    )
  }
  divide(e) {
    return (
      (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this
    )
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w)
    const t = Math.sqrt(1 - e.w * e.w)
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    )
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s
    const c = e.elements,
      u = c[0],
      h = c[4],
      m = c[8],
      g = c[1],
      y = c[5],
      _ = c[9],
      M = c[2],
      w = c[6],
      x = c[10]
    if (
      Math.abs(h - g) < 0.01 &&
      Math.abs(m - M) < 0.01 &&
      Math.abs(_ - w) < 0.01
    ) {
      if (
        Math.abs(h + g) < 0.1 &&
        Math.abs(m + M) < 0.1 &&
        Math.abs(_ + w) < 0.1 &&
        Math.abs(u + y + x - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this
      t = Math.PI
      const A = (u + 1) / 2,
        P = (y + 1) / 2,
        D = (x + 1) / 2,
        O = (h + g) / 4,
        U = (m + M) / 4,
        F = (_ + w) / 4
      return (
        A > P && A > D
          ? A < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(A)), (r = O / i), (s = U / i))
          : P > D
          ? P < 0.01
            ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(P)), (i = O / r), (s = F / r))
          : D < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(D)), (i = U / s), (r = F / s)),
        this.set(i, r, s, t),
        this
      )
    }
    let T = Math.sqrt((w - _) * (w - _) + (m - M) * (m - M) + (g - h) * (g - h))
    return (
      Math.abs(T) < 0.001 && (T = 1),
      (this.x = (w - _) / T),
      (this.y = (m - M) / T),
      (this.z = (g - h) / T),
      (this.w = Math.acos((u + y + x - 1) / 2)),
      this
    )
  }
  setFromMatrixPosition(e) {
    const t = e.elements
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    )
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    )
  }
  clamp(e, t) {
    return (
      (this.x = un(this.x, e.x, t.x)),
      (this.y = un(this.y, e.y, t.y)),
      (this.z = un(this.z, e.z, t.z)),
      (this.w = un(this.w, e.w, t.w)),
      this
    )
  }
  clampScalar(e, t) {
    return (
      (this.x = un(this.x, e, t)),
      (this.y = un(this.y, e, t)),
      (this.z = un(this.z, e, t)),
      (this.w = un(this.w, e, t)),
      this
    )
  }
  clampLength(e, t) {
    const i = this.length()
    return this.divideScalar(i || 1).multiplyScalar(un(i, e, t))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    )
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    )
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
    )
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    )
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    )
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    )
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    )
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    )
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w
  }
}
class Zx extends Pa {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new In(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new In(0, 0, e, t))
    const r = { width: e, height: t, depth: 1 }
    i = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Vn,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      i,
    )
    const s = new Xn(
      r,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.colorSpace,
    )
    ;(s.flipY = !1),
      (s.generateMipmaps = i.generateMipmaps),
      (s.internalFormat = i.internalFormat),
      (this.textures = [])
    const o = i.count
    for (let a = 0; a < o; a++)
      (this.textures[a] = s.clone()),
        (this.textures[a].isRenderTargetTexture = !0),
        (this.textures[a].renderTarget = this)
    ;(this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.resolveDepthBuffer = i.resolveDepthBuffer),
      (this.resolveStencilBuffer = i.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples)
  }
  get texture() {
    return this.textures[0]
  }
  set texture(e) {
    this.textures[0] = e
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e)
  }
  get depthTexture() {
    return this._depthTexture
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      ;(this.width = e), (this.height = t), (this.depth = i)
      for (let r = 0, s = this.textures.length; r < s; r++)
        (this.textures[r].image.width = e),
          (this.textures[r].image.height = t),
          (this.textures[r].image.depth = i)
      this.dispose()
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;(this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0)
    for (let i = 0, r = e.textures.length; i < r; i++)
      (this.textures[i] = e.textures[i].clone()),
        (this.textures[i].isRenderTargetTexture = !0),
        (this.textures[i].renderTarget = this)
    const t = Object.assign({}, e.texture.image)
    return (
      (this.texture.source = new ed(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
class uo extends Zx {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), (this.isWebGLRenderTarget = !0)
  }
}
class Pg extends Xn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = yr),
      (this.minFilter = yr),
      (this.wrapR = Bi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set())
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e)
  }
  clearLayerUpdates() {
    this.layerUpdates.clear()
  }
}
class _B extends uo {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = i),
      (this.texture = new Pg(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0)
  }
}
class Kx extends Xn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = yr),
      (this.minFilter = yr),
      (this.wrapR = Bi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
class wB extends uo {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = i),
      (this.texture = new Kx(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0)
  }
}
class xs {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ;(this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r)
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let c = i[r + 0],
      u = i[r + 1],
      h = i[r + 2],
      m = i[r + 3]
    const g = s[o + 0],
      y = s[o + 1],
      _ = s[o + 2],
      M = s[o + 3]
    if (a === 0) {
      ;(e[t + 0] = c), (e[t + 1] = u), (e[t + 2] = h), (e[t + 3] = m)
      return
    }
    if (a === 1) {
      ;(e[t + 0] = g), (e[t + 1] = y), (e[t + 2] = _), (e[t + 3] = M)
      return
    }
    if (m !== M || c !== g || u !== y || h !== _) {
      let w = 1 - a
      const x = c * g + u * y + h * _ + m * M,
        T = x >= 0 ? 1 : -1,
        A = 1 - x * x
      if (A > Number.EPSILON) {
        const D = Math.sqrt(A),
          O = Math.atan2(D, x * T)
        ;(w = Math.sin(w * O) / D), (a = Math.sin(a * O) / D)
      }
      const P = a * T
      if (
        ((c = c * w + g * P),
        (u = u * w + y * P),
        (h = h * w + _ * P),
        (m = m * w + M * P),
        w === 1 - a)
      ) {
        const D = 1 / Math.sqrt(c * c + u * u + h * h + m * m)
        ;(c *= D), (u *= D), (h *= D), (m *= D)
      }
    }
    ;(e[t] = c), (e[t + 1] = u), (e[t + 2] = h), (e[t + 3] = m)
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      c = i[r + 1],
      u = i[r + 2],
      h = i[r + 3],
      m = s[o],
      g = s[o + 1],
      y = s[o + 2],
      _ = s[o + 3]
    return (
      (e[t] = a * _ + h * m + c * y - u * g),
      (e[t + 1] = c * _ + h * g + u * m - a * y),
      (e[t + 2] = u * _ + h * y + a * g - c * m),
      (e[t + 3] = h * _ - a * m - c * g - u * y),
      e
    )
  }
  get x() {
    return this._x
  }
  set x(e) {
    ;(this._x = e), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(e) {
    ;(this._y = e), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(e) {
    ;(this._z = e), this._onChangeCallback()
  }
  get w() {
    return this._w
  }
  set w(e) {
    ;(this._w = e), this._onChangeCallback()
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w)
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    )
  }
  setFromEuler(e, t = !0) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      c = Math.sin,
      u = a(i / 2),
      h = a(r / 2),
      m = a(s / 2),
      g = c(i / 2),
      y = c(r / 2),
      _ = c(s / 2)
    switch (o) {
      case 'XYZ':
        ;(this._x = g * h * m + u * y * _),
          (this._y = u * y * m - g * h * _),
          (this._z = u * h * _ + g * y * m),
          (this._w = u * h * m - g * y * _)
        break
      case 'YXZ':
        ;(this._x = g * h * m + u * y * _),
          (this._y = u * y * m - g * h * _),
          (this._z = u * h * _ - g * y * m),
          (this._w = u * h * m + g * y * _)
        break
      case 'ZXY':
        ;(this._x = g * h * m - u * y * _),
          (this._y = u * y * m + g * h * _),
          (this._z = u * h * _ + g * y * m),
          (this._w = u * h * m - g * y * _)
        break
      case 'ZYX':
        ;(this._x = g * h * m - u * y * _),
          (this._y = u * y * m + g * h * _),
          (this._z = u * h * _ - g * y * m),
          (this._w = u * h * m + g * y * _)
        break
      case 'YZX':
        ;(this._x = g * h * m + u * y * _),
          (this._y = u * y * m + g * h * _),
          (this._z = u * h * _ - g * y * m),
          (this._w = u * h * m - g * y * _)
        break
      case 'XZY':
        ;(this._x = g * h * m - u * y * _),
          (this._y = u * y * m - g * h * _),
          (this._z = u * h * _ + g * y * m),
          (this._w = u * h * m + g * y * _)
        break
      default:
        console.warn(
          'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
            o,
        )
    }
    return t === !0 && this._onChangeCallback(), this
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i)
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      c = t[9],
      u = t[2],
      h = t[6],
      m = t[10],
      g = i + a + m
    if (g > 0) {
      const y = 0.5 / Math.sqrt(g + 1)
      ;(this._w = 0.25 / y),
        (this._x = (h - c) * y),
        (this._y = (s - u) * y),
        (this._z = (o - r) * y)
    } else if (i > a && i > m) {
      const y = 2 * Math.sqrt(1 + i - a - m)
      ;(this._w = (h - c) / y),
        (this._x = 0.25 * y),
        (this._y = (r + o) / y),
        (this._z = (s + u) / y)
    } else if (a > m) {
      const y = 2 * Math.sqrt(1 + a - i - m)
      ;(this._w = (s - u) / y),
        (this._x = (r + o) / y),
        (this._y = 0.25 * y),
        (this._z = (c + h) / y)
    } else {
      const y = 2 * Math.sqrt(1 + m - i - a)
      ;(this._w = (o - r) / y),
        (this._x = (s + u) / y),
        (this._y = (c + h) / y),
        (this._z = 0.25 * y)
    }
    return this._onChangeCallback(), this
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    )
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(un(this.dot(e), -1, 1)))
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e)
    if (i === 0) return this
    const r = Math.min(1, t / i)
    return this.slerp(e, r), this
  }
  identity() {
    return this.set(0, 0, 0, 1)
  }
  invert() {
    return this.conjugate()
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    )
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    )
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w,
    )
  }
  normalize() {
    let e = this.length()
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    )
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e)
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this)
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      c = t._y,
      u = t._z,
      h = t._w
    return (
      (this._x = i * h + o * a + r * u - s * c),
      (this._y = r * h + o * c + s * a - i * u),
      (this._z = s * h + o * u + i * c - r * a),
      (this._w = o * h - i * a - r * c - s * u),
      this._onChangeCallback(),
      this
    )
  }
  slerp(e, t) {
    if (t === 0) return this
    if (t === 1) return this.copy(e)
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w
    let a = o * e._w + i * e._x + r * e._y + s * e._z
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this
    const c = 1 - a * a
    if (c <= Number.EPSILON) {
      const y = 1 - t
      return (
        (this._w = y * o + t * this._w),
        (this._x = y * i + t * this._x),
        (this._y = y * r + t * this._y),
        (this._z = y * s + t * this._z),
        this.normalize(),
        this
      )
    }
    const u = Math.sqrt(c),
      h = Math.atan2(u, a),
      m = Math.sin((1 - t) * h) / u,
      g = Math.sin(t * h) / u
    return (
      (this._w = o * m + this._w * g),
      (this._x = i * m + this._x * g),
      (this._y = r * m + this._y * g),
      (this._z = s * m + this._z * g),
      this._onChangeCallback(),
      this
    )
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i)
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      i = Math.random(),
      r = Math.sqrt(1 - i),
      s = Math.sqrt(i)
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t),
    )
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    )
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    )
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    )
  }
  toJSON() {
    return this.toArray()
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w
  }
}
class re {
  constructor(e = 0, t = 0, i = 0) {
    ;(re.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i)
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    )
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this
  }
  setX(e) {
    return (this.x = e), this
  }
  setY(e) {
    return (this.y = e), this
  }
  setZ(e) {
    return (this.z = e), this
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t
        break
      case 1:
        this.y = t
        break
      case 2:
        this.z = t
        break
      default:
        throw new Error('index is out of range: ' + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      default:
        throw new Error('index is out of range: ' + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z)
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    )
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    )
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    )
  }
  applyEuler(e) {
    return this.applyQuaternion(NA.setFromEuler(e))
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(NA.setFromAxisAngle(e, t))
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    )
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize()
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15])
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    )
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      c = e.w,
      u = 2 * (o * r - a * i),
      h = 2 * (a * t - s * r),
      m = 2 * (s * i - o * t)
    return (
      (this.x = t + c * u + o * m - a * h),
      (this.y = i + c * h + a * u - s * m),
      (this.z = r + c * m + s * h - o * u),
      this
    )
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix,
    )
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld,
    )
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    )
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    )
  }
  clamp(e, t) {
    return (
      (this.x = un(this.x, e.x, t.x)),
      (this.y = un(this.y, e.y, t.y)),
      (this.z = un(this.z, e.z, t.z)),
      this
    )
  }
  clampScalar(e, t) {
    return (
      (this.x = un(this.x, e, t)),
      (this.y = un(this.y, e, t)),
      (this.z = un(this.z, e, t)),
      this
    )
  }
  clampLength(e, t) {
    const i = this.length()
    return this.divideScalar(i || 1).multiplyScalar(un(i, e, t))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    )
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    )
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    )
  }
  cross(e) {
    return this.crossVectors(this, e)
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      c = t.z
    return (
      (this.x = r * c - s * a),
      (this.y = s * o - i * c),
      (this.z = i * a - r * o),
      this
    )
  }
  projectOnVector(e) {
    const t = e.lengthSq()
    if (t === 0) return this.set(0, 0, 0)
    const i = e.dot(this) / t
    return this.copy(e).multiplyScalar(i)
  }
  projectOnPlane(e) {
    return b1.copy(this).projectOnVector(e), this.sub(b1)
  }
  reflect(e) {
    return this.sub(b1.copy(e).multiplyScalar(2 * this.dot(e)))
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq())
    if (t === 0) return Math.PI / 2
    const i = this.dot(e) / t
    return Math.acos(un(i, -1, 1))
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e))
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z
    return t * t + i * i + r * r
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    )
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    )
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    )
  }
  setFromMatrixPosition(e) {
    const t = e.elements
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length()
    return (this.x = t), (this.y = i), (this.z = r), this
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4)
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3)
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    )
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      i = Math.sqrt(1 - t * t)
    return (
      (this.x = i * Math.cos(e)), (this.y = t), (this.z = i * Math.sin(e)), this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z
  }
}
const b1 = new re(),
  NA = new xs()
class Jr {
  constructor(
    e = new re(1 / 0, 1 / 0, 1 / 0),
    t = new re(-1 / 0, -1 / 0, -1 / 0),
  ) {
    ;(this.isBox3 = !0), (this.min = e), (this.max = t)
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this
  }
  setFromArray(e) {
    this.makeEmpty()
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Oo.fromArray(e, t))
    return this
  }
  setFromBufferAttribute(e) {
    this.makeEmpty()
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Oo.fromBufferAttribute(e, t))
    return this
  }
  setFromPoints(e) {
    this.makeEmpty()
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t])
    return this
  }
  setFromCenterAndSize(e, t) {
    const i = Oo.copy(t).multiplyScalar(0.5)
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    )
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    )
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1)
    const i = e.geometry
    if (i !== void 0) {
      const s = i.getAttribute('position')
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, Oo)
            : Oo.fromBufferAttribute(s, o),
            Oo.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Oo)
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            Qv.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(),
            Qv.copy(i.boundingBox)),
          Qv.applyMatrix4(e.matrixWorld),
          this.union(Qv)
    }
    const r = e.children
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t)
    return this
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    )
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    )
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z),
    )
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    )
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Oo),
      Oo.distanceToSquared(e.center) <= e.radius * e.radius
    )
  }
  intersectsPlane(e) {
    let t, i
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    )
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1
    this.getCenter(Dp),
      Jv.subVectors(this.max, Dp),
      Ef.subVectors(e.a, Dp),
      bf.subVectors(e.b, Dp),
      Tf.subVectors(e.c, Dp),
      lc.subVectors(bf, Ef),
      cc.subVectors(Tf, bf),
      Au.subVectors(Ef, Tf)
    let t = [
      0,
      -lc.z,
      lc.y,
      0,
      -cc.z,
      cc.y,
      0,
      -Au.z,
      Au.y,
      lc.z,
      0,
      -lc.x,
      cc.z,
      0,
      -cc.x,
      Au.z,
      0,
      -Au.x,
      -lc.y,
      lc.x,
      0,
      -cc.y,
      cc.x,
      0,
      -Au.y,
      Au.x,
      0,
    ]
    return !T1(t, Ef, bf, Tf, Jv) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !T1(t, Ef, bf, Tf, Jv))
      ? !1
      : (e0.crossVectors(lc, cc),
        (t = [e0.x, e0.y, e0.z]),
        T1(t, Ef, bf, Tf, Jv))
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max)
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Oo).distanceTo(e)
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Oo).length() * 0.5)),
      e
    )
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    )
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (ul[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        ul[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        ul[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        ul[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        ul[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        ul[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        ul[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        ul[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(ul),
        this)
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max)
  }
}
const ul = [
    new re(),
    new re(),
    new re(),
    new re(),
    new re(),
    new re(),
    new re(),
    new re(),
  ],
  Oo = new re(),
  Qv = new Jr(),
  Ef = new re(),
  bf = new re(),
  Tf = new re(),
  lc = new re(),
  cc = new re(),
  Au = new re(),
  Dp = new re(),
  Jv = new re(),
  e0 = new re(),
  Cu = new re()
function T1(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    Cu.fromArray(n, s)
    const a =
        r.x * Math.abs(Cu.x) + r.y * Math.abs(Cu.y) + r.z * Math.abs(Cu.z),
      c = e.dot(Cu),
      u = t.dot(Cu),
      h = i.dot(Cu)
    if (Math.max(-Math.max(c, u, h), Math.min(c, u, h)) > a) return !1
  }
  return !0
}
const SB = new Jr(),
  Op = new re(),
  A1 = new re()
let Dr = class {
  constructor(e = new re(), t = -1) {
    ;(this.isSphere = !0), (this.center = e), (this.radius = t)
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this
  }
  setFromPoints(e, t) {
    const i = this.center
    t !== void 0 ? i.copy(t) : SB.setFromPoints(e).getCenter(i)
    let r = 0
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]))
    return (this.radius = Math.sqrt(r)), this
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this
  }
  isEmpty() {
    return this.radius < 0
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius
    return e.center.distanceToSquared(this.center) <= t * t
  }
  intersectsBox(e) {
    return e.intersectsSphere(this)
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e)
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    )
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    )
  }
  translate(e) {
    return this.center.add(e), this
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this
    Op.subVectors(e, this.center)
    const t = Op.lengthSq()
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5
      this.center.addScaledVector(Op, r / i), (this.radius += r)
    }
    return this
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (A1.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Op.copy(e.center).add(A1)),
            this.expandByPoint(Op.copy(e.center).sub(A1))),
        this)
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const dl = new re(),
  C1 = new re(),
  t0 = new re(),
  uc = new re(),
  P1 = new re(),
  n0 = new re(),
  R1 = new re()
class Ih {
  constructor(e = new re(), t = new re(0, 0, -1)) {
    ;(this.origin = e), (this.direction = t)
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e)
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this
  }
  recast(e) {
    return this.origin.copy(this.at(e, dl)), this
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin)
    const i = t.dot(this.direction)
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i)
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e))
  }
  distanceSqToPoint(e) {
    const t = dl.subVectors(e, this.origin).dot(this.direction)
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (dl.copy(this.origin).addScaledVector(this.direction, t),
        dl.distanceToSquared(e))
  }
  distanceSqToSegment(e, t, i, r) {
    C1.copy(e).add(t).multiplyScalar(0.5),
      t0.copy(t).sub(e).normalize(),
      uc.copy(this.origin).sub(C1)
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(t0),
      a = uc.dot(this.direction),
      c = -uc.dot(t0),
      u = uc.lengthSq(),
      h = Math.abs(1 - o * o)
    let m, g, y, _
    if (h > 0)
      if (((m = o * c - a), (g = o * a - c), (_ = s * h), m >= 0))
        if (g >= -_)
          if (g <= _) {
            const M = 1 / h
            ;(m *= M),
              (g *= M),
              (y = m * (m + o * g + 2 * a) + g * (o * m + g + 2 * c) + u)
          } else
            (g = s),
              (m = Math.max(0, -(o * g + a))),
              (y = -m * m + g * (g + 2 * c) + u)
        else
          (g = -s),
            (m = Math.max(0, -(o * g + a))),
            (y = -m * m + g * (g + 2 * c) + u)
      else
        g <= -_
          ? ((m = Math.max(0, -(-o * s + a))),
            (g = m > 0 ? -s : Math.min(Math.max(-s, -c), s)),
            (y = -m * m + g * (g + 2 * c) + u))
          : g <= _
          ? ((m = 0),
            (g = Math.min(Math.max(-s, -c), s)),
            (y = g * (g + 2 * c) + u))
          : ((m = Math.max(0, -(o * s + a))),
            (g = m > 0 ? s : Math.min(Math.max(-s, -c), s)),
            (y = -m * m + g * (g + 2 * c) + u))
    else
      (g = o > 0 ? -s : s),
        (m = Math.max(0, -(o * g + a))),
        (y = -m * m + g * (g + 2 * c) + u)
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, m),
      r && r.copy(C1).addScaledVector(t0, g),
      y
    )
  }
  intersectSphere(e, t) {
    dl.subVectors(e.center, this.origin)
    const i = dl.dot(this.direction),
      r = dl.dot(dl) - i * i,
      s = e.radius * e.radius
    if (r > s) return null
    const o = Math.sqrt(s - r),
      a = i - o,
      c = i + o
    return c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t)
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction)
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null
    const i = -(this.origin.dot(e.normal) + e.constant) / t
    return i >= 0 ? i : null
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e)
    return i === null ? null : this.at(i, t)
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin)
    return t === 0 || e.normal.dot(this.direction) * t < 0
  }
  intersectBox(e, t) {
    let i, r, s, o, a, c
    const u = 1 / this.direction.x,
      h = 1 / this.direction.y,
      m = 1 / this.direction.z,
      g = this.origin
    return (
      u >= 0
        ? ((i = (e.min.x - g.x) * u), (r = (e.max.x - g.x) * u))
        : ((i = (e.max.x - g.x) * u), (r = (e.min.x - g.x) * u)),
      h >= 0
        ? ((s = (e.min.y - g.y) * h), (o = (e.max.y - g.y) * h))
        : ((s = (e.max.y - g.y) * h), (o = (e.min.y - g.y) * h)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      m >= 0
        ? ((a = (e.min.z - g.z) * m), (c = (e.max.z - g.z) * m))
        : ((a = (e.max.z - g.z) * m), (c = (e.min.z - g.z) * m)),
      i > c || a > r) ||
      ((a > i || i !== i) && (i = a), (c < r || r !== r) && (r = c), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    )
  }
  intersectsBox(e) {
    return this.intersectBox(e, dl) !== null
  }
  intersectTriangle(e, t, i, r, s) {
    P1.subVectors(t, e), n0.subVectors(i, e), R1.crossVectors(P1, n0)
    let o = this.direction.dot(R1),
      a
    if (o > 0) {
      if (r) return null
      a = 1
    } else if (o < 0) (a = -1), (o = -o)
    else return null
    uc.subVectors(this.origin, e)
    const c = a * this.direction.dot(n0.crossVectors(uc, n0))
    if (c < 0) return null
    const u = a * this.direction.dot(P1.cross(uc))
    if (u < 0 || c + u > o) return null
    const h = -a * uc.dot(R1)
    return h < 0 ? null : this.at(h / o, s)
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    )
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class Jt {
  constructor(e, t, i, r, s, o, a, c, u, h, m, g, y, _, M, w) {
    ;(Jt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, c, u, h, m, g, y, _, M, w)
  }
  set(e, t, i, r, s, o, a, c, u, h, m, g, y, _, M, w) {
    const x = this.elements
    return (
      (x[0] = e),
      (x[4] = t),
      (x[8] = i),
      (x[12] = r),
      (x[1] = s),
      (x[5] = o),
      (x[9] = a),
      (x[13] = c),
      (x[2] = u),
      (x[6] = h),
      (x[10] = m),
      (x[14] = g),
      (x[3] = y),
      (x[7] = _),
      (x[11] = M),
      (x[15] = w),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  clone() {
    return new Jt().fromArray(this.elements)
  }
  copy(e) {
    const t = this.elements,
      i = e.elements
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    )
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this
  }
  setFromMatrix3(e) {
    const t = e.elements
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1,
      ),
      this
    )
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    )
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    )
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / Af.setFromMatrixColumn(e, 0).length(),
      s = 1 / Af.setFromMatrixColumn(e, 1).length(),
      o = 1 / Af.setFromMatrixColumn(e, 2).length()
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    )
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      c = Math.cos(r),
      u = Math.sin(r),
      h = Math.cos(s),
      m = Math.sin(s)
    if (e.order === 'XYZ') {
      const g = o * h,
        y = o * m,
        _ = a * h,
        M = a * m
      ;(t[0] = c * h),
        (t[4] = -c * m),
        (t[8] = u),
        (t[1] = y + _ * u),
        (t[5] = g - M * u),
        (t[9] = -a * c),
        (t[2] = M - g * u),
        (t[6] = _ + y * u),
        (t[10] = o * c)
    } else if (e.order === 'YXZ') {
      const g = c * h,
        y = c * m,
        _ = u * h,
        M = u * m
      ;(t[0] = g + M * a),
        (t[4] = _ * a - y),
        (t[8] = o * u),
        (t[1] = o * m),
        (t[5] = o * h),
        (t[9] = -a),
        (t[2] = y * a - _),
        (t[6] = M + g * a),
        (t[10] = o * c)
    } else if (e.order === 'ZXY') {
      const g = c * h,
        y = c * m,
        _ = u * h,
        M = u * m
      ;(t[0] = g - M * a),
        (t[4] = -o * m),
        (t[8] = _ + y * a),
        (t[1] = y + _ * a),
        (t[5] = o * h),
        (t[9] = M - g * a),
        (t[2] = -o * u),
        (t[6] = a),
        (t[10] = o * c)
    } else if (e.order === 'ZYX') {
      const g = o * h,
        y = o * m,
        _ = a * h,
        M = a * m
      ;(t[0] = c * h),
        (t[4] = _ * u - y),
        (t[8] = g * u + M),
        (t[1] = c * m),
        (t[5] = M * u + g),
        (t[9] = y * u - _),
        (t[2] = -u),
        (t[6] = a * c),
        (t[10] = o * c)
    } else if (e.order === 'YZX') {
      const g = o * c,
        y = o * u,
        _ = a * c,
        M = a * u
      ;(t[0] = c * h),
        (t[4] = M - g * m),
        (t[8] = _ * m + y),
        (t[1] = m),
        (t[5] = o * h),
        (t[9] = -a * h),
        (t[2] = -u * h),
        (t[6] = y * m + _),
        (t[10] = g - M * m)
    } else if (e.order === 'XZY') {
      const g = o * c,
        y = o * u,
        _ = a * c,
        M = a * u
      ;(t[0] = c * h),
        (t[4] = -m),
        (t[8] = u * h),
        (t[1] = g * m + M),
        (t[5] = o * h),
        (t[9] = y * m - _),
        (t[2] = _ * m - y),
        (t[6] = a * h),
        (t[10] = M * m + g)
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    )
  }
  makeRotationFromQuaternion(e) {
    return this.compose(MB, e, EB)
  }
  lookAt(e, t, i) {
    const r = this.elements
    return (
      Ls.subVectors(e, t),
      Ls.lengthSq() === 0 && (Ls.z = 1),
      Ls.normalize(),
      dc.crossVectors(i, Ls),
      dc.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (Ls.x += 1e-4) : (Ls.z += 1e-4),
        Ls.normalize(),
        dc.crossVectors(i, Ls)),
      dc.normalize(),
      i0.crossVectors(Ls, dc),
      (r[0] = dc.x),
      (r[4] = i0.x),
      (r[8] = Ls.x),
      (r[1] = dc.y),
      (r[5] = i0.y),
      (r[9] = Ls.y),
      (r[2] = dc.z),
      (r[6] = i0.z),
      (r[10] = Ls.z),
      this
    )
  }
  multiply(e) {
    return this.multiplyMatrices(this, e)
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this)
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      c = i[8],
      u = i[12],
      h = i[1],
      m = i[5],
      g = i[9],
      y = i[13],
      _ = i[2],
      M = i[6],
      w = i[10],
      x = i[14],
      T = i[3],
      A = i[7],
      P = i[11],
      D = i[15],
      O = r[0],
      U = r[4],
      F = r[8],
      N = r[12],
      k = r[1],
      z = r[5],
      $ = r[9],
      te = r[13],
      j = r[2],
      K = r[6],
      J = r[10],
      ne = r[14],
      V = r[3],
      Y = r[7],
      Q = r[11],
      q = r[15]
    return (
      (s[0] = o * O + a * k + c * j + u * V),
      (s[4] = o * U + a * z + c * K + u * Y),
      (s[8] = o * F + a * $ + c * J + u * Q),
      (s[12] = o * N + a * te + c * ne + u * q),
      (s[1] = h * O + m * k + g * j + y * V),
      (s[5] = h * U + m * z + g * K + y * Y),
      (s[9] = h * F + m * $ + g * J + y * Q),
      (s[13] = h * N + m * te + g * ne + y * q),
      (s[2] = _ * O + M * k + w * j + x * V),
      (s[6] = _ * U + M * z + w * K + x * Y),
      (s[10] = _ * F + M * $ + w * J + x * Q),
      (s[14] = _ * N + M * te + w * ne + x * q),
      (s[3] = T * O + A * k + P * j + D * V),
      (s[7] = T * U + A * z + P * K + D * Y),
      (s[11] = T * F + A * $ + P * J + D * Q),
      (s[15] = T * N + A * te + P * ne + D * q),
      this
    )
  }
  multiplyScalar(e) {
    const t = this.elements
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    )
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      c = e[9],
      u = e[13],
      h = e[2],
      m = e[6],
      g = e[10],
      y = e[14],
      _ = e[3],
      M = e[7],
      w = e[11],
      x = e[15]
    return (
      _ *
        (+s * c * m -
          r * u * m -
          s * a * g +
          i * u * g +
          r * a * y -
          i * c * y) +
      M *
        (+t * c * y -
          t * u * g +
          s * o * g -
          r * o * y +
          r * u * h -
          s * c * h) +
      w *
        (+t * u * m -
          t * a * y -
          s * o * m +
          i * o * y +
          s * a * h -
          i * u * h) +
      x *
        (-r * a * h - t * c * m + t * a * g + r * o * m - i * o * g + i * c * h)
    )
  }
  transpose() {
    const e = this.elements
    let t
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    )
  }
  setPosition(e, t, i) {
    const r = this.elements
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    )
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      c = e[6],
      u = e[7],
      h = e[8],
      m = e[9],
      g = e[10],
      y = e[11],
      _ = e[12],
      M = e[13],
      w = e[14],
      x = e[15],
      T = m * w * u - M * g * u + M * c * y - a * w * y - m * c * x + a * g * x,
      A = _ * g * u - h * w * u - _ * c * y + o * w * y + h * c * x - o * g * x,
      P = h * M * u - _ * m * u + _ * a * y - o * M * y - h * a * x + o * m * x,
      D = _ * m * c - h * M * c - _ * a * g + o * M * g + h * a * w - o * m * w,
      O = t * T + i * A + r * P + s * D
    if (O === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    const U = 1 / O
    return (
      (e[0] = T * U),
      (e[1] =
        (M * g * s -
          m * w * s -
          M * r * y +
          i * w * y +
          m * r * x -
          i * g * x) *
        U),
      (e[2] =
        (a * w * s -
          M * c * s +
          M * r * u -
          i * w * u -
          a * r * x +
          i * c * x) *
        U),
      (e[3] =
        (m * c * s -
          a * g * s -
          m * r * u +
          i * g * u +
          a * r * y -
          i * c * y) *
        U),
      (e[4] = A * U),
      (e[5] =
        (h * w * s -
          _ * g * s +
          _ * r * y -
          t * w * y -
          h * r * x +
          t * g * x) *
        U),
      (e[6] =
        (_ * c * s -
          o * w * s -
          _ * r * u +
          t * w * u +
          o * r * x -
          t * c * x) *
        U),
      (e[7] =
        (o * g * s -
          h * c * s +
          h * r * u -
          t * g * u -
          o * r * y +
          t * c * y) *
        U),
      (e[8] = P * U),
      (e[9] =
        (_ * m * s -
          h * M * s -
          _ * i * y +
          t * M * y +
          h * i * x -
          t * m * x) *
        U),
      (e[10] =
        (o * M * s -
          _ * a * s +
          _ * i * u -
          t * M * u -
          o * i * x +
          t * a * x) *
        U),
      (e[11] =
        (h * a * s -
          o * m * s -
          h * i * u +
          t * m * u +
          o * i * y -
          t * a * y) *
        U),
      (e[12] = D * U),
      (e[13] =
        (h * M * r -
          _ * m * r +
          _ * i * g -
          t * M * g -
          h * i * w +
          t * m * w) *
        U),
      (e[14] =
        (_ * a * r -
          o * M * r -
          _ * i * c +
          t * M * c +
          o * i * w -
          t * a * w) *
        U),
      (e[15] =
        (o * m * r -
          h * a * r +
          h * i * c -
          t * m * c -
          o * i * g +
          t * a * g) *
        U),
      this
    )
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    )
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]
    return Math.sqrt(Math.max(t, i, r))
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    )
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      c = e.z,
      u = s * o,
      h = s * a
    return (
      this.set(
        u * o + i,
        u * a - r * c,
        u * c + r * a,
        0,
        u * a + r * c,
        h * a + i,
        h * c - r * o,
        0,
        u * c - r * a,
        h * c + r * o,
        s * c * c + i,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    )
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      c = t._w,
      u = s + s,
      h = o + o,
      m = a + a,
      g = s * u,
      y = s * h,
      _ = s * m,
      M = o * h,
      w = o * m,
      x = a * m,
      T = c * u,
      A = c * h,
      P = c * m,
      D = i.x,
      O = i.y,
      U = i.z
    return (
      (r[0] = (1 - (M + x)) * D),
      (r[1] = (y + P) * D),
      (r[2] = (_ - A) * D),
      (r[3] = 0),
      (r[4] = (y - P) * O),
      (r[5] = (1 - (g + x)) * O),
      (r[6] = (w + T) * O),
      (r[7] = 0),
      (r[8] = (_ + A) * U),
      (r[9] = (w - T) * U),
      (r[10] = (1 - (g + M)) * U),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    )
  }
  decompose(e, t, i) {
    const r = this.elements
    let s = Af.set(r[0], r[1], r[2]).length()
    const o = Af.set(r[4], r[5], r[6]).length(),
      a = Af.set(r[8], r[9], r[10]).length()
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      ko.copy(this)
    const u = 1 / s,
      h = 1 / o,
      m = 1 / a
    return (
      (ko.elements[0] *= u),
      (ko.elements[1] *= u),
      (ko.elements[2] *= u),
      (ko.elements[4] *= h),
      (ko.elements[5] *= h),
      (ko.elements[6] *= h),
      (ko.elements[8] *= m),
      (ko.elements[9] *= m),
      (ko.elements[10] *= m),
      t.setFromRotationMatrix(ko),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    )
  }
  makePerspective(e, t, i, r, s, o, a = Go) {
    const c = this.elements,
      u = (2 * s) / (t - e),
      h = (2 * s) / (i - r),
      m = (t + e) / (t - e),
      g = (i + r) / (i - r)
    let y, _
    if (a === Go) (y = -(o + s) / (o - s)), (_ = (-2 * o * s) / (o - s))
    else if (a === Xm) (y = -o / (o - s)), (_ = (-o * s) / (o - s))
    else
      throw new Error(
        'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + a,
      )
    return (
      (c[0] = u),
      (c[4] = 0),
      (c[8] = m),
      (c[12] = 0),
      (c[1] = 0),
      (c[5] = h),
      (c[9] = g),
      (c[13] = 0),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = y),
      (c[14] = _),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = -1),
      (c[15] = 0),
      this
    )
  }
  makeOrthographic(e, t, i, r, s, o, a = Go) {
    const c = this.elements,
      u = 1 / (t - e),
      h = 1 / (i - r),
      m = 1 / (o - s),
      g = (t + e) * u,
      y = (i + r) * h
    let _, M
    if (a === Go) (_ = (o + s) * m), (M = -2 * m)
    else if (a === Xm) (_ = s * m), (M = -1 * m)
    else
      throw new Error(
        'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + a,
      )
    return (
      (c[0] = 2 * u),
      (c[4] = 0),
      (c[8] = 0),
      (c[12] = -g),
      (c[1] = 0),
      (c[5] = 2 * h),
      (c[9] = 0),
      (c[13] = -y),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = M),
      (c[14] = -_),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = 0),
      (c[15] = 1),
      this
    )
  }
  equals(e) {
    const t = this.elements,
      i = e.elements
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1
    return !0
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t]
    return this
  }
  toArray(e = [], t = 0) {
    const i = this.elements
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    )
  }
}
const Af = new re(),
  ko = new Jt(),
  MB = new re(0, 0, 0),
  EB = new re(1, 1, 1),
  dc = new re(),
  i0 = new re(),
  Ls = new re(),
  DA = new Jt(),
  OA = new xs()
class Us {
  constructor(e = 0, t = 0, i = 0, r = Us.DEFAULT_ORDER) {
    ;(this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r)
  }
  get x() {
    return this._x
  }
  set x(e) {
    ;(this._x = e), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(e) {
    ;(this._y = e), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(e) {
    ;(this._z = e), this._onChangeCallback()
  }
  get order() {
    return this._order
  }
  set order(e) {
    ;(this._order = e), this._onChangeCallback()
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order)
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      c = r[1],
      u = r[5],
      h = r[9],
      m = r[2],
      g = r[6],
      y = r[10]
    switch (t) {
      case 'XYZ':
        ;(this._y = Math.asin(un(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, y)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(g, u)), (this._z = 0))
        break
      case 'YXZ':
        ;(this._x = Math.asin(-un(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, y)), (this._z = Math.atan2(c, u)))
            : ((this._y = Math.atan2(-m, s)), (this._z = 0))
        break
      case 'ZXY':
        ;(this._x = Math.asin(un(g, -1, 1))),
          Math.abs(g) < 0.9999999
            ? ((this._y = Math.atan2(-m, y)), (this._z = Math.atan2(-o, u)))
            : ((this._y = 0), (this._z = Math.atan2(c, s)))
        break
      case 'ZYX':
        ;(this._y = Math.asin(-un(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._x = Math.atan2(g, y)), (this._z = Math.atan2(c, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, u)))
        break
      case 'YZX':
        ;(this._z = Math.asin(un(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(-h, u)), (this._y = Math.atan2(-m, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, y)))
        break
      case 'XZY':
        ;(this._z = Math.asin(-un(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(g, u)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-h, y)), (this._y = 0))
        break
      default:
        console.warn(
          'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
            t,
        )
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this
  }
  setFromQuaternion(e, t, i) {
    return (
      DA.makeRotationFromQuaternion(e), this.setFromRotationMatrix(DA, t, i)
    )
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t)
  }
  reorder(e) {
    return OA.setFromEuler(this), this.setFromQuaternion(OA, e)
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    )
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    )
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order
  }
}
Us.DEFAULT_ORDER = 'XYZ'
class cd {
  constructor() {
    this.mask = 1
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0
  }
  enable(e) {
    this.mask |= (1 << e) | 0
  }
  enableAll() {
    this.mask = -1
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0)
  }
  disableAll() {
    this.mask = 0
  }
  test(e) {
    return (this.mask & e.mask) !== 0
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0
  }
}
let bB = 0
const kA = new re(),
  Cf = new xs(),
  fl = new Jt(),
  r0 = new re(),
  kp = new re(),
  TB = new re(),
  AB = new xs(),
  FA = new re(1, 0, 0),
  UA = new re(0, 1, 0),
  BA = new re(0, 0, 1),
  zA = { type: 'added' },
  CB = { type: 'removed' },
  Pf = { type: 'childadded', child: null },
  I1 = { type: 'childremoved', child: null }
class Ln extends Pa {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, 'id', { value: bB++ }),
      (this.uuid = Ds()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = Ln.DEFAULT_UP.clone())
    const e = new re(),
      t = new Us(),
      i = new xs(),
      r = new re(1, 1, 1)
    function s() {
      i.setFromEuler(t, !1)
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1)
    }
    t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new Jt() },
        normalMatrix: { value: new pn() },
      }),
      (this.matrix = new Jt()),
      (this.matrixWorld = new Jt()),
      (this.matrixAutoUpdate = Ln.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Ln.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new cd()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {})
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale)
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t)
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0)
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e)
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e)
  }
  rotateOnAxis(e, t) {
    return Cf.setFromAxisAngle(e, t), this.quaternion.multiply(Cf), this
  }
  rotateOnWorldAxis(e, t) {
    return Cf.setFromAxisAngle(e, t), this.quaternion.premultiply(Cf), this
  }
  rotateX(e) {
    return this.rotateOnAxis(FA, e)
  }
  rotateY(e) {
    return this.rotateOnAxis(UA, e)
  }
  rotateZ(e) {
    return this.rotateOnAxis(BA, e)
  }
  translateOnAxis(e, t) {
    return (
      kA.copy(e).applyQuaternion(this.quaternion),
      this.position.add(kA.multiplyScalar(t)),
      this
    )
  }
  translateX(e) {
    return this.translateOnAxis(FA, e)
  }
  translateY(e) {
    return this.translateOnAxis(UA, e)
  }
  translateZ(e) {
    return this.translateOnAxis(BA, e)
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(fl.copy(this.matrixWorld).invert())
    )
  }
  lookAt(e, t, i) {
    e.isVector3 ? r0.copy(e) : r0.set(e, t, i)
    const r = this.parent
    this.updateWorldMatrix(!0, !1),
      kp.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? fl.lookAt(kp, r0, this.up)
        : fl.lookAt(r0, kp, this.up),
      this.quaternion.setFromRotationMatrix(fl),
      r &&
        (fl.extractRotation(r.matrixWorld),
        Cf.setFromRotationMatrix(fl),
        this.quaternion.premultiply(Cf.invert()))
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t])
      return this
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e,
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(zA),
            (Pf.child = e),
            this.dispatchEvent(Pf),
            (Pf.child = null))
          : console.error(
              'THREE.Object3D.add: object not an instance of THREE.Object3D.',
              e,
            ),
        this)
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i])
      return this
    }
    const t = this.children.indexOf(e)
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(CB),
        (I1.child = e),
        this.dispatchEvent(I1),
        (I1.child = null)),
      this
    )
  }
  removeFromParent() {
    const e = this.parent
    return e !== null && e.remove(this), this
  }
  clear() {
    return this.remove(...this.children)
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      fl.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), fl.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(fl),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(zA),
      (Pf.child = e),
      this.dispatchEvent(Pf),
      (Pf.child = null),
      this
    )
  }
  getObjectById(e) {
    return this.getObjectByProperty('id', e)
  }
  getObjectByName(e) {
    return this.getObjectByProperty('name', e)
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t)
      if (o !== void 0) return o
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this)
    const r = this.children
    for (let s = 0, o = r.length; s < o; s++) r[s].getObjectsByProperty(e, t, i)
    return i
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    )
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(kp, e, TB), e
    )
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(kp, AB, e), e
    )
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1)
    const t = this.matrixWorld.elements
    return e.set(t[8], t[9], t[10]).normalize()
  }
  raycast() {}
  traverse(e) {
    e(this)
    const t = this.children
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e)
  }
  traverseVisible(e) {
    if (this.visible === !1) return
    e(this)
    const t = this.children
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e)
  }
  traverseAncestors(e) {
    const t = this.parent
    t !== null && (e(t), t.traverseAncestors(e))
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0)
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0))
    const t = this.children
    for (let i = 0, r = t.length; i < r; i++) t[i].updateMatrixWorld(e)
  }
  updateWorldMatrix(e, t) {
    const i = this.parent
    if (
      (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            )),
      t === !0)
    ) {
      const r = this.children
      for (let s = 0, o = r.length; s < o; s++) r[s].updateWorldMatrix(!1, !0)
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string',
      i = {}
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: 'Object',
        generator: 'Object3D.toJSON',
      }))
    const r = {}
    ;(r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== '' && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = 'InstancedMesh'),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = 'BatchedMesh'),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.visibility = this._visibility),
        (r.active = this._active),
        (r.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (r.maxInstanceCount = this._maxInstanceCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.geometryCount = this._geometryCount),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray(),
          }))
    function s(a, c) {
      return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)), c.uuid
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid)
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry)
      const a = this.geometry.parameters
      if (a !== void 0 && a.shapes !== void 0) {
        const c = a.shapes
        if (Array.isArray(c))
          for (let u = 0, h = c.length; u < h; u++) {
            const m = c[u]
            s(e.shapes, m)
          }
        else s(e.shapes, c)
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = []
        for (let c = 0, u = this.material.length; c < u; c++)
          a.push(s(e.materials, this.material[c]))
        r.material = a
      } else r.material = s(e.materials, this.material)
    if (this.children.length > 0) {
      r.children = []
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object)
    }
    if (this.animations.length > 0) {
      r.animations = []
      for (let a = 0; a < this.animations.length; a++) {
        const c = this.animations[a]
        r.animations.push(s(e.animations, c))
      }
    }
    if (t) {
      const a = o(e.geometries),
        c = o(e.materials),
        u = o(e.textures),
        h = o(e.images),
        m = o(e.shapes),
        g = o(e.skeletons),
        y = o(e.animations),
        _ = o(e.nodes)
      a.length > 0 && (i.geometries = a),
        c.length > 0 && (i.materials = c),
        u.length > 0 && (i.textures = u),
        h.length > 0 && (i.images = h),
        m.length > 0 && (i.shapes = m),
        g.length > 0 && (i.skeletons = g),
        y.length > 0 && (i.animations = y),
        _.length > 0 && (i.nodes = _)
    }
    return (i.object = r), i
    function o(a) {
      const c = []
      for (const u in a) {
        const h = a[u]
        delete h.metadata, c.push(h)
      }
      return c
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e)
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i]
        this.add(r.clone())
      }
    return this
  }
}
Ln.DEFAULT_UP = new re(0, 1, 0)
Ln.DEFAULT_MATRIX_AUTO_UPDATE = !0
Ln.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0
const Fo = new re(),
  hl = new re(),
  L1 = new re(),
  pl = new re(),
  Rf = new re(),
  If = new re(),
  VA = new re(),
  N1 = new re(),
  D1 = new re(),
  O1 = new re(),
  k1 = new In(),
  F1 = new In(),
  U1 = new In()
class ys {
  constructor(e = new re(), t = new re(), i = new re()) {
    ;(this.a = e), (this.b = t), (this.c = i)
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), Fo.subVectors(e, t), r.cross(Fo)
    const s = r.lengthSq()
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
  }
  static getBarycoord(e, t, i, r, s) {
    Fo.subVectors(r, t), hl.subVectors(i, t), L1.subVectors(e, t)
    const o = Fo.dot(Fo),
      a = Fo.dot(hl),
      c = Fo.dot(L1),
      u = hl.dot(hl),
      h = hl.dot(L1),
      m = o * u - a * a
    if (m === 0) return s.set(0, 0, 0), null
    const g = 1 / m,
      y = (u * c - a * h) * g,
      _ = (o * h - a * c) * g
    return s.set(1 - y - _, _, y)
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, pl) === null
      ? !1
      : pl.x >= 0 && pl.y >= 0 && pl.x + pl.y <= 1
  }
  static getInterpolation(e, t, i, r, s, o, a, c) {
    return this.getBarycoord(e, t, i, r, pl) === null
      ? ((c.x = 0),
        (c.y = 0),
        'z' in c && (c.z = 0),
        'w' in c && (c.w = 0),
        null)
      : (c.setScalar(0),
        c.addScaledVector(s, pl.x),
        c.addScaledVector(o, pl.y),
        c.addScaledVector(a, pl.z),
        c)
  }
  static getInterpolatedAttribute(e, t, i, r, s, o) {
    return (
      k1.setScalar(0),
      F1.setScalar(0),
      U1.setScalar(0),
      k1.fromBufferAttribute(e, t),
      F1.fromBufferAttribute(e, i),
      U1.fromBufferAttribute(e, r),
      o.setScalar(0),
      o.addScaledVector(k1, s.x),
      o.addScaledVector(F1, s.y),
      o.addScaledVector(U1, s.z),
      o
    )
  }
  static isFrontFacing(e, t, i, r) {
    return Fo.subVectors(i, t), hl.subVectors(e, t), Fo.cross(hl).dot(r) < 0
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
  }
  getArea() {
    return (
      Fo.subVectors(this.c, this.b),
      hl.subVectors(this.a, this.b),
      Fo.cross(hl).length() * 0.5
    )
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3)
  }
  getNormal(e) {
    return ys.getNormal(this.a, this.b, this.c, e)
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c)
  }
  getBarycoord(e, t) {
    return ys.getBarycoord(e, this.a, this.b, this.c, t)
  }
  getInterpolation(e, t, i, r, s) {
    return ys.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
  }
  containsPoint(e) {
    return ys.containsPoint(e, this.a, this.b, this.c)
  }
  isFrontFacing(e) {
    return ys.isFrontFacing(this.a, this.b, this.c, e)
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this)
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c
    let o, a
    Rf.subVectors(r, i), If.subVectors(s, i), N1.subVectors(e, i)
    const c = Rf.dot(N1),
      u = If.dot(N1)
    if (c <= 0 && u <= 0) return t.copy(i)
    D1.subVectors(e, r)
    const h = Rf.dot(D1),
      m = If.dot(D1)
    if (h >= 0 && m <= h) return t.copy(r)
    const g = c * m - h * u
    if (g <= 0 && c >= 0 && h <= 0)
      return (o = c / (c - h)), t.copy(i).addScaledVector(Rf, o)
    O1.subVectors(e, s)
    const y = Rf.dot(O1),
      _ = If.dot(O1)
    if (_ >= 0 && y <= _) return t.copy(s)
    const M = y * u - c * _
    if (M <= 0 && u >= 0 && _ <= 0)
      return (a = u / (u - _)), t.copy(i).addScaledVector(If, a)
    const w = h * _ - y * m
    if (w <= 0 && m - h >= 0 && y - _ >= 0)
      return (
        VA.subVectors(s, r),
        (a = (m - h) / (m - h + (y - _))),
        t.copy(r).addScaledVector(VA, a)
      )
    const x = 1 / (w + M + g)
    return (
      (o = M * x),
      (a = g * x),
      t.copy(i).addScaledVector(Rf, o).addScaledVector(If, a)
    )
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
  }
}
const IL = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  fc = { h: 0, s: 0, l: 0 },
  s0 = { h: 0, s: 0, l: 0 }
function B1(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  )
}
class Tt {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    )
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e
      r && r.isColor
        ? this.copy(r)
        : typeof r == 'number'
        ? this.setHex(r)
        : typeof r == 'string' && this.setStyle(r)
    } else this.setRGB(e, t, i)
    return this
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this
  }
  setHex(e, t = Zr) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Cn.toWorkingColorSpace(this, t),
      this
    )
  }
  setRGB(e, t, i, r = Cn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      Cn.toWorkingColorSpace(this, r),
      this
    )
  }
  setHSL(e, t, i, r = Cn.workingColorSpace) {
    if (((e = aE(e, 1)), (t = un(t, 0, 1)), (i = un(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s
      ;(this.r = B1(o, s, e + 1 / 3)),
        (this.g = B1(o, s, e)),
        (this.b = B1(o, s, e - 1 / 3))
    }
    return Cn.toWorkingColorSpace(this, r), this
  }
  setStyle(e, t = Zr) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          'THREE.Color: Alpha component of ' + e + ' will be ignored.',
        )
    }
    let r
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s
      const o = r[1],
        a = r[2]
      switch (o) {
        case 'rgb':
        case 'rgba':
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a,
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t,
              )
            )
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a,
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t,
              )
            )
          break
        case 'hsl':
        case 'hsla':
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a,
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t,
              )
            )
          break
        default:
          console.warn('THREE.Color: Unknown color model ' + e)
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t,
        )
      if (o === 6) return this.setHex(parseInt(s, 16), t)
      console.warn('THREE.Color: Invalid hex color ' + e)
    } else if (e && e.length > 0) return this.setColorName(e, t)
    return this
  }
  setColorName(e, t = Zr) {
    const i = IL[e.toLowerCase()]
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn('THREE.Color: Unknown color ' + e),
      this
    )
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b)
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this
  }
  copySRGBToLinear(e) {
    return (this.r = wl(e.r)), (this.g = wl(e.g)), (this.b = wl(e.b)), this
  }
  copyLinearToSRGB(e) {
    return (this.r = ch(e.r)), (this.g = ch(e.g)), (this.b = ch(e.b)), this
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this
  }
  getHex(e = Zr) {
    return (
      Cn.fromWorkingColorSpace(Cr.copy(this), e),
      Math.round(un(Cr.r * 255, 0, 255)) * 65536 +
        Math.round(un(Cr.g * 255, 0, 255)) * 256 +
        Math.round(un(Cr.b * 255, 0, 255))
    )
  }
  getHexString(e = Zr) {
    return ('000000' + this.getHex(e).toString(16)).slice(-6)
  }
  getHSL(e, t = Cn.workingColorSpace) {
    Cn.fromWorkingColorSpace(Cr.copy(this), t)
    const i = Cr.r,
      r = Cr.g,
      s = Cr.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s)
    let c, u
    const h = (a + o) / 2
    if (a === o) (c = 0), (u = 0)
    else {
      const m = o - a
      switch (((u = h <= 0.5 ? m / (o + a) : m / (2 - o - a)), o)) {
        case i:
          c = (r - s) / m + (r < s ? 6 : 0)
          break
        case r:
          c = (s - i) / m + 2
          break
        case s:
          c = (i - r) / m + 4
          break
      }
      c /= 6
    }
    return (e.h = c), (e.s = u), (e.l = h), e
  }
  getRGB(e, t = Cn.workingColorSpace) {
    return (
      Cn.fromWorkingColorSpace(Cr.copy(this), t),
      (e.r = Cr.r),
      (e.g = Cr.g),
      (e.b = Cr.b),
      e
    )
  }
  getStyle(e = Zr) {
    Cn.fromWorkingColorSpace(Cr.copy(this), e)
    const t = Cr.r,
      i = Cr.g,
      r = Cr.b
    return e !== Zr
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(
          r * 255,
        )})`
  }
  offsetHSL(e, t, i) {
    return this.getHSL(fc), this.setHSL(fc.h + e, fc.s + t, fc.l + i)
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    )
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    )
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    )
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    )
  }
  lerpHSL(e, t) {
    this.getHSL(fc), e.getHSL(s0)
    const i = Sm(fc.h, s0.h, t),
      r = Sm(fc.s, s0.s, t),
      s = Sm(fc.l, s0.l, t)
    return this.setHSL(i, r, s), this
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    )
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    )
  }
  toJSON() {
    return this.getHex()
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b
  }
}
const Cr = new Tt()
Tt.NAMES = IL
let PB = 0
class Or extends Pa {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, 'id', { value: PB++ }),
      (this.uuid = Ds()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.blending = od),
      (this.side = Tl),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = Ly),
      (this.blendDst = Ny),
      (this.blendEquation = Sc),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Tt(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = hd),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = FS),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Hu),
      (this.stencilZFail = Hu),
      (this.stencilZPass = Hu),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0)
  }
  get alphaTest() {
    return this._alphaTest
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e)
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString()
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t]
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`,
          )
          continue
        }
        const r = this[t]
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`,
          )
          continue
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[t] = i)
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string'
    t && (e = { textures: {}, images: {} })
    const i = {
      metadata: {
        version: 4.6,
        type: 'Material',
        generator: 'Material.toJSON',
      },
    }
    ;(i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== '' && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (i.dispersion = this.dispersion),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (i.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== od && (i.blending = this.blending),
      this.side !== Tl && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== Ly && (i.blendSrc = this.blendSrc),
      this.blendDst !== Ny && (i.blendDst = this.blendDst),
      this.blendEquation !== Sc && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== hd && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== FS && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Hu && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== Hu && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Hu && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== 'round' &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== 'round' &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData)
    function r(s) {
      const o = []
      for (const a in s) {
        const c = s[a]
        delete c.metadata, o.push(c)
      }
      return o
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images)
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o)
    }
    return i
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;(this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite)
    const t = e.clippingPlanes
    let i = null
    if (t !== null) {
      const r = t.length
      i = new Array(r)
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone()
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  onBuild() {
    console.warn('Material: onBuild() has been removed.')
  }
}
class Il extends Or {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new Tt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Us()),
      (this.combine = bg),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    )
  }
}
const yl = RB()
function RB() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512)
  for (let c = 0; c < 256; ++c) {
    const u = c - 127
    u < -27
      ? ((i[c] = 0), (i[c | 256] = 32768), (r[c] = 24), (r[c | 256] = 24))
      : u < -14
      ? ((i[c] = 1024 >> (-u - 14)),
        (i[c | 256] = (1024 >> (-u - 14)) | 32768),
        (r[c] = -u - 1),
        (r[c | 256] = -u - 1))
      : u <= 15
      ? ((i[c] = (u + 15) << 10),
        (i[c | 256] = ((u + 15) << 10) | 32768),
        (r[c] = 13),
        (r[c | 256] = 13))
      : u < 128
      ? ((i[c] = 31744), (i[c | 256] = 64512), (r[c] = 24), (r[c | 256] = 24))
      : ((i[c] = 31744), (i[c | 256] = 64512), (r[c] = 13), (r[c | 256] = 13))
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64)
  for (let c = 1; c < 1024; ++c) {
    let u = c << 13,
      h = 0
    for (; !(u & 8388608); ) (u <<= 1), (h -= 8388608)
    ;(u &= -8388609), (h += 947912704), (s[c] = u | h)
  }
  for (let c = 1024; c < 2048; ++c) s[c] = 939524096 + ((c - 1024) << 13)
  for (let c = 1; c < 31; ++c) o[c] = c << 23
  ;(o[31] = 1199570944), (o[32] = 2147483648)
  for (let c = 33; c < 63; ++c) o[c] = 2147483648 + ((c - 32) << 23)
  o[63] = 3347054592
  for (let c = 1; c < 64; ++c) c !== 32 && (a[c] = 1024)
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  }
}
function gs(n) {
  Math.abs(n) > 65504 &&
    console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.'),
    (n = un(n, -65504, 65504)),
    (yl.floatView[0] = n)
  const e = yl.uint32View[0],
    t = (e >> 23) & 511
  return yl.baseTable[t] + ((e & 8388607) >> yl.shiftTable[t])
}
function rm(n) {
  const e = n >> 10
  return (
    (yl.uint32View[0] =
      yl.mantissaTable[yl.offsetTable[e] + (n & 1023)] + yl.exponentTable[e]),
    yl.floatView[0]
  )
}
const td = { toHalfFloat: gs, fromHalfFloat: rm },
  Ui = new re(),
  o0 = new qe()
class qn {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        'THREE.BufferAttribute: array should be a Typed Array.',
      )
    ;(this.isBufferAttribute = !0),
      (this.name = ''),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = $m),
      (this.updateRanges = []),
      (this.gpuType = gi),
      (this.version = 0)
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setUsage(e) {
    return (this.usage = e), this
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t })
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    )
  }
  copyAt(e, t, i) {
    ;(e *= this.itemSize), (i *= t.itemSize)
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r]
    return this
  }
  copyArray(e) {
    return this.array.set(e), this
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        o0.fromBufferAttribute(this, t),
          o0.applyMatrix3(e),
          this.setXY(t, o0.x, o0.y)
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        Ui.fromBufferAttribute(this, t),
          Ui.applyMatrix3(e),
          this.setXYZ(t, Ui.x, Ui.y, Ui.z)
    return this
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ui.fromBufferAttribute(this, t),
        Ui.applyMatrix4(e),
        this.setXYZ(t, Ui.x, Ui.y, Ui.z)
    return this
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ui.fromBufferAttribute(this, t),
        Ui.applyNormalMatrix(e),
        this.setXYZ(t, Ui.x, Ui.y, Ui.z)
    return this
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ui.fromBufferAttribute(this, t),
        Ui.transformDirection(e),
        this.setXYZ(t, Ui.x, Ui.y, Ui.z)
    return this
  }
  set(e, t = 0) {
    return this.array.set(e, t), this
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t]
    return this.normalized && (i = Kr(i, this.array)), i
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = vn(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    )
  }
  getX(e) {
    let t = this.array[e * this.itemSize]
    return this.normalized && (t = Kr(t, this.array)), t
  }
  setX(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    )
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1]
    return this.normalized && (t = Kr(t, this.array)), t
  }
  setY(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    )
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2]
    return this.normalized && (t = Kr(t, this.array)), t
  }
  setZ(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    )
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3]
    return this.normalized && (t = Kr(t, this.array)), t
  }
  setW(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    )
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = vn(t, this.array)), (i = vn(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    )
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vn(t, this.array)),
        (i = vn(i, this.array)),
        (r = vn(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    )
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vn(t, this.array)),
        (i = vn(i, this.array)),
        (r = vn(r, this.array)),
        (s = vn(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    )
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this)
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    }
    return (
      this.name !== '' && (e.name = this.name),
      this.usage !== $m && (e.usage = this.usage),
      e
    )
  }
}
class IB extends qn {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i)
  }
}
class LB extends qn {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i)
  }
}
class NB extends qn {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i)
  }
}
class DB extends qn {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i)
  }
}
class lE extends qn {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i)
  }
}
class OB extends qn {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i)
  }
}
class cE extends qn {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i)
  }
}
class kB extends qn {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0)
  }
  getX(e) {
    let t = rm(this.array[e * this.itemSize])
    return this.normalized && (t = Kr(t, this.array)), t
  }
  setX(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.array[e * this.itemSize] = gs(t)),
      this
    )
  }
  getY(e) {
    let t = rm(this.array[e * this.itemSize + 1])
    return this.normalized && (t = Kr(t, this.array)), t
  }
  setY(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.array[e * this.itemSize + 1] = gs(t)),
      this
    )
  }
  getZ(e) {
    let t = rm(this.array[e * this.itemSize + 2])
    return this.normalized && (t = Kr(t, this.array)), t
  }
  setZ(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.array[e * this.itemSize + 2] = gs(t)),
      this
    )
  }
  getW(e) {
    let t = rm(this.array[e * this.itemSize + 3])
    return this.normalized && (t = Kr(t, this.array)), t
  }
  setW(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.array[e * this.itemSize + 3] = gs(t)),
      this
    )
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = vn(t, this.array)), (i = vn(i, this.array))),
      (this.array[e + 0] = gs(t)),
      (this.array[e + 1] = gs(i)),
      this
    )
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vn(t, this.array)),
        (i = vn(i, this.array)),
        (r = vn(r, this.array))),
      (this.array[e + 0] = gs(t)),
      (this.array[e + 1] = gs(i)),
      (this.array[e + 2] = gs(r)),
      this
    )
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vn(t, this.array)),
        (i = vn(i, this.array)),
        (r = vn(r, this.array)),
        (s = vn(s, this.array))),
      (this.array[e + 0] = gs(t)),
      (this.array[e + 1] = gs(i)),
      (this.array[e + 2] = gs(r)),
      (this.array[e + 3] = gs(s)),
      this
    )
  }
}
class Ft extends qn {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i)
  }
}
let FB = 0
const Js = new Jt(),
  z1 = new Ln(),
  Lf = new re(),
  Ns = new Jr(),
  Fp = new Jr(),
  ir = new re()
class _n extends Pa {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, 'id', { value: FB++ }),
      (this.uuid = Ds()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {})
  }
  getIndex() {
    return this.index
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (CL(e) ? cE : lE)(e, 1))
        : (this.index = e),
      this
    )
  }
  setIndirect(e) {
    return (this.indirect = e), this
  }
  getIndirect() {
    return this.indirect
  }
  getAttribute(e) {
    return this.attributes[e]
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i })
  }
  clearGroups() {
    this.groups = []
  }
  setDrawRange(e, t) {
    ;(this.drawRange.start = e), (this.drawRange.count = t)
  }
  applyMatrix4(e) {
    const t = this.attributes.position
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0))
    const i = this.attributes.normal
    if (i !== void 0) {
      const s = new pn().getNormalMatrix(e)
      i.applyNormalMatrix(s), (i.needsUpdate = !0)
    }
    const r = this.attributes.tangent
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    )
  }
  applyQuaternion(e) {
    return Js.makeRotationFromQuaternion(e), this.applyMatrix4(Js), this
  }
  rotateX(e) {
    return Js.makeRotationX(e), this.applyMatrix4(Js), this
  }
  rotateY(e) {
    return Js.makeRotationY(e), this.applyMatrix4(Js), this
  }
  rotateZ(e) {
    return Js.makeRotationZ(e), this.applyMatrix4(Js), this
  }
  translate(e, t, i) {
    return Js.makeTranslation(e, t, i), this.applyMatrix4(Js), this
  }
  scale(e, t, i) {
    return Js.makeScale(e, t, i), this.applyMatrix4(Js), this
  }
  lookAt(e) {
    return z1.lookAt(e), z1.updateMatrix(), this.applyMatrix4(z1.matrix), this
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Lf).negate(),
      this.translate(Lf.x, Lf.y, Lf.z),
      this
    )
  }
  setFromPoints(e) {
    const t = this.getAttribute('position')
    if (t === void 0) {
      const i = []
      for (let r = 0, s = e.length; r < s; r++) {
        const o = e[r]
        i.push(o.x, o.y, o.z || 0)
      }
      this.setAttribute('position', new Ft(i, 3))
    } else {
      const i = Math.min(e.length, t.count)
      for (let r = 0; r < i; r++) {
        const s = e[r]
        t.setXYZ(r, s.x, s.y, s.z || 0)
      }
      e.length > t.count &&
        console.warn(
          'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.',
        ),
        (t.needsUpdate = !0)
    }
    return this
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Jr())
    const e = this.attributes.position,
      t = this.morphAttributes.position
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',
        this,
      ),
        this.boundingBox.set(
          new re(-1 / 0, -1 / 0, -1 / 0),
          new re(1 / 0, 1 / 0, 1 / 0),
        )
      return
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i]
          Ns.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (ir.addVectors(this.boundingBox.min, Ns.min),
                this.boundingBox.expandByPoint(ir),
                ir.addVectors(this.boundingBox.max, Ns.max),
                this.boundingBox.expandByPoint(ir))
              : (this.boundingBox.expandByPoint(Ns.min),
                this.boundingBox.expandByPoint(Ns.max))
        }
    } else this.boundingBox.makeEmpty()
    ;(isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      )
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Dr())
    const e = this.attributes.position,
      t = this.morphAttributes.position
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',
        this,
      ),
        this.boundingSphere.set(new re(), 1 / 0)
      return
    }
    if (e) {
      const i = this.boundingSphere.center
      if ((Ns.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s]
          Fp.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (ir.addVectors(Ns.min, Fp.min),
                Ns.expandByPoint(ir),
                ir.addVectors(Ns.max, Fp.max),
                Ns.expandByPoint(ir))
              : (Ns.expandByPoint(Fp.min), Ns.expandByPoint(Fp.max))
        }
      Ns.getCenter(i)
      let r = 0
      for (let s = 0, o = e.count; s < o; s++)
        ir.fromBufferAttribute(e, s), (r = Math.max(r, i.distanceToSquared(ir)))
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            c = this.morphTargetsRelative
          for (let u = 0, h = a.count; u < h; u++)
            ir.fromBufferAttribute(a, u),
              c && (Lf.fromBufferAttribute(e, u), ir.add(Lf)),
              (r = Math.max(r, i.distanceToSquared(ir)))
        }
      ;(this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          )
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)',
      )
      return
    }
    const i = t.position,
      r = t.normal,
      s = t.uv
    this.hasAttribute('tangent') === !1 &&
      this.setAttribute('tangent', new qn(new Float32Array(4 * i.count), 4))
    const o = this.getAttribute('tangent'),
      a = [],
      c = []
    for (let F = 0; F < i.count; F++) (a[F] = new re()), (c[F] = new re())
    const u = new re(),
      h = new re(),
      m = new re(),
      g = new qe(),
      y = new qe(),
      _ = new qe(),
      M = new re(),
      w = new re()
    function x(F, N, k) {
      u.fromBufferAttribute(i, F),
        h.fromBufferAttribute(i, N),
        m.fromBufferAttribute(i, k),
        g.fromBufferAttribute(s, F),
        y.fromBufferAttribute(s, N),
        _.fromBufferAttribute(s, k),
        h.sub(u),
        m.sub(u),
        y.sub(g),
        _.sub(g)
      const z = 1 / (y.x * _.y - _.x * y.y)
      isFinite(z) &&
        (M.copy(h)
          .multiplyScalar(_.y)
          .addScaledVector(m, -y.y)
          .multiplyScalar(z),
        w
          .copy(m)
          .multiplyScalar(y.x)
          .addScaledVector(h, -_.x)
          .multiplyScalar(z),
        a[F].add(M),
        a[N].add(M),
        a[k].add(M),
        c[F].add(w),
        c[N].add(w),
        c[k].add(w))
    }
    let T = this.groups
    T.length === 0 && (T = [{ start: 0, count: e.count }])
    for (let F = 0, N = T.length; F < N; ++F) {
      const k = T[F],
        z = k.start,
        $ = k.count
      for (let te = z, j = z + $; te < j; te += 3)
        x(e.getX(te + 0), e.getX(te + 1), e.getX(te + 2))
    }
    const A = new re(),
      P = new re(),
      D = new re(),
      O = new re()
    function U(F) {
      D.fromBufferAttribute(r, F), O.copy(D)
      const N = a[F]
      A.copy(N),
        A.sub(D.multiplyScalar(D.dot(N))).normalize(),
        P.crossVectors(O, N)
      const z = P.dot(c[F]) < 0 ? -1 : 1
      o.setXYZW(F, A.x, A.y, A.z, z)
    }
    for (let F = 0, N = T.length; F < N; ++F) {
      const k = T[F],
        z = k.start,
        $ = k.count
      for (let te = z, j = z + $; te < j; te += 3)
        U(e.getX(te + 0)), U(e.getX(te + 1)), U(e.getX(te + 2))
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute('position')
    if (t !== void 0) {
      let i = this.getAttribute('normal')
      if (i === void 0)
        (i = new qn(new Float32Array(t.count * 3), 3)),
          this.setAttribute('normal', i)
      else for (let g = 0, y = i.count; g < y; g++) i.setXYZ(g, 0, 0, 0)
      const r = new re(),
        s = new re(),
        o = new re(),
        a = new re(),
        c = new re(),
        u = new re(),
        h = new re(),
        m = new re()
      if (e)
        for (let g = 0, y = e.count; g < y; g += 3) {
          const _ = e.getX(g + 0),
            M = e.getX(g + 1),
            w = e.getX(g + 2)
          r.fromBufferAttribute(t, _),
            s.fromBufferAttribute(t, M),
            o.fromBufferAttribute(t, w),
            h.subVectors(o, s),
            m.subVectors(r, s),
            h.cross(m),
            a.fromBufferAttribute(i, _),
            c.fromBufferAttribute(i, M),
            u.fromBufferAttribute(i, w),
            a.add(h),
            c.add(h),
            u.add(h),
            i.setXYZ(_, a.x, a.y, a.z),
            i.setXYZ(M, c.x, c.y, c.z),
            i.setXYZ(w, u.x, u.y, u.z)
        }
      else
        for (let g = 0, y = t.count; g < y; g += 3)
          r.fromBufferAttribute(t, g + 0),
            s.fromBufferAttribute(t, g + 1),
            o.fromBufferAttribute(t, g + 2),
            h.subVectors(o, s),
            m.subVectors(r, s),
            h.cross(m),
            i.setXYZ(g + 0, h.x, h.y, h.z),
            i.setXYZ(g + 1, h.x, h.y, h.z),
            i.setXYZ(g + 2, h.x, h.y, h.z)
      this.normalizeNormals(), (i.needsUpdate = !0)
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal
    for (let t = 0, i = e.count; t < i; t++)
      ir.fromBufferAttribute(e, t),
        ir.normalize(),
        e.setXYZ(t, ir.x, ir.y, ir.z)
  }
  toNonIndexed() {
    function e(a, c) {
      const u = a.array,
        h = a.itemSize,
        m = a.normalized,
        g = new u.constructor(c.length * h)
      let y = 0,
        _ = 0
      for (let M = 0, w = c.length; M < w; M++) {
        a.isInterleavedBufferAttribute
          ? (y = c[M] * a.data.stride + a.offset)
          : (y = c[M] * h)
        for (let x = 0; x < h; x++) g[_++] = u[y++]
      }
      return new qn(g, h, m)
    }
    if (this.index === null)
      return (
        console.warn(
          'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.',
        ),
        this
      )
    const t = new _n(),
      i = this.index.array,
      r = this.attributes
    for (const a in r) {
      const c = r[a],
        u = e(c, i)
      t.setAttribute(a, u)
    }
    const s = this.morphAttributes
    for (const a in s) {
      const c = [],
        u = s[a]
      for (let h = 0, m = u.length; h < m; h++) {
        const g = u[h],
          y = e(g, i)
        c.push(y)
      }
      t.morphAttributes[a] = c
    }
    t.morphTargetsRelative = this.morphTargetsRelative
    const o = this.groups
    for (let a = 0, c = o.length; a < c; a++) {
      const u = o[a]
      t.addGroup(u.start, u.count, u.materialIndex)
    }
    return t
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON',
      },
    }
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== '' && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const c = this.parameters
      for (const u in c) c[u] !== void 0 && (e[u] = c[u])
      return e
    }
    e.data = { attributes: {} }
    const t = this.index
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      })
    const i = this.attributes
    for (const c in i) {
      const u = i[c]
      e.data.attributes[c] = u.toJSON(e.data)
    }
    const r = {}
    let s = !1
    for (const c in this.morphAttributes) {
      const u = this.morphAttributes[c],
        h = []
      for (let m = 0, g = u.length; m < g; m++) {
        const y = u[m]
        h.push(y.toJSON(e.data))
      }
      h.length > 0 && ((r[c] = h), (s = !0))
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative))
    const o = this.groups
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)))
    const a = this.boundingSphere
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;(this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    const t = {}
    this.name = e.name
    const i = e.index
    i !== null && this.setIndex(i.clone(t))
    const r = e.attributes
    for (const u in r) {
      const h = r[u]
      this.setAttribute(u, h.clone(t))
    }
    const s = e.morphAttributes
    for (const u in s) {
      const h = [],
        m = s[u]
      for (let g = 0, y = m.length; g < y; g++) h.push(m[g].clone(t))
      this.morphAttributes[u] = h
    }
    this.morphTargetsRelative = e.morphTargetsRelative
    const o = e.groups
    for (let u = 0, h = o.length; u < h; u++) {
      const m = o[u]
      this.addGroup(m.start, m.count, m.materialIndex)
    }
    const a = e.boundingBox
    a !== null && (this.boundingBox = a.clone())
    const c = e.boundingSphere
    return (
      c !== null && (this.boundingSphere = c.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
const jA = new Jt(),
  Pu = new Ih(),
  a0 = new Dr(),
  HA = new re(),
  l0 = new re(),
  c0 = new re(),
  u0 = new re(),
  V1 = new re(),
  d0 = new re(),
  GA = new re(),
  f0 = new re()
class vi extends Ln {
  constructor(e = new _n(), t = new Il()) {
    super(),
      (this.isMesh = !0),
      (this.type = 'Mesh'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary,
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t)
    if (i.length > 0) {
      const r = t[i[0]]
      if (r !== void 0) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s)
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative
    t.fromBufferAttribute(r, e)
    const a = this.morphTargetInfluences
    if (s && a) {
      d0.set(0, 0, 0)
      for (let c = 0, u = s.length; c < u; c++) {
        const h = a[c],
          m = s[c]
        h !== 0 &&
          (V1.fromBufferAttribute(m, e),
          o ? d0.addScaledVector(V1, h) : d0.addScaledVector(V1.sub(t), h))
      }
      t.add(d0)
    }
    return t
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      a0.copy(i.boundingSphere),
      a0.applyMatrix4(s),
      Pu.copy(e.ray).recast(e.near),
      !(
        a0.containsPoint(Pu.origin) === !1 &&
        (Pu.intersectSphere(a0, HA) === null ||
          Pu.origin.distanceToSquared(HA) > (e.far - e.near) ** 2)
      ) &&
        (jA.copy(s).invert(),
        Pu.copy(e.ray).applyMatrix4(jA),
        !(i.boundingBox !== null && Pu.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, t, Pu)))
  }
  _computeIntersections(e, t, i) {
    let r
    const s = this.geometry,
      o = this.material,
      a = s.index,
      c = s.attributes.position,
      u = s.attributes.uv,
      h = s.attributes.uv1,
      m = s.attributes.normal,
      g = s.groups,
      y = s.drawRange
    if (a !== null)
      if (Array.isArray(o))
        for (let _ = 0, M = g.length; _ < M; _++) {
          const w = g[_],
            x = o[w.materialIndex],
            T = Math.max(w.start, y.start),
            A = Math.min(
              a.count,
              Math.min(w.start + w.count, y.start + y.count),
            )
          for (let P = T, D = A; P < D; P += 3) {
            const O = a.getX(P),
              U = a.getX(P + 1),
              F = a.getX(P + 2)
            ;(r = h0(this, x, e, i, u, h, m, O, U, F)),
              r &&
                ((r.faceIndex = Math.floor(P / 3)),
                (r.face.materialIndex = w.materialIndex),
                t.push(r))
          }
        }
      else {
        const _ = Math.max(0, y.start),
          M = Math.min(a.count, y.start + y.count)
        for (let w = _, x = M; w < x; w += 3) {
          const T = a.getX(w),
            A = a.getX(w + 1),
            P = a.getX(w + 2)
          ;(r = h0(this, o, e, i, u, h, m, T, A, P)),
            r && ((r.faceIndex = Math.floor(w / 3)), t.push(r))
        }
      }
    else if (c !== void 0)
      if (Array.isArray(o))
        for (let _ = 0, M = g.length; _ < M; _++) {
          const w = g[_],
            x = o[w.materialIndex],
            T = Math.max(w.start, y.start),
            A = Math.min(
              c.count,
              Math.min(w.start + w.count, y.start + y.count),
            )
          for (let P = T, D = A; P < D; P += 3) {
            const O = P,
              U = P + 1,
              F = P + 2
            ;(r = h0(this, x, e, i, u, h, m, O, U, F)),
              r &&
                ((r.faceIndex = Math.floor(P / 3)),
                (r.face.materialIndex = w.materialIndex),
                t.push(r))
          }
        }
      else {
        const _ = Math.max(0, y.start),
          M = Math.min(c.count, y.start + y.count)
        for (let w = _, x = M; w < x; w += 3) {
          const T = w,
            A = w + 1,
            P = w + 2
          ;(r = h0(this, o, e, i, u, h, m, T, A, P)),
            r && ((r.faceIndex = Math.floor(w / 3)), t.push(r))
        }
      }
  }
}
function UB(n, e, t, i, r, s, o, a) {
  let c
  if (
    (e.side === Qr
      ? (c = i.intersectTriangle(o, s, r, !0, a))
      : (c = i.intersectTriangle(r, s, o, e.side === Tl, a)),
    c === null)
  )
    return null
  f0.copy(a), f0.applyMatrix4(n.matrixWorld)
  const u = t.ray.origin.distanceTo(f0)
  return u < t.near || u > t.far
    ? null
    : { distance: u, point: f0.clone(), object: n }
}
function h0(n, e, t, i, r, s, o, a, c, u) {
  n.getVertexPosition(a, l0),
    n.getVertexPosition(c, c0),
    n.getVertexPosition(u, u0)
  const h = UB(n, e, t, i, l0, c0, u0, GA)
  if (h) {
    const m = new re()
    ys.getBarycoord(GA, l0, c0, u0, m),
      r && (h.uv = ys.getInterpolatedAttribute(r, a, c, u, m, new qe())),
      s && (h.uv1 = ys.getInterpolatedAttribute(s, a, c, u, m, new qe())),
      o &&
        ((h.normal = ys.getInterpolatedAttribute(o, a, c, u, m, new re())),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1))
    const g = { a, b: c, c: u, normal: new re(), materialIndex: 0 }
    ys.getNormal(l0, c0, u0, g.normal), (h.face = g), (h.barycoord = m)
  }
  return h
}
class _d extends _n {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      })
    const a = this
    ;(r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o))
    const c = [],
      u = [],
      h = [],
      m = []
    let g = 0,
      y = 0
    _('z', 'y', 'x', -1, -1, i, t, e, o, s, 0),
      _('z', 'y', 'x', 1, -1, i, t, -e, o, s, 1),
      _('x', 'z', 'y', 1, 1, e, i, t, r, o, 2),
      _('x', 'z', 'y', 1, -1, e, i, -t, r, o, 3),
      _('x', 'y', 'z', 1, -1, e, t, i, r, s, 4),
      _('x', 'y', 'z', -1, -1, e, t, -i, r, s, 5),
      this.setIndex(c),
      this.setAttribute('position', new Ft(u, 3)),
      this.setAttribute('normal', new Ft(h, 3)),
      this.setAttribute('uv', new Ft(m, 2))
    function _(M, w, x, T, A, P, D, O, U, F, N) {
      const k = P / U,
        z = D / F,
        $ = P / 2,
        te = D / 2,
        j = O / 2,
        K = U + 1,
        J = F + 1
      let ne = 0,
        V = 0
      const Y = new re()
      for (let Q = 0; Q < J; Q++) {
        const q = Q * z - te
        for (let oe = 0; oe < K; oe++) {
          const _e = oe * k - $
          ;(Y[M] = _e * T),
            (Y[w] = q * A),
            (Y[x] = j),
            u.push(Y.x, Y.y, Y.z),
            (Y[M] = 0),
            (Y[w] = 0),
            (Y[x] = O > 0 ? 1 : -1),
            h.push(Y.x, Y.y, Y.z),
            m.push(oe / U),
            m.push(1 - Q / F),
            (ne += 1)
        }
      }
      for (let Q = 0; Q < F; Q++)
        for (let q = 0; q < U; q++) {
          const oe = g + q + K * Q,
            _e = g + q + K * (Q + 1),
            he = g + (q + 1) + K * (Q + 1),
            Ce = g + (q + 1) + K * Q
          c.push(oe, _e, Ce), c.push(_e, he, Ce), (V += 6)
        }
      a.addGroup(y, V, N), (y += V), (g += ne)
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new _d(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments,
    )
  }
}
function gh(n) {
  const e = {}
  for (const t in n) {
    e[t] = {}
    for (const i in n[t]) {
      const r = n[t][i]
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().',
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
        ? (e[t][i] = r.slice())
        : (e[t][i] = r)
    }
  }
  return e
}
function Yr(n) {
  const e = {}
  for (let t = 0; t < n.length; t++) {
    const i = gh(n[t])
    for (const r in i) e[r] = i[r]
  }
  return e
}
function BB(n) {
  const e = []
  for (let t = 0; t < n.length; t++) e.push(n[t].clone())
  return e
}
function LL(n) {
  const e = n.getRenderTarget()
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : Cn.workingColorSpace
}
const NL = { clone: gh, merge: Yr }
var zB = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  VB = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
class ws extends Or {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = zB),
      (this.fragmentShader = VB),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = gh(e.uniforms)),
      (this.uniformsGroups = BB(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    )
  }
  toJSON(e) {
    const t = super.toJSON(e)
    ;(t.glslVersion = this.glslVersion), (t.uniforms = {})
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value
      o && o.isTexture
        ? (t.uniforms[r] = { type: 't', value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[r] = { type: 'c', value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[r] = { type: 'v2', value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[r] = { type: 'v3', value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[r] = { type: 'v4', value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[r] = { type: 'm3', value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[r] = { type: 'm4', value: o.toArray() })
        : (t.uniforms[r] = { value: o })
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping)
    const i = {}
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0)
    return Object.keys(i).length > 0 && (t.extensions = i), t
  }
}
class Rg extends Ln {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new Jt()),
      (this.projectionMatrix = new Jt()),
      (this.projectionMatrixInverse = new Jt()),
      (this.coordinateSystem = Go)
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    )
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate()
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const hc = new re(),
  WA = new qe(),
  $A = new qe()
class sr extends Rg {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = 'PerspectiveCamera'),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    )
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e
    ;(this.fov = mh * 2 * Math.atan(t)), this.updateProjectionMatrix()
  }
  getFocalLength() {
    const e = Math.tan(ld * 0.5 * this.fov)
    return (0.5 * this.getFilmHeight()) / e
  }
  getEffectiveFOV() {
    return mh * 2 * Math.atan(Math.tan(ld * 0.5 * this.fov) / this.zoom)
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1)
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1)
  }
  getViewBounds(e, t, i) {
    hc.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(hc.x, hc.y).multiplyScalar(-e / hc.z),
      hc.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      i.set(hc.x, hc.y).multiplyScalar(-e / hc.z)
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, WA, $A), t.subVectors($A, WA)
  }
  setViewOffset(e, t, i, r, s, o) {
    ;(this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const e = this.near
    let t = (e * Math.tan(ld * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r
    const o = this.view
    if (this.view !== null && this.view.enabled) {
      const c = o.fullWidth,
        u = o.fullHeight
      ;(s += (o.offsetX * r) / c),
        (t -= (o.offsetY * i) / u),
        (r *= o.width / c),
        (i *= o.height / u)
    }
    const a = this.filmOffset
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem,
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    )
  }
}
const Nf = -90,
  Df = 1
class DL extends Ln {
  constructor(e, t, i) {
    super(),
      (this.type = 'CubeCamera'),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0)
    const r = new sr(Nf, Df, e, t)
    ;(r.layers = this.layers), this.add(r)
    const s = new sr(Nf, Df, e, t)
    ;(s.layers = this.layers), this.add(s)
    const o = new sr(Nf, Df, e, t)
    ;(o.layers = this.layers), this.add(o)
    const a = new sr(Nf, Df, e, t)
    ;(a.layers = this.layers), this.add(a)
    const c = new sr(Nf, Df, e, t)
    ;(c.layers = this.layers), this.add(c)
    const u = new sr(Nf, Df, e, t)
    ;(u.layers = this.layers), this.add(u)
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, r, s, o, a, c] = t
    for (const u of t) this.remove(u)
    if (e === Go)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        c.up.set(0, 1, 0),
        c.lookAt(0, 0, -1)
    else if (e === Xm)
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        c.up.set(0, -1, 0),
        c.lookAt(0, 0, -1)
    else
      throw new Error(
        'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' +
          e,
      )
    for (const u of t) this.add(u), u.updateMatrixWorld()
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld()
    const { renderTarget: i, activeMipmapLevel: r } = this
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem())
    const [s, o, a, c, u, h] = this.children,
      m = e.getRenderTarget(),
      g = e.getActiveCubeFace(),
      y = e.getActiveMipmapLevel(),
      _ = e.xr.enabled
    e.xr.enabled = !1
    const M = i.texture.generateMipmaps
    ;(i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(t, s),
      e.setRenderTarget(i, 1, r),
      e.render(t, o),
      e.setRenderTarget(i, 2, r),
      e.render(t, a),
      e.setRenderTarget(i, 3, r),
      e.render(t, c),
      e.setRenderTarget(i, 4, r),
      e.render(t, u),
      (i.texture.generateMipmaps = M),
      e.setRenderTarget(i, 5, r),
      e.render(t, h),
      e.setRenderTarget(m, g, y),
      (e.xr.enabled = _),
      (i.texture.needsPMREMUpdate = !0)
  }
}
class Ig extends Xn {
  constructor(e, t, i, r, s, o, a, c, u, h) {
    ;(e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : ba),
      super(e, t, i, r, s, o, a, c, u, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1)
  }
  get images() {
    return this.image
  }
  set images(e) {
    this.image = e
  }
}
class uE extends uo {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0)
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i]
    ;(this.texture = new Ig(
      r,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace,
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Vn)
  }
  fromEquirectangularTexture(e, t) {
    ;(this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter)
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new _d(5, 5, 5),
      s = new ws({
        name: 'CubemapFromEquirect',
        uniforms: gh(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: Qr,
        blending: va,
      })
    s.uniforms.tEquirect.value = t
    const o = new vi(r, s),
      a = t.minFilter
    return (
      t.minFilter === ma && (t.minFilter = Vn),
      new DL(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    )
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget()
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r)
    e.setRenderTarget(s)
  }
}
class Qx {
  constructor(e, t = 25e-5) {
    ;(this.isFogExp2 = !0),
      (this.name = ''),
      (this.color = new Tt(e)),
      (this.density = t)
  }
  clone() {
    return new Qx(this.color, this.density)
  }
  toJSON() {
    return {
      type: 'FogExp2',
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    }
  }
}
class Jx {
  constructor(e, t = 1, i = 1e3) {
    ;(this.isFog = !0),
      (this.name = ''),
      (this.color = new Tt(e)),
      (this.near = t),
      (this.far = i)
  }
  clone() {
    return new Jx(this.color, this.near, this.far)
  }
  toJSON() {
    return {
      type: 'Fog',
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    }
  }
}
let Lg = class extends Ln {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Us()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Us()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this }),
        )
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    )
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    )
  }
}
class e_ {
  constructor(e, t) {
    ;(this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = $m),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Ds())
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setUsage(e) {
    return (this.usage = e), this
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t })
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    )
  }
  copyAt(e, t, i) {
    ;(e *= this.stride), (i *= t.stride)
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r]
    return this
  }
  set(e, t = 0) {
    return this.array.set(e, t), this
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ds()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid],
      ),
      i = new this.constructor(t, this.stride)
    return i.setUsage(this.usage), i
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ds()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer),
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    )
  }
}
const qr = new re()
class gd {
  constructor(e, t, i, r = !1) {
    ;(this.isInterleavedBufferAttribute = !0),
      (this.name = ''),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r)
  }
  get count() {
    return this.data.count
  }
  get array() {
    return this.data.array
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      qr.fromBufferAttribute(this, t),
        qr.applyMatrix4(e),
        this.setXYZ(t, qr.x, qr.y, qr.z)
    return this
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      qr.fromBufferAttribute(this, t),
        qr.applyNormalMatrix(e),
        this.setXYZ(t, qr.x, qr.y, qr.z)
    return this
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      qr.fromBufferAttribute(this, t),
        qr.transformDirection(e),
        this.setXYZ(t, qr.x, qr.y, qr.z)
    return this
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t]
    return this.normalized && (i = Kr(i, this.array)), i
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = vn(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = i),
      this
    )
  }
  setX(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    )
  }
  setY(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    )
  }
  setZ(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    )
  }
  setW(e, t) {
    return (
      this.normalized && (t = vn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    )
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset]
    return this.normalized && (t = Kr(t, this.array)), t
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1]
    return this.normalized && (t = Kr(t, this.array)), t
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2]
    return this.normalized && (t = Kr(t, this.array)), t
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3]
    return this.normalized && (t = Kr(t, this.array)), t
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = vn(t, this.array)), (i = vn(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    )
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = vn(t, this.array)),
        (i = vn(i, this.array)),
        (r = vn(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    )
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = vn(t, this.array)),
        (i = vn(i, this.array)),
        (r = vn(r, this.array)),
        (s = vn(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    )
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.',
      )
      const t = []
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
      }
      return new qn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized,
      )
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new gd(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized,
        )
      )
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.',
      )
      const t = []
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      }
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      )
  }
}
class dE extends Or {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = 'SpriteMaterial'),
      (this.color = new Tt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    )
  }
}
let Of
const Up = new re(),
  kf = new re(),
  Ff = new re(),
  Uf = new qe(),
  Bp = new qe(),
  OL = new Jt(),
  p0 = new re(),
  zp = new re(),
  m0 = new re(),
  XA = new qe(),
  j1 = new qe(),
  qA = new qe()
class kL extends Ln {
  constructor(e = new dE()) {
    if (
      (super(), (this.isSprite = !0), (this.type = 'Sprite'), Of === void 0)
    ) {
      Of = new _n()
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        i = new e_(t, 5)
      Of.setIndex([0, 1, 2, 0, 2, 3]),
        Of.setAttribute('position', new gd(i, 3, 0, !1)),
        Of.setAttribute('uv', new gd(i, 2, 3, !1))
    }
    ;(this.geometry = Of), (this.material = e), (this.center = new qe(0.5, 0.5))
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      ),
      kf.setFromMatrixScale(this.matrixWorld),
      OL.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld,
      ),
      Ff.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        kf.multiplyScalar(-Ff.z)
    const i = this.material.rotation
    let r, s
    i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)))
    const o = this.center
    g0(p0.set(-0.5, -0.5, 0), Ff, o, kf, r, s),
      g0(zp.set(0.5, -0.5, 0), Ff, o, kf, r, s),
      g0(m0.set(0.5, 0.5, 0), Ff, o, kf, r, s),
      XA.set(0, 0),
      j1.set(1, 0),
      qA.set(1, 1)
    let a = e.ray.intersectTriangle(p0, zp, m0, !1, Up)
    if (
      a === null &&
      (g0(zp.set(-0.5, 0.5, 0), Ff, o, kf, r, s),
      j1.set(0, 1),
      (a = e.ray.intersectTriangle(p0, m0, zp, !1, Up)),
      a === null)
    )
      return
    const c = e.ray.origin.distanceTo(Up)
    c < e.near ||
      c > e.far ||
      t.push({
        distance: c,
        point: Up.clone(),
        uv: ys.getInterpolation(Up, p0, zp, m0, XA, j1, qA, new qe()),
        face: null,
        object: this,
      })
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    )
  }
}
function g0(n, e, t, i, r, s) {
  Uf.subVectors(n, t).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((Bp.x = s * Uf.x - r * Uf.y), (Bp.y = r * Uf.x + s * Uf.y))
      : Bp.copy(Uf),
    n.copy(e),
    (n.x += Bp.x),
    (n.y += Bp.y),
    n.applyMatrix4(OL)
}
const v0 = new re(),
  YA = new re()
class FL extends Ln {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = 'LOD'),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0)
  }
  copy(e) {
    super.copy(e, !1)
    const t = e.levels
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i]
      this.addLevel(s.object.clone(), s.distance, s.hysteresis)
    }
    return (this.autoUpdate = e.autoUpdate), this
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t)
    const r = this.levels
    let s
    for (s = 0; s < r.length && !(t < r[s].distance); s++);
    return (
      r.splice(s, 0, { distance: t, hysteresis: i, object: e }),
      this.add(e),
      this
    )
  }
  removeLevel(e) {
    const t = this.levels
    for (let i = 0; i < t.length; i++)
      if (t[i].distance === e) {
        const r = t.splice(i, 1)
        return this.remove(r[0].object), !0
      }
    return !1
  }
  getCurrentLevel() {
    return this._currentLevel
  }
  getObjectForDistance(e) {
    const t = this.levels
    if (t.length > 0) {
      let i, r
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), e < s)) break
      }
      return t[i - 1].object
    }
    return null
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      v0.setFromMatrixPosition(this.matrixWorld)
      const r = e.ray.origin.distanceTo(v0)
      this.getObjectForDistance(r).raycast(e, t)
    }
  }
  update(e) {
    const t = this.levels
    if (t.length > 1) {
      v0.setFromMatrixPosition(e.matrixWorld),
        YA.setFromMatrixPosition(this.matrixWorld)
      const i = v0.distanceTo(YA) / e.zoom
      t[0].object.visible = !0
      let r, s
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), i >= o))
          (t[r - 1].object.visible = !1), (t[r].object.visible = !0)
        else break
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1
    }
  }
  toJSON(e) {
    const t = super.toJSON(e)
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), (t.object.levels = [])
    const i = this.levels
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r]
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      })
    }
    return t
  }
}
const ZA = new re(),
  KA = new In(),
  QA = new In(),
  jB = new re(),
  JA = new Jt(),
  y0 = new re(),
  H1 = new Dr(),
  eC = new Jt(),
  G1 = new Ih()
class UL extends vi {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = OS),
      (this.bindMatrix = new Jt()),
      (this.bindMatrixInverse = new Jt()),
      (this.boundingBox = null),
      (this.boundingSphere = null)
  }
  computeBoundingBox() {
    const e = this.geometry
    this.boundingBox === null && (this.boundingBox = new Jr()),
      this.boundingBox.makeEmpty()
    const t = e.getAttribute('position')
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, y0), this.boundingBox.expandByPoint(y0)
  }
  computeBoundingSphere() {
    const e = this.geometry
    this.boundingSphere === null && (this.boundingSphere = new Dr()),
      this.boundingSphere.makeEmpty()
    const t = e.getAttribute('position')
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, y0), this.boundingSphere.expandByPoint(y0)
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    )
  }
  raycast(e, t) {
    const i = this.material,
      r = this.matrixWorld
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      H1.copy(this.boundingSphere),
      H1.applyMatrix4(r),
      e.ray.intersectsSphere(H1) !== !1 &&
        (eC.copy(r).invert(),
        G1.copy(e.ray).applyMatrix4(eC),
        !(
          this.boundingBox !== null && G1.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, G1)))
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
  }
  bind(e, t) {
    ;(this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert()
  }
  pose() {
    this.skeleton.pose()
  }
  normalizeSkinWeights() {
    const e = new In(),
      t = this.geometry.attributes.skinWeight
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i)
      const s = 1 / e.manhattanLength()
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w)
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === OS
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === pL
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode,
          )
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry
    KA.fromBufferAttribute(r.attributes.skinIndex, e),
      QA.fromBufferAttribute(r.attributes.skinWeight, e),
      ZA.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0)
    for (let s = 0; s < 4; s++) {
      const o = QA.getComponent(s)
      if (o !== 0) {
        const a = KA.getComponent(s)
        JA.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(jB.copy(ZA).applyMatrix4(JA), o)
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse)
  }
}
class fE extends Ln {
  constructor() {
    super(), (this.isBone = !0), (this.type = 'Bone')
  }
}
class $o extends Xn {
  constructor(e = null, t = 1, i = 1, r, s, o, a, c, u = yr, h = yr, m, g) {
    super(null, o, a, c, u, h, r, s, m, g),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
const tC = new Jt(),
  HB = new Jt()
class t_ {
  constructor(e = [], t = []) {
    ;(this.uuid = Ds()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init()
  }
  init() {
    const e = this.bones,
      t = this.boneInverses
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses()
    else if (e.length !== t.length) {
      console.warn(
        'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.',
      ),
        (this.boneInverses = [])
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new Jt())
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new Jt()
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i)
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e]
      i && i.matrixWorld.copy(this.boneInverses[e]).invert()
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e]
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale))
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : HB
      tC.multiplyMatrices(a, t[s]), tC.toArray(i, s * 16)
    }
    r !== null && (r.needsUpdate = !0)
  }
  clone() {
    return new t_(this.bones, this.boneInverses)
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4)
    ;(e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4))
    const t = new Float32Array(e * e * 4)
    t.set(this.boneMatrices)
    const i = new $o(t, e, e, Ii, gi)
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      this
    )
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t]
      if (r.name === e) return r
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null))
  }
  fromJSON(e, t) {
    this.uuid = e.uuid
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i]
      let o = t[s]
      o === void 0 &&
        (console.warn('THREE.Skeleton: No bone found with UUID:', s),
        (o = new fE())),
        this.bones.push(o),
        this.boneInverses.push(new Jt().fromArray(e.boneInverses[i]))
    }
    return this.init(), this
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: 'Skeleton',
        generator: 'Skeleton.toJSON',
      },
      bones: [],
      boneInverses: [],
    }
    e.uuid = this.uuid
    const t = this.bones,
      i = this.boneInverses
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r]
      e.bones.push(o.uuid)
      const a = i[r]
      e.boneInverses.push(a.toArray())
    }
    return e
  }
}
class vh extends qn {
  constructor(e, t, i, r = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r)
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    )
  }
}
const Bf = new Jt(),
  nC = new Jt(),
  x0 = [],
  iC = new Jr(),
  GB = new Jt(),
  Vp = new vi(),
  jp = new Dr()
class BL extends vi {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new vh(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    for (let r = 0; r < i; r++) this.setMatrixAt(r, GB)
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count
    this.boundingBox === null && (this.boundingBox = new Jr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty()
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, Bf),
        iC.copy(e.boundingBox).applyMatrix4(Bf),
        this.boundingBox.union(iC)
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count
    this.boundingSphere === null && (this.boundingSphere = new Dr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty()
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, Bf),
        jp.copy(e.boundingSphere).applyMatrix4(Bf),
        this.boundingSphere.union(jp)
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    )
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3)
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16)
  }
  getMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = this.morphTexture.source.data.data,
      s = i.length + 1,
      o = e * s + 1
    for (let a = 0; a < i.length; a++) i[a] = r[o + a]
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count
    if (
      ((Vp.geometry = this.geometry),
      (Vp.material = this.material),
      Vp.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        jp.copy(this.boundingSphere),
        jp.applyMatrix4(i),
        e.ray.intersectsSphere(jp) !== !1))
    )
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, Bf),
          nC.multiplyMatrices(i, Bf),
          (Vp.matrixWorld = nC),
          Vp.raycast(e, x0)
        for (let o = 0, a = x0.length; o < a; o++) {
          const c = x0[o]
          ;(c.instanceId = s), (c.object = this), t.push(c)
        }
        x0.length = 0
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new vh(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3,
      )),
      t.toArray(this.instanceColor.array, e * 3)
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16)
  }
  setMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = i.length + 1
    this.morphTexture === null &&
      (this.morphTexture = new $o(
        new Float32Array(r * this.count),
        r,
        this.count,
        Ag,
        gi,
      ))
    const s = this.morphTexture.source.data.data
    let o = 0
    for (let u = 0; u < i.length; u++) o += i[u]
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      c = r * e
    ;(s[c] = a), s.set(i, c + 1)
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: 'dispose' }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    )
  }
}
const W1 = new re(),
  WB = new re(),
  $B = new pn()
class wc {
  constructor(e = new re(1, 0, 0), t = 0) {
    ;(this.isPlane = !0), (this.normal = e), (this.constant = t)
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), (this.constant = r), this
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
  }
  setFromCoplanarPoints(e, t, i) {
    const r = W1.subVectors(i, t).cross(WB.subVectors(e, t)).normalize()
    return this.setFromNormalAndCoplanarPoint(r, e), this
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this
  }
  normalize() {
    const e = 1 / this.normal.length()
    return this.normal.multiplyScalar(e), (this.constant *= e), this
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
  }
  intersectLine(e, t) {
    const i = e.delta(W1),
      r = this.normal.dot(i)
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null
    const s = -(e.start.dot(this.normal) + this.constant) / r
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end)
    return (t < 0 && i > 0) || (i < 0 && t > 0)
  }
  intersectsBox(e) {
    return e.intersectsPlane(this)
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this)
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant)
  }
  applyMatrix4(e, t) {
    const i = t || $B.getNormalMatrix(e),
      r = this.coplanarPoint(W1).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize()
    return (this.constant = -r.dot(s)), this
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const Ru = new Dr(),
  _0 = new re()
class Ng {
  constructor(
    e = new wc(),
    t = new wc(),
    i = new wc(),
    r = new wc(),
    s = new wc(),
    o = new wc(),
  ) {
    this.planes = [e, t, i, r, s, o]
  }
  set(e, t, i, r, s, o) {
    const a = this.planes
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    )
  }
  copy(e) {
    const t = this.planes
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i])
    return this
  }
  setFromProjectionMatrix(e, t = Go) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      o = r[1],
      a = r[2],
      c = r[3],
      u = r[4],
      h = r[5],
      m = r[6],
      g = r[7],
      y = r[8],
      _ = r[9],
      M = r[10],
      w = r[11],
      x = r[12],
      T = r[13],
      A = r[14],
      P = r[15]
    if (
      (i[0].setComponents(c - s, g - u, w - y, P - x).normalize(),
      i[1].setComponents(c + s, g + u, w + y, P + x).normalize(),
      i[2].setComponents(c + o, g + h, w + _, P + T).normalize(),
      i[3].setComponents(c - o, g - h, w - _, P - T).normalize(),
      i[4].setComponents(c - a, g - m, w - M, P - A).normalize(),
      t === Go)
    )
      i[5].setComponents(c + a, g + m, w + M, P + A).normalize()
    else if (t === Xm) i[5].setComponents(a, m, M, A).normalize()
    else
      throw new Error(
        'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' +
          t,
      )
    return this
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Ru.copy(e.boundingSphere).applyMatrix4(e.matrixWorld)
    else {
      const t = e.geometry
      t.boundingSphere === null && t.computeBoundingSphere(),
        Ru.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
    }
    return this.intersectsSphere(Ru)
  }
  intersectsSprite(e) {
    return (
      Ru.center.set(0, 0, 0),
      (Ru.radius = 0.7071067811865476),
      Ru.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ru)
    )
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1
    return !0
  }
  intersectsBox(e) {
    const t = this.planes
    for (let i = 0; i < 6; i++) {
      const r = t[i]
      if (
        ((_0.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (_0.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (_0.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(_0) < 0)
      )
        return !1
    }
    return !0
  }
  containsPoint(e) {
    const t = this.planes
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1
    return !0
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
function $1(n, e) {
  return n - e
}
function XB(n, e) {
  return n.z - e.z
}
function qB(n, e) {
  return e.z - n.z
}
class YB {
  constructor() {
    ;(this.index = 0), (this.pool = []), (this.list = [])
  }
  push(e, t, i, r) {
    const s = this.pool,
      o = this.list
    this.index >= s.length && s.push({ start: -1, count: -1, z: -1, index: -1 })
    const a = s[this.index]
    o.push(a),
      this.index++,
      (a.start = e),
      (a.count = t),
      (a.z = i),
      (a.index = r)
  }
  reset() {
    ;(this.list.length = 0), (this.index = 0)
  }
}
const ms = new Jt(),
  ZB = new Tt(1, 1, 1),
  X1 = new Ng(),
  w0 = new Jr(),
  Iu = new Dr(),
  Hp = new re(),
  rC = new re(),
  KB = new re(),
  q1 = new YB(),
  Pr = new vi(),
  S0 = []
function QB(n, e, t = 0) {
  const i = e.itemSize
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const r = n.count
    for (let s = 0; s < r; s++)
      for (let o = 0; o < i; o++) e.setComponent(s + t, o, n.getComponent(s, o))
  } else e.array.set(n.array, t * i)
  e.needsUpdate = !0
}
function Lu(n, e) {
  if (n.constructor !== e.constructor) {
    const t = Math.min(n.length, e.length)
    for (let i = 0; i < t; i++) e[i] = n[i]
  } else {
    const t = Math.min(n.length, e.length)
    e.set(new n.constructor(n.buffer, 0, t))
  }
}
class zL extends vi {
  get maxInstanceCount() {
    return this._maxInstanceCount
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart
  }
  constructor(e, t, i = t * 2, r) {
    super(new _n(), r),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = i),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture()
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4)
    ;(e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4))
    const t = new Float32Array(e * e * 4),
      i = new $o(t, e, e, Ii, gi)
    this._matricesTexture = i
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount)
    e = Math.ceil(e)
    const t = new Uint32Array(e * e),
      i = new $o(t, e, e, Cg, Ta)
    this._indirectTexture = i
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount)
    e = Math.ceil(e)
    const t = new Float32Array(e * e * 4).fill(1),
      i = new $o(t, e, e, Ii, gi)
    ;(i.colorSpace = Cn.workingColorSpace), (this._colorsTexture = i)
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      i = this._maxVertexCount,
      r = this._maxIndexCount
    if (this._geometryInitialized === !1) {
      for (const s in e.attributes) {
        const o = e.getAttribute(s),
          { array: a, itemSize: c, normalized: u } = o,
          h = new a.constructor(i * c),
          m = new qn(h, c, u)
        t.setAttribute(s, m)
      }
      if (e.getIndex() !== null) {
        const s = i > 65535 ? new Uint32Array(r) : new Uint16Array(r)
        t.setIndex(new qn(s, 1))
      }
      this._geometryInitialized = !0
    }
  }
  _validateGeometry(e) {
    const t = this.geometry
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'THREE.BatchedMesh: All geometries must consistently have "index".',
      )
    for (const i in t.attributes) {
      if (!e.hasAttribute(i))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`,
        )
      const r = e.getAttribute(i),
        s = t.getAttribute(i)
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
        throw new Error(
          'THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.',
        )
    }
  }
  validateInstanceId(e) {
    const t = this._instanceInfo
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`,
      )
  }
  validateGeometryId(e) {
    const t = this._geometryInfo
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`,
      )
  }
  setCustomSort(e) {
    return (this.customSort = e), this
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Jr())
    const e = this.boundingBox,
      t = this._instanceInfo
    e.makeEmpty()
    for (let i = 0, r = t.length; i < r; i++) {
      if (t[i].active === !1) continue
      const s = t[i].geometryIndex
      this.getMatrixAt(i, ms),
        this.getBoundingBoxAt(s, w0).applyMatrix4(ms),
        e.union(w0)
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Dr())
    const e = this.boundingSphere,
      t = this._instanceInfo
    e.makeEmpty()
    for (let i = 0, r = t.length; i < r; i++) {
      if (t[i].active === !1) continue
      const s = t[i].geometryIndex
      this.getMatrixAt(i, ms),
        this.getBoundingSphereAt(s, Iu).applyMatrix4(ms),
        e.union(Iu)
    }
  }
  addInstance(e) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error('THREE.BatchedMesh: Maximum item count reached.')
    const i = { visible: !0, active: !0, geometryIndex: e }
    let r = null
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort($1),
        (r = this._availableInstanceIds.shift()),
        (this._instanceInfo[r] = i))
      : ((r = this._instanceInfo.length), this._instanceInfo.push(i))
    const s = this._matricesTexture
    ms.identity().toArray(s.image.data, r * 16), (s.needsUpdate = !0)
    const o = this._colorsTexture
    return (
      o && (ZB.toArray(o.image.data, r * 4), (o.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      r
    )
  }
  addGeometry(e, t = -1, i = -1) {
    this._initializeGeometry(e), this._validateGeometry(e)
    const r = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      s = this._geometryInfo
    ;(r.vertexStart = this._nextVertexStart),
      (r.reservedVertexCount = t === -1 ? e.getAttribute('position').count : t)
    const o = e.getIndex()
    if (
      (o !== null &&
        ((r.indexStart = this._nextIndexStart),
        (r.reservedIndexCount = i === -1 ? o.count : i)),
      (r.indexStart !== -1 &&
        r.indexStart + r.reservedIndexCount > this._maxIndexCount) ||
        r.vertexStart + r.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        'THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.',
      )
    let c
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort($1),
          (c = this._availableGeometryIds.shift()),
          (s[c] = r))
        : ((c = this._geometryCount), this._geometryCount++, s.push(r)),
      this.setGeometryAt(c, e),
      (this._nextIndexStart = r.indexStart + r.reservedIndexCount),
      (this._nextVertexStart = r.vertexStart + r.reservedVertexCount),
      c
    )
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error('THREE.BatchedMesh: Maximum geometry count reached.')
    this._validateGeometry(t)
    const i = this.geometry,
      r = i.getIndex() !== null,
      s = i.getIndex(),
      o = t.getIndex(),
      a = this._geometryInfo[e]
    if (
      (r && o.count > a.reservedIndexCount) ||
      t.attributes.position.count > a.reservedVertexCount
    )
      throw new Error(
        'THREE.BatchedMesh: Reserved space not large enough for provided geometry.',
      )
    const c = a.vertexStart,
      u = a.reservedVertexCount
    a.vertexCount = t.getAttribute('position').count
    for (const h in i.attributes) {
      const m = t.getAttribute(h),
        g = i.getAttribute(h)
      QB(m, g, c)
      const y = m.itemSize
      for (let _ = m.count, M = u; _ < M; _++) {
        const w = c + _
        for (let x = 0; x < y; x++) g.setComponent(w, x, 0)
      }
      ;(g.needsUpdate = !0), g.addUpdateRange(c * y, u * y)
    }
    if (r) {
      const h = a.indexStart,
        m = a.reservedIndexCount
      a.indexCount = t.getIndex().count
      for (let g = 0; g < o.count; g++) s.setX(h + g, c + o.getX(g))
      for (let g = o.count, y = m; g < y; g++) s.setX(h + g, c)
      ;(s.needsUpdate = !0), s.addUpdateRange(h, a.reservedIndexCount)
    }
    return (
      (a.start = r ? a.indexStart : a.vertexStart),
      (a.count = r ? a.indexCount : a.vertexCount),
      (a.boundingBox = null),
      t.boundingBox !== null && (a.boundingBox = t.boundingBox.clone()),
      (a.boundingSphere = null),
      t.boundingSphere !== null &&
        (a.boundingSphere = t.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      e
    )
  }
  deleteGeometry(e) {
    const t = this._geometryInfo
    if (e >= t.length || t[e].active === !1) return this
    const i = this._instanceInfo
    for (let r = 0, s = i.length; r < s; r++)
      i[r].geometryIndex === e && this.deleteInstance(r)
    return (
      (t[e].active = !1),
      this._availableGeometryIds.push(e),
      (this._visibilityChanged = !0),
      this
    )
  }
  deleteInstance(e) {
    return (
      this.validateInstanceId(e),
      (this._instanceInfo[e].active = !1),
      this._availableInstanceIds.push(e),
      (this._visibilityChanged = !0),
      this
    )
  }
  optimize() {
    let e = 0,
      t = 0
    const i = this._geometryInfo,
      r = i
        .map((o, a) => a)
        .sort((o, a) => i[o].vertexStart - i[a].vertexStart),
      s = this.geometry
    for (let o = 0, a = i.length; o < a; o++) {
      const c = r[o],
        u = i[c]
      if (u.active !== !1) {
        if (s.index !== null) {
          if (u.indexStart !== t) {
            const { indexStart: h, vertexStart: m, reservedIndexCount: g } = u,
              y = s.index,
              _ = y.array,
              M = e - m
            for (let w = h; w < h + g; w++) _[w] = _[w] + M
            y.array.copyWithin(t, h, h + g),
              y.addUpdateRange(t, g),
              (u.indexStart = t)
          }
          t += u.reservedIndexCount
        }
        if (u.vertexStart !== e) {
          const { vertexStart: h, reservedVertexCount: m } = u,
            g = s.attributes
          for (const y in g) {
            const _ = g[y],
              { array: M, itemSize: w } = _
            M.copyWithin(e * w, h * w, (h + m) * w),
              _.addUpdateRange(e * w, m * w)
          }
          u.vertexStart = e
        }
        ;(e += u.reservedVertexCount),
          (u.start = s.index ? u.indexStart : u.vertexStart),
          (this._nextIndexStart = s.index
            ? u.indexStart + u.reservedIndexCount
            : 0),
          (this._nextVertexStart = u.vertexStart + u.reservedVertexCount)
      }
    }
    return this
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null
    const i = this.geometry,
      r = this._geometryInfo[e]
    if (r.boundingBox === null) {
      const s = new Jr(),
        o = i.index,
        a = i.attributes.position
      for (let c = r.start, u = r.start + r.count; c < u; c++) {
        let h = c
        o && (h = o.getX(h)), s.expandByPoint(Hp.fromBufferAttribute(a, h))
      }
      r.boundingBox = s
    }
    return t.copy(r.boundingBox), t
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null
    const i = this.geometry,
      r = this._geometryInfo[e]
    if (r.boundingSphere === null) {
      const s = new Dr()
      this.getBoundingBoxAt(e, w0), w0.getCenter(s.center)
      const o = i.index,
        a = i.attributes.position
      let c = 0
      for (let u = r.start, h = r.start + r.count; u < h; u++) {
        let m = u
        o && (m = o.getX(m)),
          Hp.fromBufferAttribute(a, m),
          (c = Math.max(c, s.center.distanceToSquared(Hp)))
      }
      ;(s.radius = Math.sqrt(c)), (r.boundingSphere = s)
    }
    return t.copy(r.boundingSphere), t
  }
  setMatrixAt(e, t) {
    this.validateInstanceId(e)
    const i = this._matricesTexture,
      r = this._matricesTexture.image.data
    return t.toArray(r, e * 16), (i.needsUpdate = !0), this
  }
  getMatrixAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._matricesTexture.image.data, e * 16)
    )
  }
  setColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._colorsTexture === null && this._initColorsTexture(),
      t.toArray(this._colorsTexture.image.data, e * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    )
  }
  getColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._colorsTexture.image.data, e * 4)
    )
  }
  setVisibleAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._instanceInfo[e].visible === t
        ? this
        : ((this._instanceInfo[e].visible = t),
          (this._visibilityChanged = !0),
          this)
    )
  }
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible
  }
  setGeometryIdAt(e, t) {
    return (
      this.validateInstanceId(e),
      this.validateGeometryId(t),
      (this._instanceInfo[e].geometryIndex = t),
      this
    )
  }
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex
  }
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e)
    const i = this._geometryInfo[e]
    return (
      (t.vertexStart = i.vertexStart),
      (t.vertexCount = i.vertexCount),
      (t.reservedVertexCount = i.reservedVertexCount),
      (t.indexStart = i.indexStart),
      (t.indexCount = i.indexCount),
      (t.reservedIndexCount = i.reservedIndexCount),
      (t.start = i.start),
      (t.count = i.count),
      t
    )
  }
  setInstanceCount(e) {
    const t = this._availableInstanceIds,
      i = this._instanceInfo
    for (t.sort($1); t[t.length - 1] === i.length; ) i.pop(), t.pop()
    if (e < i.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`,
      )
    const r = new Int32Array(e),
      s = new Int32Array(e)
    Lu(this._multiDrawCounts, r),
      Lu(this._multiDrawStarts, s),
      (this._multiDrawCounts = r),
      (this._multiDrawStarts = s),
      (this._maxInstanceCount = e)
    const o = this._indirectTexture,
      a = this._matricesTexture,
      c = this._colorsTexture
    o.dispose(),
      this._initIndirectTexture(),
      Lu(o.image.data, this._indirectTexture.image.data),
      a.dispose(),
      this._initMatricesTexture(),
      Lu(a.image.data, this._matricesTexture.image.data),
      c &&
        (c.dispose(),
        this._initColorsTexture(),
        Lu(c.image.data, this._colorsTexture.image.data))
  }
  setGeometrySize(e, t) {
    const i = [...this._geometryInfo].filter((a) => a.active)
    if (Math.max(...i.map((a) => a.vertexStart + a.reservedVertexCount)) > e)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`,
      )
    if (
      this.geometry.index &&
      Math.max(...i.map((c) => c.indexStart + c.reservedIndexCount)) > t
    )
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`,
      )
    const s = this.geometry
    s.dispose(),
      (this._maxVertexCount = e),
      (this._maxIndexCount = t),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new _n()),
        this._initializeGeometry(s))
    const o = this.geometry
    s.index && Lu(s.index.array, o.index.array)
    for (const a in s.attributes)
      Lu(s.attributes[a].array, o.attributes[a].array)
  }
  raycast(e, t) {
    const i = this._instanceInfo,
      r = this._geometryInfo,
      s = this.matrixWorld,
      o = this.geometry
    ;(Pr.material = this.material),
      (Pr.geometry.index = o.index),
      (Pr.geometry.attributes = o.attributes),
      Pr.geometry.boundingBox === null && (Pr.geometry.boundingBox = new Jr()),
      Pr.geometry.boundingSphere === null &&
        (Pr.geometry.boundingSphere = new Dr())
    for (let a = 0, c = i.length; a < c; a++) {
      if (!i[a].visible || !i[a].active) continue
      const u = i[a].geometryIndex,
        h = r[u]
      Pr.geometry.setDrawRange(h.start, h.count),
        this.getMatrixAt(a, Pr.matrixWorld).premultiply(s),
        this.getBoundingBoxAt(u, Pr.geometry.boundingBox),
        this.getBoundingSphereAt(u, Pr.geometry.boundingSphere),
        Pr.raycast(e, S0)
      for (let m = 0, g = S0.length; m < g; m++) {
        const y = S0[m]
        ;(y.object = this), (y.batchId = a), t.push(y)
      }
      S0.length = 0
    }
    ;(Pr.material = null),
      (Pr.geometry.index = null),
      (Pr.geometry.attributes = {}),
      Pr.geometry.setDrawRange(0, 1 / 0)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._geometryInfo = e._geometryInfo.map((t) => ({
        ...t,
        boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
        boundingSphere:
          t.boundingSphere !== null ? t.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = e._instanceInfo.map((t) => ({ ...t }))),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    )
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    )
  }
  onBeforeRender(e, t, i, r, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return
    const o = r.getIndex(),
      a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
      c = this._instanceInfo,
      u = this._multiDrawStarts,
      h = this._multiDrawCounts,
      m = this._geometryInfo,
      g = this.perObjectFrustumCulled,
      y = this._indirectTexture,
      _ = y.image.data
    g &&
      (ms
        .multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse)
        .multiply(this.matrixWorld),
      X1.setFromProjectionMatrix(ms, e.coordinateSystem))
    let M = 0
    if (this.sortObjects) {
      ms.copy(this.matrixWorld).invert(),
        Hp.setFromMatrixPosition(i.matrixWorld).applyMatrix4(ms),
        rC
          .set(0, 0, -1)
          .transformDirection(i.matrixWorld)
          .transformDirection(ms)
      for (let T = 0, A = c.length; T < A; T++)
        if (c[T].visible && c[T].active) {
          const P = c[T].geometryIndex
          this.getMatrixAt(T, ms),
            this.getBoundingSphereAt(P, Iu).applyMatrix4(ms)
          let D = !1
          if ((g && (D = !X1.intersectsSphere(Iu)), !D)) {
            const O = m[P],
              U = KB.subVectors(Iu.center, Hp).dot(rC)
            q1.push(O.start, O.count, U, T)
          }
        }
      const w = q1.list,
        x = this.customSort
      x === null ? w.sort(s.transparent ? qB : XB) : x.call(this, w, i)
      for (let T = 0, A = w.length; T < A; T++) {
        const P = w[T]
        ;(u[M] = P.start * a), (h[M] = P.count), (_[M] = P.index), M++
      }
      q1.reset()
    } else
      for (let w = 0, x = c.length; w < x; w++)
        if (c[w].visible && c[w].active) {
          const T = c[w].geometryIndex
          let A = !1
          if (
            (g &&
              (this.getMatrixAt(w, ms),
              this.getBoundingSphereAt(T, Iu).applyMatrix4(ms),
              (A = !X1.intersectsSphere(Iu))),
            !A)
          ) {
            const P = m[T]
            ;(u[M] = P.start * a), (h[M] = P.count), (_[M] = w), M++
          }
        }
    ;(y.needsUpdate = !0),
      (this._multiDrawCount = M),
      (this._visibilityChanged = !1)
  }
  onBeforeShadow(e, t, i, r, s, o) {
    this.onBeforeRender(e, null, r, s, o)
  }
}
class ts extends Or {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = 'LineBasicMaterial'),
      (this.color = new Tt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    )
  }
}
const px = new re(),
  mx = new re(),
  sC = new Jt(),
  Gp = new Ih(),
  M0 = new Dr(),
  Y1 = new re(),
  oC = new re()
class Rc extends Ln {
  constructor(e = new _n(), t = new ts()) {
    super(),
      (this.isLine = !0),
      (this.type = 'Line'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  computeLineDistances() {
    const e = this.geometry
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0]
      for (let r = 1, s = t.count; r < s; r++)
        px.fromBufferAttribute(t, r - 1),
          mx.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += px.distanceTo(mx))
      e.setAttribute('lineDistance', new Ft(i, 1))
    } else
      console.warn(
        'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
      )
    return this
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      M0.copy(i.boundingSphere),
      M0.applyMatrix4(r),
      (M0.radius += s),
      e.ray.intersectsSphere(M0) === !1)
    )
      return
    sC.copy(r).invert(), Gp.copy(e.ray).applyMatrix4(sC)
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      c = a * a,
      u = this.isLineSegments ? 2 : 1,
      h = i.index,
      g = i.attributes.position
    if (h !== null) {
      const y = Math.max(0, o.start),
        _ = Math.min(h.count, o.start + o.count)
      for (let M = y, w = _ - 1; M < w; M += u) {
        const x = h.getX(M),
          T = h.getX(M + 1),
          A = E0(this, e, Gp, c, x, T)
        A && t.push(A)
      }
      if (this.isLineLoop) {
        const M = h.getX(_ - 1),
          w = h.getX(y),
          x = E0(this, e, Gp, c, M, w)
        x && t.push(x)
      }
    } else {
      const y = Math.max(0, o.start),
        _ = Math.min(g.count, o.start + o.count)
      for (let M = y, w = _ - 1; M < w; M += u) {
        const x = E0(this, e, Gp, c, M, M + 1)
        x && t.push(x)
      }
      if (this.isLineLoop) {
        const M = E0(this, e, Gp, c, _ - 1, y)
        M && t.push(M)
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t)
    if (i.length > 0) {
      const r = t[i[0]]
      if (r !== void 0) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s)
        }
      }
    }
  }
}
function E0(n, e, t, i, r, s) {
  const o = n.geometry.attributes.position
  if (
    (px.fromBufferAttribute(o, r),
    mx.fromBufferAttribute(o, s),
    t.distanceSqToSegment(px, mx, Y1, oC) > i)
  )
    return
  Y1.applyMatrix4(n.matrixWorld)
  const c = e.ray.origin.distanceTo(Y1)
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      point: oC.clone().applyMatrix4(n.matrixWorld),
      index: r,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: n,
    }
}
const aC = new re(),
  lC = new re()
class Ra extends Rc {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = 'LineSegments')
  }
  computeLineDistances() {
    const e = this.geometry
    if (e.index === null) {
      const t = e.attributes.position,
        i = []
      for (let r = 0, s = t.count; r < s; r += 2)
        aC.fromBufferAttribute(t, r),
          lC.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + aC.distanceTo(lC))
      e.setAttribute('lineDistance', new Ft(i, 1))
    } else
      console.warn(
        'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
      )
    return this
  }
}
class VL extends Rc {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = 'LineLoop')
  }
}
class hE extends Or {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = 'PointsMaterial'),
      (this.color = new Tt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    )
  }
}
const cC = new Jt(),
  BS = new Ih(),
  b0 = new Dr(),
  T0 = new re()
class jL extends Ln {
  constructor(e = new _n(), t = new hE()) {
    super(),
      (this.isPoints = !0),
      (this.type = 'Points'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      b0.copy(i.boundingSphere),
      b0.applyMatrix4(r),
      (b0.radius += s),
      e.ray.intersectsSphere(b0) === !1)
    )
      return
    cC.copy(r).invert(), BS.copy(e.ray).applyMatrix4(cC)
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      c = a * a,
      u = i.index,
      m = i.attributes.position
    if (u !== null) {
      const g = Math.max(0, o.start),
        y = Math.min(u.count, o.start + o.count)
      for (let _ = g, M = y; _ < M; _++) {
        const w = u.getX(_)
        T0.fromBufferAttribute(m, w), uC(T0, w, c, r, e, t, this)
      }
    } else {
      const g = Math.max(0, o.start),
        y = Math.min(m.count, o.start + o.count)
      for (let _ = g, M = y; _ < M; _++)
        T0.fromBufferAttribute(m, _), uC(T0, _, c, r, e, t, this)
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t)
    if (i.length > 0) {
      const r = t[i[0]]
      if (r !== void 0) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s)
        }
      }
    }
  }
}
function uC(n, e, t, i, r, s, o) {
  const a = BS.distanceSqToPoint(n)
  if (a < t) {
    const c = new re()
    BS.closestPointToPoint(n, c), c.applyMatrix4(i)
    const u = r.ray.origin.distanceTo(c)
    if (u < r.near || u > r.far) return
    s.push({
      distance: u,
      distanceToRay: Math.sqrt(a),
      point: c,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o,
    })
  }
}
class Yf extends Ln {
  constructor() {
    super(), (this.isGroup = !0), (this.type = 'Group')
  }
}
class JB extends Xn {
  constructor(e, t, i, r, s, o, a, c, u) {
    super(e, t, i, r, s, o, a, c, u),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : Vn),
      (this.magFilter = s !== void 0 ? s : Vn),
      (this.generateMipmaps = !1)
    const h = this
    function m() {
      ;(h.needsUpdate = !0), e.requestVideoFrameCallback(m)
    }
    'requestVideoFrameCallback' in e && e.requestVideoFrameCallback(m)
  }
  clone() {
    return new this.constructor(this.image).copy(this)
  }
  update() {
    const e = this.image
    'requestVideoFrameCallback' in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0)
  }
}
class ez extends Xn {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = yr),
      (this.minFilter = yr),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0)
  }
}
class n_ extends Xn {
  constructor(e, t, i, r, s, o, a, c, u, h, m, g) {
    super(null, o, a, c, u, h, r, s, m, g),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1)
  }
}
class tz extends n_ {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = r),
      (this.wrapR = Bi),
      (this.layerUpdates = new Set())
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e)
  }
  clearLayerUpdates() {
    this.layerUpdates.clear()
  }
}
class nz extends n_ {
  constructor(e, t, i) {
    super(void 0, e[0].width, e[0].height, t, i, ba),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e)
  }
}
class iz extends Xn {
  constructor(e, t, i, r, s, o, a, c, u) {
    super(e, t, i, r, s, o, a, c, u),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0)
  }
}
class pE extends Xn {
  constructor(e, t, i, r, s, o, a, c, u, h = ad) {
    if (h !== ad && h !== md)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
      )
    i === void 0 && h === ad && (i = Ta),
      i === void 0 && h === md && (i = pd),
      super(null, r, s, o, a, c, h, i, u),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : yr),
      (this.minFilter = c !== void 0 ? c : yr),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null)
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    )
  }
}
class Yo {
  constructor() {
    ;(this.type = 'Curve'), (this.arcLengthDivisions = 200)
  }
  getPoint() {
    return console.warn('THREE.Curve: .getPoint() not implemented.'), null
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e)
    return this.getPoint(i, t)
  }
  getPoints(e = 5) {
    const t = []
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e))
    return t
  }
  getSpacedPoints(e = 5) {
    const t = []
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e))
    return t
  }
  getLength() {
    const e = this.getLengths()
    return e[e.length - 1]
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths
    this.needsUpdate = !1
    const t = []
    let i,
      r = this.getPoint(0),
      s = 0
    t.push(0)
    for (let o = 1; o <= e; o++)
      (i = this.getPoint(o / e)), (s += i.distanceTo(r)), t.push(s), (r = i)
    return (this.cacheArcLengths = t), t
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), this.getLengths()
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths()
    let r = 0
    const s = i.length
    let o
    t ? (o = t) : (o = e * i[s - 1])
    let a = 0,
      c = s - 1,
      u
    for (; a <= c; )
      if (((r = Math.floor(a + (c - a) / 2)), (u = i[r] - o), u < 0)) a = r + 1
      else if (u > 0) c = r - 1
      else {
        c = r
        break
      }
    if (((r = c), i[r] === o)) return r / (s - 1)
    const h = i[r],
      g = i[r + 1] - h,
      y = (o - h) / g
    return (r + y) / (s - 1)
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4
    r < 0 && (r = 0), s > 1 && (s = 1)
    const o = this.getPoint(r),
      a = this.getPoint(s),
      c = t || (o.isVector2 ? new qe() : new re())
    return c.copy(a).sub(o).normalize(), c
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e)
    return this.getTangent(i, t)
  }
  computeFrenetFrames(e, t) {
    const i = new re(),
      r = [],
      s = [],
      o = [],
      a = new re(),
      c = new Jt()
    for (let y = 0; y <= e; y++) {
      const _ = y / e
      r[y] = this.getTangentAt(_, new re())
    }
    ;(s[0] = new re()), (o[0] = new re())
    let u = Number.MAX_VALUE
    const h = Math.abs(r[0].x),
      m = Math.abs(r[0].y),
      g = Math.abs(r[0].z)
    h <= u && ((u = h), i.set(1, 0, 0)),
      m <= u && ((u = m), i.set(0, 1, 0)),
      g <= u && i.set(0, 0, 1),
      a.crossVectors(r[0], i).normalize(),
      s[0].crossVectors(r[0], a),
      o[0].crossVectors(r[0], s[0])
    for (let y = 1; y <= e; y++) {
      if (
        ((s[y] = s[y - 1].clone()),
        (o[y] = o[y - 1].clone()),
        a.crossVectors(r[y - 1], r[y]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize()
        const _ = Math.acos(un(r[y - 1].dot(r[y]), -1, 1))
        s[y].applyMatrix4(c.makeRotationAxis(a, _))
      }
      o[y].crossVectors(r[y], s[y])
    }
    if (t === !0) {
      let y = Math.acos(un(s[0].dot(s[e]), -1, 1))
      ;(y /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (y = -y)
      for (let _ = 1; _ <= e; _++)
        s[_].applyMatrix4(c.makeRotationAxis(r[_], y * _)),
          o[_].crossVectors(r[_], s[_])
    }
    return { tangents: r, normals: s, binormals: o }
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: 'Curve', generator: 'Curve.toJSON' },
    }
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    )
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this
  }
}
class i_ extends Yo {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    r = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    c = 0,
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = 'EllipseCurve'),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = c)
  }
  getPoint(e, t = new qe()) {
    const i = t,
      r = Math.PI * 2
    let s = this.aEndAngle - this.aStartAngle
    const o = Math.abs(s) < Number.EPSILON
    for (; s < 0; ) s += r
    for (; s > r; ) s -= r
    s < Number.EPSILON && (o ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r))
    const a = this.aStartAngle + e * s
    let c = this.aX + this.xRadius * Math.cos(a),
      u = this.aY + this.yRadius * Math.sin(a)
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        m = Math.sin(this.aRotation),
        g = c - this.aX,
        y = u - this.aY
      ;(c = g * h - y * m + this.aX), (u = g * m + y * h + this.aY)
    }
    return i.set(c, u)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    )
  }
}
class HL extends i_ {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o), (this.isArcCurve = !0), (this.type = 'ArcCurve')
  }
}
function mE() {
  let n = 0,
    e = 0,
    t = 0,
    i = 0
  function r(s, o, a, c) {
    ;(n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - c),
      (i = 2 * s - 2 * o + a + c)
  }
  return {
    initCatmullRom: function (s, o, a, c, u) {
      r(o, a, u * (a - s), u * (c - o))
    },
    initNonuniformCatmullRom: function (s, o, a, c, u, h, m) {
      let g = (o - s) / u - (a - s) / (u + h) + (a - o) / h,
        y = (a - o) / h - (c - o) / (h + m) + (c - a) / m
      ;(g *= h), (y *= h), r(o, a, g, y)
    },
    calc: function (s) {
      const o = s * s,
        a = o * s
      return n + e * s + t * o + i * a
    },
  }
}
const A0 = new re(),
  Z1 = new mE(),
  K1 = new mE(),
  Q1 = new mE()
class GL extends Yo {
  constructor(e = [], t = !1, i = 'centripetal', r = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = 'CatmullRomCurve3'),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = r)
  }
  getPoint(e, t = new re()) {
    const i = t,
      r = this.points,
      s = r.length,
      o = (s - (this.closed ? 0 : 1)) * e
    let a = Math.floor(o),
      c = o - a
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : c === 0 && a === s - 1 && ((a = s - 2), (c = 1))
    let u, h
    this.closed || a > 0
      ? (u = r[(a - 1) % s])
      : (A0.subVectors(r[0], r[1]).add(r[0]), (u = A0))
    const m = r[a % s],
      g = r[(a + 1) % s]
    if (
      (this.closed || a + 2 < s
        ? (h = r[(a + 2) % s])
        : (A0.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (h = A0)),
      this.curveType === 'centripetal' || this.curveType === 'chordal')
    ) {
      const y = this.curveType === 'chordal' ? 0.5 : 0.25
      let _ = Math.pow(u.distanceToSquared(m), y),
        M = Math.pow(m.distanceToSquared(g), y),
        w = Math.pow(g.distanceToSquared(h), y)
      M < 1e-4 && (M = 1),
        _ < 1e-4 && (_ = M),
        w < 1e-4 && (w = M),
        Z1.initNonuniformCatmullRom(u.x, m.x, g.x, h.x, _, M, w),
        K1.initNonuniformCatmullRom(u.y, m.y, g.y, h.y, _, M, w),
        Q1.initNonuniformCatmullRom(u.z, m.z, g.z, h.z, _, M, w)
    } else
      this.curveType === 'catmullrom' &&
        (Z1.initCatmullRom(u.x, m.x, g.x, h.x, this.tension),
        K1.initCatmullRom(u.y, m.y, g.y, h.y, this.tension),
        Q1.initCatmullRom(u.z, m.z, g.z, h.z, this.tension))
    return i.set(Z1.calc(c), K1.calc(c), Q1.calc(c)), i
  }
  copy(e) {
    super.copy(e), (this.points = [])
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t]
      this.points.push(r.clone())
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    e.points = []
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t]
      e.points.push(r.toArray())
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    )
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = [])
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t]
      this.points.push(new re().fromArray(r))
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    )
  }
}
function dC(n, e, t, i, r) {
  const s = (i - e) * 0.5,
    o = (r - t) * 0.5,
    a = n * n,
    c = n * a
  return (
    (2 * t - 2 * i + s + o) * c + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
  )
}
function rz(n, e) {
  const t = 1 - n
  return t * t * e
}
function sz(n, e) {
  return 2 * (1 - n) * n * e
}
function oz(n, e) {
  return n * n * e
}
function Mm(n, e, t, i) {
  return rz(n, e) + sz(n, t) + oz(n, i)
}
function az(n, e) {
  const t = 1 - n
  return t * t * t * e
}
function lz(n, e) {
  const t = 1 - n
  return 3 * t * t * n * e
}
function cz(n, e) {
  return 3 * (1 - n) * n * n * e
}
function uz(n, e) {
  return n * n * n * e
}
function Em(n, e, t, i, r) {
  return az(n, e) + lz(n, t) + cz(n, i) + uz(n, r)
}
class gE extends Yo {
  constructor(e = new qe(), t = new qe(), i = new qe(), r = new qe()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r)
  }
  getPoint(e, t = new qe()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3
    return i.set(Em(e, r.x, s.x, o.x, a.x), Em(e, r.y, s.y, o.y, a.y)), i
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    )
  }
}
class WL extends Yo {
  constructor(e = new re(), t = new re(), i = new re(), r = new re()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r)
  }
  getPoint(e, t = new re()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3
    return (
      i.set(
        Em(e, r.x, s.x, o.x, a.x),
        Em(e, r.y, s.y, o.y, a.y),
        Em(e, r.z, s.z, o.z, a.z),
      ),
      i
    )
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    )
  }
}
class vE extends Yo {
  constructor(e = new qe(), t = new qe()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = 'LineCurve'),
      (this.v1 = e),
      (this.v2 = t)
  }
  getPoint(e, t = new qe()) {
    const i = t
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    )
  }
  getPointAt(e, t) {
    return this.getPoint(e, t)
  }
  getTangent(e, t = new qe()) {
    return t.subVectors(this.v2, this.v1).normalize()
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t)
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
  }
  toJSON() {
    const e = super.toJSON()
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    )
  }
}
class $L extends Yo {
  constructor(e = new re(), t = new re()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = 'LineCurve3'),
      (this.v1 = e),
      (this.v2 = t)
  }
  getPoint(e, t = new re()) {
    const i = t
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    )
  }
  getPointAt(e, t) {
    return this.getPoint(e, t)
  }
  getTangent(e, t = new re()) {
    return t.subVectors(this.v2, this.v1).normalize()
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t)
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
  }
  toJSON() {
    const e = super.toJSON()
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    )
  }
}
class yE extends Yo {
  constructor(e = new qe(), t = new qe(), i = new qe()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = 'QuadraticBezierCurve'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i)
  }
  getPoint(e, t = new qe()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2
    return i.set(Mm(e, r.x, s.x, o.x), Mm(e, r.y, s.y, o.y)), i
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    )
  }
}
class xE extends Yo {
  constructor(e = new re(), t = new re(), i = new re()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = 'QuadraticBezierCurve3'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i)
  }
  getPoint(e, t = new re()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2
    return (
      i.set(Mm(e, r.x, s.x, o.x), Mm(e, r.y, s.y, o.y), Mm(e, r.z, s.z, o.z)), i
    )
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    )
  }
}
class _E extends Yo {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = 'SplineCurve'),
      (this.points = e)
  }
  getPoint(e, t = new qe()) {
    const i = t,
      r = this.points,
      s = (r.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      c = r[o === 0 ? o : o - 1],
      u = r[o],
      h = r[o > r.length - 2 ? r.length - 1 : o + 1],
      m = r[o > r.length - 3 ? r.length - 1 : o + 2]
    return i.set(dC(a, c.x, u.x, h.x, m.x), dC(a, c.y, u.y, h.y, m.y)), i
  }
  copy(e) {
    super.copy(e), (this.points = [])
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t]
      this.points.push(r.clone())
    }
    return this
  }
  toJSON() {
    const e = super.toJSON()
    e.points = []
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t]
      e.points.push(r.toArray())
    }
    return e
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = [])
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t]
      this.points.push(new qe().fromArray(r))
    }
    return this
  }
}
var gx = Object.freeze({
  __proto__: null,
  ArcCurve: HL,
  CatmullRomCurve3: GL,
  CubicBezierCurve: gE,
  CubicBezierCurve3: WL,
  EllipseCurve: i_,
  LineCurve: vE,
  LineCurve3: $L,
  QuadraticBezierCurve: yE,
  QuadraticBezierCurve3: xE,
  SplineCurve: _E,
})
class XL extends Yo {
  constructor() {
    super(),
      (this.type = 'CurvePath'),
      (this.curves = []),
      (this.autoClose = !1)
  }
  add(e) {
    this.curves.push(e)
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1)
    if (!e.equals(t)) {
      const i = e.isVector2 === !0 ? 'LineCurve' : 'LineCurve3'
      this.curves.push(new gx[i](t, e))
    }
    return this
  }
  getPoint(e, t) {
    const i = e * this.getLength(),
      r = this.getCurveLengths()
    let s = 0
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i,
          a = this.curves[s],
          c = a.getLength(),
          u = c === 0 ? 0 : 1 - o / c
        return a.getPointAt(u, t)
      }
      s++
    }
    return null
  }
  getLength() {
    const e = this.getCurveLengths()
    return e[e.length - 1]
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths()
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths
    const e = []
    let t = 0
    for (let i = 0, r = this.curves.length; i < r; i++)
      (t += this.curves[i].getLength()), e.push(t)
    return (this.cacheLengths = e), e
  }
  getSpacedPoints(e = 40) {
    const t = []
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e))
    return this.autoClose && t.push(t[0]), t
  }
  getPoints(e = 12) {
    const t = []
    let i
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        c = o.getPoints(a)
      for (let u = 0; u < c.length; u++) {
        const h = c[u]
        ;(i && i.equals(h)) || (t.push(h), (i = h))
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    )
  }
  copy(e) {
    super.copy(e), (this.curves = [])
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t]
      this.curves.push(r.clone())
    }
    return (this.autoClose = e.autoClose), this
  }
  toJSON() {
    const e = super.toJSON()
    ;(e.autoClose = this.autoClose), (e.curves = [])
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t]
      e.curves.push(r.toJSON())
    }
    return e
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = [])
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t]
      this.curves.push(new gx[r.type]().fromJSON(r))
    }
    return this
  }
}
class Ym extends XL {
  constructor(e) {
    super(),
      (this.type = 'Path'),
      (this.currentPoint = new qe()),
      e && this.setFromPoints(e)
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y)
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y)
    return this
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this
  }
  lineTo(e, t) {
    const i = new vE(this.currentPoint.clone(), new qe(e, t))
    return this.curves.push(i), this.currentPoint.set(e, t), this
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new yE(this.currentPoint.clone(), new qe(e, t), new qe(i, r))
    return this.curves.push(s), this.currentPoint.set(i, r), this
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new gE(
      this.currentPoint.clone(),
      new qe(e, t),
      new qe(i, r),
      new qe(s, o),
    )
    return this.curves.push(a), this.currentPoint.set(s, o), this
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      i = new _E(t)
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x,
      c = this.currentPoint.y
    return this.absarc(e + a, t + c, i, r, s, o), this
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this
  }
  ellipse(e, t, i, r, s, o, a, c) {
    const u = this.currentPoint.x,
      h = this.currentPoint.y
    return this.absellipse(e + u, t + h, i, r, s, o, a, c), this
  }
  absellipse(e, t, i, r, s, o, a, c) {
    const u = new i_(e, t, i, r, s, o, a, c)
    if (this.curves.length > 0) {
      const m = u.getPoint(0)
      m.equals(this.currentPoint) || this.lineTo(m.x, m.y)
    }
    this.curves.push(u)
    const h = u.getPoint(1)
    return this.currentPoint.copy(h), this
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this
  }
  toJSON() {
    const e = super.toJSON()
    return (e.currentPoint = this.currentPoint.toArray()), e
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
  }
}
class Dg extends _n {
  constructor(
    e = [new qe(0, -0.5), new qe(0.5, 0), new qe(0, 0.5)],
    t = 12,
    i = 0,
    r = Math.PI * 2,
  ) {
    super(),
      (this.type = 'LatheGeometry'),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
      (t = Math.floor(t)),
      (r = un(r, 0, Math.PI * 2))
    const s = [],
      o = [],
      a = [],
      c = [],
      u = [],
      h = 1 / t,
      m = new re(),
      g = new qe(),
      y = new re(),
      _ = new re(),
      M = new re()
    let w = 0,
      x = 0
    for (let T = 0; T <= e.length - 1; T++)
      switch (T) {
        case 0:
          ;(w = e[T + 1].x - e[T].x),
            (x = e[T + 1].y - e[T].y),
            (y.x = x * 1),
            (y.y = -w),
            (y.z = x * 0),
            M.copy(y),
            y.normalize(),
            c.push(y.x, y.y, y.z)
          break
        case e.length - 1:
          c.push(M.x, M.y, M.z)
          break
        default:
          ;(w = e[T + 1].x - e[T].x),
            (x = e[T + 1].y - e[T].y),
            (y.x = x * 1),
            (y.y = -w),
            (y.z = x * 0),
            _.copy(y),
            (y.x += M.x),
            (y.y += M.y),
            (y.z += M.z),
            y.normalize(),
            c.push(y.x, y.y, y.z),
            M.copy(_)
      }
    for (let T = 0; T <= t; T++) {
      const A = i + T * h * r,
        P = Math.sin(A),
        D = Math.cos(A)
      for (let O = 0; O <= e.length - 1; O++) {
        ;(m.x = e[O].x * P),
          (m.y = e[O].y),
          (m.z = e[O].x * D),
          o.push(m.x, m.y, m.z),
          (g.x = T / t),
          (g.y = O / (e.length - 1)),
          a.push(g.x, g.y)
        const U = c[3 * O + 0] * P,
          F = c[3 * O + 1],
          N = c[3 * O + 0] * D
        u.push(U, F, N)
      }
    }
    for (let T = 0; T < t; T++)
      for (let A = 0; A < e.length - 1; A++) {
        const P = A + T * e.length,
          D = P,
          O = P + e.length,
          U = P + e.length + 1,
          F = P + 1
        s.push(D, O, F), s.push(U, F, O)
      }
    this.setIndex(s),
      this.setAttribute('position', new Ft(o, 3)),
      this.setAttribute('uv', new Ft(a, 2)),
      this.setAttribute('normal', new Ft(u, 3))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new Dg(e.points, e.segments, e.phiStart, e.phiLength)
  }
}
class r_ extends Dg {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new Ym()
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(i), r),
      (this.type = 'CapsuleGeometry'),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: i,
        radialSegments: r,
      })
  }
  static fromJSON(e) {
    return new r_(e.radius, e.length, e.capSegments, e.radialSegments)
  }
}
class s_ extends _n {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    super(),
      (this.type = 'CircleGeometry'),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: r,
      }),
      (t = Math.max(3, t))
    const s = [],
      o = [],
      a = [],
      c = [],
      u = new re(),
      h = new qe()
    o.push(0, 0, 0), a.push(0, 0, 1), c.push(0.5, 0.5)
    for (let m = 0, g = 3; m <= t; m++, g += 3) {
      const y = i + (m / t) * r
      ;(u.x = e * Math.cos(y)),
        (u.y = e * Math.sin(y)),
        o.push(u.x, u.y, u.z),
        a.push(0, 0, 1),
        (h.x = (o[g] / e + 1) / 2),
        (h.y = (o[g + 1] / e + 1) / 2),
        c.push(h.x, h.y)
    }
    for (let m = 1; m <= t; m++) s.push(m, m + 1, 0)
    this.setIndex(s),
      this.setAttribute('position', new Ft(o, 3)),
      this.setAttribute('normal', new Ft(a, 3)),
      this.setAttribute('uv', new Ft(c, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new s_(e.radius, e.segments, e.thetaStart, e.thetaLength)
  }
}
class Lh extends _n {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    r = 32,
    s = 1,
    o = !1,
    a = 0,
    c = Math.PI * 2,
  ) {
    super(),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: c,
      })
    const u = this
    ;(r = Math.floor(r)), (s = Math.floor(s))
    const h = [],
      m = [],
      g = [],
      y = []
    let _ = 0
    const M = [],
      w = i / 2
    let x = 0
    T(),
      o === !1 && (e > 0 && A(!0), t > 0 && A(!1)),
      this.setIndex(h),
      this.setAttribute('position', new Ft(m, 3)),
      this.setAttribute('normal', new Ft(g, 3)),
      this.setAttribute('uv', new Ft(y, 2))
    function T() {
      const P = new re(),
        D = new re()
      let O = 0
      const U = (t - e) / i
      for (let F = 0; F <= s; F++) {
        const N = [],
          k = F / s,
          z = k * (t - e) + e
        for (let $ = 0; $ <= r; $++) {
          const te = $ / r,
            j = te * c + a,
            K = Math.sin(j),
            J = Math.cos(j)
          ;(D.x = z * K),
            (D.y = -k * i + w),
            (D.z = z * J),
            m.push(D.x, D.y, D.z),
            P.set(K, U, J).normalize(),
            g.push(P.x, P.y, P.z),
            y.push(te, 1 - k),
            N.push(_++)
        }
        M.push(N)
      }
      for (let F = 0; F < r; F++)
        for (let N = 0; N < s; N++) {
          const k = M[N][F],
            z = M[N + 1][F],
            $ = M[N + 1][F + 1],
            te = M[N][F + 1]
          ;(e > 0 || N !== 0) && (h.push(k, z, te), (O += 3)),
            (t > 0 || N !== s - 1) && (h.push(z, $, te), (O += 3))
        }
      u.addGroup(x, O, 0), (x += O)
    }
    function A(P) {
      const D = _,
        O = new qe(),
        U = new re()
      let F = 0
      const N = P === !0 ? e : t,
        k = P === !0 ? 1 : -1
      for (let $ = 1; $ <= r; $++)
        m.push(0, w * k, 0), g.push(0, k, 0), y.push(0.5, 0.5), _++
      const z = _
      for (let $ = 0; $ <= r; $++) {
        const j = ($ / r) * c + a,
          K = Math.cos(j),
          J = Math.sin(j)
        ;(U.x = N * J),
          (U.y = w * k),
          (U.z = N * K),
          m.push(U.x, U.y, U.z),
          g.push(0, k, 0),
          (O.x = K * 0.5 + 0.5),
          (O.y = J * 0.5 * k + 0.5),
          y.push(O.x, O.y),
          _++
      }
      for (let $ = 0; $ < r; $++) {
        const te = D + $,
          j = z + $
        P === !0 ? h.push(j, j + 1, te) : h.push(j + 1, j, te), (F += 3)
      }
      u.addGroup(x, F, P === !0 ? 1 : 2), (x += F)
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new Lh(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    )
  }
}
class o_ extends Lh {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a),
      (this.type = 'ConeGeometry'),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      })
  }
  static fromJSON(e) {
    return new o_(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    )
  }
}
class Fc extends _n {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(),
      (this.type = 'PolyhedronGeometry'),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r })
    const s = [],
      o = []
    a(r),
      u(i),
      h(),
      this.setAttribute('position', new Ft(s, 3)),
      this.setAttribute('normal', new Ft(s.slice(), 3)),
      this.setAttribute('uv', new Ft(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals()
    function a(T) {
      const A = new re(),
        P = new re(),
        D = new re()
      for (let O = 0; O < t.length; O += 3)
        y(t[O + 0], A), y(t[O + 1], P), y(t[O + 2], D), c(A, P, D, T)
    }
    function c(T, A, P, D) {
      const O = D + 1,
        U = []
      for (let F = 0; F <= O; F++) {
        U[F] = []
        const N = T.clone().lerp(P, F / O),
          k = A.clone().lerp(P, F / O),
          z = O - F
        for (let $ = 0; $ <= z; $++)
          $ === 0 && F === O
            ? (U[F][$] = N)
            : (U[F][$] = N.clone().lerp(k, $ / z))
      }
      for (let F = 0; F < O; F++)
        for (let N = 0; N < 2 * (O - F) - 1; N++) {
          const k = Math.floor(N / 2)
          N % 2 === 0
            ? (g(U[F][k + 1]), g(U[F + 1][k]), g(U[F][k]))
            : (g(U[F][k + 1]), g(U[F + 1][k + 1]), g(U[F + 1][k]))
        }
    }
    function u(T) {
      const A = new re()
      for (let P = 0; P < s.length; P += 3)
        (A.x = s[P + 0]),
          (A.y = s[P + 1]),
          (A.z = s[P + 2]),
          A.normalize().multiplyScalar(T),
          (s[P + 0] = A.x),
          (s[P + 1] = A.y),
          (s[P + 2] = A.z)
    }
    function h() {
      const T = new re()
      for (let A = 0; A < s.length; A += 3) {
        ;(T.x = s[A + 0]), (T.y = s[A + 1]), (T.z = s[A + 2])
        const P = w(T) / 2 / Math.PI + 0.5,
          D = x(T) / Math.PI + 0.5
        o.push(P, 1 - D)
      }
      _(), m()
    }
    function m() {
      for (let T = 0; T < o.length; T += 6) {
        const A = o[T + 0],
          P = o[T + 2],
          D = o[T + 4],
          O = Math.max(A, P, D),
          U = Math.min(A, P, D)
        O > 0.9 &&
          U < 0.1 &&
          (A < 0.2 && (o[T + 0] += 1),
          P < 0.2 && (o[T + 2] += 1),
          D < 0.2 && (o[T + 4] += 1))
      }
    }
    function g(T) {
      s.push(T.x, T.y, T.z)
    }
    function y(T, A) {
      const P = T * 3
      ;(A.x = e[P + 0]), (A.y = e[P + 1]), (A.z = e[P + 2])
    }
    function _() {
      const T = new re(),
        A = new re(),
        P = new re(),
        D = new re(),
        O = new qe(),
        U = new qe(),
        F = new qe()
      for (let N = 0, k = 0; N < s.length; N += 9, k += 6) {
        T.set(s[N + 0], s[N + 1], s[N + 2]),
          A.set(s[N + 3], s[N + 4], s[N + 5]),
          P.set(s[N + 6], s[N + 7], s[N + 8]),
          O.set(o[k + 0], o[k + 1]),
          U.set(o[k + 2], o[k + 3]),
          F.set(o[k + 4], o[k + 5]),
          D.copy(T).add(A).add(P).divideScalar(3)
        const z = w(D)
        M(O, k + 0, T, z), M(U, k + 2, A, z), M(F, k + 4, P, z)
      }
    }
    function M(T, A, P, D) {
      D < 0 && T.x === 1 && (o[A] = T.x - 1),
        P.x === 0 && P.z === 0 && (o[A] = D / 2 / Math.PI + 0.5)
    }
    function w(T) {
      return Math.atan2(T.z, -T.x)
    }
    function x(T) {
      return Math.atan2(-T.y, Math.sqrt(T.x * T.x + T.z * T.z))
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new Fc(e.vertices, e.indices, e.radius, e.details)
  }
}
class a_ extends Fc {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = 1 / i,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        0,
        -i,
        0,
        -r,
        i,
        0,
        -r,
        -i,
        0,
        r,
        i,
        0,
        r,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ]
    super(s, o, e, t),
      (this.type = 'DodecahedronGeometry'),
      (this.parameters = { radius: e, detail: t })
  }
  static fromJSON(e) {
    return new a_(e.radius, e.detail)
  }
}
const C0 = new re(),
  P0 = new re(),
  J1 = new re(),
  R0 = new ys()
class qL extends _n {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = 'EdgesGeometry'),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(ld * t),
        o = e.getIndex(),
        a = e.getAttribute('position'),
        c = o ? o.count : a.count,
        u = [0, 0, 0],
        h = ['a', 'b', 'c'],
        m = new Array(3),
        g = {},
        y = []
      for (let _ = 0; _ < c; _ += 3) {
        o
          ? ((u[0] = o.getX(_)), (u[1] = o.getX(_ + 1)), (u[2] = o.getX(_ + 2)))
          : ((u[0] = _), (u[1] = _ + 1), (u[2] = _ + 2))
        const { a: M, b: w, c: x } = R0
        if (
          (M.fromBufferAttribute(a, u[0]),
          w.fromBufferAttribute(a, u[1]),
          x.fromBufferAttribute(a, u[2]),
          R0.getNormal(J1),
          (m[0] = `${Math.round(M.x * r)},${Math.round(M.y * r)},${Math.round(
            M.z * r,
          )}`),
          (m[1] = `${Math.round(w.x * r)},${Math.round(w.y * r)},${Math.round(
            w.z * r,
          )}`),
          (m[2] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(
            x.z * r,
          )}`),
          !(m[0] === m[1] || m[1] === m[2] || m[2] === m[0]))
        )
          for (let T = 0; T < 3; T++) {
            const A = (T + 1) % 3,
              P = m[T],
              D = m[A],
              O = R0[h[T]],
              U = R0[h[A]],
              F = `${P}_${D}`,
              N = `${D}_${P}`
            N in g && g[N]
              ? (J1.dot(g[N].normal) <= s &&
                  (y.push(O.x, O.y, O.z), y.push(U.x, U.y, U.z)),
                (g[N] = null))
              : F in g ||
                (g[F] = { index0: u[T], index1: u[A], normal: J1.clone() })
          }
      }
      for (const _ in g)
        if (g[_]) {
          const { index0: M, index1: w } = g[_]
          C0.fromBufferAttribute(a, M),
            P0.fromBufferAttribute(a, w),
            y.push(C0.x, C0.y, C0.z),
            y.push(P0.x, P0.y, P0.z)
        }
      this.setAttribute('position', new Ft(y, 3))
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
}
class ud extends Ym {
  constructor(e) {
    super(e), (this.uuid = Ds()), (this.type = 'Shape'), (this.holes = [])
  }
  getPointsHoles(e) {
    const t = []
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e)
    return t
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) }
  }
  copy(e) {
    super.copy(e), (this.holes = [])
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t]
      this.holes.push(r.clone())
    }
    return this
  }
  toJSON() {
    const e = super.toJSON()
    ;(e.uuid = this.uuid), (e.holes = [])
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t]
      e.holes.push(r.toJSON())
    }
    return e
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = [])
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t]
      this.holes.push(new Ym().fromJSON(r))
    }
    return this
  }
}
const dz = {
  triangulate: function (n, e, t = 2) {
    const i = e && e.length,
      r = i ? e[0] * t : n.length
    let s = YL(n, 0, r, t, !0)
    const o = []
    if (!s || s.next === s.prev) return o
    let a, c, u, h, m, g, y
    if ((i && (s = gz(n, e, s, t)), n.length > 80 * t)) {
      ;(a = u = n[0]), (c = h = n[1])
      for (let _ = t; _ < r; _ += t)
        (m = n[_]),
          (g = n[_ + 1]),
          m < a && (a = m),
          g < c && (c = g),
          m > u && (u = m),
          g > h && (h = g)
      ;(y = Math.max(u - a, h - c)), (y = y !== 0 ? 32767 / y : 0)
    }
    return Zm(s, o, t, a, c, y, 0), o
  },
}
function YL(n, e, t, i, r) {
  let s, o
  if (r === Az(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = fC(s, n[s], n[s + 1], o)
  else for (s = t - i; s >= e; s -= i) o = fC(s, n[s], n[s + 1], o)
  return o && l_(o, o.next) && (Qm(o), (o = o.next)), o
}
function vd(n, e) {
  if (!n) return n
  e || (e = n)
  let t = n,
    i
  do
    if (
      ((i = !1), !t.steiner && (l_(t, t.next) || hi(t.prev, t, t.next) === 0))
    ) {
      if ((Qm(t), (t = e = t.prev), t === t.next)) break
      i = !0
    } else t = t.next
  while (i || t !== e)
  return e
}
function Zm(n, e, t, i, r, s, o) {
  if (!n) return
  !o && s && wz(n, i, r, s)
  let a = n,
    c,
    u
  for (; n.prev !== n.next; ) {
    if (((c = n.prev), (u = n.next), s ? hz(n, i, r, s) : fz(n))) {
      e.push((c.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((u.i / t) | 0),
        Qm(n),
        (n = u.next),
        (a = u.next)
      continue
    }
    if (((n = u), n === a)) {
      o
        ? o === 1
          ? ((n = pz(vd(n), e, t)), Zm(n, e, t, i, r, s, 2))
          : o === 2 && mz(n, e, t, i, r, s)
        : Zm(vd(n), e, t, i, r, s, 1)
      break
    }
  }
}
function fz(n) {
  const e = n.prev,
    t = n,
    i = n.next
  if (hi(e, t, i) >= 0) return !1
  const r = e.x,
    s = t.x,
    o = i.x,
    a = e.y,
    c = t.y,
    u = i.y,
    h = r < s ? (r < o ? r : o) : s < o ? s : o,
    m = a < c ? (a < u ? a : u) : c < u ? c : u,
    g = r > s ? (r > o ? r : o) : s > o ? s : o,
    y = a > c ? (a > u ? a : u) : c > u ? c : u
  let _ = i.next
  for (; _ !== e; ) {
    if (
      _.x >= h &&
      _.x <= g &&
      _.y >= m &&
      _.y <= y &&
      Zf(r, a, s, c, o, u, _.x, _.y) &&
      hi(_.prev, _, _.next) >= 0
    )
      return !1
    _ = _.next
  }
  return !0
}
function hz(n, e, t, i) {
  const r = n.prev,
    s = n,
    o = n.next
  if (hi(r, s, o) >= 0) return !1
  const a = r.x,
    c = s.x,
    u = o.x,
    h = r.y,
    m = s.y,
    g = o.y,
    y = a < c ? (a < u ? a : u) : c < u ? c : u,
    _ = h < m ? (h < g ? h : g) : m < g ? m : g,
    M = a > c ? (a > u ? a : u) : c > u ? c : u,
    w = h > m ? (h > g ? h : g) : m > g ? m : g,
    x = zS(y, _, e, t, i),
    T = zS(M, w, e, t, i)
  let A = n.prevZ,
    P = n.nextZ
  for (; A && A.z >= x && P && P.z <= T; ) {
    if (
      (A.x >= y &&
        A.x <= M &&
        A.y >= _ &&
        A.y <= w &&
        A !== r &&
        A !== o &&
        Zf(a, h, c, m, u, g, A.x, A.y) &&
        hi(A.prev, A, A.next) >= 0) ||
      ((A = A.prevZ),
      P.x >= y &&
        P.x <= M &&
        P.y >= _ &&
        P.y <= w &&
        P !== r &&
        P !== o &&
        Zf(a, h, c, m, u, g, P.x, P.y) &&
        hi(P.prev, P, P.next) >= 0)
    )
      return !1
    P = P.nextZ
  }
  for (; A && A.z >= x; ) {
    if (
      A.x >= y &&
      A.x <= M &&
      A.y >= _ &&
      A.y <= w &&
      A !== r &&
      A !== o &&
      Zf(a, h, c, m, u, g, A.x, A.y) &&
      hi(A.prev, A, A.next) >= 0
    )
      return !1
    A = A.prevZ
  }
  for (; P && P.z <= T; ) {
    if (
      P.x >= y &&
      P.x <= M &&
      P.y >= _ &&
      P.y <= w &&
      P !== r &&
      P !== o &&
      Zf(a, h, c, m, u, g, P.x, P.y) &&
      hi(P.prev, P, P.next) >= 0
    )
      return !1
    P = P.nextZ
  }
  return !0
}
function pz(n, e, t) {
  let i = n
  do {
    const r = i.prev,
      s = i.next.next
    !l_(r, s) &&
      ZL(r, i, i.next, s) &&
      Km(r, s) &&
      Km(s, r) &&
      (e.push((r.i / t) | 0),
      e.push((i.i / t) | 0),
      e.push((s.i / t) | 0),
      Qm(i),
      Qm(i.next),
      (i = n = s)),
      (i = i.next)
  } while (i !== n)
  return vd(i)
}
function mz(n, e, t, i, r, s) {
  let o = n
  do {
    let a = o.next.next
    for (; a !== o.prev; ) {
      if (o.i !== a.i && Ez(o, a)) {
        let c = KL(o, a)
        ;(o = vd(o, o.next)),
          (c = vd(c, c.next)),
          Zm(o, e, t, i, r, s, 0),
          Zm(c, e, t, i, r, s, 0)
        return
      }
      a = a.next
    }
    o = o.next
  } while (o !== n)
}
function gz(n, e, t, i) {
  const r = []
  let s, o, a, c, u
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * i),
      (c = s < o - 1 ? e[s + 1] * i : n.length),
      (u = YL(n, a, c, i, !1)),
      u === u.next && (u.steiner = !0),
      r.push(Mz(u))
  for (r.sort(vz), s = 0; s < r.length; s++) t = yz(r[s], t)
  return t
}
function vz(n, e) {
  return n.x - e.x
}
function yz(n, e) {
  const t = xz(n, e)
  if (!t) return e
  const i = KL(t, n)
  return vd(i, i.next), vd(t, t.next)
}
function xz(n, e) {
  let t = e,
    i = -1 / 0,
    r
  const s = n.x,
    o = n.y
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const g = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y)
      if (
        g <= s &&
        g > i &&
        ((i = g), (r = t.x < t.next.x ? t : t.next), g === s)
      )
        return r
    }
    t = t.next
  } while (t !== e)
  if (!r) return null
  const a = r,
    c = r.x,
    u = r.y
  let h = 1 / 0,
    m
  t = r
  do
    s >= t.x &&
      t.x >= c &&
      s !== t.x &&
      Zf(o < u ? s : i, o, c, u, o < u ? i : s, o, t.x, t.y) &&
      ((m = Math.abs(o - t.y) / (s - t.x)),
      Km(t, n) &&
        (m < h || (m === h && (t.x > r.x || (t.x === r.x && _z(r, t))))) &&
        ((r = t), (h = m))),
      (t = t.next)
  while (t !== a)
  return r
}
function _z(n, e) {
  return hi(n.prev, n, e.prev) < 0 && hi(e.next, n, n.next) < 0
}
function wz(n, e, t, i) {
  let r = n
  do
    r.z === 0 && (r.z = zS(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next)
  while (r !== n)
  ;(r.prevZ.nextZ = null), (r.prevZ = null), Sz(r)
}
function Sz(n) {
  let e,
    t,
    i,
    r,
    s,
    o,
    a,
    c,
    u = 1
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < u && (a++, (i = i.nextZ), !!i); e++);
      for (c = u; a > 0 || (c > 0 && i); )
        a !== 0 && (c === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), c--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r)
      t = i
    }
    ;(s.nextZ = null), (u *= 2)
  } while (o > 1)
  return n
}
function zS(n, e, t, i, r) {
  return (
    (n = ((n - t) * r) | 0),
    (e = ((e - i) * r) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  )
}
function Mz(n) {
  let e = n,
    t = n
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next)
  while (e !== n)
  return t
}
function Zf(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (i - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (r - o) * (i - a)
  )
}
function Ez(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !bz(n, e) &&
    ((Km(n, e) &&
      Km(e, n) &&
      Tz(n, e) &&
      (hi(n.prev, n, e.prev) || hi(n, e.prev, e))) ||
      (l_(n, e) && hi(n.prev, n, n.next) > 0 && hi(e.prev, e, e.next) > 0))
  )
}
function hi(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function l_(n, e) {
  return n.x === e.x && n.y === e.y
}
function ZL(n, e, t, i) {
  const r = L0(hi(n, e, t)),
    s = L0(hi(n, e, i)),
    o = L0(hi(t, i, n)),
    a = L0(hi(t, i, e))
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && I0(n, t, e)) ||
    (s === 0 && I0(n, i, e)) ||
    (o === 0 && I0(t, n, i)) ||
    (a === 0 && I0(t, e, i))
  )
}
function I0(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  )
}
function L0(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0
}
function bz(n, e) {
  let t = n
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      ZL(t, t.next, n, e)
    )
      return !0
    t = t.next
  } while (t !== n)
  return !1
}
function Km(n, e) {
  return hi(n.prev, n, n.next) < 0
    ? hi(n, e, n.next) >= 0 && hi(n, n.prev, e) >= 0
    : hi(n, e, n.prev) < 0 || hi(n, n.next, e) < 0
}
function Tz(n, e) {
  let t = n,
    i = !1
  const r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next)
  while (t !== n)
  return i
}
function KL(n, e) {
  const t = new VS(n.i, n.x, n.y),
    i = new VS(e.i, e.x, e.y),
    r = n.next,
    s = e.prev
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  )
}
function fC(n, e, t, i) {
  const r = new VS(n, e, t)
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  )
}
function Qm(n) {
  ;(n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function VS(n, e, t) {
  ;(this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1)
}
function Az(n, e, t, i) {
  let r = 0
  for (let s = e, o = t - i; s < t; s += i)
    (r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s)
  return r
}
class xa {
  static area(e) {
    const t = e.length
    let i = 0
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y
    return i * 0.5
  }
  static isClockWise(e) {
    return xa.area(e) < 0
  }
  static triangulateShape(e, t) {
    const i = [],
      r = [],
      s = []
    hC(e), pC(i, e)
    let o = e.length
    t.forEach(hC)
    for (let c = 0; c < t.length; c++)
      r.push(o), (o += t[c].length), pC(i, t[c])
    const a = dz.triangulate(i, r)
    for (let c = 0; c < a.length; c += 3) s.push(a.slice(c, c + 3))
    return s
  }
}
function hC(n) {
  const e = n.length
  e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function pC(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y)
}
class c_ extends _n {
  constructor(
    e = new ud([
      new qe(0.5, 0.5),
      new qe(-0.5, 0.5),
      new qe(-0.5, -0.5),
      new qe(0.5, -0.5),
    ]),
    t = {},
  ) {
    super(),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e])
    const i = this,
      r = [],
      s = []
    for (let a = 0, c = e.length; a < c; a++) {
      const u = e[a]
      o(u)
    }
    this.setAttribute('position', new Ft(r, 3)),
      this.setAttribute('uv', new Ft(s, 2)),
      this.computeVertexNormals()
    function o(a) {
      const c = [],
        u = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1,
        m = t.depth !== void 0 ? t.depth : 1
      let g = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        y = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        _ = t.bevelSize !== void 0 ? t.bevelSize : y - 0.1,
        M = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        w = t.bevelSegments !== void 0 ? t.bevelSegments : 3
      const x = t.extrudePath,
        T = t.UVGenerator !== void 0 ? t.UVGenerator : Cz
      let A,
        P = !1,
        D,
        O,
        U,
        F
      x &&
        ((A = x.getSpacedPoints(h)),
        (P = !0),
        (g = !1),
        (D = x.computeFrenetFrames(h, !1)),
        (O = new re()),
        (U = new re()),
        (F = new re())),
        g || ((w = 0), (y = 0), (_ = 0), (M = 0))
      const N = a.extractPoints(u)
      let k = N.shape
      const z = N.holes
      if (!xa.isClockWise(k)) {
        k = k.reverse()
        for (let je = 0, $e = z.length; je < $e; je++) {
          const se = z[je]
          xa.isClockWise(se) && (z[je] = se.reverse())
        }
      }
      const te = xa.triangulateShape(k, z),
        j = k
      for (let je = 0, $e = z.length; je < $e; je++) {
        const se = z[je]
        k = k.concat(se)
      }
      function K(je, $e, se) {
        return (
          $e || console.error('THREE.ExtrudeGeometry: vec does not exist'),
          je.clone().addScaledVector($e, se)
        )
      }
      const J = k.length,
        ne = te.length
      function V(je, $e, se) {
        let Rt, Qe, _t
        const rt = je.x - $e.x,
          jt = je.y - $e.y,
          at = se.x - je.x,
          ie = se.y - je.y,
          Z = rt * rt + jt * jt,
          Se = rt * ie - jt * at
        if (Math.abs(Se) > Number.EPSILON) {
          const Ue = Math.sqrt(Z),
            Ge = Math.sqrt(at * at + ie * ie),
            ze = $e.x - jt / Ue,
            Ct = $e.y + rt / Ue,
            ct = se.x - ie / Ge,
            gt = se.y + at / Ge,
            rn = ((ct - ze) * ie - (gt - Ct) * at) / (rt * ie - jt * at)
          ;(Rt = ze + rt * rn - je.x), (Qe = Ct + jt * rn - je.y)
          const Je = Rt * Rt + Qe * Qe
          if (Je <= 2) return new qe(Rt, Qe)
          _t = Math.sqrt(Je / 2)
        } else {
          let Ue = !1
          rt > Number.EPSILON
            ? at > Number.EPSILON && (Ue = !0)
            : rt < -Number.EPSILON
            ? at < -Number.EPSILON && (Ue = !0)
            : Math.sign(jt) === Math.sign(ie) && (Ue = !0),
            Ue
              ? ((Rt = -jt), (Qe = rt), (_t = Math.sqrt(Z)))
              : ((Rt = rt), (Qe = jt), (_t = Math.sqrt(Z / 2)))
        }
        return new qe(Rt / _t, Qe / _t)
      }
      const Y = []
      for (
        let je = 0, $e = j.length, se = $e - 1, Rt = je + 1;
        je < $e;
        je++, se++, Rt++
      )
        se === $e && (se = 0),
          Rt === $e && (Rt = 0),
          (Y[je] = V(j[je], j[se], j[Rt]))
      const Q = []
      let q,
        oe = Y.concat()
      for (let je = 0, $e = z.length; je < $e; je++) {
        const se = z[je]
        q = []
        for (
          let Rt = 0, Qe = se.length, _t = Qe - 1, rt = Rt + 1;
          Rt < Qe;
          Rt++, _t++, rt++
        )
          _t === Qe && (_t = 0),
            rt === Qe && (rt = 0),
            (q[Rt] = V(se[Rt], se[_t], se[rt]))
        Q.push(q), (oe = oe.concat(q))
      }
      for (let je = 0; je < w; je++) {
        const $e = je / w,
          se = y * Math.cos(($e * Math.PI) / 2),
          Rt = _ * Math.sin(($e * Math.PI) / 2) + M
        for (let Qe = 0, _t = j.length; Qe < _t; Qe++) {
          const rt = K(j[Qe], Y[Qe], Rt)
          Pe(rt.x, rt.y, -se)
        }
        for (let Qe = 0, _t = z.length; Qe < _t; Qe++) {
          const rt = z[Qe]
          q = Q[Qe]
          for (let jt = 0, at = rt.length; jt < at; jt++) {
            const ie = K(rt[jt], q[jt], Rt)
            Pe(ie.x, ie.y, -se)
          }
        }
      }
      const _e = _ + M
      for (let je = 0; je < J; je++) {
        const $e = g ? K(k[je], oe[je], _e) : k[je]
        P
          ? (U.copy(D.normals[0]).multiplyScalar($e.x),
            O.copy(D.binormals[0]).multiplyScalar($e.y),
            F.copy(A[0]).add(U).add(O),
            Pe(F.x, F.y, F.z))
          : Pe($e.x, $e.y, 0)
      }
      for (let je = 1; je <= h; je++)
        for (let $e = 0; $e < J; $e++) {
          const se = g ? K(k[$e], oe[$e], _e) : k[$e]
          P
            ? (U.copy(D.normals[je]).multiplyScalar(se.x),
              O.copy(D.binormals[je]).multiplyScalar(se.y),
              F.copy(A[je]).add(U).add(O),
              Pe(F.x, F.y, F.z))
            : Pe(se.x, se.y, (m / h) * je)
        }
      for (let je = w - 1; je >= 0; je--) {
        const $e = je / w,
          se = y * Math.cos(($e * Math.PI) / 2),
          Rt = _ * Math.sin(($e * Math.PI) / 2) + M
        for (let Qe = 0, _t = j.length; Qe < _t; Qe++) {
          const rt = K(j[Qe], Y[Qe], Rt)
          Pe(rt.x, rt.y, m + se)
        }
        for (let Qe = 0, _t = z.length; Qe < _t; Qe++) {
          const rt = z[Qe]
          q = Q[Qe]
          for (let jt = 0, at = rt.length; jt < at; jt++) {
            const ie = K(rt[jt], q[jt], Rt)
            P
              ? Pe(ie.x, ie.y + A[h - 1].y, A[h - 1].x + se)
              : Pe(ie.x, ie.y, m + se)
          }
        }
      }
      he(), Ce()
      function he() {
        const je = r.length / 3
        if (g) {
          let $e = 0,
            se = J * $e
          for (let Rt = 0; Rt < ne; Rt++) {
            const Qe = te[Rt]
            Be(Qe[2] + se, Qe[1] + se, Qe[0] + se)
          }
          ;($e = h + w * 2), (se = J * $e)
          for (let Rt = 0; Rt < ne; Rt++) {
            const Qe = te[Rt]
            Be(Qe[0] + se, Qe[1] + se, Qe[2] + se)
          }
        } else {
          for (let $e = 0; $e < ne; $e++) {
            const se = te[$e]
            Be(se[2], se[1], se[0])
          }
          for (let $e = 0; $e < ne; $e++) {
            const se = te[$e]
            Be(se[0] + J * h, se[1] + J * h, se[2] + J * h)
          }
        }
        i.addGroup(je, r.length / 3 - je, 0)
      }
      function Ce() {
        const je = r.length / 3
        let $e = 0
        Te(j, $e), ($e += j.length)
        for (let se = 0, Rt = z.length; se < Rt; se++) {
          const Qe = z[se]
          Te(Qe, $e), ($e += Qe.length)
        }
        i.addGroup(je, r.length / 3 - je, 1)
      }
      function Te(je, $e) {
        let se = je.length
        for (; --se >= 0; ) {
          const Rt = se
          let Qe = se - 1
          Qe < 0 && (Qe = je.length - 1)
          for (let _t = 0, rt = h + w * 2; _t < rt; _t++) {
            const jt = J * _t,
              at = J * (_t + 1),
              ie = $e + Rt + jt,
              Z = $e + Qe + jt,
              Se = $e + Qe + at,
              Ue = $e + Rt + at
            et(ie, Z, Se, Ue)
          }
        }
      }
      function Pe(je, $e, se) {
        c.push(je), c.push($e), c.push(se)
      }
      function Be(je, $e, se) {
        ft(je), ft($e), ft(se)
        const Rt = r.length / 3,
          Qe = T.generateTopUV(i, r, Rt - 3, Rt - 2, Rt - 1)
        Vt(Qe[0]), Vt(Qe[1]), Vt(Qe[2])
      }
      function et(je, $e, se, Rt) {
        ft(je), ft($e), ft(Rt), ft($e), ft(se), ft(Rt)
        const Qe = r.length / 3,
          _t = T.generateSideWallUV(i, r, Qe - 6, Qe - 3, Qe - 2, Qe - 1)
        Vt(_t[0]), Vt(_t[1]), Vt(_t[3]), Vt(_t[1]), Vt(_t[2]), Vt(_t[3])
      }
      function ft(je) {
        r.push(c[je * 3 + 0]), r.push(c[je * 3 + 1]), r.push(c[je * 3 + 2])
      }
      function Vt(je) {
        s.push(je.x), s.push(je.y)
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      i = this.parameters.options
    return Pz(t, i, e)
  }
  static fromJSON(e, t) {
    const i = []
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]]
      i.push(a)
    }
    const r = e.options.extrudePath
    return (
      r !== void 0 && (e.options.extrudePath = new gx[r.type]().fromJSON(r)),
      new c_(i, e.options)
    )
  }
}
const Cz = {
  generateTopUV: function (n, e, t, i, r) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[i * 3],
      c = e[i * 3 + 1],
      u = e[r * 3],
      h = e[r * 3 + 1]
    return [new qe(s, o), new qe(a, c), new qe(u, h)]
  },
  generateSideWallUV: function (n, e, t, i, r, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      c = e[t * 3 + 2],
      u = e[i * 3],
      h = e[i * 3 + 1],
      m = e[i * 3 + 2],
      g = e[r * 3],
      y = e[r * 3 + 1],
      _ = e[r * 3 + 2],
      M = e[s * 3],
      w = e[s * 3 + 1],
      x = e[s * 3 + 2]
    return Math.abs(a - h) < Math.abs(o - u)
      ? [new qe(o, 1 - c), new qe(u, 1 - m), new qe(g, 1 - _), new qe(M, 1 - x)]
      : [new qe(a, 1 - c), new qe(h, 1 - m), new qe(y, 1 - _), new qe(w, 1 - x)]
  },
}
function Pz(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i]
      t.shapes.push(s.uuid)
    }
  else t.shapes.push(n.uuid)
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  )
}
class Og extends Fc {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ]
    super(r, s, e, t),
      (this.type = 'IcosahedronGeometry'),
      (this.parameters = { radius: e, detail: t })
  }
  static fromJSON(e) {
    return new Og(e.radius, e.detail)
  }
}
class kg extends Fc {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ]
    super(i, r, e, t),
      (this.type = 'OctahedronGeometry'),
      (this.parameters = { radius: e, detail: t })
  }
  static fromJSON(e) {
    return new kg(e.radius, e.detail)
  }
}
class Uc extends _n {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(),
      (this.type = 'PlaneGeometry'),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      })
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      c = Math.floor(r),
      u = a + 1,
      h = c + 1,
      m = e / a,
      g = t / c,
      y = [],
      _ = [],
      M = [],
      w = []
    for (let x = 0; x < h; x++) {
      const T = x * g - o
      for (let A = 0; A < u; A++) {
        const P = A * m - s
        _.push(P, -T, 0), M.push(0, 0, 1), w.push(A / a), w.push(1 - x / c)
      }
    }
    for (let x = 0; x < c; x++)
      for (let T = 0; T < a; T++) {
        const A = T + u * x,
          P = T + u * (x + 1),
          D = T + 1 + u * (x + 1),
          O = T + 1 + u * x
        y.push(A, P, O), y.push(P, D, O)
      }
    this.setIndex(y),
      this.setAttribute('position', new Ft(_, 3)),
      this.setAttribute('normal', new Ft(M, 3)),
      this.setAttribute('uv', new Ft(w, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new Uc(e.width, e.height, e.widthSegments, e.heightSegments)
  }
}
class u_ extends _n {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = 'RingGeometry'),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: r,
        thetaStart: s,
        thetaLength: o,
      }),
      (i = Math.max(3, i)),
      (r = Math.max(1, r))
    const a = [],
      c = [],
      u = [],
      h = []
    let m = e
    const g = (t - e) / r,
      y = new re(),
      _ = new qe()
    for (let M = 0; M <= r; M++) {
      for (let w = 0; w <= i; w++) {
        const x = s + (w / i) * o
        ;(y.x = m * Math.cos(x)),
          (y.y = m * Math.sin(x)),
          c.push(y.x, y.y, y.z),
          u.push(0, 0, 1),
          (_.x = (y.x / t + 1) / 2),
          (_.y = (y.y / t + 1) / 2),
          h.push(_.x, _.y)
      }
      m += g
    }
    for (let M = 0; M < r; M++) {
      const w = M * (i + 1)
      for (let x = 0; x < i; x++) {
        const T = x + w,
          A = T,
          P = T + i + 1,
          D = T + i + 2,
          O = T + 1
        a.push(A, P, O), a.push(P, D, O)
      }
    }
    this.setIndex(a),
      this.setAttribute('position', new Ft(c, 3)),
      this.setAttribute('normal', new Ft(u, 3)),
      this.setAttribute('uv', new Ft(h, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new u_(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength,
    )
  }
}
class d_ extends _n {
  constructor(
    e = new ud([new qe(0, 0.5), new qe(-0.5, -0.5), new qe(0.5, -0.5)]),
    t = 12,
  ) {
    super(),
      (this.type = 'ShapeGeometry'),
      (this.parameters = { shapes: e, curveSegments: t })
    const i = [],
      r = [],
      s = [],
      o = []
    let a = 0,
      c = 0
    if (Array.isArray(e) === !1) u(e)
    else
      for (let h = 0; h < e.length; h++)
        u(e[h]), this.addGroup(a, c, h), (a += c), (c = 0)
    this.setIndex(i),
      this.setAttribute('position', new Ft(r, 3)),
      this.setAttribute('normal', new Ft(s, 3)),
      this.setAttribute('uv', new Ft(o, 2))
    function u(h) {
      const m = r.length / 3,
        g = h.extractPoints(t)
      let y = g.shape
      const _ = g.holes
      xa.isClockWise(y) === !1 && (y = y.reverse())
      for (let w = 0, x = _.length; w < x; w++) {
        const T = _[w]
        xa.isClockWise(T) === !0 && (_[w] = T.reverse())
      }
      const M = xa.triangulateShape(y, _)
      for (let w = 0, x = _.length; w < x; w++) {
        const T = _[w]
        y = y.concat(T)
      }
      for (let w = 0, x = y.length; w < x; w++) {
        const T = y[w]
        r.push(T.x, T.y, 0), s.push(0, 0, 1), o.push(T.x, T.y)
      }
      for (let w = 0, x = M.length; w < x; w++) {
        const T = M[w],
          A = T[0] + m,
          P = T[1] + m,
          D = T[2] + m
        i.push(A, P, D), (c += 3)
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes
    return Rz(t, e)
  }
  static fromJSON(e, t) {
    const i = []
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]]
      i.push(o)
    }
    return new d_(i, e.curveSegments)
  }
}
function Rz(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t]
      e.shapes.push(r.uuid)
    }
  else e.shapes.push(n.uuid)
  return e
}
class Fg extends _n {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI,
  ) {
    super(),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)))
    const c = Math.min(o + a, Math.PI)
    let u = 0
    const h = [],
      m = new re(),
      g = new re(),
      y = [],
      _ = [],
      M = [],
      w = []
    for (let x = 0; x <= i; x++) {
      const T = [],
        A = x / i
      let P = 0
      x === 0 && o === 0
        ? (P = 0.5 / t)
        : x === i && c === Math.PI && (P = -0.5 / t)
      for (let D = 0; D <= t; D++) {
        const O = D / t
        ;(m.x = -e * Math.cos(r + O * s) * Math.sin(o + A * a)),
          (m.y = e * Math.cos(o + A * a)),
          (m.z = e * Math.sin(r + O * s) * Math.sin(o + A * a)),
          _.push(m.x, m.y, m.z),
          g.copy(m).normalize(),
          M.push(g.x, g.y, g.z),
          w.push(O + P, 1 - A),
          T.push(u++)
      }
      h.push(T)
    }
    for (let x = 0; x < i; x++)
      for (let T = 0; T < t; T++) {
        const A = h[x][T + 1],
          P = h[x][T],
          D = h[x + 1][T],
          O = h[x + 1][T + 1]
        ;(x !== 0 || o > 0) && y.push(A, P, O),
          (x !== i - 1 || c < Math.PI) && y.push(P, D, O)
      }
    this.setIndex(y),
      this.setAttribute('position', new Ft(_, 3)),
      this.setAttribute('normal', new Ft(M, 3)),
      this.setAttribute('uv', new Ft(w, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new Fg(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength,
    )
  }
}
class f_ extends Fc {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]
    super(i, r, e, t),
      (this.type = 'TetrahedronGeometry'),
      (this.parameters = { radius: e, detail: t })
  }
  static fromJSON(e) {
    return new f_(e.radius, e.detail)
  }
}
class h_ extends _n {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    super(),
      (this.type = 'TorusGeometry'),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: r,
        arc: s,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r))
    const o = [],
      a = [],
      c = [],
      u = [],
      h = new re(),
      m = new re(),
      g = new re()
    for (let y = 0; y <= i; y++)
      for (let _ = 0; _ <= r; _++) {
        const M = (_ / r) * s,
          w = (y / i) * Math.PI * 2
        ;(m.x = (e + t * Math.cos(w)) * Math.cos(M)),
          (m.y = (e + t * Math.cos(w)) * Math.sin(M)),
          (m.z = t * Math.sin(w)),
          a.push(m.x, m.y, m.z),
          (h.x = e * Math.cos(M)),
          (h.y = e * Math.sin(M)),
          g.subVectors(m, h).normalize(),
          c.push(g.x, g.y, g.z),
          u.push(_ / r),
          u.push(y / i)
      }
    for (let y = 1; y <= i; y++)
      for (let _ = 1; _ <= r; _++) {
        const M = (r + 1) * y + _ - 1,
          w = (r + 1) * (y - 1) + _ - 1,
          x = (r + 1) * (y - 1) + _,
          T = (r + 1) * y + _
        o.push(M, w, T), o.push(w, x, T)
      }
    this.setIndex(o),
      this.setAttribute('position', new Ft(a, 3)),
      this.setAttribute('normal', new Ft(c, 3)),
      this.setAttribute('uv', new Ft(u, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new h_(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
  }
}
class p_ extends _n {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(),
      (this.type = 'TorusKnotGeometry'),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: r,
        p: s,
        q: o,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r))
    const a = [],
      c = [],
      u = [],
      h = [],
      m = new re(),
      g = new re(),
      y = new re(),
      _ = new re(),
      M = new re(),
      w = new re(),
      x = new re()
    for (let A = 0; A <= i; ++A) {
      const P = (A / i) * s * Math.PI * 2
      T(P, s, o, e, y),
        T(P + 0.01, s, o, e, _),
        w.subVectors(_, y),
        x.addVectors(_, y),
        M.crossVectors(w, x),
        x.crossVectors(M, w),
        M.normalize(),
        x.normalize()
      for (let D = 0; D <= r; ++D) {
        const O = (D / r) * Math.PI * 2,
          U = -t * Math.cos(O),
          F = t * Math.sin(O)
        ;(m.x = y.x + (U * x.x + F * M.x)),
          (m.y = y.y + (U * x.y + F * M.y)),
          (m.z = y.z + (U * x.z + F * M.z)),
          c.push(m.x, m.y, m.z),
          g.subVectors(m, y).normalize(),
          u.push(g.x, g.y, g.z),
          h.push(A / i),
          h.push(D / r)
      }
    }
    for (let A = 1; A <= i; A++)
      for (let P = 1; P <= r; P++) {
        const D = (r + 1) * (A - 1) + (P - 1),
          O = (r + 1) * A + (P - 1),
          U = (r + 1) * A + P,
          F = (r + 1) * (A - 1) + P
        a.push(D, O, F), a.push(O, U, F)
      }
    this.setIndex(a),
      this.setAttribute('position', new Ft(c, 3)),
      this.setAttribute('normal', new Ft(u, 3)),
      this.setAttribute('uv', new Ft(h, 2))
    function T(A, P, D, O, U) {
      const F = Math.cos(A),
        N = Math.sin(A),
        k = (D / P) * A,
        z = Math.cos(k)
      ;(U.x = O * (2 + z) * 0.5 * F),
        (U.y = O * (2 + z) * N * 0.5),
        (U.z = O * Math.sin(k) * 0.5)
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new p_(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q,
    )
  }
}
class m_ extends _n {
  constructor(
    e = new xE(new re(-1, -1, 0), new re(-1, 1, 0), new re(1, 1, 0)),
    t = 64,
    i = 1,
    r = 8,
    s = !1,
  ) {
    super(),
      (this.type = 'TubeGeometry'),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: r,
        closed: s,
      })
    const o = e.computeFrenetFrames(t, s)
    ;(this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals)
    const a = new re(),
      c = new re(),
      u = new qe()
    let h = new re()
    const m = [],
      g = [],
      y = [],
      _ = []
    M(),
      this.setIndex(_),
      this.setAttribute('position', new Ft(m, 3)),
      this.setAttribute('normal', new Ft(g, 3)),
      this.setAttribute('uv', new Ft(y, 2))
    function M() {
      for (let A = 0; A < t; A++) w(A)
      w(s === !1 ? t : 0), T(), x()
    }
    function w(A) {
      h = e.getPointAt(A / t, h)
      const P = o.normals[A],
        D = o.binormals[A]
      for (let O = 0; O <= r; O++) {
        const U = (O / r) * Math.PI * 2,
          F = Math.sin(U),
          N = -Math.cos(U)
        ;(c.x = N * P.x + F * D.x),
          (c.y = N * P.y + F * D.y),
          (c.z = N * P.z + F * D.z),
          c.normalize(),
          g.push(c.x, c.y, c.z),
          (a.x = h.x + i * c.x),
          (a.y = h.y + i * c.y),
          (a.z = h.z + i * c.z),
          m.push(a.x, a.y, a.z)
      }
    }
    function x() {
      for (let A = 1; A <= t; A++)
        for (let P = 1; P <= r; P++) {
          const D = (r + 1) * (A - 1) + (P - 1),
            O = (r + 1) * A + (P - 1),
            U = (r + 1) * A + P,
            F = (r + 1) * (A - 1) + P
          _.push(D, O, F), _.push(O, U, F)
        }
    }
    function T() {
      for (let A = 0; A <= t; A++)
        for (let P = 0; P <= r; P++)
          (u.x = A / t), (u.y = P / r), y.push(u.x, u.y)
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (e.path = this.parameters.path.toJSON()), e
  }
  static fromJSON(e) {
    return new m_(
      new gx[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed,
    )
  }
}
class QL extends _n {
  constructor(e = null) {
    if (
      (super(),
      (this.type = 'WireframeGeometry'),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        i = new Set(),
        r = new re(),
        s = new re()
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index
        let c = e.groups
        c.length === 0 && (c = [{ start: 0, count: a.count, materialIndex: 0 }])
        for (let u = 0, h = c.length; u < h; ++u) {
          const m = c[u],
            g = m.start,
            y = m.count
          for (let _ = g, M = g + y; _ < M; _ += 3)
            for (let w = 0; w < 3; w++) {
              const x = a.getX(_ + w),
                T = a.getX(_ + ((w + 1) % 3))
              r.fromBufferAttribute(o, x),
                s.fromBufferAttribute(o, T),
                mC(r, s, i) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z))
            }
        }
      } else {
        const o = e.attributes.position
        for (let a = 0, c = o.count / 3; a < c; a++)
          for (let u = 0; u < 3; u++) {
            const h = 3 * a + u,
              m = 3 * a + ((u + 1) % 3)
            r.fromBufferAttribute(o, h),
              s.fromBufferAttribute(o, m),
              mC(r, s, i) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z))
          }
      }
      this.setAttribute('position', new Ft(t, 3))
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
}
function mC(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0)
}
var gC = Object.freeze({
  __proto__: null,
  BoxGeometry: _d,
  CapsuleGeometry: r_,
  CircleGeometry: s_,
  ConeGeometry: o_,
  CylinderGeometry: Lh,
  DodecahedronGeometry: a_,
  EdgesGeometry: qL,
  ExtrudeGeometry: c_,
  IcosahedronGeometry: Og,
  LatheGeometry: Dg,
  OctahedronGeometry: kg,
  PlaneGeometry: Uc,
  PolyhedronGeometry: Fc,
  RingGeometry: u_,
  ShapeGeometry: d_,
  SphereGeometry: Fg,
  TetrahedronGeometry: f_,
  TorusGeometry: h_,
  TorusKnotGeometry: p_,
  TubeGeometry: m_,
  WireframeGeometry: QL,
})
class JL extends Or {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = 'ShadowMaterial'),
      (this.color = new Tt(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this
  }
}
class eN extends ws {
  constructor(e) {
    super(e), (this.isRawShaderMaterial = !0), (this.type = 'RawShaderMaterial')
  }
}
class wE extends Or {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = 'MeshStandardMaterial'),
      (this.defines = { STANDARD: '' }),
      (this.color = new Tt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Tt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = kc),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Us()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '' }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    )
  }
}
class SE extends wE {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new qe(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, 'reflectivity', {
        get: function () {
          return un((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1)
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t)
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Tt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Tt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Tt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e)
  }
  get anisotropy() {
    return this._anisotropy
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e)
  }
  get clearcoat() {
    return this._clearcoat
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e)
  }
  get iridescence() {
    return this._iridescence
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e)
  }
  get dispersion() {
    return this._dispersion
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e)
  }
  get sheen() {
    return this._sheen
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e)
  }
  get transmission() {
    return this._transmission
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    )
  }
}
class tN extends Or {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = 'MeshPhongMaterial'),
      (this.color = new Tt(16777215)),
      (this.specular = new Tt(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Tt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = kc),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Us()),
      (this.combine = bg),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    )
  }
}
class nN extends Or {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: '' }),
      (this.type = 'MeshToonMaterial'),
      (this.color = new Tt(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Tt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = kc),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    )
  }
}
class iN extends Or {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = 'MeshNormalMaterial'),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = kc),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    )
  }
}
class rN extends Or {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = 'MeshLambertMaterial'),
      (this.color = new Tt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Tt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = kc),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Us()),
      (this.combine = bg),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    )
  }
}
class ME extends Or {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = yL),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    )
  }
}
class EE extends Or {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = 'MeshDistanceMaterial'),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    )
  }
}
class sN extends Or {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: '' }),
      (this.type = 'MeshMatcapMaterial'),
      (this.color = new Tt(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = kc),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: '' }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    )
  }
}
class oN extends ts {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = 'LineDashedMaterial'),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    )
  }
}
function nd(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == 'number'
    ? new e(n)
    : Array.prototype.slice.call(n)
}
function aN(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function lN(n) {
  function e(r, s) {
    return n[r] - n[s]
  }
  const t = n.length,
    i = new Array(t)
  for (let r = 0; r !== t; ++r) i[r] = r
  return i.sort(e), i
}
function jS(n, e, t) {
  const i = n.length,
    r = new n.constructor(i)
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e
    for (let c = 0; c !== e; ++c) r[o++] = n[a + c]
  }
  return r
}
function bE(n, e, t, i) {
  let r = 1,
    s = n[0]
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++]
  if (s === void 0) return
  let o = s[i]
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[r++])
      while (s !== void 0)
    else if (o.toArray !== void 0)
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[r++])
      while (s !== void 0)
    else
      do (o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++])
      while (s !== void 0)
}
function Iz(n, e, t, i, r = 30) {
  const s = n.clone()
  s.name = e
  const o = []
  for (let c = 0; c < s.tracks.length; ++c) {
    const u = s.tracks[c],
      h = u.getValueSize(),
      m = [],
      g = []
    for (let y = 0; y < u.times.length; ++y) {
      const _ = u.times[y] * r
      if (!(_ < t || _ >= i)) {
        m.push(u.times[y])
        for (let M = 0; M < h; ++M) g.push(u.values[y * h + M])
      }
    }
    m.length !== 0 &&
      ((u.times = nd(m, u.times.constructor)),
      (u.values = nd(g, u.values.constructor)),
      o.push(u))
  }
  s.tracks = o
  let a = 1 / 0
  for (let c = 0; c < s.tracks.length; ++c)
    a > s.tracks[c].times[0] && (a = s.tracks[c].times[0])
  for (let c = 0; c < s.tracks.length; ++c) s.tracks[c].shift(-1 * a)
  return s.resetDuration(), s
}
function Lz(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30)
  const r = t.tracks.length,
    s = e / i
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o],
      c = a.ValueTypeName
    if (c === 'bool' || c === 'string') continue
    const u = n.tracks.find(function (x) {
      return x.name === a.name && x.ValueTypeName === c
    })
    if (u === void 0) continue
    let h = 0
    const m = a.getValueSize()
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = m / 3)
    let g = 0
    const y = u.getValueSize()
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (g = y / 3)
    const _ = a.times.length - 1
    let M
    if (s <= a.times[0]) {
      const x = h,
        T = m - h
      M = a.values.slice(x, T)
    } else if (s >= a.times[_]) {
      const x = _ * m + h,
        T = x + m - h
      M = a.values.slice(x, T)
    } else {
      const x = a.createInterpolant(),
        T = h,
        A = m - h
      x.evaluate(s), (M = x.resultBuffer.slice(T, A))
    }
    c === 'quaternion' &&
      new xs().fromArray(M).normalize().conjugate().toArray(M)
    const w = u.times.length
    for (let x = 0; x < w; ++x) {
      const T = x * y + g
      if (c === 'quaternion')
        xs.multiplyQuaternionsFlat(u.values, T, M, 0, u.values, T)
      else {
        const A = y - g * 2
        for (let P = 0; P < A; ++P) u.values[T + P] -= M[P]
      }
    }
  }
  return (n.blendMode = sE), n
}
const Nz = {
  convertArray: nd,
  isTypedArray: aN,
  getKeyframeOrder: lN,
  sortedArray: jS,
  flattenJSON: bE,
  subclip: Iz,
  makeClipAdditive: Lz,
}
class Ug {
  constructor(e, t, i, r) {
    ;(this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {})
  }
  evaluate(e) {
    const t = this.parameterPositions
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1]
    e: {
      t: {
        let o
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                )
              }
              if (i === a) break
              if (((s = r), (r = t[++i]), e < r)) break t
            }
            o = t.length
            break n
          }
          if (!(e >= s)) {
            const a = t[1]
            e < a && ((i = 2), (s = a))
            for (let c = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0)
              if (i === c) break
              if (((r = s), (s = t[--i - 1]), e >= s)) break t
            }
            ;(o = i), (i = 0)
            break n
          }
          break e
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1
          e < t[a] ? (o = a) : (i = a + 1)
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0)
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          )
      }
      ;(this._cachedIndex = i), this.intervalChanged_(i, s, r)
    }
    return this.interpolate_(i, s, e, r)
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r
    for (let o = 0; o !== r; ++o) t[o] = i[s + o]
    return t
  }
  interpolate_() {
    throw new Error('call to abstract method')
  }
  intervalChanged_() {}
}
class cN extends Ug {
  constructor(e, t, i, r) {
    super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Qu, endingEnd: Qu })
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions
    let s = e - 2,
      o = e + 1,
      a = r[s],
      c = r[o]
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Ju:
          ;(s = e), (a = 2 * t - i)
          break
        case Gm:
          ;(s = r.length - 2), (a = t + r[s] - r[s + 1])
          break
        default:
          ;(s = e), (a = i)
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ju:
          ;(o = e), (c = 2 * i - t)
          break
        case Gm:
          ;(o = 1), (c = i + r[1] - r[0])
          break
        default:
          ;(o = e - 1), (c = t)
      }
    const u = (i - t) * 0.5,
      h = this.valueSize
    ;(this._weightPrev = u / (t - a)),
      (this._weightNext = u / (c - i)),
      (this._offsetPrev = s * h),
      (this._offsetNext = o * h)
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      c = e * a,
      u = c - a,
      h = this._offsetPrev,
      m = this._offsetNext,
      g = this._weightPrev,
      y = this._weightNext,
      _ = (i - t) / (r - t),
      M = _ * _,
      w = M * _,
      x = -g * w + 2 * g * M - g * _,
      T = (1 + g) * w + (-1.5 - 2 * g) * M + (-0.5 + g) * _ + 1,
      A = (-1 - y) * w + (1.5 + y) * M + 0.5 * _,
      P = y * w - y * M
    for (let D = 0; D !== a; ++D)
      s[D] = x * o[h + D] + T * o[u + D] + A * o[c + D] + P * o[m + D]
    return s
  }
}
class TE extends Ug {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      c = e * a,
      u = c - a,
      h = (i - t) / (r - t),
      m = 1 - h
    for (let g = 0; g !== a; ++g) s[g] = o[u + g] * m + o[c + g] * h
    return s
  }
}
class uN extends Ug {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1)
  }
}
class Zo {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error('THREE.KeyframeTrack: track name is undefined')
    if (t === void 0 || t.length === 0)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + e)
    ;(this.name = e),
      (this.times = nd(t, this.TimeBufferType)),
      (this.values = nd(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation)
  }
  static toJSON(e) {
    const t = e.constructor
    let i
    if (t.toJSON !== this.toJSON) i = t.toJSON(e)
    else {
      i = {
        name: e.name,
        times: nd(e.times, Array),
        values: nd(e.values, Array),
      }
      const r = e.getInterpolation()
      r !== e.DefaultInterpolation && (i.interpolation = r)
    }
    return (i.type = e.ValueTypeName), i
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new uN(this.times, this.values, this.getValueSize(), e)
  }
  InterpolantFactoryMethodLinear(e) {
    return new TE(this.times, this.values, this.getValueSize(), e)
  }
  InterpolantFactoryMethodSmooth(e) {
    return new cN(this.times, this.values, this.getValueSize(), e)
  }
  setInterpolation(e) {
    let t
    switch (e) {
      case Hm:
        t = this.InterpolantFactoryMethodDiscrete
        break
      case hx:
        t = this.InterpolantFactoryMethodLinear
        break
      case xy:
        t = this.InterpolantFactoryMethodSmooth
        break
    }
    if (t === void 0) {
      const i =
        'unsupported interpolation for ' +
        this.ValueTypeName +
        ' keyframe track named ' +
        this.name
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation)
        else throw new Error(i)
      return console.warn('THREE.KeyframeTrack:', i), this
    }
    return (this.createInterpolant = t), this
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Hm
      case this.InterpolantFactoryMethodLinear:
        return hx
      case this.InterpolantFactoryMethodSmooth:
        return xy
    }
  }
  getValueSize() {
    return this.values.length / this.times.length
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e
    }
    return this
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e
    }
    return this
  }
  trim(e, t) {
    const i = this.times,
      r = i.length
    let s = 0,
      o = r - 1
    for (; s !== r && i[s] < e; ) ++s
    for (; o !== -1 && i[o] > t; ) --o
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1))
      const a = this.getValueSize()
      ;(this.times = i.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a))
    }
    return this
  }
  validate() {
    let e = !0
    const t = this.getValueSize()
    t - Math.floor(t) !== 0 &&
      (console.error('THREE.KeyframeTrack: Invalid value size in track.', this),
      (e = !1))
    const i = this.times,
      r = this.values,
      s = i.length
    s === 0 &&
      (console.error('THREE.KeyframeTrack: Track is empty.', this), (e = !1))
    let o = null
    for (let a = 0; a !== s; a++) {
      const c = i[a]
      if (typeof c == 'number' && isNaN(c)) {
        console.error(
          'THREE.KeyframeTrack: Time is not a valid number.',
          this,
          a,
          c,
        ),
          (e = !1)
        break
      }
      if (o !== null && o > c) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, a, c, o),
          (e = !1)
        break
      }
      o = c
    }
    if (r !== void 0 && aN(r))
      for (let a = 0, c = r.length; a !== c; ++a) {
        const u = r[a]
        if (isNaN(u)) {
          console.error(
            'THREE.KeyframeTrack: Value is not a valid number.',
            this,
            a,
            u,
          ),
            (e = !1)
          break
        }
      }
    return e
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.getValueSize(),
      r = this.getInterpolation() === xy,
      s = e.length - 1
    let o = 1
    for (let a = 1; a < s; ++a) {
      let c = !1
      const u = e[a],
        h = e[a + 1]
      if (u !== h && (a !== 1 || u !== e[0]))
        if (r) c = !0
        else {
          const m = a * i,
            g = m - i,
            y = m + i
          for (let _ = 0; _ !== i; ++_) {
            const M = t[m + _]
            if (M !== t[g + _] || M !== t[y + _]) {
              c = !0
              break
            }
          }
        }
      if (c) {
        if (a !== o) {
          e[o] = e[a]
          const m = a * i,
            g = o * i
          for (let y = 0; y !== i; ++y) t[g + y] = t[m + y]
        }
        ++o
      }
    }
    if (s > 0) {
      e[o] = e[s]
      for (let a = s * i, c = o * i, u = 0; u !== i; ++u) t[c + u] = t[a + u]
      ++o
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    )
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.constructor,
      r = new i(this.name, e, t)
    return (r.createInterpolant = this.createInterpolant), r
  }
}
Zo.prototype.TimeBufferType = Float32Array
Zo.prototype.ValueBufferType = Float32Array
Zo.prototype.DefaultInterpolation = hx
class wd extends Zo {
  constructor(e, t, i) {
    super(e, t, i)
  }
}
wd.prototype.ValueTypeName = 'bool'
wd.prototype.ValueBufferType = Array
wd.prototype.DefaultInterpolation = Hm
wd.prototype.InterpolantFactoryMethodLinear = void 0
wd.prototype.InterpolantFactoryMethodSmooth = void 0
class AE extends Zo {}
AE.prototype.ValueTypeName = 'color'
class Jm extends Zo {}
Jm.prototype.ValueTypeName = 'number'
class dN extends Ug {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      c = (i - t) / (r - t)
    let u = e * a
    for (let h = u + a; u !== h; u += 4) xs.slerpFlat(s, 0, o, u - a, o, u, c)
    return s
  }
}
class Bg extends Zo {
  InterpolantFactoryMethodLinear(e) {
    return new dN(this.times, this.values, this.getValueSize(), e)
  }
}
Bg.prototype.ValueTypeName = 'quaternion'
Bg.prototype.InterpolantFactoryMethodSmooth = void 0
class Sd extends Zo {
  constructor(e, t, i) {
    super(e, t, i)
  }
}
Sd.prototype.ValueTypeName = 'string'
Sd.prototype.ValueBufferType = Array
Sd.prototype.DefaultInterpolation = Hm
Sd.prototype.InterpolantFactoryMethodLinear = void 0
Sd.prototype.InterpolantFactoryMethodSmooth = void 0
class eg extends Zo {}
eg.prototype.ValueTypeName = 'vector'
class tg {
  constructor(e = '', t = -1, i = [], r = Yx) {
    ;(this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = Ds()),
      this.duration < 0 && this.resetDuration()
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1)
    for (let o = 0, a = i.length; o !== a; ++o) t.push(Oz(i[o]).scale(r))
    const s = new this(e.name, e.duration, t, e.blendMode)
    return (s.uuid = e.uuid), s
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      }
    for (let s = 0, o = i.length; s !== o; ++s) t.push(Zo.toJSON(i[s]))
    return r
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = []
    for (let a = 0; a < s; a++) {
      let c = [],
        u = []
      c.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0)
      const h = lN(c)
      ;(c = jS(c, 1, h)),
        (u = jS(u, 1, h)),
        !r && c[0] === 0 && (c.push(s), u.push(u[0])),
        o.push(
          new Jm('.morphTargetInfluences[' + t[a].name + ']', c, u).scale(
            1 / i,
          ),
        )
    }
    return new this(e, -1, o)
  }
  static findByName(e, t) {
    let i = e
    if (!Array.isArray(e)) {
      const r = e
      i = (r.geometry && r.geometry.animations) || r.animations
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r]
    return null
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/
    for (let a = 0, c = e.length; a < c; a++) {
      const u = e[a],
        h = u.name.match(s)
      if (h && h.length > 1) {
        const m = h[1]
        let g = r[m]
        g || (r[m] = g = []), g.push(u)
      }
    }
    const o = []
    for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i))
    return o
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error('THREE.AnimationClip: No animation in JSONLoader data.'),
        null
      )
    const i = function (m, g, y, _, M) {
        if (y.length !== 0) {
          const w = [],
            x = []
          bE(y, w, x, _), w.length !== 0 && M.push(new m(g, w, x))
        }
      },
      r = [],
      s = e.name || 'default',
      o = e.fps || 30,
      a = e.blendMode
    let c = e.length || -1
    const u = e.hierarchy || []
    for (let m = 0; m < u.length; m++) {
      const g = u[m].keys
      if (!(!g || g.length === 0))
        if (g[0].morphTargets) {
          const y = {}
          let _
          for (_ = 0; _ < g.length; _++)
            if (g[_].morphTargets)
              for (let M = 0; M < g[_].morphTargets.length; M++)
                y[g[_].morphTargets[M]] = -1
          for (const M in y) {
            const w = [],
              x = []
            for (let T = 0; T !== g[_].morphTargets.length; ++T) {
              const A = g[_]
              w.push(A.time), x.push(A.morphTarget === M ? 1 : 0)
            }
            r.push(new Jm('.morphTargetInfluence[' + M + ']', w, x))
          }
          c = y.length * o
        } else {
          const y = '.bones[' + t[m].name + ']'
          i(eg, y + '.position', g, 'pos', r),
            i(Bg, y + '.quaternion', g, 'rot', r),
            i(eg, y + '.scale', g, 'scl', r)
        }
    }
    return r.length === 0 ? null : new this(s, c, r, a)
  }
  resetDuration() {
    const e = this.tracks
    let t = 0
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i]
      t = Math.max(t, s.times[s.times.length - 1])
    }
    return (this.duration = t), this
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration)
    return this
  }
  validate() {
    let e = !0
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate()
    return e
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize()
    return this
  }
  clone() {
    const e = []
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone())
    return new this.constructor(this.name, this.duration, e, this.blendMode)
  }
  toJSON() {
    return this.constructor.toJSON(this)
  }
}
function Dz(n) {
  switch (n.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return Jm
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return eg
    case 'color':
      return AE
    case 'quaternion':
      return Bg
    case 'bool':
    case 'boolean':
      return wd
    case 'string':
      return Sd
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + n)
}
function Oz(n) {
  if (n.type === void 0)
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')
  const e = Dz(n.type)
  if (n.times === void 0) {
    const t = [],
      i = []
    bE(n.keys, t, i, 'value'), (n.times = t), (n.values = i)
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation)
}
const xl = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e)
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n]
  },
  remove: function (n) {
    delete this.files[n]
  },
  clear: function () {
    this.files = {}
  },
}
class g_ {
  constructor(e, t, i) {
    const r = this
    let s = !1,
      o = 0,
      a = 0,
      c
    const u = []
    ;(this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (h) {
        a++, s === !1 && r.onStart !== void 0 && r.onStart(h, o, a), (s = !0)
      }),
      (this.itemEnd = function (h) {
        o++,
          r.onProgress !== void 0 && r.onProgress(h, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad())
      }),
      (this.itemError = function (h) {
        r.onError !== void 0 && r.onError(h)
      }),
      (this.resolveURL = function (h) {
        return c ? c(h) : h
      }),
      (this.setURLModifier = function (h) {
        return (c = h), this
      }),
      (this.addHandler = function (h, m) {
        return u.push(h, m), this
      }),
      (this.removeHandler = function (h) {
        const m = u.indexOf(h)
        return m !== -1 && u.splice(m, 2), this
      }),
      (this.getHandler = function (h) {
        for (let m = 0, g = u.length; m < g; m += 2) {
          const y = u[m],
            _ = u[m + 1]
          if ((y.global && (y.lastIndex = 0), y.test(h))) return _
        }
        return null
      })
  }
}
const fN = new g_()
class ns {
  constructor(e) {
    ;(this.manager = e !== void 0 ? e : fN),
      (this.crossOrigin = 'anonymous'),
      (this.withCredentials = !1),
      (this.path = ''),
      (this.resourcePath = ''),
      (this.requestHeader = {})
  }
  load() {}
  loadAsync(e, t) {
    const i = this
    return new Promise(function (r, s) {
      i.load(e, r, t, s)
    })
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this
  }
  setPath(e) {
    return (this.path = e), this
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this
  }
}
ns.DEFAULT_MATERIAL_NAME = '__DEFAULT'
const ml = {}
class kz extends Error {
  constructor(e, t) {
    super(e), (this.response = t)
  }
}
class Os extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e))
    const s = xl.get(e)
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e)
        }, 0),
        s
      )
    if (ml[e] !== void 0) {
      ml[e].push({ onLoad: t, onProgress: i, onError: r })
      return
    }
    ;(ml[e] = []), ml[e].push({ onLoad: t, onProgress: i, onError: r })
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin',
      }),
      a = this.mimeType,
      c = this.responseType
    fetch(o)
      .then((u) => {
        if (u.status === 200 || u.status === 0) {
          if (
            (u.status === 0 &&
              console.warn('THREE.FileLoader: HTTP Status 0 received.'),
            typeof ReadableStream > 'u' ||
              u.body === void 0 ||
              u.body.getReader === void 0)
          )
            return u
          const h = ml[e],
            m = u.body.getReader(),
            g = u.headers.get('X-File-Size') || u.headers.get('Content-Length'),
            y = g ? parseInt(g) : 0,
            _ = y !== 0
          let M = 0
          const w = new ReadableStream({
            start(x) {
              T()
              function T() {
                m.read().then(
                  ({ done: A, value: P }) => {
                    if (A) x.close()
                    else {
                      M += P.byteLength
                      const D = new ProgressEvent('progress', {
                        lengthComputable: _,
                        loaded: M,
                        total: y,
                      })
                      for (let O = 0, U = h.length; O < U; O++) {
                        const F = h[O]
                        F.onProgress && F.onProgress(D)
                      }
                      x.enqueue(P), T()
                    }
                  },
                  (A) => {
                    x.error(A)
                  },
                )
              }
            },
          })
          return new Response(w)
        } else
          throw new kz(
            `fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,
            u,
          )
      })
      .then((u) => {
        switch (c) {
          case 'arraybuffer':
            return u.arrayBuffer()
          case 'blob':
            return u.blob()
          case 'document':
            return u.text().then((h) => new DOMParser().parseFromString(h, a))
          case 'json':
            return u.json()
          default:
            if (a === void 0) return u.text()
            {
              const m = /charset="?([^;"\s]*)"?/i.exec(a),
                g = m && m[1] ? m[1].toLowerCase() : void 0,
                y = new TextDecoder(g)
              return u.arrayBuffer().then((_) => y.decode(_))
            }
        }
      })
      .then((u) => {
        xl.add(e, u)
        const h = ml[e]
        delete ml[e]
        for (let m = 0, g = h.length; m < g; m++) {
          const y = h[m]
          y.onLoad && y.onLoad(u)
        }
      })
      .catch((u) => {
        const h = ml[e]
        if (h === void 0) throw (this.manager.itemError(e), u)
        delete ml[e]
        for (let m = 0, g = h.length; m < g; m++) {
          const y = h[m]
          y.onError && y.onError(u)
        }
        this.manager.itemError(e)
      })
      .finally(() => {
        this.manager.itemEnd(e)
      }),
      this.manager.itemStart(e)
  }
  setResponseType(e) {
    return (this.responseType = e), this
  }
  setMimeType(e) {
    return (this.mimeType = e), this
  }
}
class Fz extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = new Os(this.manager)
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)))
          } catch (c) {
            r ? r(c) : console.error(c), s.manager.itemError(e)
          }
        },
        i,
        r,
      )
  }
  parse(e) {
    const t = []
    for (let i = 0; i < e.length; i++) {
      const r = tg.parse(e[i])
      t.push(r)
    }
    return t
  }
}
class Uz extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = [],
      a = new n_(),
      c = new Os(this.manager)
    c.setPath(this.path),
      c.setResponseType('arraybuffer'),
      c.setRequestHeader(this.requestHeader),
      c.setWithCredentials(s.withCredentials)
    let u = 0
    function h(m) {
      c.load(
        e[m],
        function (g) {
          const y = s.parse(g, !0)
          ;(o[m] = {
            width: y.width,
            height: y.height,
            format: y.format,
            mipmaps: y.mipmaps,
          }),
            (u += 1),
            u === 6 &&
              (y.mipmapCount === 1 && (a.minFilter = Vn),
              (a.image = o),
              (a.format = y.format),
              (a.needsUpdate = !0),
              t && t(a))
        },
        i,
        r,
      )
    }
    if (Array.isArray(e)) for (let m = 0, g = e.length; m < g; ++m) h(m)
    else
      c.load(
        e,
        function (m) {
          const g = s.parse(m, !0)
          if (g.isCubemap) {
            const y = g.mipmaps.length / g.mipmapCount
            for (let _ = 0; _ < y; _++) {
              o[_] = { mipmaps: [] }
              for (let M = 0; M < g.mipmapCount; M++)
                o[_].mipmaps.push(g.mipmaps[_ * g.mipmapCount + M]),
                  (o[_].format = g.format),
                  (o[_].width = g.width),
                  (o[_].height = g.height)
            }
            a.image = o
          } else
            (a.image.width = g.width),
              (a.image.height = g.height),
              (a.mipmaps = g.mipmaps)
          g.mipmapCount === 1 && (a.minFilter = Vn),
            (a.format = g.format),
            (a.needsUpdate = !0),
            t && t(a)
        },
        i,
        r,
      )
    return a
  }
}
class ng extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e))
    const s = this,
      o = xl.get(e)
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e)
        }, 0),
        o
      )
    const a = qm('img')
    function c() {
      h(), xl.add(e, this), t && t(this), s.manager.itemEnd(e)
    }
    function u(m) {
      h(), r && r(m), s.manager.itemError(e), s.manager.itemEnd(e)
    }
    function h() {
      a.removeEventListener('load', c, !1),
        a.removeEventListener('error', u, !1)
    }
    return (
      a.addEventListener('load', c, !1),
      a.addEventListener('error', u, !1),
      e.slice(0, 5) !== 'data:' &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    )
  }
}
class hN extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = new Ig()
    s.colorSpace = Zr
    const o = new ng(this.manager)
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path)
    let a = 0
    function c(u) {
      o.load(
        e[u],
        function (h) {
          ;(s.images[u] = h), a++, a === 6 && ((s.needsUpdate = !0), t && t(s))
        },
        void 0,
        r,
      )
    }
    for (let u = 0; u < e.length; ++u) c(u)
    return s
  }
}
class CE extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = new $o(),
      a = new Os(this.manager)
    return (
      a.setResponseType('arraybuffer'),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (c) {
          let u
          try {
            u = s.parse(c)
          } catch (h) {
            if (r !== void 0) r(h)
            else {
              console.error(h)
              return
            }
          }
          u.image !== void 0
            ? (o.image = u.image)
            : u.data !== void 0 &&
              ((o.image.width = u.width),
              (o.image.height = u.height),
              (o.image.data = u.data)),
            (o.wrapS = u.wrapS !== void 0 ? u.wrapS : Bi),
            (o.wrapT = u.wrapT !== void 0 ? u.wrapT : Bi),
            (o.magFilter = u.magFilter !== void 0 ? u.magFilter : Vn),
            (o.minFilter = u.minFilter !== void 0 ? u.minFilter : Vn),
            (o.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1),
            u.colorSpace !== void 0 && (o.colorSpace = u.colorSpace),
            u.flipY !== void 0 && (o.flipY = u.flipY),
            u.format !== void 0 && (o.format = u.format),
            u.type !== void 0 && (o.type = u.type),
            u.mipmaps !== void 0 &&
              ((o.mipmaps = u.mipmaps), (o.minFilter = ma)),
            u.mipmapCount === 1 && (o.minFilter = Vn),
            u.generateMipmaps !== void 0 &&
              (o.generateMipmaps = u.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, u)
        },
        i,
        r,
      ),
      o
    )
  }
}
class Bz extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = new Xn(),
      o = new ng(this.manager)
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          ;(s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s)
        },
        i,
        r,
      ),
      s
    )
  }
}
class Bc extends Ln {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = 'Light'),
      (this.color = new Tt(e)),
      (this.intensity = t)
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    )
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    )
  }
}
class pN extends Bc {
  constructor(e, t, i) {
    super(e, i),
      (this.isHemisphereLight = !0),
      (this.type = 'HemisphereLight'),
      this.position.copy(Ln.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Tt(t))
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this
  }
}
const ew = new Jt(),
  vC = new re(),
  yC = new re()
class PE {
  constructor(e) {
    ;(this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new qe(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Jt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Ng()),
      (this._frameExtents = new qe(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new In(0, 0, 1, 1)])
  }
  getViewportCount() {
    return this._viewportCount
  }
  getFrustum() {
    return this._frustum
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix
    vC.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(vC),
      yC.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(yC),
      t.updateMatrixWorld(),
      ew.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(ew),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(ew)
  }
  getViewport(e) {
    return this._viewports[e]
  }
  getFrameExtents() {
    return this._frameExtents
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const e = {}
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    )
  }
}
class zz extends PE {
  constructor() {
    super(new sr(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1)
  }
  updateMatrices(e) {
    const t = this.camera,
      i = mh * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far
    ;(i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e)
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this
  }
}
class mN extends Bc {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = 'SpotLight'),
      this.position.copy(Ln.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ln()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new zz())
  }
  get power() {
    return this.intensity * Math.PI
  }
  set power(e) {
    this.intensity = e / Math.PI
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
const xC = new Jt(),
  Wp = new re(),
  tw = new re()
class Vz extends PE {
  constructor() {
    super(new sr(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new qe(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new In(2, 1, 1, 1),
        new In(0, 1, 1, 1),
        new In(3, 1, 1, 1),
        new In(1, 1, 1, 1),
        new In(3, 0, 1, 1),
        new In(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new re(1, 0, 0),
        new re(-1, 0, 0),
        new re(0, 0, 1),
        new re(0, 0, -1),
        new re(0, 1, 0),
        new re(0, -1, 0),
      ]),
      (this._cubeUps = [
        new re(0, 1, 0),
        new re(0, 1, 0),
        new re(0, 1, 0),
        new re(0, 1, 0),
        new re(0, 0, 1),
        new re(0, 0, -1),
      ])
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      Wp.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Wp),
      tw.copy(i.position),
      tw.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(tw),
      i.updateMatrixWorld(),
      r.makeTranslation(-Wp.x, -Wp.y, -Wp.z),
      xC.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(xC)
  }
}
class gN extends Bc {
  constructor(e, t, i = 0, r = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = 'PointLight'),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new Vz())
  }
  get power() {
    return this.intensity * 4 * Math.PI
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI)
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
class Nh extends Rg {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    )
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2
    let s = i - e,
      o = i + e,
      a = r + t,
      c = r - t
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom
      ;(s += u * this.view.offsetX),
        (o = s + u * this.view.width),
        (a -= h * this.view.offsetY),
        (c = a - h * this.view.height)
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      c,
      this.near,
      this.far,
      this.coordinateSystem,
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    )
  }
}
class jz extends PE {
  constructor() {
    super(new Nh(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0)
  }
}
class vN extends Bc {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = 'DirectionalLight'),
      this.position.copy(Ln.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ln()),
      (this.shadow = new jz())
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
class yN extends Bc {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = 'AmbientLight')
  }
}
class xN extends Bc {
  constructor(e, t, i = 10, r = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = 'RectAreaLight'),
      (this.width = i),
      (this.height = r)
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI)
  }
  copy(e) {
    return super.copy(e), (this.width = e.width), (this.height = e.height), this
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (t.object.width = this.width), (t.object.height = this.height), t
  }
}
class _N {
  constructor() {
    ;(this.isSphericalHarmonics3 = !0), (this.coefficients = [])
    for (let e = 0; e < 9; e++) this.coefficients.push(new re())
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t])
    return this
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0)
    return this
  }
  getAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * r),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * i),
      t.addScaledVector(o[4], 1.092548 * (i * r)),
      t.addScaledVector(o[5], 1.092548 * (r * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (i * s)),
      t.addScaledVector(o[8], 0.546274 * (i * i - r * r)),
      t
    )
  }
  getIrradianceAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * r),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * i),
      t.addScaledVector(o[4], 2 * 0.429043 * i * r),
      t.addScaledVector(o[5], 2 * 0.429043 * r * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * i * s),
      t.addScaledVector(o[8], 0.429043 * (i * i - r * r)),
      t
    )
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t])
    return this
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t)
    return this
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e)
    return this
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t)
    return this
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1
    return !0
  }
  copy(e) {
    return this.set(e.coefficients)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  fromArray(e, t = 0) {
    const i = this.coefficients
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3)
    return this
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3)
    return e
  }
  static getBasisAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z
    ;(t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * i),
      (t[4] = 1.092548 * i * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * i * s),
      (t[8] = 0.546274 * (i * i - r * r))
  }
}
class wN extends Bc {
  constructor(e = new _N(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e)
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (t.object.sh = this.sh.toArray()), t
  }
}
class v_ extends ns {
  constructor(e) {
    super(e), (this.textures = {})
  }
  load(e, t, i, r) {
    const s = this,
      o = new Os(s.manager)
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)))
          } catch (c) {
            r ? r(c) : console.error(c), s.manager.itemError(e)
          }
        },
        i,
        r,
      )
  }
  parse(e) {
    const t = this.textures
    function i(s) {
      return (
        t[s] === void 0 &&
          console.warn('THREE.MaterialLoader: Undefined texture', s),
        t[s]
      )
    }
    const r = this.createMaterialFromType(e.type)
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new Tt().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (r.dispersion = e.dispersion),
      e.iridescence !== void 0 && (r.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (r.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (r.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        r.blendColor !== void 0 &&
        r.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== void 0 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == 'number'
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s]
        switch (((r.uniforms[s] = {}), o.type)) {
          case 't':
            r.uniforms[s].value = i(o.value)
            break
          case 'c':
            r.uniforms[s].value = new Tt().setHex(o.value)
            break
          case 'v2':
            r.uniforms[s].value = new qe().fromArray(o.value)
            break
          case 'v3':
            r.uniforms[s].value = new re().fromArray(o.value)
            break
          case 'v4':
            r.uniforms[s].value = new In().fromArray(o.value)
            break
          case 'm3':
            r.uniforms[s].value = new pn().fromArray(o.value)
            break
          case 'm4':
            r.uniforms[s].value = new Jt().fromArray(o.value)
            break
          default:
            r.uniforms[s].value = o.value
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s]
    if (
      (e.lights !== void 0 && (r.lights = e.lights),
      e.clipping !== void 0 && (r.clipping = e.clipping),
      e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = i(e.map)),
      e.matcap !== void 0 && (r.matcap = i(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale
      Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new qe().fromArray(s))
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = i(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = i(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = i(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = i(e.envMap)),
      e.envMapRotation !== void 0 &&
        r.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new qe().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = i(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
      r
    )
  }
  setTextures(e) {
    return (this.textures = e), this
  }
  createMaterialFromType(e) {
    return v_.createMaterialFromType(e)
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: JL,
      SpriteMaterial: dE,
      RawShaderMaterial: eN,
      ShaderMaterial: ws,
      PointsMaterial: hE,
      MeshPhysicalMaterial: SE,
      MeshStandardMaterial: wE,
      MeshPhongMaterial: tN,
      MeshToonMaterial: nN,
      MeshNormalMaterial: iN,
      MeshLambertMaterial: rN,
      MeshDepthMaterial: ME,
      MeshDistanceMaterial: EE,
      MeshBasicMaterial: Il,
      MeshMatcapMaterial: sN,
      LineDashedMaterial: oN,
      LineBasicMaterial: ts,
      Material: Or,
    }
    return new t[e]()
  }
}
class HS {
  static decodeText(e) {
    if (
      (console.warn(
        'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.',
      ),
      typeof TextDecoder < 'u')
    )
      return new TextDecoder().decode(e)
    let t = ''
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i])
    try {
      return decodeURIComponent(escape(t))
    } catch {
      return t
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf('/')
    return t === -1 ? './' : e.slice(0, t + 1)
  }
  static resolveURL(e, t) {
    return typeof e != 'string' || e === ''
      ? ''
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e)
  }
}
class SN extends _n {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = 'InstancedBufferGeometry'),
      (this.instanceCount = 1 / 0)
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    )
  }
}
class MN extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = new Os(s.manager)
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)))
          } catch (c) {
            r ? r(c) : console.error(c), s.manager.itemError(e)
          }
        },
        i,
        r,
      )
  }
  parse(e) {
    const t = {},
      i = {}
    function r(y, _) {
      if (t[_] !== void 0) return t[_]
      const w = y.interleavedBuffers[_],
        x = s(y, w.buffer),
        T = qf(w.type, x),
        A = new e_(T, w.stride)
      return (A.uuid = w.uuid), (t[_] = A), A
    }
    function s(y, _) {
      if (i[_] !== void 0) return i[_]
      const w = y.arrayBuffers[_],
        x = new Uint32Array(w).buffer
      return (i[_] = x), x
    }
    const o = e.isInstancedBufferGeometry ? new SN() : new _n(),
      a = e.data.index
    if (a !== void 0) {
      const y = qf(a.type, a.array)
      o.setIndex(new qn(y, 1))
    }
    const c = e.data.attributes
    for (const y in c) {
      const _ = c[y]
      let M
      if (_.isInterleavedBufferAttribute) {
        const w = r(e.data, _.data)
        M = new gd(w, _.itemSize, _.offset, _.normalized)
      } else {
        const w = qf(_.type, _.array),
          x = _.isInstancedBufferAttribute ? vh : qn
        M = new x(w, _.itemSize, _.normalized)
      }
      _.name !== void 0 && (M.name = _.name),
        _.usage !== void 0 && M.setUsage(_.usage),
        o.setAttribute(y, M)
    }
    const u = e.data.morphAttributes
    if (u)
      for (const y in u) {
        const _ = u[y],
          M = []
        for (let w = 0, x = _.length; w < x; w++) {
          const T = _[w]
          let A
          if (T.isInterleavedBufferAttribute) {
            const P = r(e.data, T.data)
            A = new gd(P, T.itemSize, T.offset, T.normalized)
          } else {
            const P = qf(T.type, T.array)
            A = new qn(P, T.itemSize, T.normalized)
          }
          T.name !== void 0 && (A.name = T.name), M.push(A)
        }
        o.morphAttributes[y] = M
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0)
    const m = e.data.groups || e.data.drawcalls || e.data.offsets
    if (m !== void 0)
      for (let y = 0, _ = m.length; y !== _; ++y) {
        const M = m[y]
        o.addGroup(M.start, M.count, M.materialIndex)
      }
    const g = e.data.boundingSphere
    if (g !== void 0) {
      const y = new re()
      g.center !== void 0 && y.fromArray(g.center),
        (o.boundingSphere = new Dr(y, g.radius))
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    )
  }
}
class Hz extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = this.path === '' ? HS.extractUrlBase(e) : this.path
    this.resourcePath = this.resourcePath || o
    const a = new Os(this.manager)
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (c) {
          let u = null
          try {
            u = JSON.parse(c)
          } catch (m) {
            r !== void 0 && r(m),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + '.',
                m.message,
              )
            return
          }
          const h = u.metadata
          if (
            h === void 0 ||
            h.type === void 0 ||
            h.type.toLowerCase() === 'geometry'
          ) {
            r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e)
            return
          }
          s.parse(u, t)
        },
        i,
        r,
      )
  }
  async loadAsync(e, t) {
    const i = this,
      r = this.path === '' ? HS.extractUrlBase(e) : this.path
    this.resourcePath = this.resourcePath || r
    const s = new Os(this.manager)
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials)
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      c = a.metadata
    if (
      c === void 0 ||
      c.type === void 0 ||
      c.type.toLowerCase() === 'geometry'
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e)
    return await i.parseAsync(a)
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(u)
      }),
      a = this.parseTextures(e.textures, o),
      c = this.parseMaterials(e.materials, a),
      u = this.parseObject(e.object, s, c, a, i),
      h = this.parseSkeletons(e.skeletons, u)
    if ((this.bindSkeletons(u, h), this.bindLightTargets(u), t !== void 0)) {
      let m = !1
      for (const g in o)
        if (o[g].data instanceof HTMLImageElement) {
          m = !0
          break
        }
      m === !1 && t(u)
    }
    return u
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, i),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      c = this.parseObject(e.object, r, a, o, t),
      u = this.parseSkeletons(e.skeletons, c)
    return this.bindSkeletons(c, u), this.bindLightTargets(c), c
  }
  parseShapes(e) {
    const t = {}
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new ud().fromJSON(e[i])
        t[s.uuid] = s
      }
    return t
  }
  parseSkeletons(e, t) {
    const i = {},
      r = {}
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s)
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new t_().fromJSON(e[s], r)
        i[a.uuid] = a
      }
    return i
  }
  parseGeometries(e, t) {
    const i = {}
    if (e !== void 0) {
      const r = new MN()
      for (let s = 0, o = e.length; s < o; s++) {
        let a
        const c = e[s]
        switch (c.type) {
          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            a = r.parse(c)
            break
          default:
            c.type in gC
              ? (a = gC[c.type].fromJSON(c, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${c.type}"`,
                )
        }
        ;(a.uuid = c.uuid),
          c.name !== void 0 && (a.name = c.name),
          c.userData !== void 0 && (a.userData = c.userData),
          (i[c.uuid] = a)
      }
    }
    return i
  }
  parseMaterials(e, t) {
    const i = {},
      r = {}
    if (e !== void 0) {
      const s = new v_()
      s.setTextures(t)
      for (let o = 0, a = e.length; o < a; o++) {
        const c = e[o]
        i[c.uuid] === void 0 && (i[c.uuid] = s.parse(c)),
          (r[c.uuid] = i[c.uuid])
      }
    }
    return r
  }
  parseAnimations(e) {
    const t = {}
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          s = tg.parse(r)
        t[s.uuid] = s
      }
    return t
  }
  parseImages(e, t) {
    const i = this,
      r = {}
    let s
    function o(c) {
      return (
        i.manager.itemStart(c),
        s.load(
          c,
          function () {
            i.manager.itemEnd(c)
          },
          void 0,
          function () {
            i.manager.itemError(c), i.manager.itemEnd(c)
          },
        )
      )
    }
    function a(c) {
      if (typeof c == 'string') {
        const u = c,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : i.resourcePath + u
        return o(h)
      } else
        return c.data
          ? { data: qf(c.type, c.data), width: c.width, height: c.height }
          : null
    }
    if (e !== void 0 && e.length > 0) {
      const c = new g_(t)
      ;(s = new ng(c)), s.setCrossOrigin(this.crossOrigin)
      for (let u = 0, h = e.length; u < h; u++) {
        const m = e[u],
          g = m.url
        if (Array.isArray(g)) {
          const y = []
          for (let _ = 0, M = g.length; _ < M; _++) {
            const w = g[_],
              x = a(w)
            x !== null &&
              (x instanceof HTMLImageElement
                ? y.push(x)
                : y.push(new $o(x.data, x.width, x.height)))
          }
          r[m.uuid] = new ed(y)
        } else {
          const y = a(m.url)
          r[m.uuid] = new ed(y)
        }
      }
    }
    return r
  }
  async parseImagesAsync(e) {
    const t = this,
      i = {}
    let r
    async function s(o) {
      if (typeof o == 'string') {
        const a = o,
          c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a
        return await r.loadAsync(c)
      } else
        return o.data
          ? { data: qf(o.type, o.data), width: o.width, height: o.height }
          : null
    }
    if (e !== void 0 && e.length > 0) {
      ;(r = new ng(this.manager)), r.setCrossOrigin(this.crossOrigin)
      for (let o = 0, a = e.length; o < a; o++) {
        const c = e[o],
          u = c.url
        if (Array.isArray(u)) {
          const h = []
          for (let m = 0, g = u.length; m < g; m++) {
            const y = u[m],
              _ = await s(y)
            _ !== null &&
              (_ instanceof HTMLImageElement
                ? h.push(_)
                : h.push(new $o(_.data, _.width, _.height)))
          }
          i[c.uuid] = new ed(h)
        } else {
          const h = await s(c.url)
          i[c.uuid] = new ed(h)
        }
      }
    }
    return i
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == 'number'
        ? s
        : (console.warn(
            'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
            s,
          ),
          o[s])
    }
    const r = {}
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s]
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn('THREE.ObjectLoader: Undefined image', a.image)
        const c = t[a.image],
          u = c.data
        let h
        Array.isArray(u)
          ? ((h = new Ig()), u.length === 6 && (h.needsUpdate = !0))
          : (u && u.data ? (h = new $o()) : (h = new Xn()),
            u && (h.needsUpdate = !0)),
          (h.source = c),
          (h.uuid = a.uuid),
          a.name !== void 0 && (h.name = a.name),
          a.mapping !== void 0 && (h.mapping = i(a.mapping, Gz)),
          a.channel !== void 0 && (h.channel = a.channel),
          a.offset !== void 0 && h.offset.fromArray(a.offset),
          a.repeat !== void 0 && h.repeat.fromArray(a.repeat),
          a.center !== void 0 && h.center.fromArray(a.center),
          a.rotation !== void 0 && (h.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((h.wrapS = i(a.wrap[0], _C)), (h.wrapT = i(a.wrap[1], _C))),
          a.format !== void 0 && (h.format = a.format),
          a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat),
          a.type !== void 0 && (h.type = a.type),
          a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace),
          a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, wC)),
          a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, wC)),
          a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (h.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (h.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (h.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (h.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (h.compareFunction = a.compareFunction),
          a.userData !== void 0 && (h.userData = a.userData),
          (r[a.uuid] = h)
      }
    return r
  }
  parseObject(e, t, i, r, s) {
    let o
    function a(g) {
      return (
        t[g] === void 0 &&
          console.warn('THREE.ObjectLoader: Undefined geometry', g),
        t[g]
      )
    }
    function c(g) {
      if (g !== void 0) {
        if (Array.isArray(g)) {
          const y = []
          for (let _ = 0, M = g.length; _ < M; _++) {
            const w = g[_]
            i[w] === void 0 &&
              console.warn('THREE.ObjectLoader: Undefined material', w),
              y.push(i[w])
          }
          return y
        }
        return (
          i[g] === void 0 &&
            console.warn('THREE.ObjectLoader: Undefined material', g),
          i[g]
        )
      }
    }
    function u(g) {
      return (
        r[g] === void 0 &&
          console.warn('THREE.ObjectLoader: Undefined texture', g),
        r[g]
      )
    }
    let h, m
    switch (e.type) {
      case 'Scene':
        ;(o = new Lg()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Tt(e.background))
              : (o.background = u(e.background))),
          e.environment !== void 0 && (o.environment = u(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === 'Fog'
              ? (o.fog = new Jx(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === 'FogExp2' &&
                (o.fog = new Qx(e.fog.color, e.fog.density)),
            e.fog.name !== '' && (o.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            o.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (o.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            o.environmentRotation.fromArray(e.environmentRotation)
        break
      case 'PerspectiveCamera':
        ;(o = new sr(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view))
        break
      case 'OrthographicCamera':
        ;(o = new Nh(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view))
        break
      case 'AmbientLight':
        o = new yN(e.color, e.intensity)
        break
      case 'DirectionalLight':
        ;(o = new vN(e.color, e.intensity)), (o.target = e.target || '')
        break
      case 'PointLight':
        o = new gN(e.color, e.intensity, e.distance, e.decay)
        break
      case 'RectAreaLight':
        o = new xN(e.color, e.intensity, e.width, e.height)
        break
      case 'SpotLight':
        ;(o = new mN(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay,
        )),
          (o.target = e.target || '')
        break
      case 'HemisphereLight':
        o = new pN(e.color, e.groundColor, e.intensity)
        break
      case 'LightProbe':
        o = new wN().fromJSON(e)
        break
      case 'SkinnedMesh':
        ;(h = a(e.geometry)),
          (m = c(e.material)),
          (o = new UL(h, m)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton)
        break
      case 'Mesh':
        ;(h = a(e.geometry)), (m = c(e.material)), (o = new vi(h, m))
        break
      case 'InstancedMesh':
        ;(h = a(e.geometry)), (m = c(e.material))
        const g = e.count,
          y = e.instanceMatrix,
          _ = e.instanceColor
        ;(o = new BL(h, m, g)),
          (o.instanceMatrix = new vh(new Float32Array(y.array), 16)),
          _ !== void 0 &&
            (o.instanceColor = new vh(new Float32Array(_.array), _.itemSize))
        break
      case 'BatchedMesh':
        ;(h = a(e.geometry)),
          (m = c(e.material)),
          (o = new zL(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            m,
          )),
          (o.geometry = h),
          (o.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (o.sortObjects = e.sortObjects),
          (o._drawRanges = e.drawRanges),
          (o._reservedRanges = e.reservedRanges),
          (o._visibility = e.visibility),
          (o._active = e.active),
          (o._bounds = e.bounds.map((M) => {
            const w = new Jr()
            w.min.fromArray(M.boxMin), w.max.fromArray(M.boxMax)
            const x = new Dr()
            return (
              (x.radius = M.sphereRadius),
              x.center.fromArray(M.sphereCenter),
              {
                boxInitialized: M.boxInitialized,
                box: w,
                sphereInitialized: M.sphereInitialized,
                sphere: x,
              }
            )
          })),
          (o._maxInstanceCount = e.maxInstanceCount),
          (o._maxVertexCount = e.maxVertexCount),
          (o._maxIndexCount = e.maxIndexCount),
          (o._geometryInitialized = e.geometryInitialized),
          (o._geometryCount = e.geometryCount),
          (o._matricesTexture = u(e.matricesTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (o._colorsTexture = u(e.colorsTexture.uuid))
        break
      case 'LOD':
        o = new FL()
        break
      case 'Line':
        o = new Rc(a(e.geometry), c(e.material))
        break
      case 'LineLoop':
        o = new VL(a(e.geometry), c(e.material))
        break
      case 'LineSegments':
        o = new Ra(a(e.geometry), c(e.material))
        break
      case 'PointCloud':
      case 'Points':
        o = new jL(a(e.geometry), c(e.material))
        break
      case 'Sprite':
        o = new kL(c(e.material))
        break
      case 'Group':
        o = new Yf()
        break
      case 'Bone':
        o = new fE()
        break
      default:
        o = new Ln()
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (o.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const g = e.children
      for (let y = 0; y < g.length; y++)
        o.add(this.parseObject(g[y], t, i, r, s))
    }
    if (e.animations !== void 0) {
      const g = e.animations
      for (let y = 0; y < g.length; y++) {
        const _ = g[y]
        o.animations.push(s[_])
      }
    }
    if (e.type === 'LOD') {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate)
      const g = e.levels
      for (let y = 0; y < g.length; y++) {
        const _ = g[y],
          M = o.getObjectByProperty('uuid', _.object)
        M !== void 0 && o.addLevel(M, _.distance, _.hysteresis)
      }
    }
    return o
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (i) {
        if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
          const r = t[i.skeleton]
          r === void 0
            ? console.warn(
                'THREE.ObjectLoader: No skeleton found with UUID:',
                i.skeleton,
              )
            : i.bind(r, i.bindMatrix)
        }
      })
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const i = t.target,
          r = e.getObjectByProperty('uuid', i)
        r !== void 0 ? (t.target = r) : (t.target = new Ln())
      }
    })
  }
}
const Gz = {
    UVMapping: Cc,
    CubeReflectionMapping: ba,
    CubeRefractionMapping: Pc,
    EquirectangularReflectionMapping: hh,
    EquirectangularRefractionMapping: zm,
    CubeUVReflectionMapping: Rh,
  },
  _C = {
    RepeatWrapping: Vm,
    ClampToEdgeWrapping: Bi,
    MirroredRepeatWrapping: jm,
  },
  wC = {
    NearestFilter: yr,
    NearestMipmapNearestFilter: KM,
    NearestMipmapLinearFilter: Xf,
    LinearFilter: Vn,
    LinearMipmapNearestFilter: gm,
    LinearMipmapLinearFilter: ma,
  }
class Wz extends ns {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > 'u' &&
        console.warn(
          'THREE.ImageBitmapLoader: createImageBitmap() not supported.',
        ),
      typeof fetch > 'u' &&
        console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      (this.options = { premultiplyAlpha: 'none' })
  }
  setOptions(e) {
    return (this.options = e), this
  }
  load(e, t, i, r) {
    e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e))
    const s = this,
      o = xl.get(e)
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((u) => {
          t && t(u), s.manager.itemEnd(e)
        }).catch((u) => {
          r && r(u)
        })
        return
      }
      return (
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e)
        }, 0),
        o
      )
    }
    const a = {}
    ;(a.credentials =
      this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'),
      (a.headers = this.requestHeader)
    const c = fetch(e, a)
      .then(function (u) {
        return u.blob()
      })
      .then(function (u) {
        return createImageBitmap(
          u,
          Object.assign(s.options, { colorSpaceConversion: 'none' }),
        )
      })
      .then(function (u) {
        return xl.add(e, u), t && t(u), s.manager.itemEnd(e), u
      })
      .catch(function (u) {
        r && r(u), xl.remove(e), s.manager.itemError(e), s.manager.itemEnd(e)
      })
    xl.add(e, c), s.manager.itemStart(e)
  }
}
let N0
class RE {
  static getContext() {
    return (
      N0 === void 0 &&
        (N0 = new (window.AudioContext || window.webkitAudioContext)()),
      N0
    )
  }
  static setContext(e) {
    N0 = e
  }
}
class $z extends ns {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = new Os(this.manager)
    o.setResponseType('arraybuffer'),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (c) {
          try {
            const u = c.slice(0)
            RE.getContext()
              .decodeAudioData(u, function (m) {
                t(m)
              })
              .catch(a)
          } catch (u) {
            a(u)
          }
        },
        i,
        r,
      )
    function a(c) {
      r ? r(c) : console.error(c), s.manager.itemError(e)
    }
  }
}
const SC = new Jt(),
  MC = new Jt(),
  Nu = new Jt()
class Xz {
  constructor() {
    ;(this.type = 'StereoCamera'),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new sr()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new sr()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      })
  }
  update(e) {
    const t = this._cache
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      ;(t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        Nu.copy(e.projectionMatrix)
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        o = (t.near * Math.tan(ld * t.fov * 0.5)) / t.zoom
      let a, c
      ;(MC.elements[12] = -r),
        (SC.elements[12] = r),
        (a = -o * t.aspect + s),
        (c = o * t.aspect + s),
        (Nu.elements[0] = (2 * t.near) / (c - a)),
        (Nu.elements[8] = (c + a) / (c - a)),
        this.cameraL.projectionMatrix.copy(Nu),
        (a = -o * t.aspect - s),
        (c = o * t.aspect - s),
        (Nu.elements[0] = (2 * t.near) / (c - a)),
        (Nu.elements[8] = (c + a) / (c - a)),
        this.cameraR.projectionMatrix.copy(Nu)
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(MC),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(SC)
  }
}
class EN extends sr {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e)
  }
}
class IE {
  constructor(e = !0) {
    ;(this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1)
  }
  start() {
    ;(this.startTime = EC()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0)
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1)
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime
  }
  getDelta() {
    let e = 0
    if (this.autoStart && !this.running) return this.start(), 0
    if (this.running) {
      const t = EC()
      ;(e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e)
    }
    return e
  }
}
function EC() {
  return performance.now()
}
const Du = new re(),
  bC = new xs(),
  qz = new re(),
  Ou = new re()
class Yz extends Ln {
  constructor() {
    super(),
      (this.type = 'AudioListener'),
      (this.context = RE.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new IE())
  }
  getInput() {
    return this.gain
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    )
  }
  getFilter() {
    return this.filter
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    )
  }
  getMasterVolume() {
    return this.gain.gain.value
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    )
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e)
    const t = this.context.listener,
      i = this.up
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Du, bC, qz),
      Ou.set(0, 0, -1).applyQuaternion(bC),
      t.positionX)
    ) {
      const r = this.context.currentTime + this.timeDelta
      t.positionX.linearRampToValueAtTime(Du.x, r),
        t.positionY.linearRampToValueAtTime(Du.y, r),
        t.positionZ.linearRampToValueAtTime(Du.z, r),
        t.forwardX.linearRampToValueAtTime(Ou.x, r),
        t.forwardY.linearRampToValueAtTime(Ou.y, r),
        t.forwardZ.linearRampToValueAtTime(Ou.z, r),
        t.upX.linearRampToValueAtTime(i.x, r),
        t.upY.linearRampToValueAtTime(i.y, r),
        t.upZ.linearRampToValueAtTime(i.z, r)
    } else
      t.setPosition(Du.x, Du.y, Du.z),
        t.setOrientation(Ou.x, Ou.y, Ou.z, i.x, i.y, i.z)
  }
}
class bN extends Ln {
  constructor(e) {
    super(),
      (this.type = 'Audio'),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = 'empty'),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = [])
  }
  getOutput() {
    return this.gain
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'audioNode'),
      (this.source = e),
      this.connect(),
      this
    )
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'mediaNode'),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    )
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'mediaStreamNode'),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    )
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = 'buffer'),
      this.autoplay && this.play(),
      this
    )
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn('THREE.Audio: Audio is already playing.')
      return
    }
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    this._startedAt = this.context.currentTime + e
    const t = this.context.createBufferSource()
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    )
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    )
  }
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + e),
        (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    )
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0])
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e])
      this.filters[this.filters.length - 1].connect(this.getOutput())
    } else this.source.connect(this.getOutput())
    return (this._connected = !0), this
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0])
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e])
        this.filters[this.filters.length - 1].disconnect(this.getOutput())
      } else this.source.disconnect(this.getOutput())
      return (this._connected = !1), this
    }
  }
  getFilters() {
    return this.filters
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    )
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01,
        ),
      this
    )
  }
  getDetune() {
    return this.detune
  }
  getFilter() {
    return this.getFilters()[0]
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : [])
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01,
        ),
      this
    )
  }
  getPlaybackRate() {
    return this.playbackRate
  }
  onEnded() {
    ;(this.isPlaying = !1), (this._progress = 0)
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
      : this.loop
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    )
  }
  setLoopStart(e) {
    return (this.loopStart = e), this
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this
  }
  getVolume() {
    return this.gain.gain.value
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    )
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.sourceType !== 'buffer'
        ? (console.warn('THREE.Audio: Audio source type cannot be copied.'),
          this)
        : ((this.autoplay = e.autoplay),
          (this.buffer = e.buffer),
          (this.detune = e.detune),
          (this.loop = e.loop),
          (this.loopStart = e.loopStart),
          (this.loopEnd = e.loopEnd),
          (this.offset = e.offset),
          (this.duration = e.duration),
          (this.playbackRate = e.playbackRate),
          (this.hasPlaybackControl = e.hasPlaybackControl),
          (this.sourceType = e.sourceType),
          (this.filters = e.filters.slice()),
          this)
    )
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e)
  }
}
const ku = new re(),
  TC = new xs(),
  Zz = new re(),
  Fu = new re()
class Kz extends bN {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = 'HRTF'),
      this.panner.connect(this.gain)
  }
  connect() {
    super.connect(), this.panner.connect(this.gain)
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain)
  }
  getOutput() {
    return this.panner
  }
  getRefDistance() {
    return this.panner.refDistance
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this
  }
  getDistanceModel() {
    return this.panner.distanceModel
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this
  }
  getMaxDistance() {
    return this.panner.maxDistance
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this
  }
  setDirectionalCone(e, t, i) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = i),
      this
    )
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return
    this.matrixWorld.decompose(ku, TC, Zz), Fu.set(0, 0, 1).applyQuaternion(TC)
    const t = this.panner
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta
      t.positionX.linearRampToValueAtTime(ku.x, i),
        t.positionY.linearRampToValueAtTime(ku.y, i),
        t.positionZ.linearRampToValueAtTime(ku.z, i),
        t.orientationX.linearRampToValueAtTime(Fu.x, i),
        t.orientationY.linearRampToValueAtTime(Fu.y, i),
        t.orientationZ.linearRampToValueAtTime(Fu.z, i)
    } else t.setPosition(ku.x, ku.y, ku.z), t.setOrientation(Fu.x, Fu.y, Fu.z)
  }
}
class Qz {
  constructor(e, t = 2048) {
    ;(this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser)
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data
  }
  getAverageFrequency() {
    let e = 0
    const t = this.getFrequencyData()
    for (let i = 0; i < t.length; i++) e += t[i]
    return e / t.length
  }
}
class TN {
  constructor(e, t, i) {
    ;(this.binding = e), (this.valueSize = i)
    let r, s, o
    switch (t) {
      case 'quaternion':
        ;(r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5)
        break
      case 'string':
      case 'bool':
        ;(r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5))
        break
      default:
        ;(r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5))
    }
    ;(this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0)
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r
    let o = this.cumulativeWeight
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a]
      o = t
    } else {
      o += t
      const a = t / o
      this._mixBufferRegion(i, s, 0, a, r)
    }
    this.cumulativeWeight = o
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e)
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const c = t * this._origIndex
      this._mixBufferRegion(i, r, c, 1 - s, t)
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t)
    for (let c = t, u = t + t; c !== u; ++c)
      if (i[c] !== i[c + t]) {
        a.setValue(i, r)
        break
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex
    e.getValue(t, r)
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)]
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0)
  }
  restoreOriginalState() {
    const e = this.valueSize * 3
    this.binding.setValue(this.buffer, e)
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize
    for (let i = e; i < t; i++) this.buffer[i] = 0
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1)
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i]
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o]
  }
  _slerp(e, t, i, r) {
    xs.slerpFlat(e, t, e, t, e, i, r)
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s
    xs.multiplyQuaternionsFlat(e, o, e, t, e, i),
      xs.slerpFlat(e, t, e, t, e, o, r)
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r
    for (let a = 0; a !== s; ++a) {
      const c = t + a
      e[c] = e[c] * o + e[i + a] * r
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o
      e[a] = e[a] + e[i + o] * r
    }
  }
}
const LE = '\\[\\]\\.:\\/',
  Jz = new RegExp('[' + LE + ']', 'g'),
  NE = '[^' + LE + ']',
  eV = '[^' + LE.replace('\\.', '') + ']',
  tV = /((?:WC+[\/:])*)/.source.replace('WC', NE),
  nV = /(WCOD+)?/.source.replace('WCOD', eV),
  iV = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', NE),
  rV = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', NE),
  sV = new RegExp('^' + tV + nV + iV + rV + '$'),
  oV = ['material', 'materials', 'bones', 'map']
class aV {
  constructor(e, t, i) {
    const r = i || Rn.parseTrackName(t)
    ;(this._targetGroup = e), (this._bindings = e.subscribe_(t, r))
  }
  getValue(e, t) {
    this.bind()
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i]
    r !== void 0 && r.getValue(e, t)
  }
  setValue(e, t) {
    const i = this._bindings
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t)
  }
  bind() {
    const e = this._bindings
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind()
  }
  unbind() {
    const e = this._bindings
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind()
  }
}
class Rn {
  constructor(e, t, i) {
    ;(this.path = t),
      (this.parsedPath = i || Rn.parseTrackName(t)),
      (this.node = Rn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new Rn.Composite(e, t, i)
      : new Rn(e, t, i)
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, '_').replace(Jz, '')
  }
  static parseTrackName(e) {
    const t = sV.exec(e)
    if (t === null)
      throw new Error('PropertyBinding: Cannot parse trackName: ' + e)
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf('.')
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1)
      oV.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s))
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        'PropertyBinding: can not parse propertyName from trackName: ' + e,
      )
    return i
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === '' ||
      t === '.' ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t)
      if (i !== void 0) return i
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o]
            if (a.name === t || a.uuid === t) return a
            const c = i(a.children)
            if (c) return c
          }
          return null
        },
        r = i(e.children)
      if (r) return r
    }
    return null
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName]
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r]
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex]
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t)
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t]
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    ;(this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    ;(this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
    this.targetObject.needsUpdate = !0
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
    this.targetObject.matrixWorldNeedsUpdate = !0
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t]
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    ;(this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    ;(this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t)
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0)
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t)
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t)
  }
  bind() {
    let e = this.node
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName
    let s = t.propertyIndex
    if (
      (e || ((e = Rn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        'THREE.PropertyBinding: No target node found for track: ' +
          this.path +
          '.',
      )
      return
    }
    if (i) {
      let u = t.objectIndex
      switch (i) {
        case 'materials':
          if (!e.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this,
            )
            return
          }
          if (!e.material.materials) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
              this,
            )
            return
          }
          e = e.material.materials
          break
        case 'bones':
          if (!e.skeleton) {
            console.error(
              'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
              this,
            )
            return
          }
          e = e.skeleton.bones
          for (let h = 0; h < e.length; h++)
            if (e[h].name === u) {
              u = h
              break
            }
          break
        case 'map':
          if ('map' in e) {
            e = e.map
            break
          }
          if (!e.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this,
            )
            return
          }
          if (!e.material.map) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.',
              this,
            )
            return
          }
          e = e.material.map
          break
        default:
          if (e[i] === void 0) {
            console.error(
              'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
              this,
            )
            return
          }
          e = e[i]
      }
      if (u !== void 0) {
        if (e[u] === void 0) {
          console.error(
            'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
            this,
            e,
          )
          return
        }
        e = e[u]
      }
    }
    const o = e[r]
    if (o === void 0) {
      const u = t.nodeName
      console.error(
        'THREE.PropertyBinding: Trying to update property for track: ' +
          u +
          '.' +
          r +
          " but it wasn't found.",
        e,
      )
      return
    }
    let a = this.Versioning.None
    ;(this.targetObject = e),
      e.isMaterial === !0
        ? (a = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (a = this.Versioning.MatrixWorldNeedsUpdate)
    let c = this.BindingType.Direct
    if (s !== void 0) {
      if (r === 'morphTargetInfluences') {
        if (!e.geometry) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
            this,
          )
          return
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
            this,
          )
          return
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s])
      }
      ;(c = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s)
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((c = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((c = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = r)
    ;(this.getValue = this.GetterByBindingType[c]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[c][a])
  }
  unbind() {
    ;(this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
}
Rn.Composite = aV
Rn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
}
Rn.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }
Rn.prototype.GetterByBindingType = [
  Rn.prototype._getValue_direct,
  Rn.prototype._getValue_array,
  Rn.prototype._getValue_arrayElement,
  Rn.prototype._getValue_toArray,
]
Rn.prototype.SetterByBindingTypeAndVersioning = [
  [
    Rn.prototype._setValue_direct,
    Rn.prototype._setValue_direct_setNeedsUpdate,
    Rn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Rn.prototype._setValue_array,
    Rn.prototype._setValue_array_setNeedsUpdate,
    Rn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Rn.prototype._setValue_arrayElement,
    Rn.prototype._setValue_arrayElement_setNeedsUpdate,
    Rn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Rn.prototype._setValue_fromArray,
    Rn.prototype._setValue_fromArray_setNeedsUpdate,
    Rn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
]
class lV {
  constructor() {
    ;(this.isAnimationObjectGroup = !0),
      (this.uuid = Ds()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0)
    const e = {}
    this._indicesByUUID = e
    for (let i = 0, r = arguments.length; i !== r; ++i) e[arguments[i].uuid] = i
    ;(this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {})
    const t = this
    this.stats = {
      objects: {
        get total() {
          return t._objects.length
        },
        get inUse() {
          return this.total - t.nCachedObjects_
        },
      },
      get bindingsPerObject() {
        return t._bindings.length
      },
    }
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      o = s.length
    let a,
      c = e.length,
      u = this.nCachedObjects_
    for (let h = 0, m = arguments.length; h !== m; ++h) {
      const g = arguments[h],
        y = g.uuid
      let _ = t[y]
      if (_ === void 0) {
        ;(_ = c++), (t[y] = _), e.push(g)
        for (let M = 0, w = o; M !== w; ++M) s[M].push(new Rn(g, i[M], r[M]))
      } else if (_ < u) {
        a = e[_]
        const M = --u,
          w = e[M]
        ;(t[w.uuid] = _), (e[_] = w), (t[y] = M), (e[M] = g)
        for (let x = 0, T = o; x !== T; ++x) {
          const A = s[x],
            P = A[M]
          let D = A[_]
          ;(A[_] = P), D === void 0 && (D = new Rn(g, i[x], r[x])), (A[M] = D)
        }
      } else
        e[_] !== a &&
          console.error(
            'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.',
          )
    }
    this.nCachedObjects_ = u
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length
    let s = this.nCachedObjects_
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const c = arguments[o],
        u = c.uuid,
        h = t[u]
      if (h !== void 0 && h >= s) {
        const m = s++,
          g = e[m]
        ;(t[g.uuid] = h), (e[h] = g), (t[u] = m), (e[m] = c)
        for (let y = 0, _ = r; y !== _; ++y) {
          const M = i[y],
            w = M[m],
            x = M[h]
          ;(M[h] = w), (M[m] = x)
        }
      }
    }
    this.nCachedObjects_ = s
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length
    let s = this.nCachedObjects_,
      o = e.length
    for (let a = 0, c = arguments.length; a !== c; ++a) {
      const u = arguments[a],
        h = u.uuid,
        m = t[h]
      if (m !== void 0)
        if ((delete t[h], m < s)) {
          const g = --s,
            y = e[g],
            _ = --o,
            M = e[_]
          ;(t[y.uuid] = m), (e[m] = y), (t[M.uuid] = g), (e[g] = M), e.pop()
          for (let w = 0, x = r; w !== x; ++w) {
            const T = i[w],
              A = T[g],
              P = T[_]
            ;(T[m] = A), (T[g] = P), T.pop()
          }
        } else {
          const g = --o,
            y = e[g]
          g > 0 && (t[y.uuid] = m), (e[m] = y), e.pop()
          for (let _ = 0, M = r; _ !== M; ++_) {
            const w = i[_]
            ;(w[m] = w[g]), w.pop()
          }
        }
    }
    this.nCachedObjects_ = s
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath
    let r = i[e]
    const s = this._bindings
    if (r !== void 0) return s[r]
    const o = this._paths,
      a = this._parsedPaths,
      c = this._objects,
      u = c.length,
      h = this.nCachedObjects_,
      m = new Array(u)
    ;(r = s.length), (i[e] = r), o.push(e), a.push(t), s.push(m)
    for (let g = h, y = c.length; g !== y; ++g) {
      const _ = c[g]
      m[g] = new Rn(_, e, t)
    }
    return m
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      i = t[e]
    if (i !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        c = o[a],
        u = e[a]
      ;(t[u] = i),
        (o[i] = c),
        o.pop(),
        (s[i] = s[a]),
        s.pop(),
        (r[i] = r[a]),
        r.pop()
    }
  }
}
class AN {
  constructor(e, t, i = null, r = t.blendMode) {
    ;(this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r)
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      c = { endingStart: Qu, endingEnd: Qu }
    for (let u = 0; u !== o; ++u) {
      const h = s[u].createInterpolant(null)
      ;(a[u] = h), (h.settings = c)
    }
    ;(this._interpolantSettings = c),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = gL),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0)
  }
  play() {
    return this._mixer._activateAction(this), this
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset()
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    )
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    )
  }
  isScheduled() {
    return this._mixer._isActiveAction(this)
  }
  startAt(e) {
    return (this._startTime = e), this
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    )
  }
  getEffectiveWeight() {
    return this._effectiveWeight
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1)
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0)
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s
      e.warp(1, o, t), this.warp(a, 1, t)
    }
    return this
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i)
  }
  stopFading() {
    const e = this._weightInterpolant
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    )
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    )
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping()
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    )
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e)
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale
    let a = this._timeScaleInterpolant
    a === null &&
      ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a))
    const c = a.parameterPositions,
      u = a.sampleValues
    return (c[0] = s), (c[1] = s + i), (u[0] = e / o), (u[1] = t / o), this
  }
  stopWarping() {
    const e = this._timeScaleInterpolant
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    )
  }
  getMixer() {
    return this._mixer
  }
  getClip() {
    return this._clip
  }
  getRoot() {
    return this._localRoot || this._mixer._root
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e)
      return
    }
    const s = this._startTime
    if (s !== null) {
      const c = (e - s) * i
      c < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * c))
    }
    t *= this._updateTimeScale(e)
    const o = this._updateTime(t),
      a = this._updateWeight(e)
    if (a > 0) {
      const c = this._interpolants,
        u = this._propertyBindings
      switch (this.blendMode) {
        case sE:
          for (let h = 0, m = c.length; h !== m; ++h)
            c[h].evaluate(o), u[h].accumulateAdditive(a)
          break
        case Yx:
        default:
          for (let h = 0, m = c.length; h !== m; ++h)
            c[h].evaluate(o), u[h].accumulate(r, a)
      }
    }
  }
  _updateWeight(e) {
    let t = 0
    if (this.enabled) {
      t = this.weight
      const i = this._weightInterpolant
      if (i !== null) {
        const r = i.evaluate(e)[0]
        ;(t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1))
      }
    }
    return (this._effectiveWeight = t), t
  }
  _updateTimeScale(e) {
    let t = 0
    if (!this.paused) {
      t = this.timeScale
      const i = this._timeScaleInterpolant
      if (i !== null) {
        const r = i.evaluate(e)[0]
        ;(t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t))
      }
    }
    return (this._effectiveTimeScale = t), t
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop
    let r = this.time + e,
      s = this._loopCount
    const o = i === vL
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r
    if (i === mL) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
      e: {
        if (r >= t) r = t
        else if (r < 0) r = 0
        else {
          this.time = r
          break e
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: e < 0 ? -1 : 1,
          })
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t)
        ;(r -= t * a), (s += Math.abs(a))
        const c = this.repetitions - s
        if (c <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: e > 0 ? 1 : -1,
            })
        else {
          if (c === 1) {
            const u = e < 0
            this._setEndings(u, !u, o)
          } else this._setEndings(!1, !1, o)
          ;(this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: 'loop',
              action: this,
              loopDelta: a,
            })
        }
      } else this.time = r
      if (o && (s & 1) === 1) return t - r
    }
    return r
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings
    i
      ? ((r.endingStart = Ju), (r.endingEnd = Ju))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? Ju : Qu)
          : (r.endingStart = Gm),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? Ju : Qu) : (r.endingEnd = Gm))
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time
    let o = this._weightInterpolant
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o))
    const a = o.parameterPositions,
      c = o.sampleValues
    return (a[0] = s), (c[0] = t), (a[1] = s + e), (c[1] = i), this
  }
}
const cV = new Float32Array(1)
class uV extends Pa {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1)
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      c = i.uuid,
      u = this._bindingsByRootAndName
    let h = u[c]
    h === void 0 && ((h = {}), (u[c] = h))
    for (let m = 0; m !== s; ++m) {
      const g = r[m],
        y = g.name
      let _ = h[y]
      if (_ !== void 0) ++_.referenceCount, (o[m] = _)
      else {
        if (((_ = o[m]), _ !== void 0)) {
          _._cacheIndex === null &&
            (++_.referenceCount, this._addInactiveBinding(_, c, y))
          continue
        }
        const M = t && t._propertyBindings[m].binding.parsedPath
        ;(_ = new TN(Rn.create(i, y, M), g.ValueTypeName, g.getValueSize())),
          ++_.referenceCount,
          this._addInactiveBinding(_, c, y),
          (o[m] = _)
      }
      a[m].resultBuffer = _.buffer
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r]
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i)
      }
      const t = e._propertyBindings
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i]
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState())
      }
      this._lendAction(e)
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i]
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s))
      }
      this._takeBackAction(e)
    }
  }
  _initMemoryManager() {
    ;(this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0)
    const e = this
    this.stats = {
      actions: {
        get total() {
          return e._actions.length
        },
        get inUse() {
          return e._nActiveActions
        },
      },
      bindings: {
        get total() {
          return e._bindings.length
        },
        get inUse() {
          return e._nActiveBindings
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length
        },
        get inUse() {
          return e._nActiveControlInterpolants
        },
      },
    }
  }
  _isActiveAction(e) {
    const t = e._cacheIndex
    return t !== null && t < this._nActiveActions
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip
    let o = s[t]
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o)
    else {
      const a = o.knownActions
      ;(e._byClipCacheIndex = a.length), a.push(e)
    }
    ;(e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e)
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex
    ;(i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null)
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      c = a.knownActions,
      u = c[c.length - 1],
      h = e._byClipCacheIndex
    ;(u._byClipCacheIndex = h),
      (c[h] = u),
      c.pop(),
      (e._byClipCacheIndex = null)
    const m = a.actionByRoot,
      g = (e._localRoot || this._root).uuid
    delete m[g],
      c.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e)
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i]
      --s.referenceCount === 0 && this._removeInactiveBinding(s)
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r]
    ;(e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s)
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r]
    ;(e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s)
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings
    let o = r[t]
    o === void 0 && ((o = {}), (r[t] = o)),
      (o[i] = e),
      (e._cacheIndex = s.length),
      s.push(e)
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      c = t[t.length - 1],
      u = e._cacheIndex
    ;(c._cacheIndex = u),
      (t[u] = c),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r]
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r]
    ;(e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s)
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r]
    ;(e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s)
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++
    let i = e[t]
    return (
      i === void 0 &&
        ((i = new TE(new Float32Array(2), new Float32Array(2), 1, cV)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    )
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r]
    ;(e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s)
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid
    let o = typeof e == 'string' ? tg.findByName(r, e) : e
    const a = o !== null ? o.uuid : e,
      c = this._actionsByClip[a]
    let u = null
    if (
      (i === void 0 && (o !== null ? (i = o.blendMode) : (i = Yx)),
      c !== void 0)
    ) {
      const m = c.actionByRoot[s]
      if (m !== void 0 && m.blendMode === i) return m
      ;(u = c.knownActions[0]), o === null && (o = u._clip)
    }
    if (o === null) return null
    const h = new AN(this, o, t, i)
    return this._bindAction(h, u), this._addInactiveAction(h, a, s), h
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == 'string' ? tg.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o]
    return (a !== void 0 && a.actionByRoot[r]) || null
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions
    for (let i = t - 1; i >= 0; --i) e[i].stop()
    return this
  }
  update(e) {
    e *= this.timeScale
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1)
    for (let u = 0; u !== i; ++u) t[u]._update(r, e, s, o)
    const a = this._bindings,
      c = this._nActiveBindings
    for (let u = 0; u !== c; ++u) a[u].apply(o)
    return this
  }
  setTime(e) {
    this.time = 0
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0
    return this.update(e)
  }
  getRoot() {
    return this._root
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i]
    if (s !== void 0) {
      const o = s.knownActions
      for (let a = 0, c = o.length; a !== c; ++a) {
        const u = o[a]
        this._deactivateAction(u)
        const h = u._cacheIndex,
          m = t[t.length - 1]
        ;(u._cacheIndex = null),
          (u._byClipCacheIndex = null),
          (m._cacheIndex = h),
          (t[h] = m),
          t.pop(),
          this._removeInactiveBindingsForAction(u)
      }
      delete r[i]
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip
    for (const o in i) {
      const a = i[o].actionByRoot,
        c = a[t]
      c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c))
    }
    const r = this._bindingsByRootAndName,
      s = r[t]
    if (s !== void 0)
      for (const o in s) {
        const a = s[o]
        a.restoreOriginalState(), this._removeInactiveBinding(a)
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t)
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i))
  }
}
class dV extends Zx {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isRenderTarget3D = !0),
      (this.depth = i),
      (this.texture = new Kx(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0)
  }
}
class fV extends Zx {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isRenderTargetArray = !0),
      (this.depth = i),
      (this.texture = new Pg(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0)
  }
}
class DE {
  constructor(e) {
    this.value = e
  }
  clone() {
    return new DE(this.value.clone === void 0 ? this.value : this.value.clone())
  }
}
let hV = 0
class pV extends Pa {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, 'id', { value: hV++ }),
      (this.name = ''),
      (this.usage = $m),
      (this.uniforms = [])
  }
  add(e) {
    return this.uniforms.push(e), this
  }
  remove(e) {
    const t = this.uniforms.indexOf(e)
    return t !== -1 && this.uniforms.splice(t, 1), this
  }
  setName(e) {
    return (this.name = e), this
  }
  setUsage(e) {
    return (this.usage = e), this
  }
  dispose() {
    return this.dispatchEvent({ type: 'dispose' }), this
  }
  copy(e) {
    ;(this.name = e.name), (this.usage = e.usage)
    const t = e.uniforms
    this.uniforms.length = 0
    for (let i = 0, r = t.length; i < r; i++) {
      const s = Array.isArray(t[i]) ? t[i] : [t[i]]
      for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone())
    }
    return this
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class mV extends e_ {
  constructor(e, t, i = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i)
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
  }
  clone(e) {
    const t = super.clone(e)
    return (t.meshPerAttribute = this.meshPerAttribute), t
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    )
  }
}
class gV {
  constructor(e, t, i, r, s) {
    ;(this.isGLBufferAttribute = !0),
      (this.name = ''),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = i),
      (this.elementSize = r),
      (this.count = s),
      (this.version = 0)
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setBuffer(e) {
    return (this.buffer = e), this
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this
  }
  setItemSize(e) {
    return (this.itemSize = e), this
  }
  setCount(e) {
    return (this.count = e), this
  }
}
const AC = new Jt()
class OE {
  constructor(e, t, i = 0, r = 1 / 0) {
    ;(this.ray = new Ih(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new cd()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      })
  }
  set(e, t) {
    this.ray.set(e, t)
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error('THREE.Raycaster: Unsupported camera type: ' + t.type)
  }
  setFromXRController(e) {
    return (
      AC.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(AC),
      this
    )
  }
  intersectObject(e, t = !0, i = []) {
    return GS(e, this, i, t), i.sort(CC), i
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) GS(e[r], this, i, t)
    return i.sort(CC), i
  }
}
function CC(n, e) {
  return n.distance - e.distance
}
function GS(n, e, t, i) {
  let r = !0
  if (
    (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (r = !1),
    r === !0 && i === !0)
  ) {
    const s = n.children
    for (let o = 0, a = s.length; o < a; o++) GS(s[o], e, t, !0)
  }
}
class vV {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    )
  }
  makeSafe() {
    return (this.phi = un(this.phi, 1e-6, Math.PI - 1e-6)), this
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z)
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(un(t / this.radius, -1, 1)))),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class yV {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.theta = t), (this.y = i), this
  }
  set(e, t, i) {
    return (this.radius = e), (this.theta = t), (this.y = i), this
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    )
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z)
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + i * i)),
      (this.theta = Math.atan2(e, i)),
      (this.y = t),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class kE {
  constructor(e, t, i, r) {
    ;(kE.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r)
  }
  identity() {
    return this.set(1, 0, 0, 1), this
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 4; i++) this.elements[i] = e[i + t]
    return this
  }
  set(e, t, i, r) {
    const s = this.elements
    return (s[0] = e), (s[2] = t), (s[1] = i), (s[3] = r), this
  }
}
const PC = new qe()
class xV {
  constructor(e = new qe(1 / 0, 1 / 0), t = new qe(-1 / 0, -1 / 0)) {
    ;(this.isBox2 = !0), (this.min = e), (this.max = t)
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this
  }
  setFromPoints(e) {
    this.makeEmpty()
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t])
    return this
  }
  setFromCenterAndSize(e, t) {
    const i = PC.copy(t).multiplyScalar(0.5)
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    )
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    )
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    )
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
    )
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    )
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max)
  }
  distanceToPoint(e) {
    return this.clampPoint(e, PC).distanceTo(e)
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    )
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max)
  }
}
const RC = new re(),
  D0 = new re()
class _V {
  constructor(e = new re(), t = new re()) {
    ;(this.start = e), (this.end = t)
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5)
  }
  delta(e) {
    return e.subVectors(this.end, this.start)
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end)
  }
  distance() {
    return this.start.distanceTo(this.end)
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start)
  }
  closestPointToPointParameter(e, t) {
    RC.subVectors(e, this.start), D0.subVectors(this.end, this.start)
    const i = D0.dot(D0)
    let s = D0.dot(RC) / i
    return t && (s = un(s, 0, 1)), s
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t)
    return this.delta(i).multiplyScalar(r).add(this.start)
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const IC = new re()
class wV extends Ln {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = 'SpotLightHelper')
    const i = new _n(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ]
    for (let o = 0, a = 1, c = 32; o < c; o++, a++) {
      const u = (o / c) * Math.PI * 2,
        h = (a / c) * Math.PI * 2
      r.push(Math.cos(u), Math.sin(u), 1, Math.cos(h), Math.sin(h), 1)
    }
    i.setAttribute('position', new Ft(r, 3))
    const s = new ts({ fog: !1, toneMapped: !1 })
    ;(this.cone = new Ra(i, s)), this.add(this.cone), this.update()
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose()
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld)
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle)
    this.cone.scale.set(t, t, e),
      IC.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(IC),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color)
  }
}
const pc = new re(),
  O0 = new Jt(),
  nw = new Jt()
class SV extends Ra {
  constructor(e) {
    const t = CN(e),
      i = new _n(),
      r = [],
      s = [],
      o = new Tt(0, 0, 1),
      a = new Tt(0, 1, 0)
    for (let u = 0; u < t.length; u++) {
      const h = t[u]
      h.parent &&
        h.parent.isBone &&
        (r.push(0, 0, 0),
        r.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b))
    }
    i.setAttribute('position', new Ft(r, 3)),
      i.setAttribute('color', new Ft(s, 3))
    const c = new ts({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    })
    super(i, c),
      (this.isSkeletonHelper = !0),
      (this.type = 'SkeletonHelper'),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1)
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      i = this.geometry,
      r = i.getAttribute('position')
    nw.copy(this.root.matrixWorld).invert()
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s]
      a.parent &&
        a.parent.isBone &&
        (O0.multiplyMatrices(nw, a.matrixWorld),
        pc.setFromMatrixPosition(O0),
        r.setXYZ(o, pc.x, pc.y, pc.z),
        O0.multiplyMatrices(nw, a.parent.matrixWorld),
        pc.setFromMatrixPosition(O0),
        r.setXYZ(o + 1, pc.x, pc.y, pc.z),
        (o += 2))
    }
    ;(i.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(e)
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
function CN(n) {
  const e = []
  n.isBone === !0 && e.push(n)
  for (let t = 0; t < n.children.length; t++) e.push.apply(e, CN(n.children[t]))
  return e
}
class MV extends vi {
  constructor(e, t, i) {
    const r = new Fg(t, 4, 2),
      s = new Il({ wireframe: !0, fog: !1, toneMapped: !1 })
    super(r, s),
      (this.light = e),
      (this.color = i),
      (this.type = 'PointLightHelper'),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update()
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color)
  }
}
const EV = new re(),
  LC = new Tt(),
  NC = new Tt()
class bV extends Ln {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = 'HemisphereLightHelper')
    const r = new kg(t)
    r.rotateY(Math.PI * 0.5),
      (this.material = new Il({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0)
    const s = r.getAttribute('position'),
      o = new Float32Array(s.count * 3)
    r.setAttribute('color', new qn(o, 3)),
      this.add(new vi(r, this.material)),
      this.update()
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose()
  }
  update() {
    const e = this.children[0]
    if (this.color !== void 0) this.material.color.set(this.color)
    else {
      const t = e.geometry.getAttribute('color')
      LC.copy(this.light.color), NC.copy(this.light.groundColor)
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? LC : NC
        t.setXYZ(i, s.r, s.g, s.b)
      }
      t.needsUpdate = !0
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(EV.setFromMatrixPosition(this.light.matrixWorld).negate())
  }
}
class TV extends Ra {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    ;(i = new Tt(i)), (r = new Tt(r))
    const s = t / 2,
      o = e / t,
      a = e / 2,
      c = [],
      u = []
    for (let g = 0, y = 0, _ = -a; g <= t; g++, _ += o) {
      c.push(-a, 0, _, a, 0, _), c.push(_, 0, -a, _, 0, a)
      const M = g === s ? i : r
      M.toArray(u, y),
        (y += 3),
        M.toArray(u, y),
        (y += 3),
        M.toArray(u, y),
        (y += 3),
        M.toArray(u, y),
        (y += 3)
    }
    const h = new _n()
    h.setAttribute('position', new Ft(c, 3)),
      h.setAttribute('color', new Ft(u, 3))
    const m = new ts({ vertexColors: !0, toneMapped: !1 })
    super(h, m), (this.type = 'GridHelper')
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class AV extends Ra {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    ;(s = new Tt(s)), (o = new Tt(o))
    const a = [],
      c = []
    if (t > 1)
      for (let m = 0; m < t; m++) {
        const g = (m / t) * (Math.PI * 2),
          y = Math.sin(g) * e,
          _ = Math.cos(g) * e
        a.push(0, 0, 0), a.push(y, 0, _)
        const M = m & 1 ? s : o
        c.push(M.r, M.g, M.b), c.push(M.r, M.g, M.b)
      }
    for (let m = 0; m < i; m++) {
      const g = m & 1 ? s : o,
        y = e - (e / i) * m
      for (let _ = 0; _ < r; _++) {
        let M = (_ / r) * (Math.PI * 2),
          w = Math.sin(M) * y,
          x = Math.cos(M) * y
        a.push(w, 0, x),
          c.push(g.r, g.g, g.b),
          (M = ((_ + 1) / r) * (Math.PI * 2)),
          (w = Math.sin(M) * y),
          (x = Math.cos(M) * y),
          a.push(w, 0, x),
          c.push(g.r, g.g, g.b)
      }
    }
    const u = new _n()
    u.setAttribute('position', new Ft(a, 3)),
      u.setAttribute('color', new Ft(c, 3))
    const h = new ts({ vertexColors: !0, toneMapped: !1 })
    super(u, h), (this.type = 'PolarGridHelper')
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
const DC = new re(),
  k0 = new re(),
  OC = new re()
class CV extends Ln {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = 'DirectionalLightHelper'),
      t === void 0 && (t = 1)
    let r = new _n()
    r.setAttribute(
      'position',
      new Ft([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3),
    )
    const s = new ts({ fog: !1, toneMapped: !1 })
    ;(this.lightPlane = new Rc(r, s)),
      this.add(this.lightPlane),
      (r = new _n()),
      r.setAttribute('position', new Ft([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Rc(r, s)),
      this.add(this.targetLine),
      this.update()
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose()
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      DC.setFromMatrixPosition(this.light.matrixWorld),
      k0.setFromMatrixPosition(this.light.target.matrixWorld),
      OC.subVectors(k0, DC),
      this.lightPlane.lookAt(k0),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(k0),
      (this.targetLine.scale.z = OC.length())
  }
}
const F0 = new re(),
  Si = new Rg()
class PV extends Ra {
  constructor(e) {
    const t = new _n(),
      i = new ts({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      o = {}
    a('n1', 'n2'),
      a('n2', 'n4'),
      a('n4', 'n3'),
      a('n3', 'n1'),
      a('f1', 'f2'),
      a('f2', 'f4'),
      a('f4', 'f3'),
      a('f3', 'f1'),
      a('n1', 'f1'),
      a('n2', 'f2'),
      a('n3', 'f3'),
      a('n4', 'f4'),
      a('p', 'n1'),
      a('p', 'n2'),
      a('p', 'n3'),
      a('p', 'n4'),
      a('u1', 'u2'),
      a('u2', 'u3'),
      a('u3', 'u1'),
      a('c', 't'),
      a('p', 'c'),
      a('cn1', 'cn2'),
      a('cn3', 'cn4'),
      a('cf1', 'cf2'),
      a('cf3', 'cf4')
    function a(_, M) {
      c(_), c(M)
    }
    function c(_) {
      r.push(0, 0, 0),
        s.push(0, 0, 0),
        o[_] === void 0 && (o[_] = []),
        o[_].push(r.length / 3 - 1)
    }
    t.setAttribute('position', new Ft(r, 3)),
      t.setAttribute('color', new Ft(s, 3)),
      super(t, i),
      (this.type = 'CameraHelper'),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update()
    const u = new Tt(16755200),
      h = new Tt(16711680),
      m = new Tt(43775),
      g = new Tt(16777215),
      y = new Tt(3355443)
    this.setColors(u, h, m, g, y)
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute('color')
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, i.r, i.g, i.b),
      a.setXYZ(33, i.r, i.g, i.b),
      a.setXYZ(34, i.r, i.g, i.b),
      a.setXYZ(35, i.r, i.g, i.b),
      a.setXYZ(36, i.r, i.g, i.b),
      a.setXYZ(37, i.r, i.g, i.b),
      a.setXYZ(38, r.r, r.g, r.b),
      a.setXYZ(39, r.r, r.g, r.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0)
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      r = 1
    Si.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse)
    const s = this.camera.coordinateSystem === Go ? -1 : 0
    Ci('c', t, e, Si, 0, 0, s),
      Ci('t', t, e, Si, 0, 0, 1),
      Ci('n1', t, e, Si, -i, -r, s),
      Ci('n2', t, e, Si, i, -r, s),
      Ci('n3', t, e, Si, -i, r, s),
      Ci('n4', t, e, Si, i, r, s),
      Ci('f1', t, e, Si, -i, -r, 1),
      Ci('f2', t, e, Si, i, -r, 1),
      Ci('f3', t, e, Si, -i, r, 1),
      Ci('f4', t, e, Si, i, r, 1),
      Ci('u1', t, e, Si, i * 0.7, r * 1.1, s),
      Ci('u2', t, e, Si, -i * 0.7, r * 1.1, s),
      Ci('u3', t, e, Si, 0, r * 2, s),
      Ci('cf1', t, e, Si, -i, 0, 1),
      Ci('cf2', t, e, Si, i, 0, 1),
      Ci('cf3', t, e, Si, 0, -r, 1),
      Ci('cf4', t, e, Si, 0, r, 1),
      Ci('cn1', t, e, Si, -i, 0, s),
      Ci('cn2', t, e, Si, i, 0, s),
      Ci('cn3', t, e, Si, 0, -r, s),
      Ci('cn4', t, e, Si, 0, r, s),
      (e.getAttribute('position').needsUpdate = !0)
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
function Ci(n, e, t, i, r, s, o) {
  F0.set(r, s, o).unproject(i)
  const a = e[n]
  if (a !== void 0) {
    const c = t.getAttribute('position')
    for (let u = 0, h = a.length; u < h; u++) c.setXYZ(a[u], F0.x, F0.y, F0.z)
  }
}
const U0 = new Jr()
class RV extends Ra {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(8 * 3),
      s = new _n()
    s.setIndex(new qn(i, 1)),
      s.setAttribute('position', new qn(r, 3)),
      super(s, new ts({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = 'BoxHelper'),
      (this.matrixAutoUpdate = !1),
      this.update()
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
      this.object !== void 0 && U0.setFromObject(this.object),
      U0.isEmpty())
    )
      return
    const t = U0.min,
      i = U0.max,
      r = this.geometry.attributes.position,
      s = r.array
    ;(s[0] = i.x),
      (s[1] = i.y),
      (s[2] = i.z),
      (s[3] = t.x),
      (s[4] = i.y),
      (s[5] = i.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = i.z),
      (s[9] = i.x),
      (s[10] = t.y),
      (s[11] = i.z),
      (s[12] = i.x),
      (s[13] = i.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = i.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = i.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere()
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class IV extends Ra {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new _n()
    s.setIndex(new qn(i, 1)),
      s.setAttribute('position', new Ft(r, 3)),
      super(s, new ts({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = 'Box3Helper'),
      this.geometry.computeBoundingSphere()
  }
  updateMatrixWorld(e) {
    const t = this.box
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e))
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class LV extends Rc {
  constructor(e, t = 1, i = 16776960) {
    const r = i,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new _n()
    o.setAttribute('position', new Ft(s, 3)),
      o.computeBoundingSphere(),
      super(o, new ts({ color: r, toneMapped: !1 })),
      (this.type = 'PlaneHelper'),
      (this.plane = e),
      (this.size = t)
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      c = new _n()
    c.setAttribute('position', new Ft(a, 3)),
      c.computeBoundingSphere(),
      this.add(
        new vi(
          c,
          new Il({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          }),
        ),
      )
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e)
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose()
  }
}
const kC = new re()
let B0, iw
class NV extends Ln {
  constructor(
    e = new re(0, 0, 1),
    t = new re(0, 0, 0),
    i = 1,
    r = 16776960,
    s = i * 0.2,
    o = s * 0.2,
  ) {
    super(),
      (this.type = 'ArrowHelper'),
      B0 === void 0 &&
        ((B0 = new _n()),
        B0.setAttribute('position', new Ft([0, 0, 0, 0, 1, 0], 3)),
        (iw = new Lh(0, 0.5, 1, 5, 1)),
        iw.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Rc(B0, new ts({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new vi(iw, new Il({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(i, s, o)
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1)
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0)
    else {
      kC.set(e.z, 0, -e.x).normalize()
      const t = Math.acos(e.y)
      this.quaternion.setFromAxisAngle(kC, t)
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(i, t, i),
      (this.cone.position.y = e),
      this.cone.updateMatrix()
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e)
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    )
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose()
  }
}
class DV extends Ra {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new _n()
    r.setAttribute('position', new Ft(t, 3)),
      r.setAttribute('color', new Ft(i, 3))
    const s = new ts({ vertexColors: !0, toneMapped: !1 })
    super(r, s), (this.type = 'AxesHelper')
  }
  setColors(e, t, i) {
    const r = new Tt(),
      s = this.geometry.attributes.color.array
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(i),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    )
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class OV {
  constructor() {
    ;(this.type = 'ShapePath'),
      (this.color = new Tt()),
      (this.subPaths = []),
      (this.currentPath = null)
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Ym()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    )
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this
  }
  toShapes(e) {
    function t(x) {
      const T = []
      for (let A = 0, P = x.length; A < P; A++) {
        const D = x[A],
          O = new ud()
        ;(O.curves = D.curves), T.push(O)
      }
      return T
    }
    function i(x, T) {
      const A = T.length
      let P = !1
      for (let D = A - 1, O = 0; O < A; D = O++) {
        let U = T[D],
          F = T[O],
          N = F.x - U.x,
          k = F.y - U.y
        if (Math.abs(k) > Number.EPSILON) {
          if (
            (k < 0 && ((U = T[O]), (N = -N), (F = T[D]), (k = -k)),
            x.y < U.y || x.y > F.y)
          )
            continue
          if (x.y === U.y) {
            if (x.x === U.x) return !0
          } else {
            const z = k * (x.x - U.x) - N * (x.y - U.y)
            if (z === 0) return !0
            if (z < 0) continue
            P = !P
          }
        } else {
          if (x.y !== U.y) continue
          if ((F.x <= x.x && x.x <= U.x) || (U.x <= x.x && x.x <= F.x))
            return !0
        }
      }
      return P
    }
    const r = xa.isClockWise,
      s = this.subPaths
    if (s.length === 0) return []
    let o, a, c
    const u = []
    if (s.length === 1)
      return (a = s[0]), (c = new ud()), (c.curves = a.curves), u.push(c), u
    let h = !r(s[0].getPoints())
    h = e ? !h : h
    const m = [],
      g = []
    let y = [],
      _ = 0,
      M
    ;(g[_] = void 0), (y[_] = [])
    for (let x = 0, T = s.length; x < T; x++)
      (a = s[x]),
        (M = a.getPoints()),
        (o = r(M)),
        (o = e ? !o : o),
        o
          ? (!h && g[_] && _++,
            (g[_] = { s: new ud(), p: M }),
            (g[_].s.curves = a.curves),
            h && _++,
            (y[_] = []))
          : y[_].push({ h: a, p: M[0] })
    if (!g[0]) return t(s)
    if (g.length > 1) {
      let x = !1,
        T = 0
      for (let A = 0, P = g.length; A < P; A++) m[A] = []
      for (let A = 0, P = g.length; A < P; A++) {
        const D = y[A]
        for (let O = 0; O < D.length; O++) {
          const U = D[O]
          let F = !0
          for (let N = 0; N < g.length; N++)
            i(U.p, g[N].p) &&
              (A !== N && T++, F ? ((F = !1), m[N].push(U)) : (x = !0))
          F && m[A].push(U)
        }
      }
      T > 0 && x === !1 && (y = m)
    }
    let w
    for (let x = 0, T = g.length; x < T; x++) {
      ;(c = g[x].s), u.push(c), (w = y[x])
      for (let A = 0, P = w.length; A < P; A++) c.holes.push(w[A].h)
    }
    return u
  }
}
class kV extends Pa {
  constructor(e, t = null) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null })
  }
  connect() {}
  disconnect() {}
  dispose() {}
  update() {}
}
function FV(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1
  return (
    t > e
      ? ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2))
      : ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0)),
    n
  )
}
function UV(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1
  return (
    t > e
      ? ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0))
      : ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2)),
    n
  )
}
function BV(n) {
  return (
    (n.repeat.x = 1), (n.repeat.y = 1), (n.offset.x = 0), (n.offset.y = 0), n
  )
}
function WS(n, e, t, i) {
  const r = zV(i)
  switch (t) {
    case JM:
      return n * e
    case tE:
      return n * e
    case nE:
      return n * e * 2
    case Ag:
      return ((n * e) / r.components) * r.byteLength
    case Cg:
      return ((n * e) / r.components) * r.byteLength
    case iE:
      return ((n * e * 2) / r.components) * r.byteLength
    case Xx:
      return ((n * e * 2) / r.components) * r.byteLength
    case eE:
      return ((n * e * 3) / r.components) * r.byteLength
    case Ii:
      return ((n * e * 4) / r.components) * r.byteLength
    case qx:
      return ((n * e * 4) / r.components) * r.byteLength
    case vm:
    case ym:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8
    case xm:
    case _m:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16
    case jy:
    case Gy:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4
    case Vy:
    case Hy:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2
    case Wy:
    case $y:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8
    case Xy:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16
    case qy:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16
    case Yy:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16
    case Zy:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16
    case Ky:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16
    case Qy:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16
    case Jy:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16
    case ex:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16
    case tx:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16
    case nx:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16
    case ix:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16
    case rx:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16
    case sx:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16
    case ox:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16
    case ax:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16
    case wm:
    case lx:
    case cx:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16
    case rE:
    case ux:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8
    case dx:
    case fx:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`)
}
function zV(n) {
  switch (n) {
    case _s:
    case Hx:
      return { byteLength: 1, components: 1 }
    case ph:
    case Gx:
    case or:
      return { byteLength: 2, components: 1 }
    case Wx:
    case $x:
      return { byteLength: 2, components: 4 }
    case Ta:
    case Tg:
    case gi:
      return { byteLength: 4, components: 1 }
    case QM:
      return { byteLength: 4, components: 3 }
  }
  throw new Error(`Unknown texture type ${n}.`)
}
const VV = { contain: FV, cover: UV, fill: BV, getByteLength: WS }
typeof __THREE_DEVTOOLS__ < 'u' &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent('register', { detail: { revision: Eg } }),
  )
typeof window < 'u' &&
  (window.__THREE__
    ? console.warn('WARNING: Multiple instances of Three.js being imported.')
    : (window.__THREE__ = Eg))
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function PN() {
  let n = null,
    e = !1,
    t = null,
    i = null
  function r(s, o) {
    t(s, o), (i = n.requestAnimationFrame(r))
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0))
    },
    stop: function () {
      n.cancelAnimationFrame(i), (e = !1)
    },
    setAnimationLoop: function (s) {
      t = s
    },
    setContext: function (s) {
      n = s
    },
  }
}
function jV(n) {
  const e = new WeakMap()
  function t(a, c) {
    const u = a.array,
      h = a.usage,
      m = u.byteLength,
      g = n.createBuffer()
    n.bindBuffer(c, g), n.bufferData(c, u, h), a.onUploadCallback()
    let y
    if (u instanceof Float32Array) y = n.FLOAT
    else if (u instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (y = n.HALF_FLOAT) : (y = n.UNSIGNED_SHORT)
    else if (u instanceof Int16Array) y = n.SHORT
    else if (u instanceof Uint32Array) y = n.UNSIGNED_INT
    else if (u instanceof Int32Array) y = n.INT
    else if (u instanceof Int8Array) y = n.BYTE
    else if (u instanceof Uint8Array) y = n.UNSIGNED_BYTE
    else if (u instanceof Uint8ClampedArray) y = n.UNSIGNED_BYTE
    else
      throw new Error(
        'THREE.WebGLAttributes: Unsupported buffer data format: ' + u,
      )
    return {
      buffer: g,
      type: y,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: a.version,
      size: m,
    }
  }
  function i(a, c, u) {
    const h = c.array,
      m = c.updateRanges
    if ((n.bindBuffer(u, a), m.length === 0)) n.bufferSubData(u, 0, h)
    else {
      m.sort((y, _) => y.start - _.start)
      let g = 0
      for (let y = 1; y < m.length; y++) {
        const _ = m[g],
          M = m[y]
        M.start <= _.start + _.count + 1
          ? (_.count = Math.max(_.count, M.start + M.count - _.start))
          : (++g, (m[g] = M))
      }
      m.length = g + 1
      for (let y = 0, _ = m.length; y < _; y++) {
        const M = m[y]
        n.bufferSubData(u, M.start * h.BYTES_PER_ELEMENT, h, M.start, M.count)
      }
      c.clearUpdateRanges()
    }
    c.onUploadCallback()
  }
  function r(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a)
  }
  function s(a) {
    a.isInterleavedBufferAttribute && (a = a.data)
    const c = e.get(a)
    c && (n.deleteBuffer(c.buffer), e.delete(a))
  }
  function o(a, c) {
    if (
      (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute)
    ) {
      const h = e.get(a)
      ;(!h || h.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        })
      return
    }
    const u = e.get(a)
    if (u === void 0) e.set(a, t(a, c))
    else if (u.version < a.version) {
      if (u.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        )
      i(u.buffer, a, c), (u.version = a.version)
    }
  }
  return { get: r, remove: s, update: o }
}
var HV = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  GV = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  WV = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  $V = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  XV = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  qV = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  YV = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  ZV = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  KV = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  QV = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  JV = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  e8 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  t8 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  n8 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  i8 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  r8 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  s8 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  o8 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  a8 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  l8 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  c8 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  u8 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  d8 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  f8 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  h8 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  p8 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  m8 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  g8 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  v8 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  y8 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  x8 = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
  _8 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  w8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  S8 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  M8 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  E8 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  b8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  T8 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  A8 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  C8 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  P8 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  R8 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  I8 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  L8 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  N8 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  D8 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  O8 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  k8 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  F8 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  U8 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  B8 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  z8 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  V8 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  j8 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  H8 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  G8 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  W8 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  $8 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  X8 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  q8 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  Y8 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  Z8 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  K8 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  Q8 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  J8 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  e6 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  t6 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  n6 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  i6 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  r6 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  s6 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  o6 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  a6 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  l6 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  c6 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  u6 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  d6 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  f6 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  h6 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  p6 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  m6 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  g6 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  v6 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  y6 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  x6 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  _6 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  w6 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  S6 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  M6 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  E6 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  b6 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  T6 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  A6 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  C6 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  P6 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  R6 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  I6 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  L6 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  N6 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  D6 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  O6 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  k6 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  F6 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  U6 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  B6 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  z6 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  V6 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`
const j6 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  H6 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  G6 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  W6 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  $6 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  X6 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  q6 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  Y6 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  Z6 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  K6 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  Q6 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  J6 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  ej = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  tj = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  nj = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  ij = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  rj = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  sj = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  oj = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  aj = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  lj = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  cj = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  uj = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  dj = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  fj = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  hj = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  pj = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  mj = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  gj = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  vj = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  yj = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  xj = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  _j = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  wj = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  xn = {
    alphahash_fragment: HV,
    alphahash_pars_fragment: GV,
    alphamap_fragment: WV,
    alphamap_pars_fragment: $V,
    alphatest_fragment: XV,
    alphatest_pars_fragment: qV,
    aomap_fragment: YV,
    aomap_pars_fragment: ZV,
    batching_pars_vertex: KV,
    batching_vertex: QV,
    begin_vertex: JV,
    beginnormal_vertex: e8,
    bsdfs: t8,
    iridescence_fragment: n8,
    bumpmap_pars_fragment: i8,
    clipping_planes_fragment: r8,
    clipping_planes_pars_fragment: s8,
    clipping_planes_pars_vertex: o8,
    clipping_planes_vertex: a8,
    color_fragment: l8,
    color_pars_fragment: c8,
    color_pars_vertex: u8,
    color_vertex: d8,
    common: f8,
    cube_uv_reflection_fragment: h8,
    defaultnormal_vertex: p8,
    displacementmap_pars_vertex: m8,
    displacementmap_vertex: g8,
    emissivemap_fragment: v8,
    emissivemap_pars_fragment: y8,
    colorspace_fragment: x8,
    colorspace_pars_fragment: _8,
    envmap_fragment: w8,
    envmap_common_pars_fragment: S8,
    envmap_pars_fragment: M8,
    envmap_pars_vertex: E8,
    envmap_physical_pars_fragment: O8,
    envmap_vertex: b8,
    fog_vertex: T8,
    fog_pars_vertex: A8,
    fog_fragment: C8,
    fog_pars_fragment: P8,
    gradientmap_pars_fragment: R8,
    lightmap_pars_fragment: I8,
    lights_lambert_fragment: L8,
    lights_lambert_pars_fragment: N8,
    lights_pars_begin: D8,
    lights_toon_fragment: k8,
    lights_toon_pars_fragment: F8,
    lights_phong_fragment: U8,
    lights_phong_pars_fragment: B8,
    lights_physical_fragment: z8,
    lights_physical_pars_fragment: V8,
    lights_fragment_begin: j8,
    lights_fragment_maps: H8,
    lights_fragment_end: G8,
    logdepthbuf_fragment: W8,
    logdepthbuf_pars_fragment: $8,
    logdepthbuf_pars_vertex: X8,
    logdepthbuf_vertex: q8,
    map_fragment: Y8,
    map_pars_fragment: Z8,
    map_particle_fragment: K8,
    map_particle_pars_fragment: Q8,
    metalnessmap_fragment: J8,
    metalnessmap_pars_fragment: e6,
    morphinstance_vertex: t6,
    morphcolor_vertex: n6,
    morphnormal_vertex: i6,
    morphtarget_pars_vertex: r6,
    morphtarget_vertex: s6,
    normal_fragment_begin: o6,
    normal_fragment_maps: a6,
    normal_pars_fragment: l6,
    normal_pars_vertex: c6,
    normal_vertex: u6,
    normalmap_pars_fragment: d6,
    clearcoat_normal_fragment_begin: f6,
    clearcoat_normal_fragment_maps: h6,
    clearcoat_pars_fragment: p6,
    iridescence_pars_fragment: m6,
    opaque_fragment: g6,
    packing: v6,
    premultiplied_alpha_fragment: y6,
    project_vertex: x6,
    dithering_fragment: _6,
    dithering_pars_fragment: w6,
    roughnessmap_fragment: S6,
    roughnessmap_pars_fragment: M6,
    shadowmap_pars_fragment: E6,
    shadowmap_pars_vertex: b6,
    shadowmap_vertex: T6,
    shadowmask_pars_fragment: A6,
    skinbase_vertex: C6,
    skinning_pars_vertex: P6,
    skinning_vertex: R6,
    skinnormal_vertex: I6,
    specularmap_fragment: L6,
    specularmap_pars_fragment: N6,
    tonemapping_fragment: D6,
    tonemapping_pars_fragment: O6,
    transmission_fragment: k6,
    transmission_pars_fragment: F6,
    uv_pars_fragment: U6,
    uv_pars_vertex: B6,
    uv_vertex: z6,
    worldpos_vertex: V6,
    background_vert: j6,
    background_frag: H6,
    backgroundCube_vert: G6,
    backgroundCube_frag: W6,
    cube_vert: $6,
    cube_frag: X6,
    depth_vert: q6,
    depth_frag: Y6,
    distanceRGBA_vert: Z6,
    distanceRGBA_frag: K6,
    equirect_vert: Q6,
    equirect_frag: J6,
    linedashed_vert: ej,
    linedashed_frag: tj,
    meshbasic_vert: nj,
    meshbasic_frag: ij,
    meshlambert_vert: rj,
    meshlambert_frag: sj,
    meshmatcap_vert: oj,
    meshmatcap_frag: aj,
    meshnormal_vert: lj,
    meshnormal_frag: cj,
    meshphong_vert: uj,
    meshphong_frag: dj,
    meshphysical_vert: fj,
    meshphysical_frag: hj,
    meshtoon_vert: pj,
    meshtoon_frag: mj,
    points_vert: gj,
    points_frag: vj,
    shadow_vert: yj,
    shadow_frag: xj,
    sprite_vert: _j,
    sprite_frag: wj,
  },
  xt = {
    common: {
      diffuse: { value: new Tt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new pn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new pn() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new pn() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new pn() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new pn() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new pn() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new pn() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new pn() },
      normalScale: { value: new qe(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new pn() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new pn() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new pn() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new pn() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Tt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Tt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new pn() },
      alphaTest: { value: 0 },
      uvTransform: { value: new pn() },
    },
    sprite: {
      diffuse: { value: new Tt(16777215) },
      opacity: { value: 1 },
      center: { value: new qe(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new pn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new pn() },
      alphaTest: { value: 0 },
    },
  },
  jo = {
    basic: {
      uniforms: Yr([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.fog,
      ]),
      vertexShader: xn.meshbasic_vert,
      fragmentShader: xn.meshbasic_frag,
    },
    lambert: {
      uniforms: Yr([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        xt.lights,
        { emissive: { value: new Tt(0) } },
      ]),
      vertexShader: xn.meshlambert_vert,
      fragmentShader: xn.meshlambert_frag,
    },
    phong: {
      uniforms: Yr([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        xt.lights,
        {
          emissive: { value: new Tt(0) },
          specular: { value: new Tt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: xn.meshphong_vert,
      fragmentShader: xn.meshphong_frag,
    },
    standard: {
      uniforms: Yr([
        xt.common,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.roughnessmap,
        xt.metalnessmap,
        xt.fog,
        xt.lights,
        {
          emissive: { value: new Tt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: xn.meshphysical_vert,
      fragmentShader: xn.meshphysical_frag,
    },
    toon: {
      uniforms: Yr([
        xt.common,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.gradientmap,
        xt.fog,
        xt.lights,
        { emissive: { value: new Tt(0) } },
      ]),
      vertexShader: xn.meshtoon_vert,
      fragmentShader: xn.meshtoon_frag,
    },
    matcap: {
      uniforms: Yr([
        xt.common,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: xn.meshmatcap_vert,
      fragmentShader: xn.meshmatcap_frag,
    },
    points: {
      uniforms: Yr([xt.points, xt.fog]),
      vertexShader: xn.points_vert,
      fragmentShader: xn.points_frag,
    },
    dashed: {
      uniforms: Yr([
        xt.common,
        xt.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: xn.linedashed_vert,
      fragmentShader: xn.linedashed_frag,
    },
    depth: {
      uniforms: Yr([xt.common, xt.displacementmap]),
      vertexShader: xn.depth_vert,
      fragmentShader: xn.depth_frag,
    },
    normal: {
      uniforms: Yr([
        xt.common,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: xn.meshnormal_vert,
      fragmentShader: xn.meshnormal_frag,
    },
    sprite: {
      uniforms: Yr([xt.sprite, xt.fog]),
      vertexShader: xn.sprite_vert,
      fragmentShader: xn.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new pn() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: xn.background_vert,
      fragmentShader: xn.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new pn() },
      },
      vertexShader: xn.backgroundCube_vert,
      fragmentShader: xn.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: xn.cube_vert,
      fragmentShader: xn.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: xn.equirect_vert,
      fragmentShader: xn.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Yr([
        xt.common,
        xt.displacementmap,
        {
          referencePosition: { value: new re() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: xn.distanceRGBA_vert,
      fragmentShader: xn.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Yr([
        xt.lights,
        xt.fog,
        { color: { value: new Tt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: xn.shadow_vert,
      fragmentShader: xn.shadow_frag,
    },
  }
jo.physical = {
  uniforms: Yr([
    jo.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new pn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new pn() },
      clearcoatNormalScale: { value: new qe(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new pn() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new pn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new pn() },
      sheen: { value: 0 },
      sheenColor: { value: new Tt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new pn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new pn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new pn() },
      transmissionSamplerSize: { value: new qe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new pn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Tt(0) },
      specularColor: { value: new Tt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new pn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new pn() },
      anisotropyVector: { value: new qe() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new pn() },
    },
  ]),
  vertexShader: xn.meshphysical_vert,
  fragmentShader: xn.meshphysical_frag,
}
const z0 = { r: 0, b: 0, g: 0 },
  Uu = new Us(),
  Sj = new Jt()
function Mj(n, e, t, i, r, s, o) {
  const a = new Tt(0)
  let c = s === !0 ? 0 : 1,
    u,
    h,
    m = null,
    g = 0,
    y = null
  function _(A) {
    let P = A.isScene === !0 ? A.background : null
    return (
      P && P.isTexture && (P = (A.backgroundBlurriness > 0 ? t : e).get(P)), P
    )
  }
  function M(A) {
    let P = !1
    const D = _(A)
    D === null ? x(a, c) : D && D.isColor && (x(D, 1), (P = !0))
    const O = n.xr.getEnvironmentBlendMode()
    O === 'additive'
      ? i.buffers.color.setClear(0, 0, 0, 1, o)
      : O === 'alpha-blend' && i.buffers.color.setClear(0, 0, 0, 0, o),
      (n.autoClear || P) &&
        (i.buffers.depth.setTest(!0),
        i.buffers.depth.setMask(!0),
        i.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil))
  }
  function w(A, P) {
    const D = _(P)
    D && (D.isCubeTexture || D.mapping === Rh)
      ? (h === void 0 &&
          ((h = new vi(
            new _d(1, 1, 1),
            new ws({
              name: 'BackgroundCubeMaterial',
              uniforms: gh(jo.backgroundCube.uniforms),
              vertexShader: jo.backgroundCube.vertexShader,
              fragmentShader: jo.backgroundCube.fragmentShader,
              side: Qr,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          h.geometry.deleteAttribute('normal'),
          h.geometry.deleteAttribute('uv'),
          (h.onBeforeRender = function (O, U, F) {
            this.matrixWorld.copyPosition(F.matrixWorld)
          }),
          Object.defineProperty(h.material, 'envMap', {
            get: function () {
              return this.uniforms.envMap.value
            },
          }),
          r.update(h)),
        Uu.copy(P.backgroundRotation),
        (Uu.x *= -1),
        (Uu.y *= -1),
        (Uu.z *= -1),
        D.isCubeTexture &&
          D.isRenderTargetTexture === !1 &&
          ((Uu.y *= -1), (Uu.z *= -1)),
        (h.material.uniforms.envMap.value = D),
        (h.material.uniforms.flipEnvMap.value =
          D.isCubeTexture && D.isRenderTargetTexture === !1 ? -1 : 1),
        (h.material.uniforms.backgroundBlurriness.value =
          P.backgroundBlurriness),
        (h.material.uniforms.backgroundIntensity.value = P.backgroundIntensity),
        h.material.uniforms.backgroundRotation.value.setFromMatrix4(
          Sj.makeRotationFromEuler(Uu),
        ),
        (h.material.toneMapped = Cn.getTransfer(D.colorSpace) !== zn),
        (m !== D || g !== D.version || y !== n.toneMapping) &&
          ((h.material.needsUpdate = !0),
          (m = D),
          (g = D.version),
          (y = n.toneMapping)),
        h.layers.enableAll(),
        A.unshift(h, h.geometry, h.material, 0, 0, null))
      : D &&
        D.isTexture &&
        (u === void 0 &&
          ((u = new vi(
            new Uc(2, 2),
            new ws({
              name: 'BackgroundMaterial',
              uniforms: gh(jo.background.uniforms),
              vertexShader: jo.background.vertexShader,
              fragmentShader: jo.background.fragmentShader,
              side: Tl,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          u.geometry.deleteAttribute('normal'),
          Object.defineProperty(u.material, 'map', {
            get: function () {
              return this.uniforms.t2D.value
            },
          }),
          r.update(u)),
        (u.material.uniforms.t2D.value = D),
        (u.material.uniforms.backgroundIntensity.value = P.backgroundIntensity),
        (u.material.toneMapped = Cn.getTransfer(D.colorSpace) !== zn),
        D.matrixAutoUpdate === !0 && D.updateMatrix(),
        u.material.uniforms.uvTransform.value.copy(D.matrix),
        (m !== D || g !== D.version || y !== n.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (m = D),
          (g = D.version),
          (y = n.toneMapping)),
        u.layers.enableAll(),
        A.unshift(u, u.geometry, u.material, 0, 0, null))
  }
  function x(A, P) {
    A.getRGB(z0, LL(n)), i.buffers.color.setClear(z0.r, z0.g, z0.b, P, o)
  }
  function T() {
    h !== void 0 && (h.geometry.dispose(), h.material.dispose()),
      u !== void 0 && (u.geometry.dispose(), u.material.dispose())
  }
  return {
    getClearColor: function () {
      return a
    },
    setClearColor: function (A, P = 1) {
      a.set(A), (c = P), x(a, c)
    },
    getClearAlpha: function () {
      return c
    },
    setClearAlpha: function (A) {
      ;(c = A), x(a, c)
    },
    render: M,
    addToRenderList: w,
    dispose: T,
  }
}
function Ej(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    i = {},
    r = g(null)
  let s = r,
    o = !1
  function a(k, z, $, te, j) {
    let K = !1
    const J = m(te, $, z)
    s !== J && ((s = J), u(s.object)),
      (K = y(k, te, $, j)),
      K && _(k, te, $, j),
      j !== null && e.update(j, n.ELEMENT_ARRAY_BUFFER),
      (K || o) &&
        ((o = !1),
        P(k, z, $, te),
        j !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(j).buffer))
  }
  function c() {
    return n.createVertexArray()
  }
  function u(k) {
    return n.bindVertexArray(k)
  }
  function h(k) {
    return n.deleteVertexArray(k)
  }
  function m(k, z, $) {
    const te = $.wireframe === !0
    let j = i[k.id]
    j === void 0 && ((j = {}), (i[k.id] = j))
    let K = j[z.id]
    K === void 0 && ((K = {}), (j[z.id] = K))
    let J = K[te]
    return J === void 0 && ((J = g(c())), (K[te] = J)), J
  }
  function g(k) {
    const z = [],
      $ = [],
      te = []
    for (let j = 0; j < t; j++) (z[j] = 0), ($[j] = 0), (te[j] = 0)
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: z,
      enabledAttributes: $,
      attributeDivisors: te,
      object: k,
      attributes: {},
      index: null,
    }
  }
  function y(k, z, $, te) {
    const j = s.attributes,
      K = z.attributes
    let J = 0
    const ne = $.getAttributes()
    for (const V in ne)
      if (ne[V].location >= 0) {
        const Q = j[V]
        let q = K[V]
        if (
          (q === void 0 &&
            (V === 'instanceMatrix' &&
              k.instanceMatrix &&
              (q = k.instanceMatrix),
            V === 'instanceColor' && k.instanceColor && (q = k.instanceColor)),
          Q === void 0 || Q.attribute !== q || (q && Q.data !== q.data))
        )
          return !0
        J++
      }
    return s.attributesNum !== J || s.index !== te
  }
  function _(k, z, $, te) {
    const j = {},
      K = z.attributes
    let J = 0
    const ne = $.getAttributes()
    for (const V in ne)
      if (ne[V].location >= 0) {
        let Q = K[V]
        Q === void 0 &&
          (V === 'instanceMatrix' && k.instanceMatrix && (Q = k.instanceMatrix),
          V === 'instanceColor' && k.instanceColor && (Q = k.instanceColor))
        const q = {}
        ;(q.attribute = Q), Q && Q.data && (q.data = Q.data), (j[V] = q), J++
      }
    ;(s.attributes = j), (s.attributesNum = J), (s.index = te)
  }
  function M() {
    const k = s.newAttributes
    for (let z = 0, $ = k.length; z < $; z++) k[z] = 0
  }
  function w(k) {
    x(k, 0)
  }
  function x(k, z) {
    const $ = s.newAttributes,
      te = s.enabledAttributes,
      j = s.attributeDivisors
    ;($[k] = 1),
      te[k] === 0 && (n.enableVertexAttribArray(k), (te[k] = 1)),
      j[k] !== z && (n.vertexAttribDivisor(k, z), (j[k] = z))
  }
  function T() {
    const k = s.newAttributes,
      z = s.enabledAttributes
    for (let $ = 0, te = z.length; $ < te; $++)
      z[$] !== k[$] && (n.disableVertexAttribArray($), (z[$] = 0))
  }
  function A(k, z, $, te, j, K, J) {
    J === !0
      ? n.vertexAttribIPointer(k, z, $, j, K)
      : n.vertexAttribPointer(k, z, $, te, j, K)
  }
  function P(k, z, $, te) {
    M()
    const j = te.attributes,
      K = $.getAttributes(),
      J = z.defaultAttributeValues
    for (const ne in K) {
      const V = K[ne]
      if (V.location >= 0) {
        let Y = j[ne]
        if (
          (Y === void 0 &&
            (ne === 'instanceMatrix' &&
              k.instanceMatrix &&
              (Y = k.instanceMatrix),
            ne === 'instanceColor' && k.instanceColor && (Y = k.instanceColor)),
          Y !== void 0)
        ) {
          const Q = Y.normalized,
            q = Y.itemSize,
            oe = e.get(Y)
          if (oe === void 0) continue
          const _e = oe.buffer,
            he = oe.type,
            Ce = oe.bytesPerElement,
            Te = he === n.INT || he === n.UNSIGNED_INT || Y.gpuType === Tg
          if (Y.isInterleavedBufferAttribute) {
            const Pe = Y.data,
              Be = Pe.stride,
              et = Y.offset
            if (Pe.isInstancedInterleavedBuffer) {
              for (let ft = 0; ft < V.locationSize; ft++)
                x(V.location + ft, Pe.meshPerAttribute)
              k.isInstancedMesh !== !0 &&
                te._maxInstanceCount === void 0 &&
                (te._maxInstanceCount = Pe.meshPerAttribute * Pe.count)
            } else
              for (let ft = 0; ft < V.locationSize; ft++) w(V.location + ft)
            n.bindBuffer(n.ARRAY_BUFFER, _e)
            for (let ft = 0; ft < V.locationSize; ft++)
              A(
                V.location + ft,
                q / V.locationSize,
                he,
                Q,
                Be * Ce,
                (et + (q / V.locationSize) * ft) * Ce,
                Te,
              )
          } else {
            if (Y.isInstancedBufferAttribute) {
              for (let Pe = 0; Pe < V.locationSize; Pe++)
                x(V.location + Pe, Y.meshPerAttribute)
              k.isInstancedMesh !== !0 &&
                te._maxInstanceCount === void 0 &&
                (te._maxInstanceCount = Y.meshPerAttribute * Y.count)
            } else
              for (let Pe = 0; Pe < V.locationSize; Pe++) w(V.location + Pe)
            n.bindBuffer(n.ARRAY_BUFFER, _e)
            for (let Pe = 0; Pe < V.locationSize; Pe++)
              A(
                V.location + Pe,
                q / V.locationSize,
                he,
                Q,
                q * Ce,
                (q / V.locationSize) * Pe * Ce,
                Te,
              )
          }
        } else if (J !== void 0) {
          const Q = J[ne]
          if (Q !== void 0)
            switch (Q.length) {
              case 2:
                n.vertexAttrib2fv(V.location, Q)
                break
              case 3:
                n.vertexAttrib3fv(V.location, Q)
                break
              case 4:
                n.vertexAttrib4fv(V.location, Q)
                break
              default:
                n.vertexAttrib1fv(V.location, Q)
            }
        }
      }
    }
    T()
  }
  function D() {
    F()
    for (const k in i) {
      const z = i[k]
      for (const $ in z) {
        const te = z[$]
        for (const j in te) h(te[j].object), delete te[j]
        delete z[$]
      }
      delete i[k]
    }
  }
  function O(k) {
    if (i[k.id] === void 0) return
    const z = i[k.id]
    for (const $ in z) {
      const te = z[$]
      for (const j in te) h(te[j].object), delete te[j]
      delete z[$]
    }
    delete i[k.id]
  }
  function U(k) {
    for (const z in i) {
      const $ = i[z]
      if ($[k.id] === void 0) continue
      const te = $[k.id]
      for (const j in te) h(te[j].object), delete te[j]
      delete $[k.id]
    }
  }
  function F() {
    N(), (o = !0), s !== r && ((s = r), u(s.object))
  }
  function N() {
    ;(r.geometry = null), (r.program = null), (r.wireframe = !1)
  }
  return {
    setup: a,
    reset: F,
    resetDefaultState: N,
    dispose: D,
    releaseStatesOfGeometry: O,
    releaseStatesOfProgram: U,
    initAttributes: M,
    enableAttribute: w,
    disableUnusedAttributes: T,
  }
}
function bj(n, e, t) {
  let i
  function r(u) {
    i = u
  }
  function s(u, h) {
    n.drawArrays(i, u, h), t.update(h, i, 1)
  }
  function o(u, h, m) {
    m !== 0 && (n.drawArraysInstanced(i, u, h, m), t.update(h, i, m))
  }
  function a(u, h, m) {
    if (m === 0) return
    e.get('WEBGL_multi_draw').multiDrawArraysWEBGL(i, u, 0, h, 0, m)
    let y = 0
    for (let _ = 0; _ < m; _++) y += h[_]
    t.update(y, i, 1)
  }
  function c(u, h, m, g) {
    if (m === 0) return
    const y = e.get('WEBGL_multi_draw')
    if (y === null) for (let _ = 0; _ < u.length; _++) o(u[_], h[_], g[_])
    else {
      y.multiDrawArraysInstancedWEBGL(i, u, 0, h, 0, g, 0, m)
      let _ = 0
      for (let M = 0; M < m; M++) _ += h[M] * g[M]
      t.update(_, i, 1)
    }
  }
  ;(this.setMode = r),
    (this.render = s),
    (this.renderInstances = o),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = c)
}
function Tj(n, e, t, i) {
  let r
  function s() {
    if (r !== void 0) return r
    if (e.has('EXT_texture_filter_anisotropic') === !0) {
      const U = e.get('EXT_texture_filter_anisotropic')
      r = n.getParameter(U.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
    } else r = 0
    return r
  }
  function o(U) {
    return !(
      U !== Ii &&
      i.convert(U) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    )
  }
  function a(U) {
    const F =
      U === or &&
      (e.has('EXT_color_buffer_half_float') || e.has('EXT_color_buffer_float'))
    return !(
      U !== _s &&
      i.convert(U) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      U !== gi &&
      !F
    )
  }
  function c(U) {
    if (U === 'highp') {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return 'highp'
      U = 'mediump'
    }
    return U === 'mediump' &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? 'mediump'
      : 'lowp'
  }
  let u = t.precision !== void 0 ? t.precision : 'highp'
  const h = c(u)
  h !== u &&
    (console.warn(
      'THREE.WebGLRenderer:',
      u,
      'not supported, using',
      h,
      'instead.',
    ),
    (u = h))
  const m = t.logarithmicDepthBuffer === !0,
    g = t.reverseDepthBuffer === !0 && e.has('EXT_clip_control'),
    y = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    _ = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    M = n.getParameter(n.MAX_TEXTURE_SIZE),
    w = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    x = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    T = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    A = n.getParameter(n.MAX_VARYING_VECTORS),
    P = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    D = _ > 0,
    O = n.getParameter(n.MAX_SAMPLES)
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: c,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: u,
    logarithmicDepthBuffer: m,
    reverseDepthBuffer: g,
    maxTextures: y,
    maxVertexTextures: _,
    maxTextureSize: M,
    maxCubemapSize: w,
    maxAttributes: x,
    maxVertexUniforms: T,
    maxVaryings: A,
    maxFragmentUniforms: P,
    vertexTextures: D,
    maxSamples: O,
  }
}
function Aj(n) {
  const e = this
  let t = null,
    i = 0,
    r = !1,
    s = !1
  const o = new wc(),
    a = new pn(),
    c = { value: null, needsUpdate: !1 }
  ;(this.uniform = c),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (m, g) {
      const y = m.length !== 0 || g || i !== 0 || r
      return (r = g), (i = m.length), y
    }),
    (this.beginShadows = function () {
      ;(s = !0), h(null)
    }),
    (this.endShadows = function () {
      s = !1
    }),
    (this.setGlobalState = function (m, g) {
      t = h(m, g, 0)
    }),
    (this.setState = function (m, g, y) {
      const _ = m.clippingPlanes,
        M = m.clipIntersection,
        w = m.clipShadows,
        x = n.get(m)
      if (!r || _ === null || _.length === 0 || (s && !w)) s ? h(null) : u()
      else {
        const T = s ? 0 : i,
          A = T * 4
        let P = x.clippingState || null
        ;(c.value = P), (P = h(_, g, A, y))
        for (let D = 0; D !== A; ++D) P[D] = t[D]
        ;(x.clippingState = P),
          (this.numIntersection = M ? this.numPlanes : 0),
          (this.numPlanes += T)
      }
    })
  function u() {
    c.value !== t && ((c.value = t), (c.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0)
  }
  function h(m, g, y, _) {
    const M = m !== null ? m.length : 0
    let w = null
    if (M !== 0) {
      if (((w = c.value), _ !== !0 || w === null)) {
        const x = y + M * 4,
          T = g.matrixWorldInverse
        a.getNormalMatrix(T),
          (w === null || w.length < x) && (w = new Float32Array(x))
        for (let A = 0, P = y; A !== M; ++A, P += 4)
          o.copy(m[A]).applyMatrix4(T, a),
            o.normal.toArray(w, P),
            (w[P + 3] = o.constant)
      }
      ;(c.value = w), (c.needsUpdate = !0)
    }
    return (e.numPlanes = M), (e.numIntersection = 0), w
  }
}
function Cj(n) {
  let e = new WeakMap()
  function t(o, a) {
    return a === hh ? (o.mapping = ba) : a === zm && (o.mapping = Pc), o
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping
      if (a === hh || a === zm)
        if (e.has(o)) {
          const c = e.get(o).texture
          return t(c, o.mapping)
        } else {
          const c = o.image
          if (c && c.height > 0) {
            const u = new uE(c.height)
            return (
              u.fromEquirectangularTexture(n, o),
              e.set(o, u),
              o.addEventListener('dispose', r),
              t(u.texture, o.mapping)
            )
          } else return null
        }
    }
    return o
  }
  function r(o) {
    const a = o.target
    a.removeEventListener('dispose', r)
    const c = e.get(a)
    c !== void 0 && (e.delete(a), c.dispose())
  }
  function s() {
    e = new WeakMap()
  }
  return { get: i, dispose: s }
}
const Kf = 4,
  FC = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Yu = 20,
  rw = new Nh(),
  UC = new Tt()
let sw = null,
  ow = 0,
  aw = 0,
  lw = !1
const Gu = (1 + Math.sqrt(5)) / 2,
  zf = 1 / Gu,
  BC = [
    new re(-Gu, zf, 0),
    new re(Gu, zf, 0),
    new re(-zf, 0, Gu),
    new re(zf, 0, Gu),
    new re(0, Gu, -zf),
    new re(0, Gu, zf),
    new re(-1, 1, -1),
    new re(1, 1, -1),
    new re(-1, 1, 1),
    new re(1, 1, 1),
  ]
class $S {
  constructor(e) {
    ;(this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial)
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    ;(sw = this._renderer.getRenderTarget()),
      (ow = this._renderer.getActiveCubeFace()),
      (aw = this._renderer.getActiveMipmapLevel()),
      (lw = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256)
    const s = this._allocateTargets()
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    )
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t)
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t)
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = jC()),
      this._compileMaterial(this._cubemapMaterial))
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = VC()),
      this._compileMaterial(this._equirectMaterial))
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose()
  }
  _setSize(e) {
    ;(this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax))
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose()
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose()
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(sw, ow, aw),
      (this._renderer.xr.enabled = lw),
      (e.scissorTest = !1),
      V0(e, 0, 0, e.width, e.height)
  }
  _fromTexture(e, t) {
    e.mapping === ba || e.mapping === Pc
      ? this._setSize(
          e.image.length === 0
            ? 16
            : e.image[0].width || e.image[0].image.width,
        )
      : this._setSize(e.image.width / 4),
      (sw = this._renderer.getRenderTarget()),
      (ow = this._renderer.getActiveCubeFace()),
      (aw = this._renderer.getActiveMipmapLevel()),
      (lw = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1)
    const i = t || this._allocateTargets()
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: Vn,
        minFilter: Vn,
        generateMipmaps: !1,
        type: or,
        format: Ii,
        colorSpace: Aa,
        depthBuffer: !1,
      },
      r = zC(e, t, i)
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = zC(e, t, i))
      const { _lodMax: s } = this
      ;({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = Pj(s)),
        (this._blurMaterial = Rj(s, e, t))
    }
    return r
  }
  _compileMaterial(e) {
    const t = new vi(this._lodPlanes[0], e)
    this._renderer.compile(t, rw)
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new sr(90, 1, t, i),
      c = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      m = h.autoClear,
      g = h.toneMapping
    h.getClearColor(UC), (h.toneMapping = ya), (h.autoClear = !1)
    const y = new Il({
        name: 'PMREM.Background',
        side: Qr,
        depthWrite: !1,
        depthTest: !1,
      }),
      _ = new vi(new _d(), y)
    let M = !1
    const w = e.background
    w
      ? w.isColor && (y.color.copy(w), (e.background = null), (M = !0))
      : (y.color.copy(UC), (M = !0))
    for (let x = 0; x < 6; x++) {
      const T = x % 3
      T === 0
        ? (a.up.set(0, c[x], 0), a.lookAt(u[x], 0, 0))
        : T === 1
        ? (a.up.set(0, 0, c[x]), a.lookAt(0, u[x], 0))
        : (a.up.set(0, c[x], 0), a.lookAt(0, 0, u[x]))
      const A = this._cubeSize
      V0(r, T * A, x > 2 ? A : 0, A, A),
        h.setRenderTarget(r),
        M && h.render(_, a),
        h.render(e, a)
    }
    _.geometry.dispose(),
      _.material.dispose(),
      (h.toneMapping = g),
      (h.autoClear = m),
      (e.background = w)
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === ba || e.mapping === Pc
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = jC()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = VC())
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new vi(this._lodPlanes[0], s),
      a = s.uniforms
    a.envMap.value = e
    const c = this._cubeSize
    V0(t, 0, 0, 3 * c, 2 * c), i.setRenderTarget(t), i.render(o, rw)
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear
    t.autoClear = !1
    const r = this._lodPlanes.length
    for (let s = 1; s < r; s++) {
      const o = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] -
            this._sigmas[s - 1] * this._sigmas[s - 1],
        ),
        a = BC[(r - s - 1) % BC.length]
      this._blur(e, s - 1, s, o, a)
    }
    t.autoClear = i
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget
    this._halfBlur(e, o, t, i, r, 'latitudinal', s),
      this._halfBlur(o, e, i, i, r, 'longitudinal', s)
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const c = this._renderer,
      u = this._blurMaterial
    o !== 'latitudinal' &&
      o !== 'longitudinal' &&
      console.error(
        'blur direction must be either latitudinal or longitudinal!',
      )
    const h = 3,
      m = new vi(this._lodPlanes[r], u),
      g = u.uniforms,
      y = this._sizeLods[i] - 1,
      _ = isFinite(s) ? Math.PI / (2 * y) : (2 * Math.PI) / (2 * Yu - 1),
      M = s / _,
      w = isFinite(s) ? 1 + Math.floor(h * M) : Yu
    w > Yu &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${w} samples when the maximum is set to ${Yu}`,
      )
    const x = []
    let T = 0
    for (let U = 0; U < Yu; ++U) {
      const F = U / M,
        N = Math.exp((-F * F) / 2)
      x.push(N), U === 0 ? (T += N) : U < w && (T += 2 * N)
    }
    for (let U = 0; U < x.length; U++) x[U] = x[U] / T
    ;(g.envMap.value = e.texture),
      (g.samples.value = w),
      (g.weights.value = x),
      (g.latitudinal.value = o === 'latitudinal'),
      a && (g.poleAxis.value = a)
    const { _lodMax: A } = this
    ;(g.dTheta.value = _), (g.mipInt.value = A - i)
    const P = this._sizeLods[r],
      D = 3 * P * (r > A - Kf ? r - A + Kf : 0),
      O = 4 * (this._cubeSize - P)
    V0(t, D, O, 3 * P, 2 * P), c.setRenderTarget(t), c.render(m, rw)
  }
}
function Pj(n) {
  const e = [],
    t = [],
    i = []
  let r = n
  const s = n - Kf + 1 + FC.length
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r)
    t.push(a)
    let c = 1 / a
    o > n - Kf ? (c = FC[o - n + Kf - 1]) : o === 0 && (c = 0), i.push(c)
    const u = 1 / (a - 2),
      h = -u,
      m = 1 + u,
      g = [h, h, m, h, m, m, h, h, m, m, h, m],
      y = 6,
      _ = 6,
      M = 3,
      w = 2,
      x = 1,
      T = new Float32Array(M * _ * y),
      A = new Float32Array(w * _ * y),
      P = new Float32Array(x * _ * y)
    for (let O = 0; O < y; O++) {
      const U = ((O % 3) * 2) / 3 - 1,
        F = O > 2 ? 0 : -1,
        N = [
          U,
          F,
          0,
          U + 2 / 3,
          F,
          0,
          U + 2 / 3,
          F + 1,
          0,
          U,
          F,
          0,
          U + 2 / 3,
          F + 1,
          0,
          U,
          F + 1,
          0,
        ]
      T.set(N, M * _ * O), A.set(g, w * _ * O)
      const k = [O, O, O, O, O, O]
      P.set(k, x * _ * O)
    }
    const D = new _n()
    D.setAttribute('position', new qn(T, M)),
      D.setAttribute('uv', new qn(A, w)),
      D.setAttribute('faceIndex', new qn(P, x)),
      e.push(D),
      r > Kf && r--
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i }
}
function zC(n, e, t) {
  const i = new uo(n, e, t)
  return (
    (i.texture.mapping = Rh),
    (i.texture.name = 'PMREM.cubeUv'),
    (i.scissorTest = !0),
    i
  )
}
function V0(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r)
}
function Rj(n, e, t) {
  const i = new Float32Array(Yu),
    r = new re(0, 1, 0)
  return new ws({
    name: 'SphericalGaussianBlur',
    defines: {
      n: Yu,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: FE(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: va,
    depthTest: !1,
    depthWrite: !1,
  })
}
function VC() {
  return new ws({
    name: 'EquirectangularToCubeUV',
    uniforms: { envMap: { value: null } },
    vertexShader: FE(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: va,
    depthTest: !1,
    depthWrite: !1,
  })
}
function jC() {
  return new ws({
    name: 'CubemapToCubeUV',
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: FE(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: va,
    depthTest: !1,
    depthWrite: !1,
  })
}
function FE() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function Ij(n) {
  let e = new WeakMap(),
    t = null
  function i(a) {
    if (a && a.isTexture) {
      const c = a.mapping,
        u = c === hh || c === zm,
        h = c === ba || c === Pc
      if (u || h) {
        let m = e.get(a)
        const g = m !== void 0 ? m.texture.pmremVersion : 0
        if (a.isRenderTargetTexture && a.pmremVersion !== g)
          return (
            t === null && (t = new $S(n)),
            (m = u ? t.fromEquirectangular(a, m) : t.fromCubemap(a, m)),
            (m.texture.pmremVersion = a.pmremVersion),
            e.set(a, m),
            m.texture
          )
        if (m !== void 0) return m.texture
        {
          const y = a.image
          return (u && y && y.height > 0) || (h && y && r(y))
            ? (t === null && (t = new $S(n)),
              (m = u ? t.fromEquirectangular(a) : t.fromCubemap(a)),
              (m.texture.pmremVersion = a.pmremVersion),
              e.set(a, m),
              a.addEventListener('dispose', s),
              m.texture)
            : null
        }
      }
    }
    return a
  }
  function r(a) {
    let c = 0
    const u = 6
    for (let h = 0; h < u; h++) a[h] !== void 0 && c++
    return c === u
  }
  function s(a) {
    const c = a.target
    c.removeEventListener('dispose', s)
    const u = e.get(c)
    u !== void 0 && (e.delete(c), u.dispose())
  }
  function o() {
    ;(e = new WeakMap()), t !== null && (t.dispose(), (t = null))
  }
  return { get: i, dispose: o }
}
function Lj(n) {
  const e = {}
  function t(i) {
    if (e[i] !== void 0) return e[i]
    let r
    switch (i) {
      case 'WEBGL_depth_texture':
        r =
          n.getExtension('WEBGL_depth_texture') ||
          n.getExtension('MOZ_WEBGL_depth_texture') ||
          n.getExtension('WEBKIT_WEBGL_depth_texture')
        break
      case 'EXT_texture_filter_anisotropic':
        r =
          n.getExtension('EXT_texture_filter_anisotropic') ||
          n.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          n.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        break
      case 'WEBGL_compressed_texture_s3tc':
        r =
          n.getExtension('WEBGL_compressed_texture_s3tc') ||
          n.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          n.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
        break
      case 'WEBGL_compressed_texture_pvrtc':
        r =
          n.getExtension('WEBGL_compressed_texture_pvrtc') ||
          n.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
        break
      default:
        r = n.getExtension(i)
    }
    return (e[i] = r), r
  }
  return {
    has: function (i) {
      return t(i) !== null
    },
    init: function () {
      t('EXT_color_buffer_float'),
        t('WEBGL_clip_cull_distance'),
        t('OES_texture_float_linear'),
        t('EXT_color_buffer_half_float'),
        t('WEBGL_multisampled_render_to_texture'),
        t('WEBGL_render_shared_exponent')
    },
    get: function (i) {
      const r = t(i)
      return (
        r === null &&
          Gf('THREE.WebGLRenderer: ' + i + ' extension not supported.'),
        r
      )
    },
  }
}
function Nj(n, e, t, i) {
  const r = {},
    s = new WeakMap()
  function o(m) {
    const g = m.target
    g.index !== null && e.remove(g.index)
    for (const _ in g.attributes) e.remove(g.attributes[_])
    g.removeEventListener('dispose', o), delete r[g.id]
    const y = s.get(g)
    y && (e.remove(y), s.delete(g)),
      i.releaseStatesOfGeometry(g),
      g.isInstancedBufferGeometry === !0 && delete g._maxInstanceCount,
      t.memory.geometries--
  }
  function a(m, g) {
    return (
      r[g.id] === !0 ||
        (g.addEventListener('dispose', o),
        (r[g.id] = !0),
        t.memory.geometries++),
      g
    )
  }
  function c(m) {
    const g = m.attributes
    for (const y in g) e.update(g[y], n.ARRAY_BUFFER)
  }
  function u(m) {
    const g = [],
      y = m.index,
      _ = m.attributes.position
    let M = 0
    if (y !== null) {
      const T = y.array
      M = y.version
      for (let A = 0, P = T.length; A < P; A += 3) {
        const D = T[A + 0],
          O = T[A + 1],
          U = T[A + 2]
        g.push(D, O, O, U, U, D)
      }
    } else if (_ !== void 0) {
      const T = _.array
      M = _.version
      for (let A = 0, P = T.length / 3 - 1; A < P; A += 3) {
        const D = A + 0,
          O = A + 1,
          U = A + 2
        g.push(D, O, O, U, U, D)
      }
    } else return
    const w = new (CL(g) ? cE : lE)(g, 1)
    w.version = M
    const x = s.get(m)
    x && e.remove(x), s.set(m, w)
  }
  function h(m) {
    const g = s.get(m)
    if (g) {
      const y = m.index
      y !== null && g.version < y.version && u(m)
    } else u(m)
    return s.get(m)
  }
  return { get: a, update: c, getWireframeAttribute: h }
}
function Dj(n, e, t) {
  let i
  function r(g) {
    i = g
  }
  let s, o
  function a(g) {
    ;(s = g.type), (o = g.bytesPerElement)
  }
  function c(g, y) {
    n.drawElements(i, y, s, g * o), t.update(y, i, 1)
  }
  function u(g, y, _) {
    _ !== 0 && (n.drawElementsInstanced(i, y, s, g * o, _), t.update(y, i, _))
  }
  function h(g, y, _) {
    if (_ === 0) return
    e.get('WEBGL_multi_draw').multiDrawElementsWEBGL(i, y, 0, s, g, 0, _)
    let w = 0
    for (let x = 0; x < _; x++) w += y[x]
    t.update(w, i, 1)
  }
  function m(g, y, _, M) {
    if (_ === 0) return
    const w = e.get('WEBGL_multi_draw')
    if (w === null) for (let x = 0; x < g.length; x++) u(g[x] / o, y[x], M[x])
    else {
      w.multiDrawElementsInstancedWEBGL(i, y, 0, s, g, 0, M, 0, _)
      let x = 0
      for (let T = 0; T < _; T++) x += y[T] * M[T]
      t.update(x, i, 1)
    }
  }
  ;(this.setMode = r),
    (this.setIndex = a),
    (this.render = c),
    (this.renderInstances = u),
    (this.renderMultiDraw = h),
    (this.renderMultiDrawInstances = m)
}
function Oj(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3)
        break
      case n.LINES:
        t.lines += a * (s / 2)
        break
      case n.LINE_STRIP:
        t.lines += a * (s - 1)
        break
      case n.LINE_LOOP:
        t.lines += a * s
        break
      case n.POINTS:
        t.points += a * s
        break
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', o)
        break
    }
  }
  function r() {
    ;(t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0)
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  }
}
function kj(n, e, t) {
  const i = new WeakMap(),
    r = new In()
  function s(o, a, c) {
    const u = o.morphTargetInfluences,
      h =
        a.morphAttributes.position ||
        a.morphAttributes.normal ||
        a.morphAttributes.color,
      m = h !== void 0 ? h.length : 0
    let g = i.get(a)
    if (g === void 0 || g.count !== m) {
      let N = function () {
        U.dispose(), i.delete(a), a.removeEventListener('dispose', N)
      }
      g !== void 0 && g.texture.dispose()
      const y = a.morphAttributes.position !== void 0,
        _ = a.morphAttributes.normal !== void 0,
        M = a.morphAttributes.color !== void 0,
        w = a.morphAttributes.position || [],
        x = a.morphAttributes.normal || [],
        T = a.morphAttributes.color || []
      let A = 0
      y === !0 && (A = 1), _ === !0 && (A = 2), M === !0 && (A = 3)
      let P = a.attributes.position.count * A,
        D = 1
      P > e.maxTextureSize &&
        ((D = Math.ceil(P / e.maxTextureSize)), (P = e.maxTextureSize))
      const O = new Float32Array(P * D * 4 * m),
        U = new Pg(O, P, D, m)
      ;(U.type = gi), (U.needsUpdate = !0)
      const F = A * 4
      for (let k = 0; k < m; k++) {
        const z = w[k],
          $ = x[k],
          te = T[k],
          j = P * D * 4 * k
        for (let K = 0; K < z.count; K++) {
          const J = K * F
          y === !0 &&
            (r.fromBufferAttribute(z, K),
            (O[j + J + 0] = r.x),
            (O[j + J + 1] = r.y),
            (O[j + J + 2] = r.z),
            (O[j + J + 3] = 0)),
            _ === !0 &&
              (r.fromBufferAttribute($, K),
              (O[j + J + 4] = r.x),
              (O[j + J + 5] = r.y),
              (O[j + J + 6] = r.z),
              (O[j + J + 7] = 0)),
            M === !0 &&
              (r.fromBufferAttribute(te, K),
              (O[j + J + 8] = r.x),
              (O[j + J + 9] = r.y),
              (O[j + J + 10] = r.z),
              (O[j + J + 11] = te.itemSize === 4 ? r.w : 1))
        }
      }
      ;(g = { count: m, texture: U, size: new qe(P, D) }),
        i.set(a, g),
        a.addEventListener('dispose', N)
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      c.getUniforms().setValue(n, 'morphTexture', o.morphTexture, t)
    else {
      let y = 0
      for (let M = 0; M < u.length; M++) y += u[M]
      const _ = a.morphTargetsRelative ? 1 : 1 - y
      c.getUniforms().setValue(n, 'morphTargetBaseInfluence', _),
        c.getUniforms().setValue(n, 'morphTargetInfluences', u)
    }
    c.getUniforms().setValue(n, 'morphTargetsTexture', g.texture, t),
      c.getUniforms().setValue(n, 'morphTargetsTextureSize', g.size)
  }
  return { update: s }
}
function Fj(n, e, t, i) {
  let r = new WeakMap()
  function s(c) {
    const u = i.render.frame,
      h = c.geometry,
      m = e.get(c, h)
    if (
      (r.get(m) !== u && (e.update(m), r.set(m, u)),
      c.isInstancedMesh &&
        (c.hasEventListener('dispose', a) === !1 &&
          c.addEventListener('dispose', a),
        r.get(c) !== u &&
          (t.update(c.instanceMatrix, n.ARRAY_BUFFER),
          c.instanceColor !== null && t.update(c.instanceColor, n.ARRAY_BUFFER),
          r.set(c, u))),
      c.isSkinnedMesh)
    ) {
      const g = c.skeleton
      r.get(g) !== u && (g.update(), r.set(g, u))
    }
    return m
  }
  function o() {
    r = new WeakMap()
  }
  function a(c) {
    const u = c.target
    u.removeEventListener('dispose', a),
      t.remove(u.instanceMatrix),
      u.instanceColor !== null && t.remove(u.instanceColor)
  }
  return { update: s, dispose: o }
}
const RN = new Xn(),
  HC = new pE(1, 1),
  IN = new Pg(),
  LN = new Kx(),
  NN = new Ig(),
  GC = [],
  WC = [],
  $C = new Float32Array(16),
  XC = new Float32Array(9),
  qC = new Float32Array(4)
function Dh(n, e, t) {
  const i = n[0]
  if (i <= 0 || i > 0) return n
  const r = e * t
  let s = GC[r]
  if ((s === void 0 && ((s = new Float32Array(r)), (GC[r] = s)), e !== 0)) {
    i.toArray(s, 0)
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a)
  }
  return s
}
function Zi(n, e) {
  if (n.length !== e.length) return !1
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1
  return !0
}
function Ki(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t]
}
function y_(n, e) {
  let t = WC[e]
  t === void 0 && ((t = new Int32Array(e)), (WC[e] = t))
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit()
  return t
}
function Uj(n, e) {
  const t = this.cache
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e))
}
function Bj(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y))
  else {
    if (Zi(t, e)) return
    n.uniform2fv(this.addr, e), Ki(t, e)
  }
}
function zj(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z))
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b))
  else {
    if (Zi(t, e)) return
    n.uniform3fv(this.addr, e), Ki(t, e)
  }
}
function Vj(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w))
  else {
    if (Zi(t, e)) return
    n.uniform4fv(this.addr, e), Ki(t, e)
  }
}
function jj(n, e) {
  const t = this.cache,
    i = e.elements
  if (i === void 0) {
    if (Zi(t, e)) return
    n.uniformMatrix2fv(this.addr, !1, e), Ki(t, e)
  } else {
    if (Zi(t, i)) return
    qC.set(i), n.uniformMatrix2fv(this.addr, !1, qC), Ki(t, i)
  }
}
function Hj(n, e) {
  const t = this.cache,
    i = e.elements
  if (i === void 0) {
    if (Zi(t, e)) return
    n.uniformMatrix3fv(this.addr, !1, e), Ki(t, e)
  } else {
    if (Zi(t, i)) return
    XC.set(i), n.uniformMatrix3fv(this.addr, !1, XC), Ki(t, i)
  }
}
function Gj(n, e) {
  const t = this.cache,
    i = e.elements
  if (i === void 0) {
    if (Zi(t, e)) return
    n.uniformMatrix4fv(this.addr, !1, e), Ki(t, e)
  } else {
    if (Zi(t, i)) return
    $C.set(i), n.uniformMatrix4fv(this.addr, !1, $C), Ki(t, i)
  }
}
function Wj(n, e) {
  const t = this.cache
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e))
}
function $j(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y))
  else {
    if (Zi(t, e)) return
    n.uniform2iv(this.addr, e), Ki(t, e)
  }
}
function Xj(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z))
  else {
    if (Zi(t, e)) return
    n.uniform3iv(this.addr, e), Ki(t, e)
  }
}
function qj(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w))
  else {
    if (Zi(t, e)) return
    n.uniform4iv(this.addr, e), Ki(t, e)
  }
}
function Yj(n, e) {
  const t = this.cache
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e))
}
function Zj(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y))
  else {
    if (Zi(t, e)) return
    n.uniform2uiv(this.addr, e), Ki(t, e)
  }
}
function Kj(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z))
  else {
    if (Zi(t, e)) return
    n.uniform3uiv(this.addr, e), Ki(t, e)
  }
}
function Qj(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w))
  else {
    if (Zi(t, e)) return
    n.uniform4uiv(this.addr, e), Ki(t, e)
  }
}
function Jj(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r))
  let s
  this.type === n.SAMPLER_2D_SHADOW
    ? ((HC.compareFunction = oE), (s = HC))
    : (s = RN),
    t.setTexture2D(e || s, r)
}
function eH(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || LN, r)
}
function tH(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || NN, r)
}
function nH(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || IN, r)
}
function iH(n) {
  switch (n) {
    case 5126:
      return Uj
    case 35664:
      return Bj
    case 35665:
      return zj
    case 35666:
      return Vj
    case 35674:
      return jj
    case 35675:
      return Hj
    case 35676:
      return Gj
    case 5124:
    case 35670:
      return Wj
    case 35667:
    case 35671:
      return $j
    case 35668:
    case 35672:
      return Xj
    case 35669:
    case 35673:
      return qj
    case 5125:
      return Yj
    case 36294:
      return Zj
    case 36295:
      return Kj
    case 36296:
      return Qj
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Jj
    case 35679:
    case 36299:
    case 36307:
      return eH
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return tH
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return nH
  }
}
function rH(n, e) {
  n.uniform1fv(this.addr, e)
}
function sH(n, e) {
  const t = Dh(e, this.size, 2)
  n.uniform2fv(this.addr, t)
}
function oH(n, e) {
  const t = Dh(e, this.size, 3)
  n.uniform3fv(this.addr, t)
}
function aH(n, e) {
  const t = Dh(e, this.size, 4)
  n.uniform4fv(this.addr, t)
}
function lH(n, e) {
  const t = Dh(e, this.size, 4)
  n.uniformMatrix2fv(this.addr, !1, t)
}
function cH(n, e) {
  const t = Dh(e, this.size, 9)
  n.uniformMatrix3fv(this.addr, !1, t)
}
function uH(n, e) {
  const t = Dh(e, this.size, 16)
  n.uniformMatrix4fv(this.addr, !1, t)
}
function dH(n, e) {
  n.uniform1iv(this.addr, e)
}
function fH(n, e) {
  n.uniform2iv(this.addr, e)
}
function hH(n, e) {
  n.uniform3iv(this.addr, e)
}
function pH(n, e) {
  n.uniform4iv(this.addr, e)
}
function mH(n, e) {
  n.uniform1uiv(this.addr, e)
}
function gH(n, e) {
  n.uniform2uiv(this.addr, e)
}
function vH(n, e) {
  n.uniform3uiv(this.addr, e)
}
function yH(n, e) {
  n.uniform4uiv(this.addr, e)
}
function xH(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = y_(t, r)
  Zi(i, s) || (n.uniform1iv(this.addr, s), Ki(i, s))
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || RN, s[o])
}
function _H(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = y_(t, r)
  Zi(i, s) || (n.uniform1iv(this.addr, s), Ki(i, s))
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || LN, s[o])
}
function wH(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = y_(t, r)
  Zi(i, s) || (n.uniform1iv(this.addr, s), Ki(i, s))
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || NN, s[o])
}
function SH(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = y_(t, r)
  Zi(i, s) || (n.uniform1iv(this.addr, s), Ki(i, s))
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || IN, s[o])
}
function MH(n) {
  switch (n) {
    case 5126:
      return rH
    case 35664:
      return sH
    case 35665:
      return oH
    case 35666:
      return aH
    case 35674:
      return lH
    case 35675:
      return cH
    case 35676:
      return uH
    case 5124:
    case 35670:
      return dH
    case 35667:
    case 35671:
      return fH
    case 35668:
    case 35672:
      return hH
    case 35669:
    case 35673:
      return pH
    case 5125:
      return mH
    case 36294:
      return gH
    case 36295:
      return vH
    case 36296:
      return yH
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return xH
    case 35679:
    case 36299:
    case 36307:
      return _H
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return wH
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return SH
  }
}
class EH {
  constructor(e, t, i) {
    ;(this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = iH(t.type))
  }
}
class bH {
  constructor(e, t, i) {
    ;(this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = MH(t.type))
  }
}
class TH {
  constructor(e) {
    ;(this.id = e), (this.seq = []), (this.map = {})
  }
  setValue(e, t, i) {
    const r = this.seq
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s]
      a.setValue(e, t[a.id], i)
    }
  }
}
const cw = /(\w+)(\])?(\[|\.)?/g
function YC(n, e) {
  n.seq.push(e), (n.map[e.id] = e)
}
function AH(n, e, t) {
  const i = n.name,
    r = i.length
  for (cw.lastIndex = 0; ; ) {
    const s = cw.exec(i),
      o = cw.lastIndex
    let a = s[1]
    const c = s[2] === ']',
      u = s[3]
    if ((c && (a = a | 0), u === void 0 || (u === '[' && o + 2 === r))) {
      YC(t, u === void 0 ? new EH(a, n, e) : new bH(a, n, e))
      break
    } else {
      let m = t.map[a]
      m === void 0 && ((m = new TH(a)), YC(t, m)), (t = m)
    }
  }
}
class _y {
  constructor(e, t) {
    ;(this.seq = []), (this.map = {})
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS)
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name)
      AH(s, o, this)
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t]
    s !== void 0 && s.setValue(e, i, r)
  }
  setOptional(e, t, i) {
    const r = t[i]
    r !== void 0 && this.setValue(e, i, r)
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        c = i[a.id]
      c.needsUpdate !== !1 && a.setValue(e, c.value, r)
    }
  }
  static seqWithValue(e, t) {
    const i = []
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r]
      o.id in t && i.push(o)
    }
    return i
  }
}
function ZC(n, e, t) {
  const i = n.createShader(e)
  return n.shaderSource(i, t), n.compileShader(i), i
}
const CH = 37297
let PH = 0
function RH(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length)
  for (let o = r; o < s; o++) {
    const a = o + 1
    i.push(`${a === e ? '>' : ' '} ${a}: ${t[o]}`)
  }
  return i.join(`
`)
}
const KC = new pn()
function IH(n) {
  Cn._getMatrix(KC, Cn.workingColorSpace, n)
  const e = `mat3( ${KC.elements.map((t) => t.toFixed(4))} )`
  switch (Cn.getTransfer(n)) {
    case Wm:
      return [e, 'LinearTransferOETF']
    case zn:
      return [e, 'sRGBTransferOETF']
    default:
      return (
        console.warn('THREE.WebGLProgram: Unsupported color space: ', n),
        [e, 'LinearTransferOETF']
      )
  }
}
function QC(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS),
    r = n.getShaderInfoLog(e).trim()
  if (i && r === '') return ''
  const s = /ERROR: 0:(\d+)/.exec(r)
  if (s) {
    const o = parseInt(s[1])
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      RH(n.getShaderSource(e), o)
    )
  } else return r
}
function LH(n, e) {
  const t = IH(e)
  return [
    `vec4 ${n}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    '}',
  ].join(`
`)
}
function NH(n, e) {
  let t
  switch (e) {
    case lL:
      t = 'Linear'
      break
    case cL:
      t = 'Reinhard'
      break
    case uL:
      t = 'Cineon'
      break
    case ZM:
      t = 'ACESFilmic'
      break
    case fL:
      t = 'AgX'
      break
    case hL:
      t = 'Neutral'
      break
    case dL:
      t = 'Custom'
      break
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e),
        (t = 'Linear')
  }
  return (
    'vec3 ' + n + '( vec3 color ) { return ' + t + 'ToneMapping( color ); }'
  )
}
const j0 = new re()
function DH() {
  Cn.getLuminanceCoefficients(j0)
  const n = j0.x.toFixed(4),
    e = j0.y.toFixed(4),
    t = j0.z.toFixed(4)
  return [
    'float luminance( const in vec3 rgb ) {',
    `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
    '	return dot( weights, rgb );',
    '}',
  ].join(`
`)
}
function OH(n) {
  return [
    n.extensionClipCullDistance
      ? '#extension GL_ANGLE_clip_cull_distance : require'
      : '',
    n.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
  ].filter(sm).join(`
`)
}
function kH(n) {
  const e = []
  for (const t in n) {
    const i = n[t]
    i !== !1 && e.push('#define ' + t + ' ' + i)
  }
  return e.join(`
`)
}
function FH(n, e) {
  const t = {},
    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES)
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name
    let a = 1
    s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      })
  }
  return t
}
function sm(n) {
  return n !== ''
}
function JC(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function e2(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection,
    )
}
const UH = /^[ \t]*#include +<([\w\d./]+)>/gm
function XS(n) {
  return n.replace(UH, zH)
}
const BH = new Map()
function zH(n, e) {
  let t = xn[e]
  if (t === void 0) {
    const i = BH.get(e)
    if (i !== void 0)
      (t = xn[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i,
        )
    else throw new Error('Can not resolve #include <' + e + '>')
  }
  return XS(t)
}
const VH =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
function t2(n) {
  return n.replace(VH, jH)
}
function jH(n, e, t, i) {
  let r = ''
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, '[ ' + s + ' ]')
      .replace(/UNROLLED_LOOP_INDEX/g, s)
  return r
}
function n2(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`
  return (
    n.precision === 'highp'
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === 'mediump'
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === 'lowp' &&
        (e += `
#define LOW_PRECISION`),
    e
  )
}
function HH(n) {
  let e = 'SHADOWMAP_TYPE_BASIC'
  return (
    n.shadowMapType === jx
      ? (e = 'SHADOWMAP_TYPE_PCF')
      : n.shadowMapType === mm
      ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
      : n.shadowMapType === Vo && (e = 'SHADOWMAP_TYPE_VSM'),
    e
  )
}
function GH(n) {
  let e = 'ENVMAP_TYPE_CUBE'
  if (n.envMap)
    switch (n.envMapMode) {
      case ba:
      case Pc:
        e = 'ENVMAP_TYPE_CUBE'
        break
      case Rh:
        e = 'ENVMAP_TYPE_CUBE_UV'
        break
    }
  return e
}
function WH(n) {
  let e = 'ENVMAP_MODE_REFLECTION'
  if (n.envMap)
    switch (n.envMapMode) {
      case Pc:
        e = 'ENVMAP_MODE_REFRACTION'
        break
    }
  return e
}
function $H(n) {
  let e = 'ENVMAP_BLENDING_NONE'
  if (n.envMap)
    switch (n.combine) {
      case bg:
        e = 'ENVMAP_BLENDING_MULTIPLY'
        break
      case oL:
        e = 'ENVMAP_BLENDING_MIX'
        break
      case aL:
        e = 'ENVMAP_BLENDING_ADD'
        break
    }
  return e
}
function XH(n) {
  const e = n.envMapCubeUVHeight
  if (e === null) return null
  const t = Math.log2(e) - 2,
    i = 1 / e
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  }
}
function qH(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines
  let o = t.vertexShader,
    a = t.fragmentShader
  const c = HH(t),
    u = GH(t),
    h = WH(t),
    m = $H(t),
    g = XH(t),
    y = OH(t),
    _ = kH(s),
    M = r.createProgram()
  let w,
    x,
    T = t.glslVersion
      ? '#version ' +
        t.glslVersion +
        `
`
      : ''
  t.isRawShaderMaterial
    ? ((w = [
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        _,
      ].filter(sm).join(`
`)),
      w.length > 0 &&
        (w += `
`),
      (x = [
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        _,
      ].filter(sm).join(`
`)),
      x.length > 0 &&
        (x += `
`))
    : ((w = [
        n2(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        _,
        t.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
        t.batching ? '#define USE_BATCHING' : '',
        t.batchingColor ? '#define USE_BATCHING_COLOR' : '',
        t.instancing ? '#define USE_INSTANCING' : '',
        t.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
        t.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.map ? '#define USE_MAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + h : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropy ? '#define USE_ANISOTROPY' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.mapUv ? '#define MAP_UV ' + t.mapUv : '',
        t.alphaMapUv ? '#define ALPHAMAP_UV ' + t.alphaMapUv : '',
        t.lightMapUv ? '#define LIGHTMAP_UV ' + t.lightMapUv : '',
        t.aoMapUv ? '#define AOMAP_UV ' + t.aoMapUv : '',
        t.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + t.emissiveMapUv : '',
        t.bumpMapUv ? '#define BUMPMAP_UV ' + t.bumpMapUv : '',
        t.normalMapUv ? '#define NORMALMAP_UV ' + t.normalMapUv : '',
        t.displacementMapUv
          ? '#define DISPLACEMENTMAP_UV ' + t.displacementMapUv
          : '',
        t.metalnessMapUv ? '#define METALNESSMAP_UV ' + t.metalnessMapUv : '',
        t.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + t.roughnessMapUv : '',
        t.anisotropyMapUv
          ? '#define ANISOTROPYMAP_UV ' + t.anisotropyMapUv
          : '',
        t.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + t.clearcoatMapUv : '',
        t.clearcoatNormalMapUv
          ? '#define CLEARCOAT_NORMALMAP_UV ' + t.clearcoatNormalMapUv
          : '',
        t.clearcoatRoughnessMapUv
          ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + t.clearcoatRoughnessMapUv
          : '',
        t.iridescenceMapUv
          ? '#define IRIDESCENCEMAP_UV ' + t.iridescenceMapUv
          : '',
        t.iridescenceThicknessMapUv
          ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + t.iridescenceThicknessMapUv
          : '',
        t.sheenColorMapUv
          ? '#define SHEEN_COLORMAP_UV ' + t.sheenColorMapUv
          : '',
        t.sheenRoughnessMapUv
          ? '#define SHEEN_ROUGHNESSMAP_UV ' + t.sheenRoughnessMapUv
          : '',
        t.specularMapUv ? '#define SPECULARMAP_UV ' + t.specularMapUv : '',
        t.specularColorMapUv
          ? '#define SPECULAR_COLORMAP_UV ' + t.specularColorMapUv
          : '',
        t.specularIntensityMapUv
          ? '#define SPECULAR_INTENSITYMAP_UV ' + t.specularIntensityMapUv
          : '',
        t.transmissionMapUv
          ? '#define TRANSMISSIONMAP_UV ' + t.transmissionMapUv
          : '',
        t.thicknessMapUv ? '#define THICKNESSMAP_UV ' + t.thicknessMapUv : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors ? '#define USE_COLOR' : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.skinning ? '#define USE_SKINNING' : '',
        t.morphTargets ? '#define USE_MORPHTARGETS' : '',
        t.morphNormals && t.flatShading === !1
          ? '#define USE_MORPHNORMALS'
          : '',
        t.morphColors ? '#define USE_MORPHCOLORS' : '',
        t.morphTargetsCount > 0
          ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + t.morphTextureStride
          : '',
        t.morphTargetsCount > 0
          ? '#define MORPHTARGETS_COUNT ' + t.morphTargetsCount
          : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + c : '',
        t.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        t.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        '#ifdef USE_INSTANCING',
        '	attribute mat4 instanceMatrix;',
        '#endif',
        '#ifdef USE_INSTANCING_COLOR',
        '	attribute vec3 instanceColor;',
        '#endif',
        '#ifdef USE_INSTANCING_MORPH',
        '	uniform sampler2D morphTexture;',
        '#endif',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_UV1',
        '	attribute vec2 uv1;',
        '#endif',
        '#ifdef USE_UV2',
        '	attribute vec2 uv2;',
        '#endif',
        '#ifdef USE_UV3',
        '	attribute vec2 uv3;',
        '#endif',
        '#ifdef USE_TANGENT',
        '	attribute vec4 tangent;',
        '#endif',
        '#if defined( USE_COLOR_ALPHA )',
        '	attribute vec4 color;',
        '#elif defined( USE_COLOR )',
        '	attribute vec3 color;',
        '#endif',
        '#ifdef USE_SKINNING',
        '	attribute vec4 skinIndex;',
        '	attribute vec4 skinWeight;',
        '#endif',
        `
`,
      ].filter(sm).join(`
`)),
      (x = [
        n2(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        _,
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
        t.map ? '#define USE_MAP' : '',
        t.matcap ? '#define USE_MATCAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + u : '',
        t.envMap ? '#define ' + h : '',
        t.envMap ? '#define ' + m : '',
        g ? '#define CUBEUV_TEXEL_WIDTH ' + g.texelWidth : '',
        g ? '#define CUBEUV_TEXEL_HEIGHT ' + g.texelHeight : '',
        g ? '#define CUBEUV_MAX_MIP ' + g.maxMip + '.0' : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropy ? '#define USE_ANISOTROPY' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoat ? '#define USE_CLEARCOAT' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.dispersion ? '#define USE_DISPERSION' : '',
        t.iridescence ? '#define USE_IRIDESCENCE' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaTest ? '#define USE_ALPHATEST' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.sheen ? '#define USE_SHEEN' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors || t.instancingColor || t.batchingColor
          ? '#define USE_COLOR'
          : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.gradientMap ? '#define USE_GRADIENTMAP' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + c : '',
        t.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        t.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
        t.decodeVideoTextureEmissive
          ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE'
          : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        t.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        t.toneMapping !== ya ? '#define TONE_MAPPING' : '',
        t.toneMapping !== ya ? xn.tonemapping_pars_fragment : '',
        t.toneMapping !== ya ? NH('toneMapping', t.toneMapping) : '',
        t.dithering ? '#define DITHERING' : '',
        t.opaque ? '#define OPAQUE' : '',
        xn.colorspace_pars_fragment,
        LH('linearToOutputTexel', t.outputColorSpace),
        DH(),
        t.useDepthPacking ? '#define DEPTH_PACKING ' + t.depthPacking : '',
        `
`,
      ].filter(sm).join(`
`))),
    (o = XS(o)),
    (o = JC(o, t)),
    (o = e2(o, t)),
    (a = XS(a)),
    (a = JC(a, t)),
    (a = e2(a, t)),
    (o = t2(o)),
    (a = t2(a)),
    t.isRawShaderMaterial !== !0 &&
      ((T = `#version 300 es
`),
      (w =
        [
          y,
          '#define attribute in',
          '#define varying out',
          '#define texture2D texture',
        ].join(`
`) +
        `
` +
        w),
      (x =
        [
          '#define varying in',
          t.glslVersion === US
            ? ''
            : 'layout(location = 0) out highp vec4 pc_fragColor;',
          t.glslVersion === US ? '' : '#define gl_FragColor pc_fragColor',
          '#define gl_FragDepthEXT gl_FragDepth',
          '#define texture2D texture',
          '#define textureCube texture',
          '#define texture2DProj textureProj',
          '#define texture2DLodEXT textureLod',
          '#define texture2DProjLodEXT textureProjLod',
          '#define textureCubeLodEXT textureLod',
          '#define texture2DGradEXT textureGrad',
          '#define texture2DProjGradEXT textureProjGrad',
          '#define textureCubeGradEXT textureGrad',
        ].join(`
`) +
        `
` +
        x))
  const A = T + w + o,
    P = T + x + a,
    D = ZC(r, r.VERTEX_SHADER, A),
    O = ZC(r, r.FRAGMENT_SHADER, P)
  r.attachShader(M, D),
    r.attachShader(M, O),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(M, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(M, 0, 'position'),
    r.linkProgram(M)
  function U(z) {
    if (n.debug.checkShaderErrors) {
      const $ = r.getProgramInfoLog(M).trim(),
        te = r.getShaderInfoLog(D).trim(),
        j = r.getShaderInfoLog(O).trim()
      let K = !0,
        J = !0
      if (r.getProgramParameter(M, r.LINK_STATUS) === !1)
        if (((K = !1), typeof n.debug.onShaderError == 'function'))
          n.debug.onShaderError(r, M, D, O)
        else {
          const ne = QC(r, D, 'vertex'),
            V = QC(r, O, 'fragment')
          console.error(
            'THREE.WebGLProgram: Shader Error ' +
              r.getError() +
              ' - VALIDATE_STATUS ' +
              r.getProgramParameter(M, r.VALIDATE_STATUS) +
              `

Material Name: ` +
              z.name +
              `
Material Type: ` +
              z.type +
              `

Program Info Log: ` +
              $ +
              `
` +
              ne +
              `
` +
              V,
          )
        }
      else
        $ !== ''
          ? console.warn('THREE.WebGLProgram: Program Info Log:', $)
          : (te === '' || j === '') && (J = !1)
      J &&
        (z.diagnostics = {
          runnable: K,
          programLog: $,
          vertexShader: { log: te, prefix: w },
          fragmentShader: { log: j, prefix: x },
        })
    }
    r.deleteShader(D), r.deleteShader(O), (F = new _y(r, M)), (N = FH(r, M))
  }
  let F
  this.getUniforms = function () {
    return F === void 0 && U(this), F
  }
  let N
  this.getAttributes = function () {
    return N === void 0 && U(this), N
  }
  let k = t.rendererExtensionParallelShaderCompile === !1
  return (
    (this.isReady = function () {
      return k === !1 && (k = r.getProgramParameter(M, CH)), k
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(M),
        (this.program = void 0)
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = PH++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = M),
    (this.vertexShader = D),
    (this.fragmentShader = O),
    this
  )
}
let YH = 0
class ZH {
  constructor() {
    ;(this.shaderCache = new Map()), (this.materialCache = new Map())
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e)
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    )
  }
  remove(e) {
    const t = this.materialCache.get(e)
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code)
    return this.materialCache.delete(e), this
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear()
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache
    let i = t.get(e)
    return i === void 0 && ((i = new Set()), t.set(e, i)), i
  }
  _getShaderStage(e) {
    const t = this.shaderCache
    let i = t.get(e)
    return i === void 0 && ((i = new KH(e)), t.set(e, i)), i
  }
}
class KH {
  constructor(e) {
    ;(this.id = YH++), (this.code = e), (this.usedTimes = 0)
  }
}
function QH(n, e, t, i, r, s, o) {
  const a = new cd(),
    c = new ZH(),
    u = new Set(),
    h = [],
    m = r.logarithmicDepthBuffer,
    g = r.vertexTextures
  let y = r.precision
  const _ = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite',
  }
  function M(N) {
    return u.add(N), N === 0 ? 'uv' : `uv${N}`
  }
  function w(N, k, z, $, te) {
    const j = $.fog,
      K = te.geometry,
      J = N.isMeshStandardMaterial ? $.environment : null,
      ne = (N.isMeshStandardMaterial ? t : e).get(N.envMap || J),
      V = ne && ne.mapping === Rh ? ne.image.height : null,
      Y = _[N.type]
    N.precision !== null &&
      ((y = r.getMaxPrecision(N.precision)),
      y !== N.precision &&
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          N.precision,
          'not supported, using',
          y,
          'instead.',
        ))
    const Q =
        K.morphAttributes.position ||
        K.morphAttributes.normal ||
        K.morphAttributes.color,
      q = Q !== void 0 ? Q.length : 0
    let oe = 0
    K.morphAttributes.position !== void 0 && (oe = 1),
      K.morphAttributes.normal !== void 0 && (oe = 2),
      K.morphAttributes.color !== void 0 && (oe = 3)
    let _e, he, Ce, Te
    if (Y) {
      const wn = jo[Y]
      ;(_e = wn.vertexShader), (he = wn.fragmentShader)
    } else
      (_e = N.vertexShader),
        (he = N.fragmentShader),
        c.update(N),
        (Ce = c.getVertexShaderID(N)),
        (Te = c.getFragmentShaderID(N))
    const Pe = n.getRenderTarget(),
      Be = n.state.buffers.depth.getReversed(),
      et = te.isInstancedMesh === !0,
      ft = te.isBatchedMesh === !0,
      Vt = !!N.map,
      je = !!N.matcap,
      $e = !!ne,
      se = !!N.aoMap,
      Rt = !!N.lightMap,
      Qe = !!N.bumpMap,
      _t = !!N.normalMap,
      rt = !!N.displacementMap,
      jt = !!N.emissiveMap,
      at = !!N.metalnessMap,
      ie = !!N.roughnessMap,
      Z = N.anisotropy > 0,
      Se = N.clearcoat > 0,
      Ue = N.dispersion > 0,
      Ge = N.iridescence > 0,
      ze = N.sheen > 0,
      Ct = N.transmission > 0,
      ct = Z && !!N.anisotropyMap,
      gt = Se && !!N.clearcoatMap,
      rn = Se && !!N.clearcoatNormalMap,
      Je = Se && !!N.clearcoatRoughnessMap,
      bt = Ge && !!N.iridescenceMap,
      Ut = Ge && !!N.iridescenceThicknessMap,
      It = ze && !!N.sheenColorMap,
      Mt = ze && !!N.sheenRoughnessMap,
      en = !!N.specularMap,
      Bt = !!N.specularColorMap,
      Kt = !!N.specularIntensityMap,
      ve = Ct && !!N.transmissionMap,
      Ie = Ct && !!N.thicknessMap,
      Le = !!N.gradientMap,
      Ve = !!N.alphaMap,
      vt = N.alphaTest > 0,
      ht = !!N.alphaHash,
      Qt = !!N.extensions
    let Un = ya
    N.toneMapped &&
      (Pe === null || Pe.isXRRenderTarget === !0) &&
      (Un = n.toneMapping)
    const si = {
      shaderID: Y,
      shaderType: N.type,
      shaderName: N.name,
      vertexShader: _e,
      fragmentShader: he,
      defines: N.defines,
      customVertexShaderID: Ce,
      customFragmentShaderID: Te,
      isRawShaderMaterial: N.isRawShaderMaterial === !0,
      glslVersion: N.glslVersion,
      precision: y,
      batching: ft,
      batchingColor: ft && te._colorsTexture !== null,
      instancing: et,
      instancingColor: et && te.instanceColor !== null,
      instancingMorph: et && te.morphTexture !== null,
      supportsVertexTextures: g,
      outputColorSpace:
        Pe === null
          ? n.outputColorSpace
          : Pe.isXRRenderTarget === !0
          ? Pe.texture.colorSpace
          : Aa,
      alphaToCoverage: !!N.alphaToCoverage,
      map: Vt,
      matcap: je,
      envMap: $e,
      envMapMode: $e && ne.mapping,
      envMapCubeUVHeight: V,
      aoMap: se,
      lightMap: Rt,
      bumpMap: Qe,
      normalMap: _t,
      displacementMap: g && rt,
      emissiveMap: jt,
      normalMapObjectSpace: _t && N.normalMapType === _L,
      normalMapTangentSpace: _t && N.normalMapType === kc,
      metalnessMap: at,
      roughnessMap: ie,
      anisotropy: Z,
      anisotropyMap: ct,
      clearcoat: Se,
      clearcoatMap: gt,
      clearcoatNormalMap: rn,
      clearcoatRoughnessMap: Je,
      dispersion: Ue,
      iridescence: Ge,
      iridescenceMap: bt,
      iridescenceThicknessMap: Ut,
      sheen: ze,
      sheenColorMap: It,
      sheenRoughnessMap: Mt,
      specularMap: en,
      specularColorMap: Bt,
      specularIntensityMap: Kt,
      transmission: Ct,
      transmissionMap: ve,
      thicknessMap: Ie,
      gradientMap: Le,
      opaque:
        N.transparent === !1 && N.blending === od && N.alphaToCoverage === !1,
      alphaMap: Ve,
      alphaTest: vt,
      alphaHash: ht,
      combine: N.combine,
      mapUv: Vt && M(N.map.channel),
      aoMapUv: se && M(N.aoMap.channel),
      lightMapUv: Rt && M(N.lightMap.channel),
      bumpMapUv: Qe && M(N.bumpMap.channel),
      normalMapUv: _t && M(N.normalMap.channel),
      displacementMapUv: rt && M(N.displacementMap.channel),
      emissiveMapUv: jt && M(N.emissiveMap.channel),
      metalnessMapUv: at && M(N.metalnessMap.channel),
      roughnessMapUv: ie && M(N.roughnessMap.channel),
      anisotropyMapUv: ct && M(N.anisotropyMap.channel),
      clearcoatMapUv: gt && M(N.clearcoatMap.channel),
      clearcoatNormalMapUv: rn && M(N.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Je && M(N.clearcoatRoughnessMap.channel),
      iridescenceMapUv: bt && M(N.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ut && M(N.iridescenceThicknessMap.channel),
      sheenColorMapUv: It && M(N.sheenColorMap.channel),
      sheenRoughnessMapUv: Mt && M(N.sheenRoughnessMap.channel),
      specularMapUv: en && M(N.specularMap.channel),
      specularColorMapUv: Bt && M(N.specularColorMap.channel),
      specularIntensityMapUv: Kt && M(N.specularIntensityMap.channel),
      transmissionMapUv: ve && M(N.transmissionMap.channel),
      thicknessMapUv: Ie && M(N.thicknessMap.channel),
      alphaMapUv: Ve && M(N.alphaMap.channel),
      vertexTangents: !!K.attributes.tangent && (_t || Z),
      vertexColors: N.vertexColors,
      vertexAlphas:
        N.vertexColors === !0 &&
        !!K.attributes.color &&
        K.attributes.color.itemSize === 4,
      pointsUvs: te.isPoints === !0 && !!K.attributes.uv && (Vt || Ve),
      fog: !!j,
      useFog: N.fog === !0,
      fogExp2: !!j && j.isFogExp2,
      flatShading: N.flatShading === !0,
      sizeAttenuation: N.sizeAttenuation === !0,
      logarithmicDepthBuffer: m,
      reverseDepthBuffer: Be,
      skinning: te.isSkinnedMesh === !0,
      morphTargets: K.morphAttributes.position !== void 0,
      morphNormals: K.morphAttributes.normal !== void 0,
      morphColors: K.morphAttributes.color !== void 0,
      morphTargetsCount: q,
      morphTextureStride: oe,
      numDirLights: k.directional.length,
      numPointLights: k.point.length,
      numSpotLights: k.spot.length,
      numSpotLightMaps: k.spotLightMap.length,
      numRectAreaLights: k.rectArea.length,
      numHemiLights: k.hemi.length,
      numDirLightShadows: k.directionalShadowMap.length,
      numPointLightShadows: k.pointShadowMap.length,
      numSpotLightShadows: k.spotShadowMap.length,
      numSpotLightShadowsWithMaps: k.numSpotLightShadowsWithMaps,
      numLightProbes: k.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: N.dithering,
      shadowMapEnabled: n.shadowMap.enabled && z.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: Un,
      decodeVideoTexture:
        Vt &&
        N.map.isVideoTexture === !0 &&
        Cn.getTransfer(N.map.colorSpace) === zn,
      decodeVideoTextureEmissive:
        jt &&
        N.emissiveMap.isVideoTexture === !0 &&
        Cn.getTransfer(N.emissiveMap.colorSpace) === zn,
      premultipliedAlpha: N.premultipliedAlpha,
      doubleSided: N.side === oo,
      flipSided: N.side === Qr,
      useDepthPacking: N.depthPacking >= 0,
      depthPacking: N.depthPacking || 0,
      index0AttributeName: N.index0AttributeName,
      extensionClipCullDistance:
        Qt &&
        N.extensions.clipCullDistance === !0 &&
        i.has('WEBGL_clip_cull_distance'),
      extensionMultiDraw:
        ((Qt && N.extensions.multiDraw === !0) || ft) &&
        i.has('WEBGL_multi_draw'),
      rendererExtensionParallelShaderCompile: i.has(
        'KHR_parallel_shader_compile',
      ),
      customProgramCacheKey: N.customProgramCacheKey(),
    }
    return (
      (si.vertexUv1s = u.has(1)),
      (si.vertexUv2s = u.has(2)),
      (si.vertexUv3s = u.has(3)),
      u.clear(),
      si
    )
  }
  function x(N) {
    const k = []
    if (
      (N.shaderID
        ? k.push(N.shaderID)
        : (k.push(N.customVertexShaderID), k.push(N.customFragmentShaderID)),
      N.defines !== void 0)
    )
      for (const z in N.defines) k.push(z), k.push(N.defines[z])
    return (
      N.isRawShaderMaterial === !1 &&
        (T(k, N), A(k, N), k.push(n.outputColorSpace)),
      k.push(N.customProgramCacheKey),
      k.join()
    )
  }
  function T(N, k) {
    N.push(k.precision),
      N.push(k.outputColorSpace),
      N.push(k.envMapMode),
      N.push(k.envMapCubeUVHeight),
      N.push(k.mapUv),
      N.push(k.alphaMapUv),
      N.push(k.lightMapUv),
      N.push(k.aoMapUv),
      N.push(k.bumpMapUv),
      N.push(k.normalMapUv),
      N.push(k.displacementMapUv),
      N.push(k.emissiveMapUv),
      N.push(k.metalnessMapUv),
      N.push(k.roughnessMapUv),
      N.push(k.anisotropyMapUv),
      N.push(k.clearcoatMapUv),
      N.push(k.clearcoatNormalMapUv),
      N.push(k.clearcoatRoughnessMapUv),
      N.push(k.iridescenceMapUv),
      N.push(k.iridescenceThicknessMapUv),
      N.push(k.sheenColorMapUv),
      N.push(k.sheenRoughnessMapUv),
      N.push(k.specularMapUv),
      N.push(k.specularColorMapUv),
      N.push(k.specularIntensityMapUv),
      N.push(k.transmissionMapUv),
      N.push(k.thicknessMapUv),
      N.push(k.combine),
      N.push(k.fogExp2),
      N.push(k.sizeAttenuation),
      N.push(k.morphTargetsCount),
      N.push(k.morphAttributeCount),
      N.push(k.numDirLights),
      N.push(k.numPointLights),
      N.push(k.numSpotLights),
      N.push(k.numSpotLightMaps),
      N.push(k.numHemiLights),
      N.push(k.numRectAreaLights),
      N.push(k.numDirLightShadows),
      N.push(k.numPointLightShadows),
      N.push(k.numSpotLightShadows),
      N.push(k.numSpotLightShadowsWithMaps),
      N.push(k.numLightProbes),
      N.push(k.shadowMapType),
      N.push(k.toneMapping),
      N.push(k.numClippingPlanes),
      N.push(k.numClipIntersection),
      N.push(k.depthPacking)
  }
  function A(N, k) {
    a.disableAll(),
      k.supportsVertexTextures && a.enable(0),
      k.instancing && a.enable(1),
      k.instancingColor && a.enable(2),
      k.instancingMorph && a.enable(3),
      k.matcap && a.enable(4),
      k.envMap && a.enable(5),
      k.normalMapObjectSpace && a.enable(6),
      k.normalMapTangentSpace && a.enable(7),
      k.clearcoat && a.enable(8),
      k.iridescence && a.enable(9),
      k.alphaTest && a.enable(10),
      k.vertexColors && a.enable(11),
      k.vertexAlphas && a.enable(12),
      k.vertexUv1s && a.enable(13),
      k.vertexUv2s && a.enable(14),
      k.vertexUv3s && a.enable(15),
      k.vertexTangents && a.enable(16),
      k.anisotropy && a.enable(17),
      k.alphaHash && a.enable(18),
      k.batching && a.enable(19),
      k.dispersion && a.enable(20),
      k.batchingColor && a.enable(21),
      N.push(a.mask),
      a.disableAll(),
      k.fog && a.enable(0),
      k.useFog && a.enable(1),
      k.flatShading && a.enable(2),
      k.logarithmicDepthBuffer && a.enable(3),
      k.reverseDepthBuffer && a.enable(4),
      k.skinning && a.enable(5),
      k.morphTargets && a.enable(6),
      k.morphNormals && a.enable(7),
      k.morphColors && a.enable(8),
      k.premultipliedAlpha && a.enable(9),
      k.shadowMapEnabled && a.enable(10),
      k.doubleSided && a.enable(11),
      k.flipSided && a.enable(12),
      k.useDepthPacking && a.enable(13),
      k.dithering && a.enable(14),
      k.transmission && a.enable(15),
      k.sheen && a.enable(16),
      k.opaque && a.enable(17),
      k.pointsUvs && a.enable(18),
      k.decodeVideoTexture && a.enable(19),
      k.decodeVideoTextureEmissive && a.enable(20),
      k.alphaToCoverage && a.enable(21),
      N.push(a.mask)
  }
  function P(N) {
    const k = _[N.type]
    let z
    if (k) {
      const $ = jo[k]
      z = NL.clone($.uniforms)
    } else z = N.uniforms
    return z
  }
  function D(N, k) {
    let z
    for (let $ = 0, te = h.length; $ < te; $++) {
      const j = h[$]
      if (j.cacheKey === k) {
        ;(z = j), ++z.usedTimes
        break
      }
    }
    return z === void 0 && ((z = new qH(n, k, N, s)), h.push(z)), z
  }
  function O(N) {
    if (--N.usedTimes === 0) {
      const k = h.indexOf(N)
      ;(h[k] = h[h.length - 1]), h.pop(), N.destroy()
    }
  }
  function U(N) {
    c.remove(N)
  }
  function F() {
    c.dispose()
  }
  return {
    getParameters: w,
    getProgramCacheKey: x,
    getUniforms: P,
    acquireProgram: D,
    releaseProgram: O,
    releaseShaderCache: U,
    programs: h,
    dispose: F,
  }
}
function JH() {
  let n = new WeakMap()
  function e(o) {
    return n.has(o)
  }
  function t(o) {
    let a = n.get(o)
    return a === void 0 && ((a = {}), n.set(o, a)), a
  }
  function i(o) {
    n.delete(o)
  }
  function r(o, a, c) {
    n.get(o)[a] = c
  }
  function s() {
    n = new WeakMap()
  }
  return { has: e, get: t, remove: i, update: r, dispose: s }
}
function eG(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id
}
function i2(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id
}
function r2() {
  const n = []
  let e = 0
  const t = [],
    i = [],
    r = []
  function s() {
    ;(e = 0), (t.length = 0), (i.length = 0), (r.length = 0)
  }
  function o(m, g, y, _, M, w) {
    let x = n[e]
    return (
      x === void 0
        ? ((x = {
            id: m.id,
            object: m,
            geometry: g,
            material: y,
            groupOrder: _,
            renderOrder: m.renderOrder,
            z: M,
            group: w,
          }),
          (n[e] = x))
        : ((x.id = m.id),
          (x.object = m),
          (x.geometry = g),
          (x.material = y),
          (x.groupOrder = _),
          (x.renderOrder = m.renderOrder),
          (x.z = M),
          (x.group = w)),
      e++,
      x
    )
  }
  function a(m, g, y, _, M, w) {
    const x = o(m, g, y, _, M, w)
    y.transmission > 0
      ? i.push(x)
      : y.transparent === !0
      ? r.push(x)
      : t.push(x)
  }
  function c(m, g, y, _, M, w) {
    const x = o(m, g, y, _, M, w)
    y.transmission > 0
      ? i.unshift(x)
      : y.transparent === !0
      ? r.unshift(x)
      : t.unshift(x)
  }
  function u(m, g) {
    t.length > 1 && t.sort(m || eG),
      i.length > 1 && i.sort(g || i2),
      r.length > 1 && r.sort(g || i2)
  }
  function h() {
    for (let m = e, g = n.length; m < g; m++) {
      const y = n[m]
      if (y.id === null) break
      ;(y.id = null),
        (y.object = null),
        (y.geometry = null),
        (y.material = null),
        (y.group = null)
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: c,
    finish: h,
    sort: u,
  }
}
function tG() {
  let n = new WeakMap()
  function e(i, r) {
    const s = n.get(i)
    let o
    return (
      s === void 0
        ? ((o = new r2()), n.set(i, [o]))
        : r >= s.length
        ? ((o = new r2()), s.push(o))
        : (o = s[r]),
      o
    )
  }
  function t() {
    n = new WeakMap()
  }
  return { get: e, dispose: t }
}
function nG() {
  const n = {}
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id]
      let t
      switch (e.type) {
        case 'DirectionalLight':
          t = { direction: new re(), color: new Tt() }
          break
        case 'SpotLight':
          t = {
            position: new re(),
            direction: new re(),
            color: new Tt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          }
          break
        case 'PointLight':
          t = { position: new re(), color: new Tt(), distance: 0, decay: 0 }
          break
        case 'HemisphereLight':
          t = { direction: new re(), skyColor: new Tt(), groundColor: new Tt() }
          break
        case 'RectAreaLight':
          t = {
            color: new Tt(),
            position: new re(),
            halfWidth: new re(),
            halfHeight: new re(),
          }
          break
      }
      return (n[e.id] = t), t
    },
  }
}
function iG() {
  const n = {}
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id]
      let t
      switch (e.type) {
        case 'DirectionalLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe(),
          }
          break
        case 'SpotLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe(),
          }
          break
        case 'PointLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          }
          break
      }
      return (n[e.id] = t), t
    },
  }
}
let rG = 0
function sG(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  )
}
function oG(n) {
  const e = new nG(),
    t = iG(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    }
  for (let u = 0; u < 9; u++) i.probe.push(new re())
  const r = new re(),
    s = new Jt(),
    o = new Jt()
  function a(u) {
    let h = 0,
      m = 0,
      g = 0
    for (let N = 0; N < 9; N++) i.probe[N].set(0, 0, 0)
    let y = 0,
      _ = 0,
      M = 0,
      w = 0,
      x = 0,
      T = 0,
      A = 0,
      P = 0,
      D = 0,
      O = 0,
      U = 0
    u.sort(sG)
    for (let N = 0, k = u.length; N < k; N++) {
      const z = u[N],
        $ = z.color,
        te = z.intensity,
        j = z.distance,
        K = z.shadow && z.shadow.map ? z.shadow.map.texture : null
      if (z.isAmbientLight) (h += $.r * te), (m += $.g * te), (g += $.b * te)
      else if (z.isLightProbe) {
        for (let J = 0; J < 9; J++)
          i.probe[J].addScaledVector(z.sh.coefficients[J], te)
        U++
      } else if (z.isDirectionalLight) {
        const J = e.get(z)
        if ((J.color.copy(z.color).multiplyScalar(z.intensity), z.castShadow)) {
          const ne = z.shadow,
            V = t.get(z)
          ;(V.shadowIntensity = ne.intensity),
            (V.shadowBias = ne.bias),
            (V.shadowNormalBias = ne.normalBias),
            (V.shadowRadius = ne.radius),
            (V.shadowMapSize = ne.mapSize),
            (i.directionalShadow[y] = V),
            (i.directionalShadowMap[y] = K),
            (i.directionalShadowMatrix[y] = z.shadow.matrix),
            T++
        }
        ;(i.directional[y] = J), y++
      } else if (z.isSpotLight) {
        const J = e.get(z)
        J.position.setFromMatrixPosition(z.matrixWorld),
          J.color.copy($).multiplyScalar(te),
          (J.distance = j),
          (J.coneCos = Math.cos(z.angle)),
          (J.penumbraCos = Math.cos(z.angle * (1 - z.penumbra))),
          (J.decay = z.decay),
          (i.spot[M] = J)
        const ne = z.shadow
        if (
          (z.map &&
            ((i.spotLightMap[D] = z.map),
            D++,
            ne.updateMatrices(z),
            z.castShadow && O++),
          (i.spotLightMatrix[M] = ne.matrix),
          z.castShadow)
        ) {
          const V = t.get(z)
          ;(V.shadowIntensity = ne.intensity),
            (V.shadowBias = ne.bias),
            (V.shadowNormalBias = ne.normalBias),
            (V.shadowRadius = ne.radius),
            (V.shadowMapSize = ne.mapSize),
            (i.spotShadow[M] = V),
            (i.spotShadowMap[M] = K),
            P++
        }
        M++
      } else if (z.isRectAreaLight) {
        const J = e.get(z)
        J.color.copy($).multiplyScalar(te),
          J.halfWidth.set(z.width * 0.5, 0, 0),
          J.halfHeight.set(0, z.height * 0.5, 0),
          (i.rectArea[w] = J),
          w++
      } else if (z.isPointLight) {
        const J = e.get(z)
        if (
          (J.color.copy(z.color).multiplyScalar(z.intensity),
          (J.distance = z.distance),
          (J.decay = z.decay),
          z.castShadow)
        ) {
          const ne = z.shadow,
            V = t.get(z)
          ;(V.shadowIntensity = ne.intensity),
            (V.shadowBias = ne.bias),
            (V.shadowNormalBias = ne.normalBias),
            (V.shadowRadius = ne.radius),
            (V.shadowMapSize = ne.mapSize),
            (V.shadowCameraNear = ne.camera.near),
            (V.shadowCameraFar = ne.camera.far),
            (i.pointShadow[_] = V),
            (i.pointShadowMap[_] = K),
            (i.pointShadowMatrix[_] = z.shadow.matrix),
            A++
        }
        ;(i.point[_] = J), _++
      } else if (z.isHemisphereLight) {
        const J = e.get(z)
        J.skyColor.copy(z.color).multiplyScalar(te),
          J.groundColor.copy(z.groundColor).multiplyScalar(te),
          (i.hemi[x] = J),
          x++
      }
    }
    w > 0 &&
      (n.has('OES_texture_float_linear') === !0
        ? ((i.rectAreaLTC1 = xt.LTC_FLOAT_1), (i.rectAreaLTC2 = xt.LTC_FLOAT_2))
        : ((i.rectAreaLTC1 = xt.LTC_HALF_1), (i.rectAreaLTC2 = xt.LTC_HALF_2))),
      (i.ambient[0] = h),
      (i.ambient[1] = m),
      (i.ambient[2] = g)
    const F = i.hash
    ;(F.directionalLength !== y ||
      F.pointLength !== _ ||
      F.spotLength !== M ||
      F.rectAreaLength !== w ||
      F.hemiLength !== x ||
      F.numDirectionalShadows !== T ||
      F.numPointShadows !== A ||
      F.numSpotShadows !== P ||
      F.numSpotMaps !== D ||
      F.numLightProbes !== U) &&
      ((i.directional.length = y),
      (i.spot.length = M),
      (i.rectArea.length = w),
      (i.point.length = _),
      (i.hemi.length = x),
      (i.directionalShadow.length = T),
      (i.directionalShadowMap.length = T),
      (i.pointShadow.length = A),
      (i.pointShadowMap.length = A),
      (i.spotShadow.length = P),
      (i.spotShadowMap.length = P),
      (i.directionalShadowMatrix.length = T),
      (i.pointShadowMatrix.length = A),
      (i.spotLightMatrix.length = P + D - O),
      (i.spotLightMap.length = D),
      (i.numSpotLightShadowsWithMaps = O),
      (i.numLightProbes = U),
      (F.directionalLength = y),
      (F.pointLength = _),
      (F.spotLength = M),
      (F.rectAreaLength = w),
      (F.hemiLength = x),
      (F.numDirectionalShadows = T),
      (F.numPointShadows = A),
      (F.numSpotShadows = P),
      (F.numSpotMaps = D),
      (F.numLightProbes = U),
      (i.version = rG++))
  }
  function c(u, h) {
    let m = 0,
      g = 0,
      y = 0,
      _ = 0,
      M = 0
    const w = h.matrixWorldInverse
    for (let x = 0, T = u.length; x < T; x++) {
      const A = u[x]
      if (A.isDirectionalLight) {
        const P = i.directional[m]
        P.direction.setFromMatrixPosition(A.matrixWorld),
          r.setFromMatrixPosition(A.target.matrixWorld),
          P.direction.sub(r),
          P.direction.transformDirection(w),
          m++
      } else if (A.isSpotLight) {
        const P = i.spot[y]
        P.position.setFromMatrixPosition(A.matrixWorld),
          P.position.applyMatrix4(w),
          P.direction.setFromMatrixPosition(A.matrixWorld),
          r.setFromMatrixPosition(A.target.matrixWorld),
          P.direction.sub(r),
          P.direction.transformDirection(w),
          y++
      } else if (A.isRectAreaLight) {
        const P = i.rectArea[_]
        P.position.setFromMatrixPosition(A.matrixWorld),
          P.position.applyMatrix4(w),
          o.identity(),
          s.copy(A.matrixWorld),
          s.premultiply(w),
          o.extractRotation(s),
          P.halfWidth.set(A.width * 0.5, 0, 0),
          P.halfHeight.set(0, A.height * 0.5, 0),
          P.halfWidth.applyMatrix4(o),
          P.halfHeight.applyMatrix4(o),
          _++
      } else if (A.isPointLight) {
        const P = i.point[g]
        P.position.setFromMatrixPosition(A.matrixWorld),
          P.position.applyMatrix4(w),
          g++
      } else if (A.isHemisphereLight) {
        const P = i.hemi[M]
        P.direction.setFromMatrixPosition(A.matrixWorld),
          P.direction.transformDirection(w),
          M++
      }
    }
  }
  return { setup: a, setupView: c, state: i }
}
function s2(n) {
  const e = new oG(n),
    t = [],
    i = []
  function r(h) {
    ;(u.camera = h), (t.length = 0), (i.length = 0)
  }
  function s(h) {
    t.push(h)
  }
  function o(h) {
    i.push(h)
  }
  function a() {
    e.setup(t)
  }
  function c(h) {
    e.setupView(t, h)
  }
  const u = {
    lightsArray: t,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  }
  return {
    init: r,
    state: u,
    setupLights: a,
    setupLightsView: c,
    pushLight: s,
    pushShadow: o,
  }
}
function aG(n) {
  let e = new WeakMap()
  function t(r, s = 0) {
    const o = e.get(r)
    let a
    return (
      o === void 0
        ? ((a = new s2(n)), e.set(r, [a]))
        : s >= o.length
        ? ((a = new s2(n)), o.push(a))
        : (a = o[s]),
      a
    )
  }
  function i() {
    e = new WeakMap()
  }
  return { get: t, dispose: i }
}
const lG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  cG = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`
function uG(n, e, t) {
  let i = new Ng()
  const r = new qe(),
    s = new qe(),
    o = new In(),
    a = new ME({ depthPacking: xL }),
    c = new EE(),
    u = {},
    h = t.maxTextureSize,
    m = { [Tl]: Qr, [Qr]: Tl, [oo]: oo },
    g = new ws({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new qe() },
        radius: { value: 4 },
      },
      vertexShader: lG,
      fragmentShader: cG,
    }),
    y = g.clone()
  y.defines.HORIZONTAL_PASS = 1
  const _ = new _n()
  _.setAttribute(
    'position',
    new qn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
  )
  const M = new vi(_, g),
    w = this
  ;(this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = jx)
  let x = this.type
  this.render = function (O, U, F) {
    if (
      w.enabled === !1 ||
      (w.autoUpdate === !1 && w.needsUpdate === !1) ||
      O.length === 0
    )
      return
    const N = n.getRenderTarget(),
      k = n.getActiveCubeFace(),
      z = n.getActiveMipmapLevel(),
      $ = n.state
    $.setBlending(va),
      $.buffers.color.setClear(1, 1, 1, 1),
      $.buffers.depth.setTest(!0),
      $.setScissorTest(!1)
    const te = x !== Vo && this.type === Vo,
      j = x === Vo && this.type !== Vo
    for (let K = 0, J = O.length; K < J; K++) {
      const ne = O[K],
        V = ne.shadow
      if (V === void 0) {
        console.warn('THREE.WebGLShadowMap:', ne, 'has no shadow.')
        continue
      }
      if (V.autoUpdate === !1 && V.needsUpdate === !1) continue
      r.copy(V.mapSize)
      const Y = V.getFrameExtents()
      if (
        (r.multiply(Y),
        s.copy(V.mapSize),
        (r.x > h || r.y > h) &&
          (r.x > h &&
            ((s.x = Math.floor(h / Y.x)),
            (r.x = s.x * Y.x),
            (V.mapSize.x = s.x)),
          r.y > h &&
            ((s.y = Math.floor(h / Y.y)),
            (r.y = s.y * Y.y),
            (V.mapSize.y = s.y))),
        V.map === null || te === !0 || j === !0)
      ) {
        const q = this.type !== Vo ? { minFilter: yr, magFilter: yr } : {}
        V.map !== null && V.map.dispose(),
          (V.map = new uo(r.x, r.y, q)),
          (V.map.texture.name = ne.name + '.shadowMap'),
          V.camera.updateProjectionMatrix()
      }
      n.setRenderTarget(V.map), n.clear()
      const Q = V.getViewportCount()
      for (let q = 0; q < Q; q++) {
        const oe = V.getViewport(q)
        o.set(s.x * oe.x, s.y * oe.y, s.x * oe.z, s.y * oe.w),
          $.viewport(o),
          V.updateMatrices(ne, q),
          (i = V.getFrustum()),
          P(U, F, V.camera, ne, this.type)
      }
      V.isPointLightShadow !== !0 && this.type === Vo && T(V, F),
        (V.needsUpdate = !1)
    }
    ;(x = this.type), (w.needsUpdate = !1), n.setRenderTarget(N, k, z)
  }
  function T(O, U) {
    const F = e.update(M)
    g.defines.VSM_SAMPLES !== O.blurSamples &&
      ((g.defines.VSM_SAMPLES = O.blurSamples),
      (y.defines.VSM_SAMPLES = O.blurSamples),
      (g.needsUpdate = !0),
      (y.needsUpdate = !0)),
      O.mapPass === null && (O.mapPass = new uo(r.x, r.y)),
      (g.uniforms.shadow_pass.value = O.map.texture),
      (g.uniforms.resolution.value = O.mapSize),
      (g.uniforms.radius.value = O.radius),
      n.setRenderTarget(O.mapPass),
      n.clear(),
      n.renderBufferDirect(U, null, F, g, M, null),
      (y.uniforms.shadow_pass.value = O.mapPass.texture),
      (y.uniforms.resolution.value = O.mapSize),
      (y.uniforms.radius.value = O.radius),
      n.setRenderTarget(O.map),
      n.clear(),
      n.renderBufferDirect(U, null, F, y, M, null)
  }
  function A(O, U, F, N) {
    let k = null
    const z =
      F.isPointLight === !0 ? O.customDistanceMaterial : O.customDepthMaterial
    if (z !== void 0) k = z
    else if (
      ((k = F.isPointLight === !0 ? c : a),
      (n.localClippingEnabled &&
        U.clipShadows === !0 &&
        Array.isArray(U.clippingPlanes) &&
        U.clippingPlanes.length !== 0) ||
        (U.displacementMap && U.displacementScale !== 0) ||
        (U.alphaMap && U.alphaTest > 0) ||
        (U.map && U.alphaTest > 0))
    ) {
      const $ = k.uuid,
        te = U.uuid
      let j = u[$]
      j === void 0 && ((j = {}), (u[$] = j))
      let K = j[te]
      K === void 0 &&
        ((K = k.clone()), (j[te] = K), U.addEventListener('dispose', D)),
        (k = K)
    }
    if (
      ((k.visible = U.visible),
      (k.wireframe = U.wireframe),
      N === Vo
        ? (k.side = U.shadowSide !== null ? U.shadowSide : U.side)
        : (k.side = U.shadowSide !== null ? U.shadowSide : m[U.side]),
      (k.alphaMap = U.alphaMap),
      (k.alphaTest = U.alphaTest),
      (k.map = U.map),
      (k.clipShadows = U.clipShadows),
      (k.clippingPlanes = U.clippingPlanes),
      (k.clipIntersection = U.clipIntersection),
      (k.displacementMap = U.displacementMap),
      (k.displacementScale = U.displacementScale),
      (k.displacementBias = U.displacementBias),
      (k.wireframeLinewidth = U.wireframeLinewidth),
      (k.linewidth = U.linewidth),
      F.isPointLight === !0 && k.isMeshDistanceMaterial === !0)
    ) {
      const $ = n.properties.get(k)
      $.light = F
    }
    return k
  }
  function P(O, U, F, N, k) {
    if (O.visible === !1) return
    if (
      O.layers.test(U.layers) &&
      (O.isMesh || O.isLine || O.isPoints) &&
      (O.castShadow || (O.receiveShadow && k === Vo)) &&
      (!O.frustumCulled || i.intersectsObject(O))
    ) {
      O.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse, O.matrixWorld)
      const te = e.update(O),
        j = O.material
      if (Array.isArray(j)) {
        const K = te.groups
        for (let J = 0, ne = K.length; J < ne; J++) {
          const V = K[J],
            Y = j[V.materialIndex]
          if (Y && Y.visible) {
            const Q = A(O, Y, N, k)
            O.onBeforeShadow(n, O, U, F, te, Q, V),
              n.renderBufferDirect(F, null, te, Q, O, V),
              O.onAfterShadow(n, O, U, F, te, Q, V)
          }
        }
      } else if (j.visible) {
        const K = A(O, j, N, k)
        O.onBeforeShadow(n, O, U, F, te, K, null),
          n.renderBufferDirect(F, null, te, K, O, null),
          O.onAfterShadow(n, O, U, F, te, K, null)
      }
    }
    const $ = O.children
    for (let te = 0, j = $.length; te < j; te++) P($[te], U, F, N, k)
  }
  function D(O) {
    O.target.removeEventListener('dispose', D)
    for (const F in u) {
      const N = u[F],
        k = O.target.uuid
      k in N && (N[k].dispose(), delete N[k])
    }
  }
}
const dG = {
  [Dy]: Oy,
  [ky]: By,
  [Fy]: zy,
  [hd]: Uy,
  [Oy]: Dy,
  [By]: ky,
  [zy]: Fy,
  [Uy]: hd,
}
function fG(n, e) {
  function t() {
    let ve = !1
    const Ie = new In()
    let Le = null
    const Ve = new In(0, 0, 0, 0)
    return {
      setMask: function (vt) {
        Le !== vt && !ve && (n.colorMask(vt, vt, vt, vt), (Le = vt))
      },
      setLocked: function (vt) {
        ve = vt
      },
      setClear: function (vt, ht, Qt, Un, si) {
        si === !0 && ((vt *= Un), (ht *= Un), (Qt *= Un)),
          Ie.set(vt, ht, Qt, Un),
          Ve.equals(Ie) === !1 && (n.clearColor(vt, ht, Qt, Un), Ve.copy(Ie))
      },
      reset: function () {
        ;(ve = !1), (Le = null), Ve.set(-1, 0, 0, 0)
      },
    }
  }
  function i() {
    let ve = !1,
      Ie = !1,
      Le = null,
      Ve = null,
      vt = null
    return {
      setReversed: function (ht) {
        if (Ie !== ht) {
          const Qt = e.get('EXT_clip_control')
          Ie
            ? Qt.clipControlEXT(Qt.LOWER_LEFT_EXT, Qt.ZERO_TO_ONE_EXT)
            : Qt.clipControlEXT(Qt.LOWER_LEFT_EXT, Qt.NEGATIVE_ONE_TO_ONE_EXT)
          const Un = vt
          ;(vt = null), this.setClear(Un)
        }
        Ie = ht
      },
      getReversed: function () {
        return Ie
      },
      setTest: function (ht) {
        ht ? Pe(n.DEPTH_TEST) : Be(n.DEPTH_TEST)
      },
      setMask: function (ht) {
        Le !== ht && !ve && (n.depthMask(ht), (Le = ht))
      },
      setFunc: function (ht) {
        if ((Ie && (ht = dG[ht]), Ve !== ht)) {
          switch (ht) {
            case Dy:
              n.depthFunc(n.NEVER)
              break
            case Oy:
              n.depthFunc(n.ALWAYS)
              break
            case ky:
              n.depthFunc(n.LESS)
              break
            case hd:
              n.depthFunc(n.LEQUAL)
              break
            case Fy:
              n.depthFunc(n.EQUAL)
              break
            case Uy:
              n.depthFunc(n.GEQUAL)
              break
            case By:
              n.depthFunc(n.GREATER)
              break
            case zy:
              n.depthFunc(n.NOTEQUAL)
              break
            default:
              n.depthFunc(n.LEQUAL)
          }
          Ve = ht
        }
      },
      setLocked: function (ht) {
        ve = ht
      },
      setClear: function (ht) {
        vt !== ht && (Ie && (ht = 1 - ht), n.clearDepth(ht), (vt = ht))
      },
      reset: function () {
        ;(ve = !1), (Le = null), (Ve = null), (vt = null), (Ie = !1)
      },
    }
  }
  function r() {
    let ve = !1,
      Ie = null,
      Le = null,
      Ve = null,
      vt = null,
      ht = null,
      Qt = null,
      Un = null,
      si = null
    return {
      setTest: function (wn) {
        ve || (wn ? Pe(n.STENCIL_TEST) : Be(n.STENCIL_TEST))
      },
      setMask: function (wn) {
        Ie !== wn && !ve && (n.stencilMask(wn), (Ie = wn))
      },
      setFunc: function (wn, zi, Vi) {
        ;(Le !== wn || Ve !== zi || vt !== Vi) &&
          (n.stencilFunc(wn, zi, Vi), (Le = wn), (Ve = zi), (vt = Vi))
      },
      setOp: function (wn, zi, Vi) {
        ;(ht !== wn || Qt !== zi || Un !== Vi) &&
          (n.stencilOp(wn, zi, Vi), (ht = wn), (Qt = zi), (Un = Vi))
      },
      setLocked: function (wn) {
        ve = wn
      },
      setClear: function (wn) {
        si !== wn && (n.clearStencil(wn), (si = wn))
      },
      reset: function () {
        ;(ve = !1),
          (Ie = null),
          (Le = null),
          (Ve = null),
          (vt = null),
          (ht = null),
          (Qt = null),
          (Un = null),
          (si = null)
      },
    }
  }
  const s = new t(),
    o = new i(),
    a = new r(),
    c = new WeakMap(),
    u = new WeakMap()
  let h = {},
    m = {},
    g = new WeakMap(),
    y = [],
    _ = null,
    M = !1,
    w = null,
    x = null,
    T = null,
    A = null,
    P = null,
    D = null,
    O = null,
    U = new Tt(0, 0, 0),
    F = 0,
    N = !1,
    k = null,
    z = null,
    $ = null,
    te = null,
    j = null
  const K = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
  let J = !1,
    ne = 0
  const V = n.getParameter(n.VERSION)
  V.indexOf('WebGL') !== -1
    ? ((ne = parseFloat(/^WebGL (\d)/.exec(V)[1])), (J = ne >= 1))
    : V.indexOf('OpenGL ES') !== -1 &&
      ((ne = parseFloat(/^OpenGL ES (\d)/.exec(V)[1])), (J = ne >= 2))
  let Y = null,
    Q = {}
  const q = n.getParameter(n.SCISSOR_BOX),
    oe = n.getParameter(n.VIEWPORT),
    _e = new In().fromArray(q),
    he = new In().fromArray(oe)
  function Ce(ve, Ie, Le, Ve) {
    const vt = new Uint8Array(4),
      ht = n.createTexture()
    n.bindTexture(ve, ht),
      n.texParameteri(ve, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(ve, n.TEXTURE_MAG_FILTER, n.NEAREST)
    for (let Qt = 0; Qt < Le; Qt++)
      ve === n.TEXTURE_3D || ve === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(Ie, 0, n.RGBA, 1, 1, Ve, 0, n.RGBA, n.UNSIGNED_BYTE, vt)
        : n.texImage2D(Ie + Qt, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, vt)
    return ht
  }
  const Te = {}
  ;(Te[n.TEXTURE_2D] = Ce(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (Te[n.TEXTURE_CUBE_MAP] = Ce(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6,
    )),
    (Te[n.TEXTURE_2D_ARRAY] = Ce(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (Te[n.TEXTURE_3D] = Ce(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    Pe(n.DEPTH_TEST),
    o.setFunc(hd),
    Qe(!1),
    _t(IS),
    Pe(n.CULL_FACE),
    se(va)
  function Pe(ve) {
    h[ve] !== !0 && (n.enable(ve), (h[ve] = !0))
  }
  function Be(ve) {
    h[ve] !== !1 && (n.disable(ve), (h[ve] = !1))
  }
  function et(ve, Ie) {
    return m[ve] !== Ie
      ? (n.bindFramebuffer(ve, Ie),
        (m[ve] = Ie),
        ve === n.DRAW_FRAMEBUFFER && (m[n.FRAMEBUFFER] = Ie),
        ve === n.FRAMEBUFFER && (m[n.DRAW_FRAMEBUFFER] = Ie),
        !0)
      : !1
  }
  function ft(ve, Ie) {
    let Le = y,
      Ve = !1
    if (ve) {
      ;(Le = g.get(Ie)), Le === void 0 && ((Le = []), g.set(Ie, Le))
      const vt = ve.textures
      if (Le.length !== vt.length || Le[0] !== n.COLOR_ATTACHMENT0) {
        for (let ht = 0, Qt = vt.length; ht < Qt; ht++)
          Le[ht] = n.COLOR_ATTACHMENT0 + ht
        ;(Le.length = vt.length), (Ve = !0)
      }
    } else Le[0] !== n.BACK && ((Le[0] = n.BACK), (Ve = !0))
    Ve && n.drawBuffers(Le)
  }
  function Vt(ve) {
    return _ !== ve ? (n.useProgram(ve), (_ = ve), !0) : !1
  }
  const je = {
    [Sc]: n.FUNC_ADD,
    [HI]: n.FUNC_SUBTRACT,
    [GI]: n.FUNC_REVERSE_SUBTRACT,
  }
  ;(je[WI] = n.MIN), (je[$I] = n.MAX)
  const $e = {
    [XI]: n.ZERO,
    [qI]: n.ONE,
    [YI]: n.SRC_COLOR,
    [Ly]: n.SRC_ALPHA,
    [tL]: n.SRC_ALPHA_SATURATE,
    [JI]: n.DST_COLOR,
    [KI]: n.DST_ALPHA,
    [ZI]: n.ONE_MINUS_SRC_COLOR,
    [Ny]: n.ONE_MINUS_SRC_ALPHA,
    [eL]: n.ONE_MINUS_DST_COLOR,
    [QI]: n.ONE_MINUS_DST_ALPHA,
    [nL]: n.CONSTANT_COLOR,
    [iL]: n.ONE_MINUS_CONSTANT_COLOR,
    [rL]: n.CONSTANT_ALPHA,
    [sL]: n.ONE_MINUS_CONSTANT_ALPHA,
  }
  function se(ve, Ie, Le, Ve, vt, ht, Qt, Un, si, wn) {
    if (ve === va) {
      M === !0 && (Be(n.BLEND), (M = !1))
      return
    }
    if ((M === !1 && (Pe(n.BLEND), (M = !0)), ve !== jI)) {
      if (ve !== w || wn !== N) {
        if (
          ((x !== Sc || P !== Sc) &&
            (n.blendEquation(n.FUNC_ADD), (x = Sc), (P = Sc)),
          wn)
        )
          switch (ve) {
            case od:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
              )
              break
            case LS:
              n.blendFunc(n.ONE, n.ONE)
              break
            case NS:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE)
              break
            case DS:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', ve)
              break
          }
        else
          switch (ve) {
            case od:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
              )
              break
            case LS:
              n.blendFunc(n.SRC_ALPHA, n.ONE)
              break
            case NS:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE)
              break
            case DS:
              n.blendFunc(n.ZERO, n.SRC_COLOR)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', ve)
              break
          }
        ;(T = null),
          (A = null),
          (D = null),
          (O = null),
          U.set(0, 0, 0),
          (F = 0),
          (w = ve),
          (N = wn)
      }
      return
    }
    ;(vt = vt || Ie),
      (ht = ht || Le),
      (Qt = Qt || Ve),
      (Ie !== x || vt !== P) &&
        (n.blendEquationSeparate(je[Ie], je[vt]), (x = Ie), (P = vt)),
      (Le !== T || Ve !== A || ht !== D || Qt !== O) &&
        (n.blendFuncSeparate($e[Le], $e[Ve], $e[ht], $e[Qt]),
        (T = Le),
        (A = Ve),
        (D = ht),
        (O = Qt)),
      (Un.equals(U) === !1 || si !== F) &&
        (n.blendColor(Un.r, Un.g, Un.b, si), U.copy(Un), (F = si)),
      (w = ve),
      (N = !1)
  }
  function Rt(ve, Ie) {
    ve.side === oo ? Be(n.CULL_FACE) : Pe(n.CULL_FACE)
    let Le = ve.side === Qr
    Ie && (Le = !Le),
      Qe(Le),
      ve.blending === od && ve.transparent === !1
        ? se(va)
        : se(
            ve.blending,
            ve.blendEquation,
            ve.blendSrc,
            ve.blendDst,
            ve.blendEquationAlpha,
            ve.blendSrcAlpha,
            ve.blendDstAlpha,
            ve.blendColor,
            ve.blendAlpha,
            ve.premultipliedAlpha,
          ),
      o.setFunc(ve.depthFunc),
      o.setTest(ve.depthTest),
      o.setMask(ve.depthWrite),
      s.setMask(ve.colorWrite)
    const Ve = ve.stencilWrite
    a.setTest(Ve),
      Ve &&
        (a.setMask(ve.stencilWriteMask),
        a.setFunc(ve.stencilFunc, ve.stencilRef, ve.stencilFuncMask),
        a.setOp(ve.stencilFail, ve.stencilZFail, ve.stencilZPass)),
      jt(ve.polygonOffset, ve.polygonOffsetFactor, ve.polygonOffsetUnits),
      ve.alphaToCoverage === !0
        ? Pe(n.SAMPLE_ALPHA_TO_COVERAGE)
        : Be(n.SAMPLE_ALPHA_TO_COVERAGE)
  }
  function Qe(ve) {
    k !== ve && (ve ? n.frontFace(n.CW) : n.frontFace(n.CCW), (k = ve))
  }
  function _t(ve) {
    ve !== BI
      ? (Pe(n.CULL_FACE),
        ve !== z &&
          (ve === IS
            ? n.cullFace(n.BACK)
            : ve === zI
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : Be(n.CULL_FACE),
      (z = ve)
  }
  function rt(ve) {
    ve !== $ && (J && n.lineWidth(ve), ($ = ve))
  }
  function jt(ve, Ie, Le) {
    ve
      ? (Pe(n.POLYGON_OFFSET_FILL),
        (te !== Ie || j !== Le) &&
          (n.polygonOffset(Ie, Le), (te = Ie), (j = Le)))
      : Be(n.POLYGON_OFFSET_FILL)
  }
  function at(ve) {
    ve ? Pe(n.SCISSOR_TEST) : Be(n.SCISSOR_TEST)
  }
  function ie(ve) {
    ve === void 0 && (ve = n.TEXTURE0 + K - 1),
      Y !== ve && (n.activeTexture(ve), (Y = ve))
  }
  function Z(ve, Ie, Le) {
    Le === void 0 && (Y === null ? (Le = n.TEXTURE0 + K - 1) : (Le = Y))
    let Ve = Q[Le]
    Ve === void 0 && ((Ve = { type: void 0, texture: void 0 }), (Q[Le] = Ve)),
      (Ve.type !== ve || Ve.texture !== Ie) &&
        (Y !== Le && (n.activeTexture(Le), (Y = Le)),
        n.bindTexture(ve, Ie || Te[ve]),
        (Ve.type = ve),
        (Ve.texture = Ie))
  }
  function Se() {
    const ve = Q[Y]
    ve !== void 0 &&
      ve.type !== void 0 &&
      (n.bindTexture(ve.type, null), (ve.type = void 0), (ve.texture = void 0))
  }
  function Ue() {
    try {
      n.compressedTexImage2D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function Ge() {
    try {
      n.compressedTexImage3D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function ze() {
    try {
      n.texSubImage2D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function Ct() {
    try {
      n.texSubImage3D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function ct() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function gt() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function rn() {
    try {
      n.texStorage2D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function Je() {
    try {
      n.texStorage3D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function bt() {
    try {
      n.texImage2D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function Ut() {
    try {
      n.texImage3D.apply(n, arguments)
    } catch (ve) {
      console.error('THREE.WebGLState:', ve)
    }
  }
  function It(ve) {
    _e.equals(ve) === !1 && (n.scissor(ve.x, ve.y, ve.z, ve.w), _e.copy(ve))
  }
  function Mt(ve) {
    he.equals(ve) === !1 && (n.viewport(ve.x, ve.y, ve.z, ve.w), he.copy(ve))
  }
  function en(ve, Ie) {
    let Le = u.get(Ie)
    Le === void 0 && ((Le = new WeakMap()), u.set(Ie, Le))
    let Ve = Le.get(ve)
    Ve === void 0 &&
      ((Ve = n.getUniformBlockIndex(Ie, ve.name)), Le.set(ve, Ve))
  }
  function Bt(ve, Ie) {
    const Ve = u.get(Ie).get(ve)
    c.get(Ie) !== Ve &&
      (n.uniformBlockBinding(Ie, Ve, ve.__bindingPointIndex), c.set(Ie, Ve))
  }
  function Kt() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      o.setReversed(!1),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (h = {}),
      (Y = null),
      (Q = {}),
      (m = {}),
      (g = new WeakMap()),
      (y = []),
      (_ = null),
      (M = !1),
      (w = null),
      (x = null),
      (T = null),
      (A = null),
      (P = null),
      (D = null),
      (O = null),
      (U = new Tt(0, 0, 0)),
      (F = 0),
      (N = !1),
      (k = null),
      (z = null),
      ($ = null),
      (te = null),
      (j = null),
      _e.set(0, 0, n.canvas.width, n.canvas.height),
      he.set(0, 0, n.canvas.width, n.canvas.height),
      s.reset(),
      o.reset(),
      a.reset()
  }
  return {
    buffers: { color: s, depth: o, stencil: a },
    enable: Pe,
    disable: Be,
    bindFramebuffer: et,
    drawBuffers: ft,
    useProgram: Vt,
    setBlending: se,
    setMaterial: Rt,
    setFlipSided: Qe,
    setCullFace: _t,
    setLineWidth: rt,
    setPolygonOffset: jt,
    setScissorTest: at,
    activeTexture: ie,
    bindTexture: Z,
    unbindTexture: Se,
    compressedTexImage2D: Ue,
    compressedTexImage3D: Ge,
    texImage2D: bt,
    texImage3D: Ut,
    updateUBOMapping: en,
    uniformBlockBinding: Bt,
    texStorage2D: rn,
    texStorage3D: Je,
    texSubImage2D: ze,
    texSubImage3D: Ct,
    compressedTexSubImage2D: ct,
    compressedTexSubImage3D: gt,
    scissor: It,
    viewport: Mt,
    reset: Kt,
  }
}
function hG(n, e, t, i, r, s, o) {
  const a = e.has('WEBGL_multisampled_render_to_texture')
      ? e.get('WEBGL_multisampled_render_to_texture')
      : null,
    c =
      typeof navigator > 'u' ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    u = new qe(),
    h = new WeakMap()
  let m
  const g = new WeakMap()
  let y = !1
  try {
    y =
      typeof OffscreenCanvas < 'u' &&
      new OffscreenCanvas(1, 1).getContext('2d') !== null
  } catch {}
  function _(ie, Z) {
    return y ? new OffscreenCanvas(ie, Z) : qm('canvas')
  }
  function M(ie, Z, Se) {
    let Ue = 1
    const Ge = at(ie)
    if (
      ((Ge.width > Se || Ge.height > Se) &&
        (Ue = Se / Math.max(Ge.width, Ge.height)),
      Ue < 1)
    )
      if (
        (typeof HTMLImageElement < 'u' && ie instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && ie instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && ie instanceof ImageBitmap) ||
        (typeof VideoFrame < 'u' && ie instanceof VideoFrame)
      ) {
        const ze = Math.floor(Ue * Ge.width),
          Ct = Math.floor(Ue * Ge.height)
        m === void 0 && (m = _(ze, Ct))
        const ct = Z ? _(ze, Ct) : m
        return (
          (ct.width = ze),
          (ct.height = Ct),
          ct.getContext('2d').drawImage(ie, 0, 0, ze, Ct),
          console.warn(
            'THREE.WebGLRenderer: Texture has been resized from (' +
              Ge.width +
              'x' +
              Ge.height +
              ') to (' +
              ze +
              'x' +
              Ct +
              ').',
          ),
          ct
        )
      } else
        return (
          'data' in ie &&
            console.warn(
              'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                Ge.width +
                'x' +
                Ge.height +
                ').',
            ),
          ie
        )
    return ie
  }
  function w(ie) {
    return ie.generateMipmaps
  }
  function x(ie) {
    n.generateMipmap(ie)
  }
  function T(ie) {
    return ie.isWebGLCubeRenderTarget
      ? n.TEXTURE_CUBE_MAP
      : ie.isWebGL3DRenderTarget
      ? n.TEXTURE_3D
      : ie.isWebGLArrayRenderTarget || ie.isCompressedArrayTexture
      ? n.TEXTURE_2D_ARRAY
      : n.TEXTURE_2D
  }
  function A(ie, Z, Se, Ue, Ge = !1) {
    if (ie !== null) {
      if (n[ie] !== void 0) return n[ie]
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          ie +
          "'",
      )
    }
    let ze = Z
    if (
      (Z === n.RED &&
        (Se === n.FLOAT && (ze = n.R32F),
        Se === n.HALF_FLOAT && (ze = n.R16F),
        Se === n.UNSIGNED_BYTE && (ze = n.R8)),
      Z === n.RED_INTEGER &&
        (Se === n.UNSIGNED_BYTE && (ze = n.R8UI),
        Se === n.UNSIGNED_SHORT && (ze = n.R16UI),
        Se === n.UNSIGNED_INT && (ze = n.R32UI),
        Se === n.BYTE && (ze = n.R8I),
        Se === n.SHORT && (ze = n.R16I),
        Se === n.INT && (ze = n.R32I)),
      Z === n.RG &&
        (Se === n.FLOAT && (ze = n.RG32F),
        Se === n.HALF_FLOAT && (ze = n.RG16F),
        Se === n.UNSIGNED_BYTE && (ze = n.RG8)),
      Z === n.RG_INTEGER &&
        (Se === n.UNSIGNED_BYTE && (ze = n.RG8UI),
        Se === n.UNSIGNED_SHORT && (ze = n.RG16UI),
        Se === n.UNSIGNED_INT && (ze = n.RG32UI),
        Se === n.BYTE && (ze = n.RG8I),
        Se === n.SHORT && (ze = n.RG16I),
        Se === n.INT && (ze = n.RG32I)),
      Z === n.RGB_INTEGER &&
        (Se === n.UNSIGNED_BYTE && (ze = n.RGB8UI),
        Se === n.UNSIGNED_SHORT && (ze = n.RGB16UI),
        Se === n.UNSIGNED_INT && (ze = n.RGB32UI),
        Se === n.BYTE && (ze = n.RGB8I),
        Se === n.SHORT && (ze = n.RGB16I),
        Se === n.INT && (ze = n.RGB32I)),
      Z === n.RGBA_INTEGER &&
        (Se === n.UNSIGNED_BYTE && (ze = n.RGBA8UI),
        Se === n.UNSIGNED_SHORT && (ze = n.RGBA16UI),
        Se === n.UNSIGNED_INT && (ze = n.RGBA32UI),
        Se === n.BYTE && (ze = n.RGBA8I),
        Se === n.SHORT && (ze = n.RGBA16I),
        Se === n.INT && (ze = n.RGBA32I)),
      Z === n.RGB && Se === n.UNSIGNED_INT_5_9_9_9_REV && (ze = n.RGB9_E5),
      Z === n.RGBA)
    ) {
      const Ct = Ge ? Wm : Cn.getTransfer(Ue)
      Se === n.FLOAT && (ze = n.RGBA32F),
        Se === n.HALF_FLOAT && (ze = n.RGBA16F),
        Se === n.UNSIGNED_BYTE && (ze = Ct === zn ? n.SRGB8_ALPHA8 : n.RGBA8),
        Se === n.UNSIGNED_SHORT_4_4_4_4 && (ze = n.RGBA4),
        Se === n.UNSIGNED_SHORT_5_5_5_1 && (ze = n.RGB5_A1)
    }
    return (
      (ze === n.R16F ||
        ze === n.R32F ||
        ze === n.RG16F ||
        ze === n.RG32F ||
        ze === n.RGBA16F ||
        ze === n.RGBA32F) &&
        e.get('EXT_color_buffer_float'),
      ze
    )
  }
  function P(ie, Z) {
    let Se
    return (
      ie
        ? Z === null || Z === Ta || Z === pd
          ? (Se = n.DEPTH24_STENCIL8)
          : Z === gi
          ? (Se = n.DEPTH32F_STENCIL8)
          : Z === ph &&
            ((Se = n.DEPTH24_STENCIL8),
            console.warn(
              'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.',
            ))
        : Z === null || Z === Ta || Z === pd
        ? (Se = n.DEPTH_COMPONENT24)
        : Z === gi
        ? (Se = n.DEPTH_COMPONENT32F)
        : Z === ph && (Se = n.DEPTH_COMPONENT16),
      Se
    )
  }
  function D(ie, Z) {
    return w(ie) === !0 ||
      (ie.isFramebufferTexture && ie.minFilter !== yr && ie.minFilter !== Vn)
      ? Math.log2(Math.max(Z.width, Z.height)) + 1
      : ie.mipmaps !== void 0 && ie.mipmaps.length > 0
      ? ie.mipmaps.length
      : ie.isCompressedTexture && Array.isArray(ie.image)
      ? Z.mipmaps.length
      : 1
  }
  function O(ie) {
    const Z = ie.target
    Z.removeEventListener('dispose', O), F(Z), Z.isVideoTexture && h.delete(Z)
  }
  function U(ie) {
    const Z = ie.target
    Z.removeEventListener('dispose', U), k(Z)
  }
  function F(ie) {
    const Z = i.get(ie)
    if (Z.__webglInit === void 0) return
    const Se = ie.source,
      Ue = g.get(Se)
    if (Ue) {
      const Ge = Ue[Z.__cacheKey]
      Ge.usedTimes--,
        Ge.usedTimes === 0 && N(ie),
        Object.keys(Ue).length === 0 && g.delete(Se)
    }
    i.remove(ie)
  }
  function N(ie) {
    const Z = i.get(ie)
    n.deleteTexture(Z.__webglTexture)
    const Se = ie.source,
      Ue = g.get(Se)
    delete Ue[Z.__cacheKey], o.memory.textures--
  }
  function k(ie) {
    const Z = i.get(ie)
    if (
      (ie.depthTexture &&
        (ie.depthTexture.dispose(), i.remove(ie.depthTexture)),
      ie.isWebGLCubeRenderTarget)
    )
      for (let Ue = 0; Ue < 6; Ue++) {
        if (Array.isArray(Z.__webglFramebuffer[Ue]))
          for (let Ge = 0; Ge < Z.__webglFramebuffer[Ue].length; Ge++)
            n.deleteFramebuffer(Z.__webglFramebuffer[Ue][Ge])
        else n.deleteFramebuffer(Z.__webglFramebuffer[Ue])
        Z.__webglDepthbuffer && n.deleteRenderbuffer(Z.__webglDepthbuffer[Ue])
      }
    else {
      if (Array.isArray(Z.__webglFramebuffer))
        for (let Ue = 0; Ue < Z.__webglFramebuffer.length; Ue++)
          n.deleteFramebuffer(Z.__webglFramebuffer[Ue])
      else n.deleteFramebuffer(Z.__webglFramebuffer)
      if (
        (Z.__webglDepthbuffer && n.deleteRenderbuffer(Z.__webglDepthbuffer),
        Z.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(Z.__webglMultisampledFramebuffer),
        Z.__webglColorRenderbuffer)
      )
        for (let Ue = 0; Ue < Z.__webglColorRenderbuffer.length; Ue++)
          Z.__webglColorRenderbuffer[Ue] &&
            n.deleteRenderbuffer(Z.__webglColorRenderbuffer[Ue])
      Z.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(Z.__webglDepthRenderbuffer)
    }
    const Se = ie.textures
    for (let Ue = 0, Ge = Se.length; Ue < Ge; Ue++) {
      const ze = i.get(Se[Ue])
      ze.__webglTexture &&
        (n.deleteTexture(ze.__webglTexture), o.memory.textures--),
        i.remove(Se[Ue])
    }
    i.remove(ie)
  }
  let z = 0
  function $() {
    z = 0
  }
  function te() {
    const ie = z
    return (
      ie >= r.maxTextures &&
        console.warn(
          'THREE.WebGLTextures: Trying to use ' +
            ie +
            ' texture units while this GPU supports only ' +
            r.maxTextures,
        ),
      (z += 1),
      ie
    )
  }
  function j(ie) {
    const Z = []
    return (
      Z.push(ie.wrapS),
      Z.push(ie.wrapT),
      Z.push(ie.wrapR || 0),
      Z.push(ie.magFilter),
      Z.push(ie.minFilter),
      Z.push(ie.anisotropy),
      Z.push(ie.internalFormat),
      Z.push(ie.format),
      Z.push(ie.type),
      Z.push(ie.generateMipmaps),
      Z.push(ie.premultiplyAlpha),
      Z.push(ie.flipY),
      Z.push(ie.unpackAlignment),
      Z.push(ie.colorSpace),
      Z.join()
    )
  }
  function K(ie, Z) {
    const Se = i.get(ie)
    if (
      (ie.isVideoTexture && rt(ie),
      ie.isRenderTargetTexture === !1 &&
        ie.version > 0 &&
        Se.__version !== ie.version)
    ) {
      const Ue = ie.image
      if (Ue === null)
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but no image data found.',
        )
      else if (Ue.complete === !1)
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but image is incomplete',
        )
      else {
        he(Se, ie, Z)
        return
      }
    }
    t.bindTexture(n.TEXTURE_2D, Se.__webglTexture, n.TEXTURE0 + Z)
  }
  function J(ie, Z) {
    const Se = i.get(ie)
    if (ie.version > 0 && Se.__version !== ie.version) {
      he(Se, ie, Z)
      return
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, Se.__webglTexture, n.TEXTURE0 + Z)
  }
  function ne(ie, Z) {
    const Se = i.get(ie)
    if (ie.version > 0 && Se.__version !== ie.version) {
      he(Se, ie, Z)
      return
    }
    t.bindTexture(n.TEXTURE_3D, Se.__webglTexture, n.TEXTURE0 + Z)
  }
  function V(ie, Z) {
    const Se = i.get(ie)
    if (ie.version > 0 && Se.__version !== ie.version) {
      Ce(Se, ie, Z)
      return
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, Se.__webglTexture, n.TEXTURE0 + Z)
  }
  const Y = { [Vm]: n.REPEAT, [Bi]: n.CLAMP_TO_EDGE, [jm]: n.MIRRORED_REPEAT },
    Q = {
      [yr]: n.NEAREST,
      [KM]: n.NEAREST_MIPMAP_NEAREST,
      [Xf]: n.NEAREST_MIPMAP_LINEAR,
      [Vn]: n.LINEAR,
      [gm]: n.LINEAR_MIPMAP_NEAREST,
      [ma]: n.LINEAR_MIPMAP_LINEAR,
    },
    q = {
      [wL]: n.NEVER,
      [AL]: n.ALWAYS,
      [SL]: n.LESS,
      [oE]: n.LEQUAL,
      [ML]: n.EQUAL,
      [TL]: n.GEQUAL,
      [EL]: n.GREATER,
      [bL]: n.NOTEQUAL,
    }
  function oe(ie, Z) {
    if (
      (Z.type === gi &&
        e.has('OES_texture_float_linear') === !1 &&
        (Z.magFilter === Vn ||
          Z.magFilter === gm ||
          Z.magFilter === Xf ||
          Z.magFilter === ma ||
          Z.minFilter === Vn ||
          Z.minFilter === gm ||
          Z.minFilter === Xf ||
          Z.minFilter === ma) &&
        console.warn(
          'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.',
        ),
      n.texParameteri(ie, n.TEXTURE_WRAP_S, Y[Z.wrapS]),
      n.texParameteri(ie, n.TEXTURE_WRAP_T, Y[Z.wrapT]),
      (ie === n.TEXTURE_3D || ie === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(ie, n.TEXTURE_WRAP_R, Y[Z.wrapR]),
      n.texParameteri(ie, n.TEXTURE_MAG_FILTER, Q[Z.magFilter]),
      n.texParameteri(ie, n.TEXTURE_MIN_FILTER, Q[Z.minFilter]),
      Z.compareFunction &&
        (n.texParameteri(ie, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(ie, n.TEXTURE_COMPARE_FUNC, q[Z.compareFunction])),
      e.has('EXT_texture_filter_anisotropic') === !0)
    ) {
      if (
        Z.magFilter === yr ||
        (Z.minFilter !== Xf && Z.minFilter !== ma) ||
        (Z.type === gi && e.has('OES_texture_float_linear') === !1)
      )
        return
      if (Z.anisotropy > 1 || i.get(Z).__currentAnisotropy) {
        const Se = e.get('EXT_texture_filter_anisotropic')
        n.texParameterf(
          ie,
          Se.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(Z.anisotropy, r.getMaxAnisotropy()),
        ),
          (i.get(Z).__currentAnisotropy = Z.anisotropy)
      }
    }
  }
  function _e(ie, Z) {
    let Se = !1
    ie.__webglInit === void 0 &&
      ((ie.__webglInit = !0), Z.addEventListener('dispose', O))
    const Ue = Z.source
    let Ge = g.get(Ue)
    Ge === void 0 && ((Ge = {}), g.set(Ue, Ge))
    const ze = j(Z)
    if (ze !== ie.__cacheKey) {
      Ge[ze] === void 0 &&
        ((Ge[ze] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (Se = !0)),
        Ge[ze].usedTimes++
      const Ct = Ge[ie.__cacheKey]
      Ct !== void 0 &&
        (Ge[ie.__cacheKey].usedTimes--, Ct.usedTimes === 0 && N(Z)),
        (ie.__cacheKey = ze),
        (ie.__webglTexture = Ge[ze].texture)
    }
    return Se
  }
  function he(ie, Z, Se) {
    let Ue = n.TEXTURE_2D
    ;(Z.isDataArrayTexture || Z.isCompressedArrayTexture) &&
      (Ue = n.TEXTURE_2D_ARRAY),
      Z.isData3DTexture && (Ue = n.TEXTURE_3D)
    const Ge = _e(ie, Z),
      ze = Z.source
    t.bindTexture(Ue, ie.__webglTexture, n.TEXTURE0 + Se)
    const Ct = i.get(ze)
    if (ze.version !== Ct.__version || Ge === !0) {
      t.activeTexture(n.TEXTURE0 + Se)
      const ct = Cn.getPrimaries(Cn.workingColorSpace),
        gt = Z.colorSpace === vl ? null : Cn.getPrimaries(Z.colorSpace),
        rn = Z.colorSpace === vl || ct === gt ? n.NONE : n.BROWSER_DEFAULT_WEBGL
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, Z.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Z.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, Z.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, rn)
      let Je = M(Z.image, !1, r.maxTextureSize)
      Je = jt(Z, Je)
      const bt = s.convert(Z.format, Z.colorSpace),
        Ut = s.convert(Z.type)
      let It = A(Z.internalFormat, bt, Ut, Z.colorSpace, Z.isVideoTexture)
      oe(Ue, Z)
      let Mt
      const en = Z.mipmaps,
        Bt = Z.isVideoTexture !== !0,
        Kt = Ct.__version === void 0 || Ge === !0,
        ve = ze.dataReady,
        Ie = D(Z, Je)
      if (Z.isDepthTexture)
        (It = P(Z.format === md, Z.type)),
          Kt &&
            (Bt
              ? t.texStorage2D(n.TEXTURE_2D, 1, It, Je.width, Je.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  It,
                  Je.width,
                  Je.height,
                  0,
                  bt,
                  Ut,
                  null,
                ))
      else if (Z.isDataTexture)
        if (en.length > 0) {
          Bt &&
            Kt &&
            t.texStorage2D(n.TEXTURE_2D, Ie, It, en[0].width, en[0].height)
          for (let Le = 0, Ve = en.length; Le < Ve; Le++)
            (Mt = en[Le]),
              Bt
                ? ve &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Le,
                    0,
                    0,
                    Mt.width,
                    Mt.height,
                    bt,
                    Ut,
                    Mt.data,
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Le,
                    It,
                    Mt.width,
                    Mt.height,
                    0,
                    bt,
                    Ut,
                    Mt.data,
                  )
          Z.generateMipmaps = !1
        } else
          Bt
            ? (Kt && t.texStorage2D(n.TEXTURE_2D, Ie, It, Je.width, Je.height),
              ve &&
                t.texSubImage2D(
                  n.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Je.width,
                  Je.height,
                  bt,
                  Ut,
                  Je.data,
                ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                It,
                Je.width,
                Je.height,
                0,
                bt,
                Ut,
                Je.data,
              )
      else if (Z.isCompressedTexture)
        if (Z.isCompressedArrayTexture) {
          Bt &&
            Kt &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              Ie,
              It,
              en[0].width,
              en[0].height,
              Je.depth,
            )
          for (let Le = 0, Ve = en.length; Le < Ve; Le++)
            if (((Mt = en[Le]), Z.format !== Ii))
              if (bt !== null)
                if (Bt) {
                  if (ve)
                    if (Z.layerUpdates.size > 0) {
                      const vt = WS(Mt.width, Mt.height, Z.format, Z.type)
                      for (const ht of Z.layerUpdates) {
                        const Qt = Mt.data.subarray(
                          (ht * vt) / Mt.data.BYTES_PER_ELEMENT,
                          ((ht + 1) * vt) / Mt.data.BYTES_PER_ELEMENT,
                        )
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          Le,
                          0,
                          0,
                          ht,
                          Mt.width,
                          Mt.height,
                          1,
                          bt,
                          Qt,
                        )
                      }
                      Z.clearLayerUpdates()
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Le,
                        0,
                        0,
                        0,
                        Mt.width,
                        Mt.height,
                        Je.depth,
                        bt,
                        Mt.data,
                      )
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Le,
                    It,
                    Mt.width,
                    Mt.height,
                    Je.depth,
                    0,
                    Mt.data,
                    0,
                    0,
                  )
              else
                console.warn(
                  'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                )
            else
              Bt
                ? ve &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Le,
                    0,
                    0,
                    0,
                    Mt.width,
                    Mt.height,
                    Je.depth,
                    bt,
                    Ut,
                    Mt.data,
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Le,
                    It,
                    Mt.width,
                    Mt.height,
                    Je.depth,
                    0,
                    bt,
                    Ut,
                    Mt.data,
                  )
        } else {
          Bt &&
            Kt &&
            t.texStorage2D(n.TEXTURE_2D, Ie, It, en[0].width, en[0].height)
          for (let Le = 0, Ve = en.length; Le < Ve; Le++)
            (Mt = en[Le]),
              Z.format !== Ii
                ? bt !== null
                  ? Bt
                    ? ve &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Le,
                        0,
                        0,
                        Mt.width,
                        Mt.height,
                        bt,
                        Mt.data,
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        Le,
                        It,
                        Mt.width,
                        Mt.height,
                        0,
                        Mt.data,
                      )
                  : console.warn(
                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                    )
                : Bt
                ? ve &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Le,
                    0,
                    0,
                    Mt.width,
                    Mt.height,
                    bt,
                    Ut,
                    Mt.data,
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Le,
                    It,
                    Mt.width,
                    Mt.height,
                    0,
                    bt,
                    Ut,
                    Mt.data,
                  )
        }
      else if (Z.isDataArrayTexture)
        if (Bt) {
          if (
            (Kt &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                Ie,
                It,
                Je.width,
                Je.height,
                Je.depth,
              ),
            ve)
          )
            if (Z.layerUpdates.size > 0) {
              const Le = WS(Je.width, Je.height, Z.format, Z.type)
              for (const Ve of Z.layerUpdates) {
                const vt = Je.data.subarray(
                  (Ve * Le) / Je.data.BYTES_PER_ELEMENT,
                  ((Ve + 1) * Le) / Je.data.BYTES_PER_ELEMENT,
                )
                t.texSubImage3D(
                  n.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Ve,
                  Je.width,
                  Je.height,
                  1,
                  bt,
                  Ut,
                  vt,
                )
              }
              Z.clearLayerUpdates()
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Je.width,
                Je.height,
                Je.depth,
                bt,
                Ut,
                Je.data,
              )
        } else
          t.texImage3D(
            n.TEXTURE_2D_ARRAY,
            0,
            It,
            Je.width,
            Je.height,
            Je.depth,
            0,
            bt,
            Ut,
            Je.data,
          )
      else if (Z.isData3DTexture)
        Bt
          ? (Kt &&
              t.texStorage3D(
                n.TEXTURE_3D,
                Ie,
                It,
                Je.width,
                Je.height,
                Je.depth,
              ),
            ve &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Je.width,
                Je.height,
                Je.depth,
                bt,
                Ut,
                Je.data,
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              It,
              Je.width,
              Je.height,
              Je.depth,
              0,
              bt,
              Ut,
              Je.data,
            )
      else if (Z.isFramebufferTexture) {
        if (Kt)
          if (Bt) t.texStorage2D(n.TEXTURE_2D, Ie, It, Je.width, Je.height)
          else {
            let Le = Je.width,
              Ve = Je.height
            for (let vt = 0; vt < Ie; vt++)
              t.texImage2D(n.TEXTURE_2D, vt, It, Le, Ve, 0, bt, Ut, null),
                (Le >>= 1),
                (Ve >>= 1)
          }
      } else if (en.length > 0) {
        if (Bt && Kt) {
          const Le = at(en[0])
          t.texStorage2D(n.TEXTURE_2D, Ie, It, Le.width, Le.height)
        }
        for (let Le = 0, Ve = en.length; Le < Ve; Le++)
          (Mt = en[Le]),
            Bt
              ? ve && t.texSubImage2D(n.TEXTURE_2D, Le, 0, 0, bt, Ut, Mt)
              : t.texImage2D(n.TEXTURE_2D, Le, It, bt, Ut, Mt)
        Z.generateMipmaps = !1
      } else if (Bt) {
        if (Kt) {
          const Le = at(Je)
          t.texStorage2D(n.TEXTURE_2D, Ie, It, Le.width, Le.height)
        }
        ve && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, bt, Ut, Je)
      } else t.texImage2D(n.TEXTURE_2D, 0, It, bt, Ut, Je)
      w(Z) && x(Ue), (Ct.__version = ze.version), Z.onUpdate && Z.onUpdate(Z)
    }
    ie.__version = Z.version
  }
  function Ce(ie, Z, Se) {
    if (Z.image.length !== 6) return
    const Ue = _e(ie, Z),
      Ge = Z.source
    t.bindTexture(n.TEXTURE_CUBE_MAP, ie.__webglTexture, n.TEXTURE0 + Se)
    const ze = i.get(Ge)
    if (Ge.version !== ze.__version || Ue === !0) {
      t.activeTexture(n.TEXTURE0 + Se)
      const Ct = Cn.getPrimaries(Cn.workingColorSpace),
        ct = Z.colorSpace === vl ? null : Cn.getPrimaries(Z.colorSpace),
        gt = Z.colorSpace === vl || Ct === ct ? n.NONE : n.BROWSER_DEFAULT_WEBGL
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, Z.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Z.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, Z.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, gt)
      const rn = Z.isCompressedTexture || Z.image[0].isCompressedTexture,
        Je = Z.image[0] && Z.image[0].isDataTexture,
        bt = []
      for (let Ve = 0; Ve < 6; Ve++)
        !rn && !Je
          ? (bt[Ve] = M(Z.image[Ve], !0, r.maxCubemapSize))
          : (bt[Ve] = Je ? Z.image[Ve].image : Z.image[Ve]),
          (bt[Ve] = jt(Z, bt[Ve]))
      const Ut = bt[0],
        It = s.convert(Z.format, Z.colorSpace),
        Mt = s.convert(Z.type),
        en = A(Z.internalFormat, It, Mt, Z.colorSpace),
        Bt = Z.isVideoTexture !== !0,
        Kt = ze.__version === void 0 || Ue === !0,
        ve = Ge.dataReady
      let Ie = D(Z, Ut)
      oe(n.TEXTURE_CUBE_MAP, Z)
      let Le
      if (rn) {
        Bt &&
          Kt &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Ie, en, Ut.width, Ut.height)
        for (let Ve = 0; Ve < 6; Ve++) {
          Le = bt[Ve].mipmaps
          for (let vt = 0; vt < Le.length; vt++) {
            const ht = Le[vt]
            Z.format !== Ii
              ? It !== null
                ? Bt
                  ? ve &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                      vt,
                      0,
                      0,
                      ht.width,
                      ht.height,
                      It,
                      ht.data,
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                      vt,
                      en,
                      ht.width,
                      ht.height,
                      0,
                      ht.data,
                    )
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                  )
              : Bt
              ? ve &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                  vt,
                  0,
                  0,
                  ht.width,
                  ht.height,
                  It,
                  Mt,
                  ht.data,
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                  vt,
                  en,
                  ht.width,
                  ht.height,
                  0,
                  It,
                  Mt,
                  ht.data,
                )
          }
        }
      } else {
        if (((Le = Z.mipmaps), Bt && Kt)) {
          Le.length > 0 && Ie++
          const Ve = at(bt[0])
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Ie, en, Ve.width, Ve.height)
        }
        for (let Ve = 0; Ve < 6; Ve++)
          if (Je) {
            Bt
              ? ve &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                  0,
                  0,
                  0,
                  bt[Ve].width,
                  bt[Ve].height,
                  It,
                  Mt,
                  bt[Ve].data,
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                  0,
                  en,
                  bt[Ve].width,
                  bt[Ve].height,
                  0,
                  It,
                  Mt,
                  bt[Ve].data,
                )
            for (let vt = 0; vt < Le.length; vt++) {
              const Qt = Le[vt].image[Ve].image
              Bt
                ? ve &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                    vt + 1,
                    0,
                    0,
                    Qt.width,
                    Qt.height,
                    It,
                    Mt,
                    Qt.data,
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                    vt + 1,
                    en,
                    Qt.width,
                    Qt.height,
                    0,
                    It,
                    Mt,
                    Qt.data,
                  )
            }
          } else {
            Bt
              ? ve &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                  0,
                  0,
                  0,
                  It,
                  Mt,
                  bt[Ve],
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                  0,
                  en,
                  It,
                  Mt,
                  bt[Ve],
                )
            for (let vt = 0; vt < Le.length; vt++) {
              const ht = Le[vt]
              Bt
                ? ve &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                    vt + 1,
                    0,
                    0,
                    It,
                    Mt,
                    ht.image[Ve],
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + Ve,
                    vt + 1,
                    en,
                    It,
                    Mt,
                    ht.image[Ve],
                  )
            }
          }
      }
      w(Z) && x(n.TEXTURE_CUBE_MAP),
        (ze.__version = Ge.version),
        Z.onUpdate && Z.onUpdate(Z)
    }
    ie.__version = Z.version
  }
  function Te(ie, Z, Se, Ue, Ge, ze) {
    const Ct = s.convert(Se.format, Se.colorSpace),
      ct = s.convert(Se.type),
      gt = A(Se.internalFormat, Ct, ct, Se.colorSpace),
      rn = i.get(Z),
      Je = i.get(Se)
    if (((Je.__renderTarget = Z), !rn.__hasExternalTextures)) {
      const bt = Math.max(1, Z.width >> ze),
        Ut = Math.max(1, Z.height >> ze)
      Ge === n.TEXTURE_3D || Ge === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(Ge, ze, gt, bt, Ut, Z.depth, 0, Ct, ct, null)
        : t.texImage2D(Ge, ze, gt, bt, Ut, 0, Ct, ct, null)
    }
    t.bindFramebuffer(n.FRAMEBUFFER, ie),
      _t(Z)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            Ue,
            Ge,
            Je.__webglTexture,
            0,
            Qe(Z),
          )
        : (Ge === n.TEXTURE_2D ||
            (Ge >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Ge <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(n.FRAMEBUFFER, Ue, Ge, Je.__webglTexture, ze),
      t.bindFramebuffer(n.FRAMEBUFFER, null)
  }
  function Pe(ie, Z, Se) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, ie), Z.depthBuffer)) {
      const Ue = Z.depthTexture,
        Ge = Ue && Ue.isDepthTexture ? Ue.type : null,
        ze = P(Z.stencilBuffer, Ge),
        Ct = Z.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        ct = Qe(Z)
      _t(Z)
        ? a.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            ct,
            ze,
            Z.width,
            Z.height,
          )
        : Se
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            ct,
            ze,
            Z.width,
            Z.height,
          )
        : n.renderbufferStorage(n.RENDERBUFFER, ze, Z.width, Z.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, Ct, n.RENDERBUFFER, ie)
    } else {
      const Ue = Z.textures
      for (let Ge = 0; Ge < Ue.length; Ge++) {
        const ze = Ue[Ge],
          Ct = s.convert(ze.format, ze.colorSpace),
          ct = s.convert(ze.type),
          gt = A(ze.internalFormat, Ct, ct, ze.colorSpace),
          rn = Qe(Z)
        Se && _t(Z) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              rn,
              gt,
              Z.width,
              Z.height,
            )
          : _t(Z)
          ? a.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              rn,
              gt,
              Z.width,
              Z.height,
            )
          : n.renderbufferStorage(n.RENDERBUFFER, gt, Z.width, Z.height)
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null)
  }
  function Be(ie, Z) {
    if (Z && Z.isWebGLCubeRenderTarget)
      throw new Error('Depth Texture with cube render targets is not supported')
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, ie),
      !(Z.depthTexture && Z.depthTexture.isDepthTexture))
    )
      throw new Error(
        'renderTarget.depthTexture must be an instance of THREE.DepthTexture',
      )
    const Ue = i.get(Z.depthTexture)
    ;(Ue.__renderTarget = Z),
      (!Ue.__webglTexture ||
        Z.depthTexture.image.width !== Z.width ||
        Z.depthTexture.image.height !== Z.height) &&
        ((Z.depthTexture.image.width = Z.width),
        (Z.depthTexture.image.height = Z.height),
        (Z.depthTexture.needsUpdate = !0)),
      K(Z.depthTexture, 0)
    const Ge = Ue.__webglTexture,
      ze = Qe(Z)
    if (Z.depthTexture.format === ad)
      _t(Z)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Ge,
            0,
            ze,
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Ge,
            0,
          )
    else if (Z.depthTexture.format === md)
      _t(Z)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Ge,
            0,
            ze,
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Ge,
            0,
          )
    else throw new Error('Unknown depthTexture format')
  }
  function et(ie) {
    const Z = i.get(ie),
      Se = ie.isWebGLCubeRenderTarget === !0
    if (Z.__boundDepthTexture !== ie.depthTexture) {
      const Ue = ie.depthTexture
      if ((Z.__depthDisposeCallback && Z.__depthDisposeCallback(), Ue)) {
        const Ge = () => {
          delete Z.__boundDepthTexture,
            delete Z.__depthDisposeCallback,
            Ue.removeEventListener('dispose', Ge)
        }
        Ue.addEventListener('dispose', Ge), (Z.__depthDisposeCallback = Ge)
      }
      Z.__boundDepthTexture = Ue
    }
    if (ie.depthTexture && !Z.__autoAllocateDepthBuffer) {
      if (Se)
        throw new Error(
          'target.depthTexture not supported in Cube render targets',
        )
      Be(Z.__webglFramebuffer, ie)
    } else if (Se) {
      Z.__webglDepthbuffer = []
      for (let Ue = 0; Ue < 6; Ue++)
        if (
          (t.bindFramebuffer(n.FRAMEBUFFER, Z.__webglFramebuffer[Ue]),
          Z.__webglDepthbuffer[Ue] === void 0)
        )
          (Z.__webglDepthbuffer[Ue] = n.createRenderbuffer()),
            Pe(Z.__webglDepthbuffer[Ue], ie, !1)
        else {
          const Ge = ie.stencilBuffer
              ? n.DEPTH_STENCIL_ATTACHMENT
              : n.DEPTH_ATTACHMENT,
            ze = Z.__webglDepthbuffer[Ue]
          n.bindRenderbuffer(n.RENDERBUFFER, ze),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, Ge, n.RENDERBUFFER, ze)
        }
    } else if (
      (t.bindFramebuffer(n.FRAMEBUFFER, Z.__webglFramebuffer),
      Z.__webglDepthbuffer === void 0)
    )
      (Z.__webglDepthbuffer = n.createRenderbuffer()),
        Pe(Z.__webglDepthbuffer, ie, !1)
    else {
      const Ue = ie.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT,
        Ge = Z.__webglDepthbuffer
      n.bindRenderbuffer(n.RENDERBUFFER, Ge),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, Ue, n.RENDERBUFFER, Ge)
    }
    t.bindFramebuffer(n.FRAMEBUFFER, null)
  }
  function ft(ie, Z, Se) {
    const Ue = i.get(ie)
    Z !== void 0 &&
      Te(
        Ue.__webglFramebuffer,
        ie,
        ie.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0,
      ),
      Se !== void 0 && et(ie)
  }
  function Vt(ie) {
    const Z = ie.texture,
      Se = i.get(ie),
      Ue = i.get(Z)
    ie.addEventListener('dispose', U)
    const Ge = ie.textures,
      ze = ie.isWebGLCubeRenderTarget === !0,
      Ct = Ge.length > 1
    if (
      (Ct ||
        (Ue.__webglTexture === void 0 &&
          (Ue.__webglTexture = n.createTexture()),
        (Ue.__version = Z.version),
        o.memory.textures++),
      ze)
    ) {
      Se.__webglFramebuffer = []
      for (let ct = 0; ct < 6; ct++)
        if (Z.mipmaps && Z.mipmaps.length > 0) {
          Se.__webglFramebuffer[ct] = []
          for (let gt = 0; gt < Z.mipmaps.length; gt++)
            Se.__webglFramebuffer[ct][gt] = n.createFramebuffer()
        } else Se.__webglFramebuffer[ct] = n.createFramebuffer()
    } else {
      if (Z.mipmaps && Z.mipmaps.length > 0) {
        Se.__webglFramebuffer = []
        for (let ct = 0; ct < Z.mipmaps.length; ct++)
          Se.__webglFramebuffer[ct] = n.createFramebuffer()
      } else Se.__webglFramebuffer = n.createFramebuffer()
      if (Ct)
        for (let ct = 0, gt = Ge.length; ct < gt; ct++) {
          const rn = i.get(Ge[ct])
          rn.__webglTexture === void 0 &&
            ((rn.__webglTexture = n.createTexture()), o.memory.textures++)
        }
      if (ie.samples > 0 && _t(ie) === !1) {
        ;(Se.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (Se.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, Se.__webglMultisampledFramebuffer)
        for (let ct = 0; ct < Ge.length; ct++) {
          const gt = Ge[ct]
          ;(Se.__webglColorRenderbuffer[ct] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, Se.__webglColorRenderbuffer[ct])
          const rn = s.convert(gt.format, gt.colorSpace),
            Je = s.convert(gt.type),
            bt = A(
              gt.internalFormat,
              rn,
              Je,
              gt.colorSpace,
              ie.isXRRenderTarget === !0,
            ),
            Ut = Qe(ie)
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Ut,
            bt,
            ie.width,
            ie.height,
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + ct,
              n.RENDERBUFFER,
              Se.__webglColorRenderbuffer[ct],
            )
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          ie.depthBuffer &&
            ((Se.__webglDepthRenderbuffer = n.createRenderbuffer()),
            Pe(Se.__webglDepthRenderbuffer, ie, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null)
      }
    }
    if (ze) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, Ue.__webglTexture),
        oe(n.TEXTURE_CUBE_MAP, Z)
      for (let ct = 0; ct < 6; ct++)
        if (Z.mipmaps && Z.mipmaps.length > 0)
          for (let gt = 0; gt < Z.mipmaps.length; gt++)
            Te(
              Se.__webglFramebuffer[ct][gt],
              ie,
              Z,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + ct,
              gt,
            )
        else
          Te(
            Se.__webglFramebuffer[ct],
            ie,
            Z,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + ct,
            0,
          )
      w(Z) && x(n.TEXTURE_CUBE_MAP), t.unbindTexture()
    } else if (Ct) {
      for (let ct = 0, gt = Ge.length; ct < gt; ct++) {
        const rn = Ge[ct],
          Je = i.get(rn)
        t.bindTexture(n.TEXTURE_2D, Je.__webglTexture),
          oe(n.TEXTURE_2D, rn),
          Te(
            Se.__webglFramebuffer,
            ie,
            rn,
            n.COLOR_ATTACHMENT0 + ct,
            n.TEXTURE_2D,
            0,
          ),
          w(rn) && x(n.TEXTURE_2D)
      }
      t.unbindTexture()
    } else {
      let ct = n.TEXTURE_2D
      if (
        ((ie.isWebGL3DRenderTarget || ie.isWebGLArrayRenderTarget) &&
          (ct = ie.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(ct, Ue.__webglTexture),
        oe(ct, Z),
        Z.mipmaps && Z.mipmaps.length > 0)
      )
        for (let gt = 0; gt < Z.mipmaps.length; gt++)
          Te(Se.__webglFramebuffer[gt], ie, Z, n.COLOR_ATTACHMENT0, ct, gt)
      else Te(Se.__webglFramebuffer, ie, Z, n.COLOR_ATTACHMENT0, ct, 0)
      w(Z) && x(ct), t.unbindTexture()
    }
    ie.depthBuffer && et(ie)
  }
  function je(ie) {
    const Z = ie.textures
    for (let Se = 0, Ue = Z.length; Se < Ue; Se++) {
      const Ge = Z[Se]
      if (w(Ge)) {
        const ze = T(ie),
          Ct = i.get(Ge).__webglTexture
        t.bindTexture(ze, Ct), x(ze), t.unbindTexture()
      }
    }
  }
  const $e = [],
    se = []
  function Rt(ie) {
    if (ie.samples > 0) {
      if (_t(ie) === !1) {
        const Z = ie.textures,
          Se = ie.width,
          Ue = ie.height
        let Ge = n.COLOR_BUFFER_BIT
        const ze = ie.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          Ct = i.get(ie),
          ct = Z.length > 1
        if (ct)
          for (let gt = 0; gt < Z.length; gt++)
            t.bindFramebuffer(n.FRAMEBUFFER, Ct.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + gt,
                n.RENDERBUFFER,
                null,
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, Ct.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + gt,
                n.TEXTURE_2D,
                null,
                0,
              )
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          Ct.__webglMultisampledFramebuffer,
        ),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ct.__webglFramebuffer)
        for (let gt = 0; gt < Z.length; gt++) {
          if (
            (ie.resolveDepthBuffer &&
              (ie.depthBuffer && (Ge |= n.DEPTH_BUFFER_BIT),
              ie.stencilBuffer &&
                ie.resolveStencilBuffer &&
                (Ge |= n.STENCIL_BUFFER_BIT)),
            ct)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Ct.__webglColorRenderbuffer[gt],
            )
            const rn = i.get(Z[gt]).__webglTexture
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              rn,
              0,
            )
          }
          n.blitFramebuffer(0, 0, Se, Ue, 0, 0, Se, Ue, Ge, n.NEAREST),
            c === !0 &&
              (($e.length = 0),
              (se.length = 0),
              $e.push(n.COLOR_ATTACHMENT0 + gt),
              ie.depthBuffer &&
                ie.resolveDepthBuffer === !1 &&
                ($e.push(ze),
                se.push(ze),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, se)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, $e))
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          ct)
        )
          for (let gt = 0; gt < Z.length; gt++) {
            t.bindFramebuffer(n.FRAMEBUFFER, Ct.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + gt,
                n.RENDERBUFFER,
                Ct.__webglColorRenderbuffer[gt],
              )
            const rn = i.get(Z[gt]).__webglTexture
            t.bindFramebuffer(n.FRAMEBUFFER, Ct.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + gt,
                n.TEXTURE_2D,
                rn,
                0,
              )
          }
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ct.__webglMultisampledFramebuffer)
      } else if (ie.depthBuffer && ie.resolveDepthBuffer === !1 && c) {
        const Z = ie.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Z])
      }
    }
  }
  function Qe(ie) {
    return Math.min(r.maxSamples, ie.samples)
  }
  function _t(ie) {
    const Z = i.get(ie)
    return (
      ie.samples > 0 &&
      e.has('WEBGL_multisampled_render_to_texture') === !0 &&
      Z.__useRenderToTexture !== !1
    )
  }
  function rt(ie) {
    const Z = o.render.frame
    h.get(ie) !== Z && (h.set(ie, Z), ie.update())
  }
  function jt(ie, Z) {
    const Se = ie.colorSpace,
      Ue = ie.format,
      Ge = ie.type
    return (
      ie.isCompressedTexture === !0 ||
        ie.isVideoTexture === !0 ||
        (Se !== Aa &&
          Se !== vl &&
          (Cn.getTransfer(Se) === zn
            ? (Ue !== Ii || Ge !== _s) &&
              console.warn(
                'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.',
              )
            : console.error(
                'THREE.WebGLTextures: Unsupported texture color space:',
                Se,
              ))),
      Z
    )
  }
  function at(ie) {
    return (
      typeof HTMLImageElement < 'u' && ie instanceof HTMLImageElement
        ? ((u.width = ie.naturalWidth || ie.width),
          (u.height = ie.naturalHeight || ie.height))
        : typeof VideoFrame < 'u' && ie instanceof VideoFrame
        ? ((u.width = ie.displayWidth), (u.height = ie.displayHeight))
        : ((u.width = ie.width), (u.height = ie.height)),
      u
    )
  }
  ;(this.allocateTextureUnit = te),
    (this.resetTextureUnits = $),
    (this.setTexture2D = K),
    (this.setTexture2DArray = J),
    (this.setTexture3D = ne),
    (this.setTextureCube = V),
    (this.rebindTextures = ft),
    (this.setupRenderTarget = Vt),
    (this.updateRenderTargetMipmap = je),
    (this.updateMultisampleRenderTarget = Rt),
    (this.setupDepthRenderbuffer = et),
    (this.setupFrameBufferTexture = Te),
    (this.useMultisampledRTT = _t)
}
function DN(n, e) {
  function t(i, r = vl) {
    let s
    const o = Cn.getTransfer(r)
    if (i === _s) return n.UNSIGNED_BYTE
    if (i === Wx) return n.UNSIGNED_SHORT_4_4_4_4
    if (i === $x) return n.UNSIGNED_SHORT_5_5_5_1
    if (i === QM) return n.UNSIGNED_INT_5_9_9_9_REV
    if (i === Hx) return n.BYTE
    if (i === Gx) return n.SHORT
    if (i === ph) return n.UNSIGNED_SHORT
    if (i === Tg) return n.INT
    if (i === Ta) return n.UNSIGNED_INT
    if (i === gi) return n.FLOAT
    if (i === or) return n.HALF_FLOAT
    if (i === JM) return n.ALPHA
    if (i === eE) return n.RGB
    if (i === Ii) return n.RGBA
    if (i === tE) return n.LUMINANCE
    if (i === nE) return n.LUMINANCE_ALPHA
    if (i === ad) return n.DEPTH_COMPONENT
    if (i === md) return n.DEPTH_STENCIL
    if (i === Ag) return n.RED
    if (i === Cg) return n.RED_INTEGER
    if (i === iE) return n.RG
    if (i === Xx) return n.RG_INTEGER
    if (i === qx) return n.RGBA_INTEGER
    if (i === vm || i === ym || i === xm || i === _m)
      if (o === zn)
        if (((s = e.get('WEBGL_compressed_texture_s3tc_srgb')), s !== null)) {
          if (i === vm) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT
          if (i === ym) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
          if (i === xm) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
          if (i === _m) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } else return null
      else if (((s = e.get('WEBGL_compressed_texture_s3tc')), s !== null)) {
        if (i === vm) return s.COMPRESSED_RGB_S3TC_DXT1_EXT
        if (i === ym) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT
        if (i === xm) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT
        if (i === _m) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } else return null
    if (i === Vy || i === jy || i === Hy || i === Gy)
      if (((s = e.get('WEBGL_compressed_texture_pvrtc')), s !== null)) {
        if (i === Vy) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        if (i === jy) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        if (i === Hy) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        if (i === Gy) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
      } else return null
    if (i === Wy || i === $y || i === Xy)
      if (((s = e.get('WEBGL_compressed_texture_etc')), s !== null)) {
        if (i === Wy || i === $y)
          return o === zn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2
        if (i === Xy)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC
      } else return null
    if (
      i === qy ||
      i === Yy ||
      i === Zy ||
      i === Ky ||
      i === Qy ||
      i === Jy ||
      i === ex ||
      i === tx ||
      i === nx ||
      i === ix ||
      i === rx ||
      i === sx ||
      i === ox ||
      i === ax
    )
      if (((s = e.get('WEBGL_compressed_texture_astc')), s !== null)) {
        if (i === qy)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR
        if (i === Yy)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR
        if (i === Zy)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR
        if (i === Ky)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR
        if (i === Qy)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR
        if (i === Jy)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR
        if (i === ex)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR
        if (i === tx)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR
        if (i === nx)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR
        if (i === ix)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR
        if (i === rx)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR
        if (i === sx)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR
        if (i === ox)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR
        if (i === ax)
          return o === zn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR
      } else return null
    if (i === wm || i === lx || i === cx)
      if (((s = e.get('EXT_texture_compression_bptc')), s !== null)) {
        if (i === wm)
          return o === zn
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
        if (i === lx) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT
        if (i === cx) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
      } else return null
    if (i === rE || i === ux || i === dx || i === fx)
      if (((s = e.get('EXT_texture_compression_rgtc')), s !== null)) {
        if (i === wm) return s.COMPRESSED_RED_RGTC1_EXT
        if (i === ux) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT
        if (i === dx) return s.COMPRESSED_RED_GREEN_RGTC2_EXT
        if (i === fx) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } else return null
    return i === pd ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null
  }
  return { convert: t }
}
const pG = { type: 'move' }
class uw {
  constructor() {
    ;(this._targetRay = null), (this._grip = null), (this._hand = null)
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Yf()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    )
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Yf()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new re()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new re())),
      this._targetRay
    )
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Yf()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new re()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new re())),
      this._grip
    )
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    )
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i)
    }
    return this.dispatchEvent({ type: 'connected', data: e }), this
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: 'disconnected', data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    )
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null
    const a = this._targetRay,
      c = this._grip,
      u = this._hand
    if (e && t.session.visibilityState !== 'visible-blurred') {
      if (u && e.hand) {
        o = !0
        for (const M of e.hand.values()) {
          const w = t.getJointPose(M, i),
            x = this._getHandJoint(u, M)
          w !== null &&
            (x.matrix.fromArray(w.transform.matrix),
            x.matrix.decompose(x.position, x.rotation, x.scale),
            (x.matrixWorldNeedsUpdate = !0),
            (x.jointRadius = w.radius)),
            (x.visible = w !== null)
        }
        const h = u.joints['index-finger-tip'],
          m = u.joints['thumb-tip'],
          g = h.position.distanceTo(m.position),
          y = 0.02,
          _ = 0.005
        u.inputState.pinching && g > y + _
          ? ((u.inputState.pinching = !1),
            this.dispatchEvent({
              type: 'pinchend',
              handedness: e.handedness,
              target: this,
            }))
          : !u.inputState.pinching &&
            g <= y - _ &&
            ((u.inputState.pinching = !0),
            this.dispatchEvent({
              type: 'pinchstart',
              handedness: e.handedness,
              target: this,
            }))
      } else
        c !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (c.matrix.fromArray(s.transform.matrix),
            c.matrix.decompose(c.position, c.rotation, c.scale),
            (c.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((c.hasLinearVelocity = !0),
                c.linearVelocity.copy(s.linearVelocity))
              : (c.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((c.hasAngularVelocity = !0),
                c.angularVelocity.copy(s.angularVelocity))
              : (c.hasAngularVelocity = !1)))
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(pG)))
    }
    return (
      a !== null && (a.visible = r !== null),
      c !== null && (c.visible = s !== null),
      u !== null && (u.visible = o !== null),
      this
    )
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Yf()
      ;(i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i)
    }
    return e.joints[t.jointName]
  }
}
const mG = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  gG = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`
class vG {
  constructor() {
    ;(this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0)
  }
  init(e, t, i) {
    if (this.texture === null) {
      const r = new Xn(),
        s = e.properties.get(r)
      ;(s.__webglTexture = t.texture),
        (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = r)
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        i = new ws({
          vertexShader: mG,
          fragmentShader: gG,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        })
      this.mesh = new vi(new Uc(20, 20), i)
    }
    return this.mesh
  }
  reset() {
    ;(this.texture = null), (this.mesh = null)
  }
  getDepthTexture() {
    return this.texture
  }
}
class yG extends Pa {
  constructor(e, t) {
    super()
    const i = this
    let r = null,
      s = 1,
      o = null,
      a = 'local-floor',
      c = 1,
      u = null,
      h = null,
      m = null,
      g = null,
      y = null,
      _ = null
    const M = new vG(),
      w = t.getContextAttributes()
    let x = null,
      T = null
    const A = [],
      P = [],
      D = new qe()
    let O = null
    const U = new sr()
    U.viewport = new In()
    const F = new sr()
    F.viewport = new In()
    const N = [U, F],
      k = new EN()
    let z = null,
      $ = null
    ;(this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (he) {
        let Ce = A[he]
        return (
          Ce === void 0 && ((Ce = new uw()), (A[he] = Ce)),
          Ce.getTargetRaySpace()
        )
      }),
      (this.getControllerGrip = function (he) {
        let Ce = A[he]
        return (
          Ce === void 0 && ((Ce = new uw()), (A[he] = Ce)), Ce.getGripSpace()
        )
      }),
      (this.getHand = function (he) {
        let Ce = A[he]
        return (
          Ce === void 0 && ((Ce = new uw()), (A[he] = Ce)), Ce.getHandSpace()
        )
      })
    function te(he) {
      const Ce = P.indexOf(he.inputSource)
      if (Ce === -1) return
      const Te = A[Ce]
      Te !== void 0 &&
        (Te.update(he.inputSource, he.frame, u || o),
        Te.dispatchEvent({ type: he.type, data: he.inputSource }))
    }
    function j() {
      r.removeEventListener('select', te),
        r.removeEventListener('selectstart', te),
        r.removeEventListener('selectend', te),
        r.removeEventListener('squeeze', te),
        r.removeEventListener('squeezestart', te),
        r.removeEventListener('squeezeend', te),
        r.removeEventListener('end', j),
        r.removeEventListener('inputsourceschange', K)
      for (let he = 0; he < A.length; he++) {
        const Ce = P[he]
        Ce !== null && ((P[he] = null), A[he].disconnect(Ce))
      }
      ;(z = null),
        ($ = null),
        M.reset(),
        e.setRenderTarget(x),
        (y = null),
        (g = null),
        (m = null),
        (r = null),
        (T = null),
        _e.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(O),
        e.setSize(D.width, D.height, !1),
        i.dispatchEvent({ type: 'sessionend' })
    }
    ;(this.setFramebufferScaleFactor = function (he) {
      ;(s = he),
        i.isPresenting === !0 &&
          console.warn(
            'THREE.WebXRManager: Cannot change framebuffer scale while presenting.',
          )
    }),
      (this.setReferenceSpaceType = function (he) {
        ;(a = he),
          i.isPresenting === !0 &&
            console.warn(
              'THREE.WebXRManager: Cannot change reference space type while presenting.',
            )
      }),
      (this.getReferenceSpace = function () {
        return u || o
      }),
      (this.setReferenceSpace = function (he) {
        u = he
      }),
      (this.getBaseLayer = function () {
        return g !== null ? g : y
      }),
      (this.getBinding = function () {
        return m
      }),
      (this.getFrame = function () {
        return _
      }),
      (this.getSession = function () {
        return r
      }),
      (this.setSession = async function (he) {
        if (((r = he), r !== null)) {
          if (
            ((x = e.getRenderTarget()),
            r.addEventListener('select', te),
            r.addEventListener('selectstart', te),
            r.addEventListener('selectend', te),
            r.addEventListener('squeeze', te),
            r.addEventListener('squeezestart', te),
            r.addEventListener('squeezeend', te),
            r.addEventListener('end', j),
            r.addEventListener('inputsourceschange', K),
            w.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (O = e.getPixelRatio()),
            e.getSize(D),
            r.enabledFeatures !== void 0 &&
              r.enabledFeatures.includes('layers'))
          ) {
            let Te = null,
              Pe = null,
              Be = null
            w.depth &&
              ((Be = w.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (Te = w.stencil ? md : ad),
              (Pe = w.stencil ? pd : Ta))
            const et = { colorFormat: t.RGBA8, depthFormat: Be, scaleFactor: s }
            ;(m = new XRWebGLBinding(r, t)),
              (g = m.createProjectionLayer(et)),
              r.updateRenderState({ layers: [g] }),
              e.setPixelRatio(1),
              e.setSize(g.textureWidth, g.textureHeight, !1),
              (T = new uo(g.textureWidth, g.textureHeight, {
                format: Ii,
                type: _s,
                depthTexture: new pE(
                  g.textureWidth,
                  g.textureHeight,
                  Pe,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Te,
                ),
                stencilBuffer: w.stencil,
                colorSpace: e.outputColorSpace,
                samples: w.antialias ? 4 : 0,
                resolveDepthBuffer: g.ignoreDepthValues === !1,
              }))
          } else {
            const Te = {
              antialias: w.antialias,
              alpha: !0,
              depth: w.depth,
              stencil: w.stencil,
              framebufferScaleFactor: s,
            }
            ;(y = new XRWebGLLayer(r, t, Te)),
              r.updateRenderState({ baseLayer: y }),
              e.setPixelRatio(1),
              e.setSize(y.framebufferWidth, y.framebufferHeight, !1),
              (T = new uo(y.framebufferWidth, y.framebufferHeight, {
                format: Ii,
                type: _s,
                colorSpace: e.outputColorSpace,
                stencilBuffer: w.stencil,
              }))
          }
          ;(T.isXRRenderTarget = !0),
            this.setFoveation(c),
            (u = null),
            (o = await r.requestReferenceSpace(a)),
            _e.setContext(r),
            _e.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: 'sessionstart' })
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode
      }),
      (this.getDepthTexture = function () {
        return M.getDepthTexture()
      })
    function K(he) {
      for (let Ce = 0; Ce < he.removed.length; Ce++) {
        const Te = he.removed[Ce],
          Pe = P.indexOf(Te)
        Pe >= 0 && ((P[Pe] = null), A[Pe].disconnect(Te))
      }
      for (let Ce = 0; Ce < he.added.length; Ce++) {
        const Te = he.added[Ce]
        let Pe = P.indexOf(Te)
        if (Pe === -1) {
          for (let et = 0; et < A.length; et++)
            if (et >= P.length) {
              P.push(Te), (Pe = et)
              break
            } else if (P[et] === null) {
              ;(P[et] = Te), (Pe = et)
              break
            }
          if (Pe === -1) break
        }
        const Be = A[Pe]
        Be && Be.connect(Te)
      }
    }
    const J = new re(),
      ne = new re()
    function V(he, Ce, Te) {
      J.setFromMatrixPosition(Ce.matrixWorld),
        ne.setFromMatrixPosition(Te.matrixWorld)
      const Pe = J.distanceTo(ne),
        Be = Ce.projectionMatrix.elements,
        et = Te.projectionMatrix.elements,
        ft = Be[14] / (Be[10] - 1),
        Vt = Be[14] / (Be[10] + 1),
        je = (Be[9] + 1) / Be[5],
        $e = (Be[9] - 1) / Be[5],
        se = (Be[8] - 1) / Be[0],
        Rt = (et[8] + 1) / et[0],
        Qe = ft * se,
        _t = ft * Rt,
        rt = Pe / (-se + Rt),
        jt = rt * -se
      if (
        (Ce.matrixWorld.decompose(he.position, he.quaternion, he.scale),
        he.translateX(jt),
        he.translateZ(rt),
        he.matrixWorld.compose(he.position, he.quaternion, he.scale),
        he.matrixWorldInverse.copy(he.matrixWorld).invert(),
        Be[10] === -1)
      )
        he.projectionMatrix.copy(Ce.projectionMatrix),
          he.projectionMatrixInverse.copy(Ce.projectionMatrixInverse)
      else {
        const at = ft + rt,
          ie = Vt + rt,
          Z = Qe - jt,
          Se = _t + (Pe - jt),
          Ue = ((je * Vt) / ie) * at,
          Ge = (($e * Vt) / ie) * at
        he.projectionMatrix.makePerspective(Z, Se, Ue, Ge, at, ie),
          he.projectionMatrixInverse.copy(he.projectionMatrix).invert()
      }
    }
    function Y(he, Ce) {
      Ce === null
        ? he.matrixWorld.copy(he.matrix)
        : he.matrixWorld.multiplyMatrices(Ce.matrixWorld, he.matrix),
        he.matrixWorldInverse.copy(he.matrixWorld).invert()
    }
    this.updateCamera = function (he) {
      if (r === null) return
      let Ce = he.near,
        Te = he.far
      M.texture !== null &&
        (M.depthNear > 0 && (Ce = M.depthNear),
        M.depthFar > 0 && (Te = M.depthFar)),
        (k.near = F.near = U.near = Ce),
        (k.far = F.far = U.far = Te),
        (z !== k.near || $ !== k.far) &&
          (r.updateRenderState({ depthNear: k.near, depthFar: k.far }),
          (z = k.near),
          ($ = k.far)),
        (U.layers.mask = he.layers.mask | 2),
        (F.layers.mask = he.layers.mask | 4),
        (k.layers.mask = U.layers.mask | F.layers.mask)
      const Pe = he.parent,
        Be = k.cameras
      Y(k, Pe)
      for (let et = 0; et < Be.length; et++) Y(Be[et], Pe)
      Be.length === 2
        ? V(k, U, F)
        : k.projectionMatrix.copy(U.projectionMatrix),
        Q(he, k, Pe)
    }
    function Q(he, Ce, Te) {
      Te === null
        ? he.matrix.copy(Ce.matrixWorld)
        : (he.matrix.copy(Te.matrixWorld),
          he.matrix.invert(),
          he.matrix.multiply(Ce.matrixWorld)),
        he.matrix.decompose(he.position, he.quaternion, he.scale),
        he.updateMatrixWorld(!0),
        he.projectionMatrix.copy(Ce.projectionMatrix),
        he.projectionMatrixInverse.copy(Ce.projectionMatrixInverse),
        he.isPerspectiveCamera &&
          ((he.fov = mh * 2 * Math.atan(1 / he.projectionMatrix.elements[5])),
          (he.zoom = 1))
    }
    ;(this.getCamera = function () {
      return k
    }),
      (this.getFoveation = function () {
        if (!(g === null && y === null)) return c
      }),
      (this.setFoveation = function (he) {
        ;(c = he),
          g !== null && (g.fixedFoveation = he),
          y !== null && y.fixedFoveation !== void 0 && (y.fixedFoveation = he)
      }),
      (this.hasDepthSensing = function () {
        return M.texture !== null
      }),
      (this.getDepthSensingMesh = function () {
        return M.getMesh(k)
      })
    let q = null
    function oe(he, Ce) {
      if (((h = Ce.getViewerPose(u || o)), (_ = Ce), h !== null)) {
        const Te = h.views
        y !== null &&
          (e.setRenderTargetFramebuffer(T, y.framebuffer), e.setRenderTarget(T))
        let Pe = !1
        Te.length !== k.cameras.length && ((k.cameras.length = 0), (Pe = !0))
        for (let et = 0; et < Te.length; et++) {
          const ft = Te[et]
          let Vt = null
          if (y !== null) Vt = y.getViewport(ft)
          else {
            const $e = m.getViewSubImage(g, ft)
            ;(Vt = $e.viewport),
              et === 0 &&
                (e.setRenderTargetTextures(
                  T,
                  $e.colorTexture,
                  g.ignoreDepthValues ? void 0 : $e.depthStencilTexture,
                ),
                e.setRenderTarget(T))
          }
          let je = N[et]
          je === void 0 &&
            ((je = new sr()),
            je.layers.enable(et),
            (je.viewport = new In()),
            (N[et] = je)),
            je.matrix.fromArray(ft.transform.matrix),
            je.matrix.decompose(je.position, je.quaternion, je.scale),
            je.projectionMatrix.fromArray(ft.projectionMatrix),
            je.projectionMatrixInverse.copy(je.projectionMatrix).invert(),
            je.viewport.set(Vt.x, Vt.y, Vt.width, Vt.height),
            et === 0 &&
              (k.matrix.copy(je.matrix),
              k.matrix.decompose(k.position, k.quaternion, k.scale)),
            Pe === !0 && k.cameras.push(je)
        }
        const Be = r.enabledFeatures
        if (Be && Be.includes('depth-sensing')) {
          const et = m.getDepthInformation(Te[0])
          et && et.isValid && et.texture && M.init(e, et, r.renderState)
        }
      }
      for (let Te = 0; Te < A.length; Te++) {
        const Pe = P[Te],
          Be = A[Te]
        Pe !== null && Be !== void 0 && Be.update(Pe, Ce, u || o)
      }
      q && q(he, Ce),
        Ce.detectedPlanes &&
          i.dispatchEvent({ type: 'planesdetected', data: Ce }),
        (_ = null)
    }
    const _e = new PN()
    _e.setAnimationLoop(oe),
      (this.setAnimationLoop = function (he) {
        q = he
      }),
      (this.dispose = function () {})
  }
}
const Bu = new Us(),
  xG = new Jt()
function _G(n, e) {
  function t(w, x) {
    w.matrixAutoUpdate === !0 && w.updateMatrix(), x.value.copy(w.matrix)
  }
  function i(w, x) {
    x.color.getRGB(w.fogColor.value, LL(n)),
      x.isFog
        ? ((w.fogNear.value = x.near), (w.fogFar.value = x.far))
        : x.isFogExp2 && (w.fogDensity.value = x.density)
  }
  function r(w, x, T, A, P) {
    x.isMeshBasicMaterial || x.isMeshLambertMaterial
      ? s(w, x)
      : x.isMeshToonMaterial
      ? (s(w, x), m(w, x))
      : x.isMeshPhongMaterial
      ? (s(w, x), h(w, x))
      : x.isMeshStandardMaterial
      ? (s(w, x), g(w, x), x.isMeshPhysicalMaterial && y(w, x, P))
      : x.isMeshMatcapMaterial
      ? (s(w, x), _(w, x))
      : x.isMeshDepthMaterial
      ? s(w, x)
      : x.isMeshDistanceMaterial
      ? (s(w, x), M(w, x))
      : x.isMeshNormalMaterial
      ? s(w, x)
      : x.isLineBasicMaterial
      ? (o(w, x), x.isLineDashedMaterial && a(w, x))
      : x.isPointsMaterial
      ? c(w, x, T, A)
      : x.isSpriteMaterial
      ? u(w, x)
      : x.isShadowMaterial
      ? (w.color.value.copy(x.color), (w.opacity.value = x.opacity))
      : x.isShaderMaterial && (x.uniformsNeedUpdate = !1)
  }
  function s(w, x) {
    ;(w.opacity.value = x.opacity),
      x.color && w.diffuse.value.copy(x.color),
      x.emissive &&
        w.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity),
      x.map && ((w.map.value = x.map), t(x.map, w.mapTransform)),
      x.alphaMap &&
        ((w.alphaMap.value = x.alphaMap), t(x.alphaMap, w.alphaMapTransform)),
      x.bumpMap &&
        ((w.bumpMap.value = x.bumpMap),
        t(x.bumpMap, w.bumpMapTransform),
        (w.bumpScale.value = x.bumpScale),
        x.side === Qr && (w.bumpScale.value *= -1)),
      x.normalMap &&
        ((w.normalMap.value = x.normalMap),
        t(x.normalMap, w.normalMapTransform),
        w.normalScale.value.copy(x.normalScale),
        x.side === Qr && w.normalScale.value.negate()),
      x.displacementMap &&
        ((w.displacementMap.value = x.displacementMap),
        t(x.displacementMap, w.displacementMapTransform),
        (w.displacementScale.value = x.displacementScale),
        (w.displacementBias.value = x.displacementBias)),
      x.emissiveMap &&
        ((w.emissiveMap.value = x.emissiveMap),
        t(x.emissiveMap, w.emissiveMapTransform)),
      x.specularMap &&
        ((w.specularMap.value = x.specularMap),
        t(x.specularMap, w.specularMapTransform)),
      x.alphaTest > 0 && (w.alphaTest.value = x.alphaTest)
    const T = e.get(x),
      A = T.envMap,
      P = T.envMapRotation
    A &&
      ((w.envMap.value = A),
      Bu.copy(P),
      (Bu.x *= -1),
      (Bu.y *= -1),
      (Bu.z *= -1),
      A.isCubeTexture &&
        A.isRenderTargetTexture === !1 &&
        ((Bu.y *= -1), (Bu.z *= -1)),
      w.envMapRotation.value.setFromMatrix4(xG.makeRotationFromEuler(Bu)),
      (w.flipEnvMap.value =
        A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1),
      (w.reflectivity.value = x.reflectivity),
      (w.ior.value = x.ior),
      (w.refractionRatio.value = x.refractionRatio)),
      x.lightMap &&
        ((w.lightMap.value = x.lightMap),
        (w.lightMapIntensity.value = x.lightMapIntensity),
        t(x.lightMap, w.lightMapTransform)),
      x.aoMap &&
        ((w.aoMap.value = x.aoMap),
        (w.aoMapIntensity.value = x.aoMapIntensity),
        t(x.aoMap, w.aoMapTransform))
  }
  function o(w, x) {
    w.diffuse.value.copy(x.color),
      (w.opacity.value = x.opacity),
      x.map && ((w.map.value = x.map), t(x.map, w.mapTransform))
  }
  function a(w, x) {
    ;(w.dashSize.value = x.dashSize),
      (w.totalSize.value = x.dashSize + x.gapSize),
      (w.scale.value = x.scale)
  }
  function c(w, x, T, A) {
    w.diffuse.value.copy(x.color),
      (w.opacity.value = x.opacity),
      (w.size.value = x.size * T),
      (w.scale.value = A * 0.5),
      x.map && ((w.map.value = x.map), t(x.map, w.uvTransform)),
      x.alphaMap &&
        ((w.alphaMap.value = x.alphaMap), t(x.alphaMap, w.alphaMapTransform)),
      x.alphaTest > 0 && (w.alphaTest.value = x.alphaTest)
  }
  function u(w, x) {
    w.diffuse.value.copy(x.color),
      (w.opacity.value = x.opacity),
      (w.rotation.value = x.rotation),
      x.map && ((w.map.value = x.map), t(x.map, w.mapTransform)),
      x.alphaMap &&
        ((w.alphaMap.value = x.alphaMap), t(x.alphaMap, w.alphaMapTransform)),
      x.alphaTest > 0 && (w.alphaTest.value = x.alphaTest)
  }
  function h(w, x) {
    w.specular.value.copy(x.specular),
      (w.shininess.value = Math.max(x.shininess, 1e-4))
  }
  function m(w, x) {
    x.gradientMap && (w.gradientMap.value = x.gradientMap)
  }
  function g(w, x) {
    ;(w.metalness.value = x.metalness),
      x.metalnessMap &&
        ((w.metalnessMap.value = x.metalnessMap),
        t(x.metalnessMap, w.metalnessMapTransform)),
      (w.roughness.value = x.roughness),
      x.roughnessMap &&
        ((w.roughnessMap.value = x.roughnessMap),
        t(x.roughnessMap, w.roughnessMapTransform)),
      x.envMap && (w.envMapIntensity.value = x.envMapIntensity)
  }
  function y(w, x, T) {
    ;(w.ior.value = x.ior),
      x.sheen > 0 &&
        (w.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen),
        (w.sheenRoughness.value = x.sheenRoughness),
        x.sheenColorMap &&
          ((w.sheenColorMap.value = x.sheenColorMap),
          t(x.sheenColorMap, w.sheenColorMapTransform)),
        x.sheenRoughnessMap &&
          ((w.sheenRoughnessMap.value = x.sheenRoughnessMap),
          t(x.sheenRoughnessMap, w.sheenRoughnessMapTransform))),
      x.clearcoat > 0 &&
        ((w.clearcoat.value = x.clearcoat),
        (w.clearcoatRoughness.value = x.clearcoatRoughness),
        x.clearcoatMap &&
          ((w.clearcoatMap.value = x.clearcoatMap),
          t(x.clearcoatMap, w.clearcoatMapTransform)),
        x.clearcoatRoughnessMap &&
          ((w.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap),
          t(x.clearcoatRoughnessMap, w.clearcoatRoughnessMapTransform)),
        x.clearcoatNormalMap &&
          ((w.clearcoatNormalMap.value = x.clearcoatNormalMap),
          t(x.clearcoatNormalMap, w.clearcoatNormalMapTransform),
          w.clearcoatNormalScale.value.copy(x.clearcoatNormalScale),
          x.side === Qr && w.clearcoatNormalScale.value.negate())),
      x.dispersion > 0 && (w.dispersion.value = x.dispersion),
      x.iridescence > 0 &&
        ((w.iridescence.value = x.iridescence),
        (w.iridescenceIOR.value = x.iridescenceIOR),
        (w.iridescenceThicknessMinimum.value = x.iridescenceThicknessRange[0]),
        (w.iridescenceThicknessMaximum.value = x.iridescenceThicknessRange[1]),
        x.iridescenceMap &&
          ((w.iridescenceMap.value = x.iridescenceMap),
          t(x.iridescenceMap, w.iridescenceMapTransform)),
        x.iridescenceThicknessMap &&
          ((w.iridescenceThicknessMap.value = x.iridescenceThicknessMap),
          t(x.iridescenceThicknessMap, w.iridescenceThicknessMapTransform))),
      x.transmission > 0 &&
        ((w.transmission.value = x.transmission),
        (w.transmissionSamplerMap.value = T.texture),
        w.transmissionSamplerSize.value.set(T.width, T.height),
        x.transmissionMap &&
          ((w.transmissionMap.value = x.transmissionMap),
          t(x.transmissionMap, w.transmissionMapTransform)),
        (w.thickness.value = x.thickness),
        x.thicknessMap &&
          ((w.thicknessMap.value = x.thicknessMap),
          t(x.thicknessMap, w.thicknessMapTransform)),
        (w.attenuationDistance.value = x.attenuationDistance),
        w.attenuationColor.value.copy(x.attenuationColor)),
      x.anisotropy > 0 &&
        (w.anisotropyVector.value.set(
          x.anisotropy * Math.cos(x.anisotropyRotation),
          x.anisotropy * Math.sin(x.anisotropyRotation),
        ),
        x.anisotropyMap &&
          ((w.anisotropyMap.value = x.anisotropyMap),
          t(x.anisotropyMap, w.anisotropyMapTransform))),
      (w.specularIntensity.value = x.specularIntensity),
      w.specularColor.value.copy(x.specularColor),
      x.specularColorMap &&
        ((w.specularColorMap.value = x.specularColorMap),
        t(x.specularColorMap, w.specularColorMapTransform)),
      x.specularIntensityMap &&
        ((w.specularIntensityMap.value = x.specularIntensityMap),
        t(x.specularIntensityMap, w.specularIntensityMapTransform))
  }
  function _(w, x) {
    x.matcap && (w.matcap.value = x.matcap)
  }
  function M(w, x) {
    const T = e.get(x).light
    w.referencePosition.value.setFromMatrixPosition(T.matrixWorld),
      (w.nearDistance.value = T.shadow.camera.near),
      (w.farDistance.value = T.shadow.camera.far)
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r }
}
function wG(n, e, t, i) {
  let r = {},
    s = {},
    o = []
  const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS)
  function c(T, A) {
    const P = A.program
    i.uniformBlockBinding(T, P)
  }
  function u(T, A) {
    let P = r[T.id]
    P === void 0 &&
      (_(T), (P = h(T)), (r[T.id] = P), T.addEventListener('dispose', w))
    const D = A.program
    i.updateUBOMapping(T, D)
    const O = e.render.frame
    s[T.id] !== O && (g(T), (s[T.id] = O))
  }
  function h(T) {
    const A = m()
    T.__bindingPointIndex = A
    const P = n.createBuffer(),
      D = T.__size,
      O = T.usage
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, P),
      n.bufferData(n.UNIFORM_BUFFER, D, O),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, A, P),
      P
    )
  }
  function m() {
    for (let T = 0; T < a; T++) if (o.indexOf(T) === -1) return o.push(T), T
    return (
      console.error(
        'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.',
      ),
      0
    )
  }
  function g(T) {
    const A = r[T.id],
      P = T.uniforms,
      D = T.__cache
    n.bindBuffer(n.UNIFORM_BUFFER, A)
    for (let O = 0, U = P.length; O < U; O++) {
      const F = Array.isArray(P[O]) ? P[O] : [P[O]]
      for (let N = 0, k = F.length; N < k; N++) {
        const z = F[N]
        if (y(z, O, N, D) === !0) {
          const $ = z.__offset,
            te = Array.isArray(z.value) ? z.value : [z.value]
          let j = 0
          for (let K = 0; K < te.length; K++) {
            const J = te[K],
              ne = M(J)
            typeof J == 'number' || typeof J == 'boolean'
              ? ((z.__data[0] = J),
                n.bufferSubData(n.UNIFORM_BUFFER, $ + j, z.__data))
              : J.isMatrix3
              ? ((z.__data[0] = J.elements[0]),
                (z.__data[1] = J.elements[1]),
                (z.__data[2] = J.elements[2]),
                (z.__data[3] = 0),
                (z.__data[4] = J.elements[3]),
                (z.__data[5] = J.elements[4]),
                (z.__data[6] = J.elements[5]),
                (z.__data[7] = 0),
                (z.__data[8] = J.elements[6]),
                (z.__data[9] = J.elements[7]),
                (z.__data[10] = J.elements[8]),
                (z.__data[11] = 0))
              : (J.toArray(z.__data, j),
                (j += ne.storage / Float32Array.BYTES_PER_ELEMENT))
          }
          n.bufferSubData(n.UNIFORM_BUFFER, $, z.__data)
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null)
  }
  function y(T, A, P, D) {
    const O = T.value,
      U = A + '_' + P
    if (D[U] === void 0)
      return (
        typeof O == 'number' || typeof O == 'boolean'
          ? (D[U] = O)
          : (D[U] = O.clone()),
        !0
      )
    {
      const F = D[U]
      if (typeof O == 'number' || typeof O == 'boolean') {
        if (F !== O) return (D[U] = O), !0
      } else if (F.equals(O) === !1) return F.copy(O), !0
    }
    return !1
  }
  function _(T) {
    const A = T.uniforms
    let P = 0
    const D = 16
    for (let U = 0, F = A.length; U < F; U++) {
      const N = Array.isArray(A[U]) ? A[U] : [A[U]]
      for (let k = 0, z = N.length; k < z; k++) {
        const $ = N[k],
          te = Array.isArray($.value) ? $.value : [$.value]
        for (let j = 0, K = te.length; j < K; j++) {
          const J = te[j],
            ne = M(J),
            V = P % D,
            Y = V % ne.boundary,
            Q = V + Y
          ;(P += Y),
            Q !== 0 && D - Q < ne.storage && (P += D - Q),
            ($.__data = new Float32Array(
              ne.storage / Float32Array.BYTES_PER_ELEMENT,
            )),
            ($.__offset = P),
            (P += ne.storage)
        }
      }
    }
    const O = P % D
    return O > 0 && (P += D - O), (T.__size = P), (T.__cache = {}), this
  }
  function M(T) {
    const A = { boundary: 0, storage: 0 }
    return (
      typeof T == 'number' || typeof T == 'boolean'
        ? ((A.boundary = 4), (A.storage = 4))
        : T.isVector2
        ? ((A.boundary = 8), (A.storage = 8))
        : T.isVector3 || T.isColor
        ? ((A.boundary = 16), (A.storage = 12))
        : T.isVector4
        ? ((A.boundary = 16), (A.storage = 16))
        : T.isMatrix3
        ? ((A.boundary = 48), (A.storage = 48))
        : T.isMatrix4
        ? ((A.boundary = 64), (A.storage = 64))
        : T.isTexture
        ? console.warn(
            'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.',
          )
        : console.warn(
            'THREE.WebGLRenderer: Unsupported uniform value type.',
            T,
          ),
      A
    )
  }
  function w(T) {
    const A = T.target
    A.removeEventListener('dispose', w)
    const P = o.indexOf(A.__bindingPointIndex)
    o.splice(P, 1), n.deleteBuffer(r[A.id]), delete r[A.id], delete s[A.id]
  }
  function x() {
    for (const T in r) n.deleteBuffer(r[T])
    ;(o = []), (r = {}), (s = {})
  }
  return { bind: c, update: u, dispose: x }
}
class UE {
  constructor(e = {}) {
    const {
      canvas: t = PL(),
      context: i = null,
      depth: r = !0,
      stencil: s = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: h = 'default',
      failIfMajorPerformanceCaveat: m = !1,
      reverseDepthBuffer: g = !1,
    } = e
    this.isWebGLRenderer = !0
    let y
    if (i !== null) {
      if (
        typeof WebGLRenderingContext < 'u' &&
        i instanceof WebGLRenderingContext
      )
        throw new Error(
          'THREE.WebGLRenderer: WebGL 1 is not supported since r163.',
        )
      y = i.getContextAttributes().alpha
    } else y = o
    const _ = new Uint32Array(4),
      M = new Int32Array(4)
    let w = null,
      x = null
    const T = [],
      A = []
    ;(this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Zr),
      (this.toneMapping = ya),
      (this.toneMappingExposure = 1)
    const P = this
    let D = !1,
      O = 0,
      U = 0,
      F = null,
      N = -1,
      k = null
    const z = new In(),
      $ = new In()
    let te = null
    const j = new Tt(0)
    let K = 0,
      J = t.width,
      ne = t.height,
      V = 1,
      Y = null,
      Q = null
    const q = new In(0, 0, J, ne),
      oe = new In(0, 0, J, ne)
    let _e = !1
    const he = new Ng()
    let Ce = !1,
      Te = !1
    this.transmissionResolutionScale = 1
    const Pe = new Jt(),
      Be = new Jt(),
      et = new re(),
      ft = new In(),
      Vt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      }
    let je = !1
    function $e() {
      return F === null ? V : 1
    }
    let se = i
    function Rt(G, le) {
      return t.getContext(G, le)
    }
    try {
      const G = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: c,
        preserveDrawingBuffer: u,
        powerPreference: h,
        failIfMajorPerformanceCaveat: m,
      }
      if (
        ('setAttribute' in t &&
          t.setAttribute('data-engine', `three.js r${Eg}`),
        t.addEventListener('webglcontextlost', Ve, !1),
        t.addEventListener('webglcontextrestored', vt, !1),
        t.addEventListener('webglcontextcreationerror', ht, !1),
        se === null)
      ) {
        const le = 'webgl2'
        if (((se = Rt(le, G)), se === null))
          throw Rt(le)
            ? new Error(
                'Error creating WebGL context with your selected attributes.',
              )
            : new Error('Error creating WebGL context.')
      }
    } catch (G) {
      throw (console.error('THREE.WebGLRenderer: ' + G.message), G)
    }
    let Qe,
      _t,
      rt,
      jt,
      at,
      ie,
      Z,
      Se,
      Ue,
      Ge,
      ze,
      Ct,
      ct,
      gt,
      rn,
      Je,
      bt,
      Ut,
      It,
      Mt,
      en,
      Bt,
      Kt,
      ve
    function Ie() {
      ;(Qe = new Lj(se)),
        Qe.init(),
        (Bt = new DN(se, Qe)),
        (_t = new Tj(se, Qe, e, Bt)),
        (rt = new fG(se, Qe)),
        _t.reverseDepthBuffer && g && rt.buffers.depth.setReversed(!0),
        (jt = new Oj(se)),
        (at = new JH()),
        (ie = new hG(se, Qe, rt, at, _t, Bt, jt)),
        (Z = new Cj(P)),
        (Se = new Ij(P)),
        (Ue = new jV(se)),
        (Kt = new Ej(se, Ue)),
        (Ge = new Nj(se, Ue, jt, Kt)),
        (ze = new Fj(se, Ge, Ue, jt)),
        (It = new kj(se, _t, ie)),
        (Je = new Aj(at)),
        (Ct = new QH(P, Z, Se, Qe, _t, Kt, Je)),
        (ct = new _G(P, at)),
        (gt = new tG()),
        (rn = new aG(Qe)),
        (Ut = new Mj(P, Z, Se, rt, ze, y, c)),
        (bt = new uG(P, ze, _t)),
        (ve = new wG(se, jt, _t, rt)),
        (Mt = new bj(se, Qe, jt)),
        (en = new Dj(se, Qe, jt)),
        (jt.programs = Ct.programs),
        (P.capabilities = _t),
        (P.extensions = Qe),
        (P.properties = at),
        (P.renderLists = gt),
        (P.shadowMap = bt),
        (P.state = rt),
        (P.info = jt)
    }
    Ie()
    const Le = new yG(P, se)
    ;(this.xr = Le),
      (this.getContext = function () {
        return se
      }),
      (this.getContextAttributes = function () {
        return se.getContextAttributes()
      }),
      (this.forceContextLoss = function () {
        const G = Qe.get('WEBGL_lose_context')
        G && G.loseContext()
      }),
      (this.forceContextRestore = function () {
        const G = Qe.get('WEBGL_lose_context')
        G && G.restoreContext()
      }),
      (this.getPixelRatio = function () {
        return V
      }),
      (this.setPixelRatio = function (G) {
        G !== void 0 && ((V = G), this.setSize(J, ne, !1))
      }),
      (this.getSize = function (G) {
        return G.set(J, ne)
      }),
      (this.setSize = function (G, le, de = !0) {
        if (Le.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
          )
          return
        }
        ;(J = G),
          (ne = le),
          (t.width = Math.floor(G * V)),
          (t.height = Math.floor(le * V)),
          de === !0 &&
            ((t.style.width = G + 'px'), (t.style.height = le + 'px')),
          this.setViewport(0, 0, G, le)
      }),
      (this.getDrawingBufferSize = function (G) {
        return G.set(J * V, ne * V).floor()
      }),
      (this.setDrawingBufferSize = function (G, le, de) {
        ;(J = G),
          (ne = le),
          (V = de),
          (t.width = Math.floor(G * de)),
          (t.height = Math.floor(le * de)),
          this.setViewport(0, 0, G, le)
      }),
      (this.getCurrentViewport = function (G) {
        return G.copy(z)
      }),
      (this.getViewport = function (G) {
        return G.copy(q)
      }),
      (this.setViewport = function (G, le, de, ce) {
        G.isVector4 ? q.set(G.x, G.y, G.z, G.w) : q.set(G, le, de, ce),
          rt.viewport(z.copy(q).multiplyScalar(V).round())
      }),
      (this.getScissor = function (G) {
        return G.copy(oe)
      }),
      (this.setScissor = function (G, le, de, ce) {
        G.isVector4 ? oe.set(G.x, G.y, G.z, G.w) : oe.set(G, le, de, ce),
          rt.scissor($.copy(oe).multiplyScalar(V).round())
      }),
      (this.getScissorTest = function () {
        return _e
      }),
      (this.setScissorTest = function (G) {
        rt.setScissorTest((_e = G))
      }),
      (this.setOpaqueSort = function (G) {
        Y = G
      }),
      (this.setTransparentSort = function (G) {
        Q = G
      }),
      (this.getClearColor = function (G) {
        return G.copy(Ut.getClearColor())
      }),
      (this.setClearColor = function () {
        Ut.setClearColor.apply(Ut, arguments)
      }),
      (this.getClearAlpha = function () {
        return Ut.getClearAlpha()
      }),
      (this.setClearAlpha = function () {
        Ut.setClearAlpha.apply(Ut, arguments)
      }),
      (this.clear = function (G = !0, le = !0, de = !0) {
        let ce = 0
        if (G) {
          let me = !1
          if (F !== null) {
            const Me = F.texture.format
            me = Me === qx || Me === Xx || Me === Cg
          }
          if (me) {
            const Me = F.texture.type,
              ke =
                Me === _s ||
                Me === Ta ||
                Me === ph ||
                Me === pd ||
                Me === Wx ||
                Me === $x,
              He = Ut.getClearColor(),
              Xe = Ut.getClearAlpha(),
              ut = He.r,
              ot = He.g,
              We = He.b
            ke
              ? ((_[0] = ut),
                (_[1] = ot),
                (_[2] = We),
                (_[3] = Xe),
                se.clearBufferuiv(se.COLOR, 0, _))
              : ((M[0] = ut),
                (M[1] = ot),
                (M[2] = We),
                (M[3] = Xe),
                se.clearBufferiv(se.COLOR, 0, M))
          } else ce |= se.COLOR_BUFFER_BIT
        }
        le && (ce |= se.DEPTH_BUFFER_BIT),
          de &&
            ((ce |= se.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          se.clear(ce)
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1)
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1)
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0)
      }),
      (this.dispose = function () {
        t.removeEventListener('webglcontextlost', Ve, !1),
          t.removeEventListener('webglcontextrestored', vt, !1),
          t.removeEventListener('webglcontextcreationerror', ht, !1),
          Ut.dispose(),
          gt.dispose(),
          rn.dispose(),
          at.dispose(),
          Z.dispose(),
          Se.dispose(),
          ze.dispose(),
          Kt.dispose(),
          ve.dispose(),
          Ct.dispose(),
          Le.dispose(),
          Le.removeEventListener('sessionstart', Ko),
          Le.removeEventListener('sessionend', js),
          ar.stop()
      })
    function Ve(G) {
      G.preventDefault(),
        console.log('THREE.WebGLRenderer: Context Lost.'),
        (D = !0)
    }
    function vt() {
      console.log('THREE.WebGLRenderer: Context Restored.'), (D = !1)
      const G = jt.autoReset,
        le = bt.enabled,
        de = bt.autoUpdate,
        ce = bt.needsUpdate,
        me = bt.type
      Ie(),
        (jt.autoReset = G),
        (bt.enabled = le),
        (bt.autoUpdate = de),
        (bt.needsUpdate = ce),
        (bt.type = me)
    }
    function ht(G) {
      console.error(
        'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
        G.statusMessage,
      )
    }
    function Qt(G) {
      const le = G.target
      le.removeEventListener('dispose', Qt), Un(le)
    }
    function Un(G) {
      si(G), at.remove(G)
    }
    function si(G) {
      const le = at.get(G).programs
      le !== void 0 &&
        (le.forEach(function (de) {
          Ct.releaseProgram(de)
        }),
        G.isShaderMaterial && Ct.releaseShaderCache(G))
    }
    this.renderBufferDirect = function (G, le, de, ce, me, Me) {
      le === null && (le = Vt)
      const ke = me.isMesh && me.matrixWorld.determinant() < 0,
        He = fe(G, le, de, ce, me)
      rt.setMaterial(ce, ke)
      let Xe = de.index,
        ut = 1
      if (ce.wireframe === !0) {
        if (((Xe = Ge.getWireframeAttribute(de)), Xe === void 0)) return
        ut = 2
      }
      const ot = de.drawRange,
        We = de.attributes.position
      let pt = ot.start * ut,
        mt = (ot.start + ot.count) * ut
      Me !== null &&
        ((pt = Math.max(pt, Me.start * ut)),
        (mt = Math.min(mt, (Me.start + Me.count) * ut))),
        Xe !== null
          ? ((pt = Math.max(pt, 0)), (mt = Math.min(mt, Xe.count)))
          : We != null &&
            ((pt = Math.max(pt, 0)), (mt = Math.min(mt, We.count)))
      const qt = mt - pt
      if (qt < 0 || qt === 1 / 0) return
      Kt.setup(me, ce, He, de, Xe)
      let Lt,
        Ot = Mt
      if (
        (Xe !== null && ((Lt = Ue.get(Xe)), (Ot = en), Ot.setIndex(Lt)),
        me.isMesh)
      )
        ce.wireframe === !0
          ? (rt.setLineWidth(ce.wireframeLinewidth * $e()),
            Ot.setMode(se.LINES))
          : Ot.setMode(se.TRIANGLES)
      else if (me.isLine) {
        let wt = ce.linewidth
        wt === void 0 && (wt = 1),
          rt.setLineWidth(wt * $e()),
          me.isLineSegments
            ? Ot.setMode(se.LINES)
            : me.isLineLoop
            ? Ot.setMode(se.LINE_LOOP)
            : Ot.setMode(se.LINE_STRIP)
      } else
        me.isPoints
          ? Ot.setMode(se.POINTS)
          : me.isSprite && Ot.setMode(se.TRIANGLES)
      if (me.isBatchedMesh)
        if (me._multiDrawInstances !== null)
          Ot.renderMultiDrawInstances(
            me._multiDrawStarts,
            me._multiDrawCounts,
            me._multiDrawCount,
            me._multiDrawInstances,
          )
        else if (Qe.get('WEBGL_multi_draw'))
          Ot.renderMultiDraw(
            me._multiDrawStarts,
            me._multiDrawCounts,
            me._multiDrawCount,
          )
        else {
          const wt = me._multiDrawStarts,
            fn = me._multiDrawCounts,
            Ht = me._multiDrawCount,
            tn = Xe ? Ue.get(Xe).bytesPerElement : 1,
            jn = at.get(ce).currentProgram.getUniforms()
          for (let ln = 0; ln < Ht; ln++)
            jn.setValue(se, '_gl_DrawID', ln), Ot.render(wt[ln] / tn, fn[ln])
        }
      else if (me.isInstancedMesh) Ot.renderInstances(pt, qt, me.count)
      else if (de.isInstancedBufferGeometry) {
        const wt =
            de._maxInstanceCount !== void 0 ? de._maxInstanceCount : 1 / 0,
          fn = Math.min(de.instanceCount, wt)
        Ot.renderInstances(pt, qt, fn)
      } else Ot.render(pt, qt)
    }
    function wn(G, le, de) {
      G.transparent === !0 && G.side === oo && G.forceSinglePass === !1
        ? ((G.side = Qr),
          (G.needsUpdate = !0),
          Qo(G, le, de),
          (G.side = Tl),
          (G.needsUpdate = !0),
          Qo(G, le, de),
          (G.side = oo))
        : Qo(G, le, de)
    }
    ;(this.compile = function (G, le, de = null) {
      de === null && (de = G),
        (x = rn.get(de)),
        x.init(le),
        A.push(x),
        de.traverseVisible(function (me) {
          me.isLight &&
            me.layers.test(le.layers) &&
            (x.pushLight(me), me.castShadow && x.pushShadow(me))
        }),
        G !== de &&
          G.traverseVisible(function (me) {
            me.isLight &&
              me.layers.test(le.layers) &&
              (x.pushLight(me), me.castShadow && x.pushShadow(me))
          }),
        x.setupLights()
      const ce = new Set()
      return (
        G.traverse(function (me) {
          if (!(me.isMesh || me.isPoints || me.isLine || me.isSprite)) return
          const Me = me.material
          if (Me)
            if (Array.isArray(Me))
              for (let ke = 0; ke < Me.length; ke++) {
                const He = Me[ke]
                wn(He, de, me), ce.add(He)
              }
            else wn(Me, de, me), ce.add(Me)
        }),
        A.pop(),
        (x = null),
        ce
      )
    }),
      (this.compileAsync = function (G, le, de = null) {
        const ce = this.compile(G, le, de)
        return new Promise((me) => {
          function Me() {
            if (
              (ce.forEach(function (ke) {
                at.get(ke).currentProgram.isReady() && ce.delete(ke)
              }),
              ce.size === 0)
            ) {
              me(G)
              return
            }
            setTimeout(Me, 10)
          }
          Qe.get('KHR_parallel_shader_compile') !== null
            ? Me()
            : setTimeout(Me, 10)
        })
      })
    let zi = null
    function Vi(G) {
      zi && zi(G)
    }
    function Ko() {
      ar.stop()
    }
    function js() {
      ar.start()
    }
    const ar = new PN()
    ar.setAnimationLoop(Vi),
      typeof self < 'u' && ar.setContext(self),
      (this.setAnimationLoop = function (G) {
        ;(zi = G), Le.setAnimationLoop(G), G === null ? ar.stop() : ar.start()
      }),
      Le.addEventListener('sessionstart', Ko),
      Le.addEventListener('sessionend', js),
      (this.render = function (G, le) {
        if (le !== void 0 && le.isCamera !== !0) {
          console.error(
            'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',
          )
          return
        }
        if (D === !0) return
        if (
          (G.matrixWorldAutoUpdate === !0 && G.updateMatrixWorld(),
          le.parent === null &&
            le.matrixWorldAutoUpdate === !0 &&
            le.updateMatrixWorld(),
          Le.enabled === !0 &&
            Le.isPresenting === !0 &&
            (Le.cameraAutoUpdate === !0 && Le.updateCamera(le),
            (le = Le.getCamera())),
          G.isScene === !0 && G.onBeforeRender(P, G, le, F),
          (x = rn.get(G, A.length)),
          x.init(le),
          A.push(x),
          Be.multiplyMatrices(le.projectionMatrix, le.matrixWorldInverse),
          he.setFromProjectionMatrix(Be),
          (Te = this.localClippingEnabled),
          (Ce = Je.init(this.clippingPlanes, Te)),
          (w = gt.get(G, T.length)),
          w.init(),
          T.push(w),
          Le.enabled === !0 && Le.isPresenting === !0)
        ) {
          const Me = P.xr.getDepthSensingMesh()
          Me !== null && kr(Me, le, -1 / 0, P.sortObjects)
        }
        kr(G, le, 0, P.sortObjects),
          w.finish(),
          P.sortObjects === !0 && w.sort(Y, Q),
          (je =
            Le.enabled === !1 ||
            Le.isPresenting === !1 ||
            Le.hasDepthSensing() === !1),
          je && Ut.addToRenderList(w, G),
          this.info.render.frame++,
          Ce === !0 && Je.beginShadows()
        const de = x.state.shadowsArray
        bt.render(de, G, le),
          Ce === !0 && Je.endShadows(),
          this.info.autoReset === !0 && this.info.reset()
        const ce = w.opaque,
          me = w.transmissive
        if ((x.setupLights(), le.isArrayCamera)) {
          const Me = le.cameras
          if (me.length > 0)
            for (let ke = 0, He = Me.length; ke < He; ke++) {
              const Xe = Me[ke]
              ji(ce, me, G, Xe)
            }
          je && Ut.render(G)
          for (let ke = 0, He = Me.length; ke < He; ke++) {
            const Xe = Me[ke]
            Fr(w, G, Xe, Xe.viewport)
          }
        } else
          me.length > 0 && ji(ce, me, G, le), je && Ut.render(G), Fr(w, G, le)
        F !== null &&
          U === 0 &&
          (ie.updateMultisampleRenderTarget(F), ie.updateRenderTargetMipmap(F)),
          G.isScene === !0 && G.onAfterRender(P, G, le),
          Kt.resetDefaultState(),
          (N = -1),
          (k = null),
          A.pop(),
          A.length > 0
            ? ((x = A[A.length - 1]),
              Ce === !0 && Je.setGlobalState(P.clippingPlanes, x.state.camera))
            : (x = null),
          T.pop(),
          T.length > 0 ? (w = T[T.length - 1]) : (w = null)
      })
    function kr(G, le, de, ce) {
      if (G.visible === !1) return
      if (G.layers.test(le.layers)) {
        if (G.isGroup) de = G.renderOrder
        else if (G.isLOD) G.autoUpdate === !0 && G.update(le)
        else if (G.isLight) x.pushLight(G), G.castShadow && x.pushShadow(G)
        else if (G.isSprite) {
          if (!G.frustumCulled || he.intersectsSprite(G)) {
            ce && ft.setFromMatrixPosition(G.matrixWorld).applyMatrix4(Be)
            const ke = ze.update(G),
              He = G.material
            He.visible && w.push(G, ke, He, de, ft.z, null)
          }
        } else if (
          (G.isMesh || G.isLine || G.isPoints) &&
          (!G.frustumCulled || he.intersectsObject(G))
        ) {
          const ke = ze.update(G),
            He = G.material
          if (
            (ce &&
              (G.boundingSphere !== void 0
                ? (G.boundingSphere === null && G.computeBoundingSphere(),
                  ft.copy(G.boundingSphere.center))
                : (ke.boundingSphere === null && ke.computeBoundingSphere(),
                  ft.copy(ke.boundingSphere.center)),
              ft.applyMatrix4(G.matrixWorld).applyMatrix4(Be)),
            Array.isArray(He))
          ) {
            const Xe = ke.groups
            for (let ut = 0, ot = Xe.length; ut < ot; ut++) {
              const We = Xe[ut],
                pt = He[We.materialIndex]
              pt && pt.visible && w.push(G, ke, pt, de, ft.z, We)
            }
          } else He.visible && w.push(G, ke, He, de, ft.z, null)
        }
      }
      const Me = G.children
      for (let ke = 0, He = Me.length; ke < He; ke++) kr(Me[ke], le, de, ce)
    }
    function Fr(G, le, de, ce) {
      const me = G.opaque,
        Me = G.transmissive,
        ke = G.transparent
      x.setupLightsView(de),
        Ce === !0 && Je.setGlobalState(P.clippingPlanes, de),
        ce && rt.viewport(z.copy(ce)),
        me.length > 0 && sn(me, le, de),
        Me.length > 0 && sn(Me, le, de),
        ke.length > 0 && sn(ke, le, de),
        rt.buffers.depth.setTest(!0),
        rt.buffers.depth.setMask(!0),
        rt.buffers.color.setMask(!0),
        rt.setPolygonOffset(!1)
    }
    function ji(G, le, de, ce) {
      if ((de.isScene === !0 ? de.overrideMaterial : null) !== null) return
      x.state.transmissionRenderTarget[ce.id] === void 0 &&
        (x.state.transmissionRenderTarget[ce.id] = new uo(1, 1, {
          generateMipmaps: !0,
          type:
            Qe.has('EXT_color_buffer_half_float') ||
            Qe.has('EXT_color_buffer_float')
              ? or
              : _s,
          minFilter: ma,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Cn.workingColorSpace,
        }))
      const Me = x.state.transmissionRenderTarget[ce.id],
        ke = ce.viewport || z
      Me.setSize(
        ke.z * P.transmissionResolutionScale,
        ke.w * P.transmissionResolutionScale,
      )
      const He = P.getRenderTarget()
      P.setRenderTarget(Me),
        P.getClearColor(j),
        (K = P.getClearAlpha()),
        K < 1 && P.setClearColor(16777215, 0.5),
        P.clear(),
        je && Ut.render(de)
      const Xe = P.toneMapping
      P.toneMapping = ya
      const ut = ce.viewport
      if (
        (ce.viewport !== void 0 && (ce.viewport = void 0),
        x.setupLightsView(ce),
        Ce === !0 && Je.setGlobalState(P.clippingPlanes, ce),
        sn(G, de, ce),
        ie.updateMultisampleRenderTarget(Me),
        ie.updateRenderTargetMipmap(Me),
        Qe.has('WEBGL_multisampled_render_to_texture') === !1)
      ) {
        let ot = !1
        for (let We = 0, pt = le.length; We < pt; We++) {
          const mt = le[We],
            qt = mt.object,
            Lt = mt.geometry,
            Ot = mt.material,
            wt = mt.group
          if (Ot.side === oo && qt.layers.test(ce.layers)) {
            const fn = Ot.side
            ;(Ot.side = Qr),
              (Ot.needsUpdate = !0),
              Ia(qt, de, ce, Lt, Ot, wt),
              (Ot.side = fn),
              (Ot.needsUpdate = !0),
              (ot = !0)
          }
        }
        ot === !0 &&
          (ie.updateMultisampleRenderTarget(Me),
          ie.updateRenderTargetMipmap(Me))
      }
      P.setRenderTarget(He),
        P.setClearColor(j, K),
        ut !== void 0 && (ce.viewport = ut),
        (P.toneMapping = Xe)
    }
    function sn(G, le, de) {
      const ce = le.isScene === !0 ? le.overrideMaterial : null
      for (let me = 0, Me = G.length; me < Me; me++) {
        const ke = G[me],
          He = ke.object,
          Xe = ke.geometry,
          ut = ce === null ? ke.material : ce,
          ot = ke.group
        He.layers.test(de.layers) && Ia(He, le, de, Xe, ut, ot)
      }
    }
    function Ia(G, le, de, ce, me, Me) {
      G.onBeforeRender(P, le, de, ce, me, Me),
        G.modelViewMatrix.multiplyMatrices(
          de.matrixWorldInverse,
          G.matrixWorld,
        ),
        G.normalMatrix.getNormalMatrix(G.modelViewMatrix),
        me.onBeforeRender(P, le, de, ce, G, Me),
        me.transparent === !0 && me.side === oo && me.forceSinglePass === !1
          ? ((me.side = Qr),
            (me.needsUpdate = !0),
            P.renderBufferDirect(de, le, ce, me, G, Me),
            (me.side = Tl),
            (me.needsUpdate = !0),
            P.renderBufferDirect(de, le, ce, me, G, Me),
            (me.side = oo))
          : P.renderBufferDirect(de, le, ce, me, G, Me),
        G.onAfterRender(P, le, de, ce, me, Me)
    }
    function Qo(G, le, de) {
      le.isScene !== !0 && (le = Vt)
      const ce = at.get(G),
        me = x.state.lights,
        Me = x.state.shadowsArray,
        ke = me.state.version,
        He = Ct.getParameters(G, me.state, Me, le, de),
        Xe = Ct.getProgramCacheKey(He)
      let ut = ce.programs
      ;(ce.environment = G.isMeshStandardMaterial ? le.environment : null),
        (ce.fog = le.fog),
        (ce.envMap = (G.isMeshStandardMaterial ? Se : Z).get(
          G.envMap || ce.environment,
        )),
        (ce.envMapRotation =
          ce.environment !== null && G.envMap === null
            ? le.environmentRotation
            : G.envMapRotation),
        ut === void 0 &&
          (G.addEventListener('dispose', Qt),
          (ut = new Map()),
          (ce.programs = ut))
      let ot = ut.get(Xe)
      if (ot !== void 0) {
        if (ce.currentProgram === ot && ce.lightsStateVersion === ke)
          return ee(G, He), ot
      } else
        (He.uniforms = Ct.getUniforms(G)),
          G.onBeforeCompile(He, P),
          (ot = Ct.acquireProgram(He, Xe)),
          ut.set(Xe, ot),
          (ce.uniforms = He.uniforms)
      const We = ce.uniforms
      return (
        ((!G.isShaderMaterial && !G.isRawShaderMaterial) ||
          G.clipping === !0) &&
          (We.clippingPlanes = Je.uniform),
        ee(G, He),
        (ce.needsLights = De(G)),
        (ce.lightsStateVersion = ke),
        ce.needsLights &&
          ((We.ambientLightColor.value = me.state.ambient),
          (We.lightProbe.value = me.state.probe),
          (We.directionalLights.value = me.state.directional),
          (We.directionalLightShadows.value = me.state.directionalShadow),
          (We.spotLights.value = me.state.spot),
          (We.spotLightShadows.value = me.state.spotShadow),
          (We.rectAreaLights.value = me.state.rectArea),
          (We.ltc_1.value = me.state.rectAreaLTC1),
          (We.ltc_2.value = me.state.rectAreaLTC2),
          (We.pointLights.value = me.state.point),
          (We.pointLightShadows.value = me.state.pointShadow),
          (We.hemisphereLights.value = me.state.hemi),
          (We.directionalShadowMap.value = me.state.directionalShadowMap),
          (We.directionalShadowMatrix.value = me.state.directionalShadowMatrix),
          (We.spotShadowMap.value = me.state.spotShadowMap),
          (We.spotLightMatrix.value = me.state.spotLightMatrix),
          (We.spotLightMap.value = me.state.spotLightMap),
          (We.pointShadowMap.value = me.state.pointShadowMap),
          (We.pointShadowMatrix.value = me.state.pointShadowMatrix)),
        (ce.currentProgram = ot),
        (ce.uniformsList = null),
        ot
      )
    }
    function H(G) {
      if (G.uniformsList === null) {
        const le = G.currentProgram.getUniforms()
        G.uniformsList = _y.seqWithValue(le.seq, G.uniforms)
      }
      return G.uniformsList
    }
    function ee(G, le) {
      const de = at.get(G)
      ;(de.outputColorSpace = le.outputColorSpace),
        (de.batching = le.batching),
        (de.batchingColor = le.batchingColor),
        (de.instancing = le.instancing),
        (de.instancingColor = le.instancingColor),
        (de.instancingMorph = le.instancingMorph),
        (de.skinning = le.skinning),
        (de.morphTargets = le.morphTargets),
        (de.morphNormals = le.morphNormals),
        (de.morphColors = le.morphColors),
        (de.morphTargetsCount = le.morphTargetsCount),
        (de.numClippingPlanes = le.numClippingPlanes),
        (de.numIntersection = le.numClipIntersection),
        (de.vertexAlphas = le.vertexAlphas),
        (de.vertexTangents = le.vertexTangents),
        (de.toneMapping = le.toneMapping)
    }
    function fe(G, le, de, ce, me) {
      le.isScene !== !0 && (le = Vt), ie.resetTextureUnits()
      const Me = le.fog,
        ke = ce.isMeshStandardMaterial ? le.environment : null,
        He =
          F === null
            ? P.outputColorSpace
            : F.isXRRenderTarget === !0
            ? F.texture.colorSpace
            : Aa,
        Xe = (ce.isMeshStandardMaterial ? Se : Z).get(ce.envMap || ke),
        ut =
          ce.vertexColors === !0 &&
          !!de.attributes.color &&
          de.attributes.color.itemSize === 4,
        ot = !!de.attributes.tangent && (!!ce.normalMap || ce.anisotropy > 0),
        We = !!de.morphAttributes.position,
        pt = !!de.morphAttributes.normal,
        mt = !!de.morphAttributes.color
      let qt = ya
      ce.toneMapped &&
        (F === null || F.isXRRenderTarget === !0) &&
        (qt = P.toneMapping)
      const Lt =
          de.morphAttributes.position ||
          de.morphAttributes.normal ||
          de.morphAttributes.color,
        Ot = Lt !== void 0 ? Lt.length : 0,
        wt = at.get(ce),
        fn = x.state.lights
      if (Ce === !0 && (Te === !0 || G !== k)) {
        const Hn = G === k && ce.id === N
        Je.setState(ce, G, Hn)
      }
      let Ht = !1
      ce.version === wt.__version
        ? ((wt.needsLights && wt.lightsStateVersion !== fn.state.version) ||
            wt.outputColorSpace !== He ||
            (me.isBatchedMesh && wt.batching === !1) ||
            (!me.isBatchedMesh && wt.batching === !0) ||
            (me.isBatchedMesh &&
              wt.batchingColor === !0 &&
              me.colorTexture === null) ||
            (me.isBatchedMesh &&
              wt.batchingColor === !1 &&
              me.colorTexture !== null) ||
            (me.isInstancedMesh && wt.instancing === !1) ||
            (!me.isInstancedMesh && wt.instancing === !0) ||
            (me.isSkinnedMesh && wt.skinning === !1) ||
            (!me.isSkinnedMesh && wt.skinning === !0) ||
            (me.isInstancedMesh &&
              wt.instancingColor === !0 &&
              me.instanceColor === null) ||
            (me.isInstancedMesh &&
              wt.instancingColor === !1 &&
              me.instanceColor !== null) ||
            (me.isInstancedMesh &&
              wt.instancingMorph === !0 &&
              me.morphTexture === null) ||
            (me.isInstancedMesh &&
              wt.instancingMorph === !1 &&
              me.morphTexture !== null) ||
            wt.envMap !== Xe ||
            (ce.fog === !0 && wt.fog !== Me) ||
            (wt.numClippingPlanes !== void 0 &&
              (wt.numClippingPlanes !== Je.numPlanes ||
                wt.numIntersection !== Je.numIntersection)) ||
            wt.vertexAlphas !== ut ||
            wt.vertexTangents !== ot ||
            wt.morphTargets !== We ||
            wt.morphNormals !== pt ||
            wt.morphColors !== mt ||
            wt.toneMapping !== qt ||
            wt.morphTargetsCount !== Ot) &&
          (Ht = !0)
        : ((Ht = !0), (wt.__version = ce.version))
      let tn = wt.currentProgram
      Ht === !0 && (tn = Qo(ce, le, me))
      let jn = !1,
        ln = !1,
        mn = !1
      const Wt = tn.getUniforms(),
        Kn = wt.uniforms
      if (
        (rt.useProgram(tn.program) && ((jn = !0), (ln = !0), (mn = !0)),
        ce.id !== N && ((N = ce.id), (ln = !0)),
        jn || k !== G)
      ) {
        rt.buffers.depth.getReversed()
          ? (Pe.copy(G.projectionMatrix),
            mB(Pe),
            gB(Pe),
            Wt.setValue(se, 'projectionMatrix', Pe))
          : Wt.setValue(se, 'projectionMatrix', G.projectionMatrix),
          Wt.setValue(se, 'viewMatrix', G.matrixWorldInverse)
        const ui = Wt.map.cameraPosition
        ui !== void 0 &&
          ui.setValue(se, et.setFromMatrixPosition(G.matrixWorld)),
          _t.logarithmicDepthBuffer &&
            Wt.setValue(
              se,
              'logDepthBufFC',
              2 / (Math.log(G.far + 1) / Math.LN2),
            ),
          (ce.isMeshPhongMaterial ||
            ce.isMeshToonMaterial ||
            ce.isMeshLambertMaterial ||
            ce.isMeshBasicMaterial ||
            ce.isMeshStandardMaterial ||
            ce.isShaderMaterial) &&
            Wt.setValue(se, 'isOrthographic', G.isOrthographicCamera === !0),
          k !== G && ((k = G), (ln = !0), (mn = !0))
      }
      if (me.isSkinnedMesh) {
        Wt.setOptional(se, me, 'bindMatrix'),
          Wt.setOptional(se, me, 'bindMatrixInverse')
        const Hn = me.skeleton
        Hn &&
          (Hn.boneTexture === null && Hn.computeBoneTexture(),
          Wt.setValue(se, 'boneTexture', Hn.boneTexture, ie))
      }
      me.isBatchedMesh &&
        (Wt.setOptional(se, me, 'batchingTexture'),
        Wt.setValue(se, 'batchingTexture', me._matricesTexture, ie),
        Wt.setOptional(se, me, 'batchingIdTexture'),
        Wt.setValue(se, 'batchingIdTexture', me._indirectTexture, ie),
        Wt.setOptional(se, me, 'batchingColorTexture'),
        me._colorsTexture !== null &&
          Wt.setValue(se, 'batchingColorTexture', me._colorsTexture, ie))
      const Tn = de.morphAttributes
      if (
        ((Tn.position !== void 0 ||
          Tn.normal !== void 0 ||
          Tn.color !== void 0) &&
          It.update(me, de, tn),
        (ln || wt.receiveShadow !== me.receiveShadow) &&
          ((wt.receiveShadow = me.receiveShadow),
          Wt.setValue(se, 'receiveShadow', me.receiveShadow)),
        ce.isMeshGouraudMaterial &&
          ce.envMap !== null &&
          ((Kn.envMap.value = Xe),
          (Kn.flipEnvMap.value =
            Xe.isCubeTexture && Xe.isRenderTargetTexture === !1 ? -1 : 1)),
        ce.isMeshStandardMaterial &&
          ce.envMap === null &&
          le.environment !== null &&
          (Kn.envMapIntensity.value = le.environmentIntensity),
        ln &&
          (Wt.setValue(se, 'toneMappingExposure', P.toneMappingExposure),
          wt.needsLights && Ae(Kn, mn),
          Me && ce.fog === !0 && ct.refreshFogUniforms(Kn, Me),
          ct.refreshMaterialUniforms(
            Kn,
            ce,
            V,
            ne,
            x.state.transmissionRenderTarget[G.id],
          ),
          _y.upload(se, H(wt), Kn, ie)),
        ce.isShaderMaterial &&
          ce.uniformsNeedUpdate === !0 &&
          (_y.upload(se, H(wt), Kn, ie), (ce.uniformsNeedUpdate = !1)),
        ce.isSpriteMaterial && Wt.setValue(se, 'center', me.center),
        Wt.setValue(se, 'modelViewMatrix', me.modelViewMatrix),
        Wt.setValue(se, 'normalMatrix', me.normalMatrix),
        Wt.setValue(se, 'modelMatrix', me.matrixWorld),
        ce.isShaderMaterial || ce.isRawShaderMaterial)
      ) {
        const Hn = ce.uniformsGroups
        for (let ui = 0, Sn = Hn.length; ui < Sn; ui++) {
          const xr = Hn[ui]
          ve.update(xr, tn), ve.bind(xr, tn)
        }
      }
      return tn
    }
    function Ae(G, le) {
      ;(G.ambientLightColor.needsUpdate = le),
        (G.lightProbe.needsUpdate = le),
        (G.directionalLights.needsUpdate = le),
        (G.directionalLightShadows.needsUpdate = le),
        (G.pointLights.needsUpdate = le),
        (G.pointLightShadows.needsUpdate = le),
        (G.spotLights.needsUpdate = le),
        (G.spotLightShadows.needsUpdate = le),
        (G.rectAreaLights.needsUpdate = le),
        (G.hemisphereLights.needsUpdate = le)
    }
    function De(G) {
      return (
        G.isMeshLambertMaterial ||
        G.isMeshToonMaterial ||
        G.isMeshPhongMaterial ||
        G.isMeshStandardMaterial ||
        G.isShadowMaterial ||
        (G.isShaderMaterial && G.lights === !0)
      )
    }
    ;(this.getActiveCubeFace = function () {
      return O
    }),
      (this.getActiveMipmapLevel = function () {
        return U
      }),
      (this.getRenderTarget = function () {
        return F
      }),
      (this.setRenderTargetTextures = function (G, le, de) {
        ;(at.get(G.texture).__webglTexture = le),
          (at.get(G.depthTexture).__webglTexture = de)
        const ce = at.get(G)
        ;(ce.__hasExternalTextures = !0),
          (ce.__autoAllocateDepthBuffer = de === void 0),
          ce.__autoAllocateDepthBuffer ||
            (Qe.has('WEBGL_multisampled_render_to_texture') === !0 &&
              (console.warn(
                'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided',
              ),
              (ce.__useRenderToTexture = !1)))
      }),
      (this.setRenderTargetFramebuffer = function (G, le) {
        const de = at.get(G)
        ;(de.__webglFramebuffer = le),
          (de.__useDefaultFramebuffer = le === void 0)
      })
    const Oe = se.createFramebuffer()
    ;(this.setRenderTarget = function (G, le = 0, de = 0) {
      ;(F = G), (O = le), (U = de)
      let ce = !0,
        me = null,
        Me = !1,
        ke = !1
      if (G) {
        const Xe = at.get(G)
        if (Xe.__useDefaultFramebuffer !== void 0)
          rt.bindFramebuffer(se.FRAMEBUFFER, null), (ce = !1)
        else if (Xe.__webglFramebuffer === void 0) ie.setupRenderTarget(G)
        else if (Xe.__hasExternalTextures)
          ie.rebindTextures(
            G,
            at.get(G.texture).__webglTexture,
            at.get(G.depthTexture).__webglTexture,
          )
        else if (G.depthBuffer) {
          const We = G.depthTexture
          if (Xe.__boundDepthTexture !== We) {
            if (
              We !== null &&
              at.has(We) &&
              (G.width !== We.image.width || G.height !== We.image.height)
            )
              throw new Error(
                'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.',
              )
            ie.setupDepthRenderbuffer(G)
          }
        }
        const ut = G.texture
        ;(ut.isData3DTexture ||
          ut.isDataArrayTexture ||
          ut.isCompressedArrayTexture) &&
          (ke = !0)
        const ot = at.get(G).__webglFramebuffer
        G.isWebGLCubeRenderTarget
          ? (Array.isArray(ot[le]) ? (me = ot[le][de]) : (me = ot[le]),
            (Me = !0))
          : G.samples > 0 && ie.useMultisampledRTT(G) === !1
          ? (me = at.get(G).__webglMultisampledFramebuffer)
          : Array.isArray(ot)
          ? (me = ot[de])
          : (me = ot),
          z.copy(G.viewport),
          $.copy(G.scissor),
          (te = G.scissorTest)
      } else
        z.copy(q).multiplyScalar(V).floor(),
          $.copy(oe).multiplyScalar(V).floor(),
          (te = _e)
      if (
        (de !== 0 && (me = Oe),
        rt.bindFramebuffer(se.FRAMEBUFFER, me) && ce && rt.drawBuffers(G, me),
        rt.viewport(z),
        rt.scissor($),
        rt.setScissorTest(te),
        Me)
      ) {
        const Xe = at.get(G.texture)
        se.framebufferTexture2D(
          se.FRAMEBUFFER,
          se.COLOR_ATTACHMENT0,
          se.TEXTURE_CUBE_MAP_POSITIVE_X + le,
          Xe.__webglTexture,
          de,
        )
      } else if (ke) {
        const Xe = at.get(G.texture),
          ut = le
        se.framebufferTextureLayer(
          se.FRAMEBUFFER,
          se.COLOR_ATTACHMENT0,
          Xe.__webglTexture,
          de,
          ut,
        )
      } else if (G !== null && de !== 0) {
        const Xe = at.get(G.texture)
        se.framebufferTexture2D(
          se.FRAMEBUFFER,
          se.COLOR_ATTACHMENT0,
          se.TEXTURE_2D,
          Xe.__webglTexture,
          de,
        )
      }
      N = -1
    }),
      (this.readRenderTargetPixels = function (G, le, de, ce, me, Me, ke) {
        if (!(G && G.isWebGLRenderTarget)) {
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
          )
          return
        }
        let He = at.get(G).__webglFramebuffer
        if ((G.isWebGLCubeRenderTarget && ke !== void 0 && (He = He[ke]), He)) {
          rt.bindFramebuffer(se.FRAMEBUFFER, He)
          try {
            const Xe = G.texture,
              ut = Xe.format,
              ot = Xe.type
            if (!_t.textureFormatReadable(ut)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
              )
              return
            }
            if (!_t.textureTypeReadable(ot)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
              )
              return
            }
            le >= 0 &&
              le <= G.width - ce &&
              de >= 0 &&
              de <= G.height - me &&
              se.readPixels(le, de, ce, me, Bt.convert(ut), Bt.convert(ot), Me)
          } finally {
            const Xe = F !== null ? at.get(F).__webglFramebuffer : null
            rt.bindFramebuffer(se.FRAMEBUFFER, Xe)
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        G,
        le,
        de,
        ce,
        me,
        Me,
        ke,
      ) {
        if (!(G && G.isWebGLRenderTarget))
          throw new Error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
          )
        let He = at.get(G).__webglFramebuffer
        if ((G.isWebGLCubeRenderTarget && ke !== void 0 && (He = He[ke]), He)) {
          const Xe = G.texture,
            ut = Xe.format,
            ot = Xe.type
          if (!_t.textureFormatReadable(ut))
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.',
            )
          if (!_t.textureTypeReadable(ot))
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.',
            )
          if (le >= 0 && le <= G.width - ce && de >= 0 && de <= G.height - me) {
            rt.bindFramebuffer(se.FRAMEBUFFER, He)
            const We = se.createBuffer()
            se.bindBuffer(se.PIXEL_PACK_BUFFER, We),
              se.bufferData(
                se.PIXEL_PACK_BUFFER,
                Me.byteLength,
                se.STREAM_READ,
              ),
              se.readPixels(le, de, ce, me, Bt.convert(ut), Bt.convert(ot), 0)
            const pt = F !== null ? at.get(F).__webglFramebuffer : null
            rt.bindFramebuffer(se.FRAMEBUFFER, pt)
            const mt = se.fenceSync(se.SYNC_GPU_COMMANDS_COMPLETE, 0)
            return (
              se.flush(),
              await pB(se, mt, 4),
              se.bindBuffer(se.PIXEL_PACK_BUFFER, We),
              se.getBufferSubData(se.PIXEL_PACK_BUFFER, 0, Me),
              se.deleteBuffer(We),
              se.deleteSync(mt),
              Me
            )
          } else
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.',
            )
        }
      }),
      (this.copyFramebufferToTexture = function (G, le = null, de = 0) {
        G.isTexture !== !0 &&
          (Gf(
            'WebGLRenderer: copyFramebufferToTexture function signature has changed.',
          ),
          (le = arguments[0] || null),
          (G = arguments[1]))
        const ce = Math.pow(2, -de),
          me = Math.floor(G.image.width * ce),
          Me = Math.floor(G.image.height * ce),
          ke = le !== null ? le.x : 0,
          He = le !== null ? le.y : 0
        ie.setTexture2D(G, 0),
          se.copyTexSubImage2D(se.TEXTURE_2D, de, 0, 0, ke, He, me, Me),
          rt.unbindTexture()
      })
    const nt = se.createFramebuffer(),
      Ze = se.createFramebuffer()
    ;(this.copyTextureToTexture = function (
      G,
      le,
      de = null,
      ce = null,
      me = 0,
      Me = null,
    ) {
      G.isTexture !== !0 &&
        (Gf(
          'WebGLRenderer: copyTextureToTexture function signature has changed.',
        ),
        (ce = arguments[0] || null),
        (G = arguments[1]),
        (le = arguments[2]),
        (Me = arguments[3] || 0),
        (de = null)),
        Me === null &&
          (me !== 0
            ? (Gf(
                'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.',
              ),
              (Me = me),
              (me = 0))
            : (Me = 0))
      let ke, He, Xe, ut, ot, We, pt, mt, qt
      const Lt = G.isCompressedTexture ? G.mipmaps[Me] : G.image
      if (de !== null)
        (ke = de.max.x - de.min.x),
          (He = de.max.y - de.min.y),
          (Xe = de.isBox3 ? de.max.z - de.min.z : 1),
          (ut = de.min.x),
          (ot = de.min.y),
          (We = de.isBox3 ? de.min.z : 0)
      else {
        const Tn = Math.pow(2, -me)
        ;(ke = Math.floor(Lt.width * Tn)),
          (He = Math.floor(Lt.height * Tn)),
          G.isDataArrayTexture
            ? (Xe = Lt.depth)
            : G.isData3DTexture
            ? (Xe = Math.floor(Lt.depth * Tn))
            : (Xe = 1),
          (ut = 0),
          (ot = 0),
          (We = 0)
      }
      ce !== null
        ? ((pt = ce.x), (mt = ce.y), (qt = ce.z))
        : ((pt = 0), (mt = 0), (qt = 0))
      const Ot = Bt.convert(le.format),
        wt = Bt.convert(le.type)
      let fn
      le.isData3DTexture
        ? (ie.setTexture3D(le, 0), (fn = se.TEXTURE_3D))
        : le.isDataArrayTexture || le.isCompressedArrayTexture
        ? (ie.setTexture2DArray(le, 0), (fn = se.TEXTURE_2D_ARRAY))
        : (ie.setTexture2D(le, 0), (fn = se.TEXTURE_2D)),
        se.pixelStorei(se.UNPACK_FLIP_Y_WEBGL, le.flipY),
        se.pixelStorei(se.UNPACK_PREMULTIPLY_ALPHA_WEBGL, le.premultiplyAlpha),
        se.pixelStorei(se.UNPACK_ALIGNMENT, le.unpackAlignment)
      const Ht = se.getParameter(se.UNPACK_ROW_LENGTH),
        tn = se.getParameter(se.UNPACK_IMAGE_HEIGHT),
        jn = se.getParameter(se.UNPACK_SKIP_PIXELS),
        ln = se.getParameter(se.UNPACK_SKIP_ROWS),
        mn = se.getParameter(se.UNPACK_SKIP_IMAGES)
      se.pixelStorei(se.UNPACK_ROW_LENGTH, Lt.width),
        se.pixelStorei(se.UNPACK_IMAGE_HEIGHT, Lt.height),
        se.pixelStorei(se.UNPACK_SKIP_PIXELS, ut),
        se.pixelStorei(se.UNPACK_SKIP_ROWS, ot),
        se.pixelStorei(se.UNPACK_SKIP_IMAGES, We)
      const Wt = G.isDataArrayTexture || G.isData3DTexture,
        Kn = le.isDataArrayTexture || le.isData3DTexture
      if (G.isDepthTexture) {
        const Tn = at.get(G),
          Hn = at.get(le),
          ui = at.get(Tn.__renderTarget),
          Sn = at.get(Hn.__renderTarget)
        rt.bindFramebuffer(se.READ_FRAMEBUFFER, ui.__webglFramebuffer),
          rt.bindFramebuffer(se.DRAW_FRAMEBUFFER, Sn.__webglFramebuffer)
        for (let xr = 0; xr < Xe; xr++)
          Wt &&
            (se.framebufferTextureLayer(
              se.READ_FRAMEBUFFER,
              se.COLOR_ATTACHMENT0,
              at.get(G).__webglTexture,
              me,
              We + xr,
            ),
            se.framebufferTextureLayer(
              se.DRAW_FRAMEBUFFER,
              se.COLOR_ATTACHMENT0,
              at.get(le).__webglTexture,
              Me,
              qt + xr,
            )),
            se.blitFramebuffer(
              ut,
              ot,
              ke,
              He,
              pt,
              mt,
              ke,
              He,
              se.DEPTH_BUFFER_BIT,
              se.NEAREST,
            )
        rt.bindFramebuffer(se.READ_FRAMEBUFFER, null),
          rt.bindFramebuffer(se.DRAW_FRAMEBUFFER, null)
      } else if (me !== 0 || G.isRenderTargetTexture || at.has(G)) {
        const Tn = at.get(G),
          Hn = at.get(le)
        rt.bindFramebuffer(se.READ_FRAMEBUFFER, nt),
          rt.bindFramebuffer(se.DRAW_FRAMEBUFFER, Ze)
        for (let ui = 0; ui < Xe; ui++)
          Wt
            ? se.framebufferTextureLayer(
                se.READ_FRAMEBUFFER,
                se.COLOR_ATTACHMENT0,
                Tn.__webglTexture,
                me,
                We + ui,
              )
            : se.framebufferTexture2D(
                se.READ_FRAMEBUFFER,
                se.COLOR_ATTACHMENT0,
                se.TEXTURE_2D,
                Tn.__webglTexture,
                me,
              ),
            Kn
              ? se.framebufferTextureLayer(
                  se.DRAW_FRAMEBUFFER,
                  se.COLOR_ATTACHMENT0,
                  Hn.__webglTexture,
                  Me,
                  qt + ui,
                )
              : se.framebufferTexture2D(
                  se.DRAW_FRAMEBUFFER,
                  se.COLOR_ATTACHMENT0,
                  se.TEXTURE_2D,
                  Hn.__webglTexture,
                  Me,
                ),
            me !== 0
              ? se.blitFramebuffer(
                  ut,
                  ot,
                  ke,
                  He,
                  pt,
                  mt,
                  ke,
                  He,
                  se.COLOR_BUFFER_BIT,
                  se.NEAREST,
                )
              : Kn
              ? se.copyTexSubImage3D(fn, Me, pt, mt, qt + ui, ut, ot, ke, He)
              : se.copyTexSubImage2D(fn, Me, pt, mt, ut, ot, ke, He)
        rt.bindFramebuffer(se.READ_FRAMEBUFFER, null),
          rt.bindFramebuffer(se.DRAW_FRAMEBUFFER, null)
      } else
        Kn
          ? G.isDataTexture || G.isData3DTexture
            ? se.texSubImage3D(fn, Me, pt, mt, qt, ke, He, Xe, Ot, wt, Lt.data)
            : le.isCompressedArrayTexture
            ? se.compressedTexSubImage3D(
                fn,
                Me,
                pt,
                mt,
                qt,
                ke,
                He,
                Xe,
                Ot,
                Lt.data,
              )
            : se.texSubImage3D(fn, Me, pt, mt, qt, ke, He, Xe, Ot, wt, Lt)
          : G.isDataTexture
          ? se.texSubImage2D(se.TEXTURE_2D, Me, pt, mt, ke, He, Ot, wt, Lt.data)
          : G.isCompressedTexture
          ? se.compressedTexSubImage2D(
              se.TEXTURE_2D,
              Me,
              pt,
              mt,
              Lt.width,
              Lt.height,
              Ot,
              Lt.data,
            )
          : se.texSubImage2D(se.TEXTURE_2D, Me, pt, mt, ke, He, Ot, wt, Lt)
      se.pixelStorei(se.UNPACK_ROW_LENGTH, Ht),
        se.pixelStorei(se.UNPACK_IMAGE_HEIGHT, tn),
        se.pixelStorei(se.UNPACK_SKIP_PIXELS, jn),
        se.pixelStorei(se.UNPACK_SKIP_ROWS, ln),
        se.pixelStorei(se.UNPACK_SKIP_IMAGES, mn),
        Me === 0 && le.generateMipmaps && se.generateMipmap(fn),
        rt.unbindTexture()
    }),
      (this.copyTextureToTexture3D = function (
        G,
        le,
        de = null,
        ce = null,
        me = 0,
      ) {
        return (
          G.isTexture !== !0 &&
            (Gf(
              'WebGLRenderer: copyTextureToTexture3D function signature has changed.',
            ),
            (de = arguments[0] || null),
            (ce = arguments[1] || null),
            (G = arguments[2]),
            (le = arguments[3]),
            (me = arguments[4] || 0)),
          Gf(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.',
          ),
          this.copyTextureToTexture(G, le, de, ce, me)
        )
      }),
      (this.initRenderTarget = function (G) {
        at.get(G).__webglFramebuffer === void 0 && ie.setupRenderTarget(G)
      }),
      (this.initTexture = function (G) {
        G.isCubeTexture
          ? ie.setTextureCube(G, 0)
          : G.isData3DTexture
          ? ie.setTexture3D(G, 0)
          : G.isDataArrayTexture || G.isCompressedArrayTexture
          ? ie.setTexture2DArray(G, 0)
          : ie.setTexture2D(G, 0),
          rt.unbindTexture()
      }),
      (this.resetState = function () {
        ;(O = 0), (U = 0), (F = null), rt.reset(), Kt.reset()
      }),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this }),
        )
  }
  get coordinateSystem() {
    return Go
  }
  get outputColorSpace() {
    return this._outputColorSpace
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e
    const t = this.getContext()
    ;(t.drawingBufferColorspace = Cn._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = Cn._getUnpackColorSpace())
  }
}
const ON = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: ZM,
      AddEquation: Sc,
      AddOperation: aL,
      AdditiveAnimationBlendMode: sE,
      AdditiveBlending: LS,
      AgXToneMapping: fL,
      AlphaFormat: JM,
      AlwaysCompare: AL,
      AlwaysDepth: Oy,
      AlwaysStencilFunc: FS,
      AmbientLight: yN,
      AnimationAction: AN,
      AnimationClip: tg,
      AnimationLoader: Fz,
      AnimationMixer: uV,
      AnimationObjectGroup: lV,
      AnimationUtils: Nz,
      ArcCurve: HL,
      ArrayCamera: EN,
      ArrowHelper: NV,
      AttachedBindMode: OS,
      Audio: bN,
      AudioAnalyser: Qz,
      AudioContext: RE,
      AudioListener: Yz,
      AudioLoader: $z,
      AxesHelper: DV,
      BackSide: Qr,
      BasicDepthPacking: yL,
      BasicShadowMap: VI,
      BatchedMesh: zL,
      Bone: fE,
      BooleanKeyframeTrack: wd,
      Box2: xV,
      Box3: Jr,
      Box3Helper: IV,
      BoxGeometry: _d,
      BoxHelper: RV,
      BufferAttribute: qn,
      BufferGeometry: _n,
      BufferGeometryLoader: MN,
      ByteType: Hx,
      Cache: xl,
      Camera: Rg,
      CameraHelper: PV,
      CanvasTexture: iz,
      CapsuleGeometry: r_,
      CatmullRomCurve3: GL,
      CineonToneMapping: uL,
      CircleGeometry: s_,
      ClampToEdgeWrapping: Bi,
      Clock: IE,
      Color: Tt,
      ColorKeyframeTrack: AE,
      ColorManagement: Cn,
      CompressedArrayTexture: tz,
      CompressedCubeTexture: nz,
      CompressedTexture: n_,
      CompressedTextureLoader: Uz,
      ConeGeometry: o_,
      ConstantAlphaFactor: rL,
      ConstantColorFactor: nL,
      Controls: kV,
      CubeCamera: DL,
      CubeReflectionMapping: ba,
      CubeRefractionMapping: Pc,
      CubeTexture: Ig,
      CubeTextureLoader: hN,
      CubeUVReflectionMapping: Rh,
      CubicBezierCurve: gE,
      CubicBezierCurve3: WL,
      CubicInterpolant: cN,
      CullFaceBack: IS,
      CullFaceFront: zI,
      CullFaceFrontBack: v5,
      CullFaceNone: BI,
      Curve: Yo,
      CurvePath: XL,
      CustomBlending: jI,
      CustomToneMapping: dL,
      CylinderGeometry: Lh,
      Cylindrical: yV,
      Data3DTexture: Kx,
      DataArrayTexture: Pg,
      DataTexture: $o,
      DataTextureLoader: CE,
      DataUtils: td,
      DecrementStencilOp: R5,
      DecrementWrapStencilOp: L5,
      DefaultLoadingManager: fN,
      DepthFormat: ad,
      DepthStencilFormat: md,
      DepthTexture: pE,
      DetachedBindMode: pL,
      DirectionalLight: vN,
      DirectionalLightHelper: CV,
      DiscreteInterpolant: uN,
      DodecahedronGeometry: a_,
      DoubleSide: oo,
      DstAlphaFactor: KI,
      DstColorFactor: JI,
      DynamicCopyUsage: X5,
      DynamicDrawUsage: V5,
      DynamicReadUsage: G5,
      EdgesGeometry: qL,
      EllipseCurve: i_,
      EqualCompare: ML,
      EqualDepth: Fy,
      EqualStencilFunc: k5,
      EquirectangularReflectionMapping: hh,
      EquirectangularRefractionMapping: zm,
      Euler: Us,
      EventDispatcher: Pa,
      ExtrudeGeometry: c_,
      FileLoader: Os,
      Float16BufferAttribute: kB,
      Float32BufferAttribute: Ft,
      FloatType: gi,
      Fog: Jx,
      FogExp2: Qx,
      FramebufferTexture: ez,
      FrontSide: Tl,
      Frustum: Ng,
      GLBufferAttribute: gV,
      GLSL1: Y5,
      GLSL3: US,
      GreaterCompare: EL,
      GreaterDepth: By,
      GreaterEqualCompare: TL,
      GreaterEqualDepth: Uy,
      GreaterEqualStencilFunc: z5,
      GreaterStencilFunc: U5,
      GridHelper: TV,
      Group: Yf,
      HalfFloatType: or,
      HemisphereLight: pN,
      HemisphereLightHelper: bV,
      IcosahedronGeometry: Og,
      ImageBitmapLoader: Wz,
      ImageLoader: ng,
      ImageUtils: RL,
      IncrementStencilOp: P5,
      IncrementWrapStencilOp: I5,
      InstancedBufferAttribute: vh,
      InstancedBufferGeometry: SN,
      InstancedInterleavedBuffer: mV,
      InstancedMesh: BL,
      Int16BufferAttribute: DB,
      Int32BufferAttribute: OB,
      Int8BufferAttribute: IB,
      IntType: Tg,
      InterleavedBuffer: e_,
      InterleavedBufferAttribute: gd,
      Interpolant: Ug,
      InterpolateDiscrete: Hm,
      InterpolateLinear: hx,
      InterpolateSmooth: xy,
      InvertStencilOp: N5,
      KeepStencilOp: Hu,
      KeyframeTrack: Zo,
      LOD: FL,
      LatheGeometry: Dg,
      Layers: cd,
      LessCompare: SL,
      LessDepth: ky,
      LessEqualCompare: oE,
      LessEqualDepth: hd,
      LessEqualStencilFunc: F5,
      LessStencilFunc: O5,
      Light: Bc,
      LightProbe: wN,
      Line: Rc,
      Line3: _V,
      LineBasicMaterial: ts,
      LineCurve: vE,
      LineCurve3: $L,
      LineDashedMaterial: oN,
      LineLoop: VL,
      LineSegments: Ra,
      LinearFilter: Vn,
      LinearInterpolant: TE,
      LinearMipMapLinearFilter: kS,
      LinearMipMapNearestFilter: _5,
      LinearMipmapLinearFilter: ma,
      LinearMipmapNearestFilter: gm,
      LinearSRGBColorSpace: Aa,
      LinearToneMapping: lL,
      LinearTransfer: Wm,
      Loader: ns,
      LoaderUtils: HS,
      LoadingManager: g_,
      LoopOnce: mL,
      LoopPingPong: vL,
      LoopRepeat: gL,
      LuminanceAlphaFormat: nE,
      LuminanceFormat: tE,
      MOUSE: m5,
      Material: Or,
      MaterialLoader: v_,
      MathUtils: fB,
      Matrix2: kE,
      Matrix3: pn,
      Matrix4: Jt,
      MaxEquation: $I,
      Mesh: vi,
      MeshBasicMaterial: Il,
      MeshDepthMaterial: ME,
      MeshDistanceMaterial: EE,
      MeshLambertMaterial: rN,
      MeshMatcapMaterial: sN,
      MeshNormalMaterial: iN,
      MeshPhongMaterial: tN,
      MeshPhysicalMaterial: SE,
      MeshStandardMaterial: wE,
      MeshToonMaterial: nN,
      MinEquation: WI,
      MirroredRepeatWrapping: jm,
      MixOperation: oL,
      MultiplyBlending: DS,
      MultiplyOperation: bg,
      NearestFilter: yr,
      NearestMipMapLinearFilter: x5,
      NearestMipMapNearestFilter: y5,
      NearestMipmapLinearFilter: Xf,
      NearestMipmapNearestFilter: KM,
      NeutralToneMapping: hL,
      NeverCompare: wL,
      NeverDepth: Dy,
      NeverStencilFunc: D5,
      NoBlending: va,
      NoColorSpace: vl,
      NoToneMapping: ya,
      NormalAnimationBlendMode: Yx,
      NormalBlending: od,
      NotEqualCompare: bL,
      NotEqualDepth: zy,
      NotEqualStencilFunc: B5,
      NumberKeyframeTrack: Jm,
      Object3D: Ln,
      ObjectLoader: Hz,
      ObjectSpaceNormalMap: _L,
      OctahedronGeometry: kg,
      OneFactor: qI,
      OneMinusConstantAlphaFactor: sL,
      OneMinusConstantColorFactor: iL,
      OneMinusDstAlphaFactor: QI,
      OneMinusDstColorFactor: eL,
      OneMinusSrcAlphaFactor: Ny,
      OneMinusSrcColorFactor: ZI,
      OrthographicCamera: Nh,
      PCFShadowMap: jx,
      PCFSoftShadowMap: mm,
      PMREMGenerator: $S,
      Path: Ym,
      PerspectiveCamera: sr,
      Plane: wc,
      PlaneGeometry: Uc,
      PlaneHelper: LV,
      PointLight: gN,
      PointLightHelper: MV,
      Points: jL,
      PointsMaterial: hE,
      PolarGridHelper: AV,
      PolyhedronGeometry: Fc,
      PositionalAudio: Kz,
      PropertyBinding: Rn,
      PropertyMixer: TN,
      QuadraticBezierCurve: yE,
      QuadraticBezierCurve3: xE,
      Quaternion: xs,
      QuaternionKeyframeTrack: Bg,
      QuaternionLinearInterpolant: dN,
      RED_GREEN_RGTC2_Format: dx,
      RED_RGTC1_Format: rE,
      REVISION: Eg,
      RGBADepthPacking: xL,
      RGBAFormat: Ii,
      RGBAIntegerFormat: qx,
      RGBA_ASTC_10x10_Format: sx,
      RGBA_ASTC_10x5_Format: nx,
      RGBA_ASTC_10x6_Format: ix,
      RGBA_ASTC_10x8_Format: rx,
      RGBA_ASTC_12x10_Format: ox,
      RGBA_ASTC_12x12_Format: ax,
      RGBA_ASTC_4x4_Format: qy,
      RGBA_ASTC_5x4_Format: Yy,
      RGBA_ASTC_5x5_Format: Zy,
      RGBA_ASTC_6x5_Format: Ky,
      RGBA_ASTC_6x6_Format: Qy,
      RGBA_ASTC_8x5_Format: Jy,
      RGBA_ASTC_8x6_Format: ex,
      RGBA_ASTC_8x8_Format: tx,
      RGBA_BPTC_Format: wm,
      RGBA_ETC2_EAC_Format: Xy,
      RGBA_PVRTC_2BPPV1_Format: Gy,
      RGBA_PVRTC_4BPPV1_Format: Hy,
      RGBA_S3TC_DXT1_Format: ym,
      RGBA_S3TC_DXT3_Format: xm,
      RGBA_S3TC_DXT5_Format: _m,
      RGBDepthPacking: b5,
      RGBFormat: eE,
      RGBIntegerFormat: w5,
      RGB_BPTC_SIGNED_Format: lx,
      RGB_BPTC_UNSIGNED_Format: cx,
      RGB_ETC1_Format: Wy,
      RGB_ETC2_Format: $y,
      RGB_PVRTC_2BPPV1_Format: jy,
      RGB_PVRTC_4BPPV1_Format: Vy,
      RGB_S3TC_DXT1_Format: vm,
      RGDepthPacking: T5,
      RGFormat: iE,
      RGIntegerFormat: Xx,
      RawShaderMaterial: eN,
      Ray: Ih,
      Raycaster: OE,
      RectAreaLight: xN,
      RedFormat: Ag,
      RedIntegerFormat: Cg,
      ReinhardToneMapping: cL,
      RenderTarget: Zx,
      RenderTarget3D: dV,
      RenderTargetArray: fV,
      RepeatWrapping: Vm,
      ReplaceStencilOp: C5,
      ReverseSubtractEquation: GI,
      RingGeometry: u_,
      SIGNED_RED_GREEN_RGTC2_Format: fx,
      SIGNED_RED_RGTC1_Format: ux,
      SRGBColorSpace: Zr,
      SRGBTransfer: zn,
      Scene: Lg,
      ShaderChunk: xn,
      ShaderLib: jo,
      ShaderMaterial: ws,
      ShadowMaterial: JL,
      Shape: ud,
      ShapeGeometry: d_,
      ShapePath: OV,
      ShapeUtils: xa,
      ShortType: Gx,
      Skeleton: t_,
      SkeletonHelper: SV,
      SkinnedMesh: UL,
      Source: ed,
      Sphere: Dr,
      SphereGeometry: Fg,
      Spherical: vV,
      SphericalHarmonics3: _N,
      SplineCurve: _E,
      SpotLight: mN,
      SpotLightHelper: wV,
      Sprite: kL,
      SpriteMaterial: dE,
      SrcAlphaFactor: Ly,
      SrcAlphaSaturateFactor: tL,
      SrcColorFactor: YI,
      StaticCopyUsage: $5,
      StaticDrawUsage: $m,
      StaticReadUsage: H5,
      StereoCamera: Xz,
      StreamCopyUsage: q5,
      StreamDrawUsage: j5,
      StreamReadUsage: W5,
      StringKeyframeTrack: Sd,
      SubtractEquation: HI,
      SubtractiveBlending: NS,
      TOUCH: g5,
      TangentSpaceNormalMap: kc,
      TetrahedronGeometry: f_,
      Texture: Xn,
      TextureLoader: Bz,
      TextureUtils: VV,
      TorusGeometry: h_,
      TorusKnotGeometry: p_,
      Triangle: ys,
      TriangleFanDrawMode: E5,
      TriangleStripDrawMode: M5,
      TrianglesDrawMode: S5,
      TubeGeometry: m_,
      UVMapping: Cc,
      Uint16BufferAttribute: lE,
      Uint32BufferAttribute: cE,
      Uint8BufferAttribute: LB,
      Uint8ClampedBufferAttribute: NB,
      Uniform: DE,
      UniformsGroup: pV,
      UniformsLib: xt,
      UniformsUtils: NL,
      UnsignedByteType: _s,
      UnsignedInt248Type: pd,
      UnsignedInt5999Type: QM,
      UnsignedIntType: Ta,
      UnsignedShort4444Type: Wx,
      UnsignedShort5551Type: $x,
      UnsignedShortType: ph,
      VSMShadowMap: Vo,
      Vector2: qe,
      Vector3: re,
      Vector4: In,
      VectorKeyframeTrack: eg,
      VideoTexture: JB,
      WebGL3DRenderTarget: wB,
      WebGLArrayRenderTarget: _B,
      WebGLCoordinateSystem: Go,
      WebGLCubeRenderTarget: uE,
      WebGLRenderTarget: uo,
      WebGLRenderer: UE,
      WebGLUtils: DN,
      WebGPUCoordinateSystem: Xm,
      WireframeGeometry: QL,
      WrapAroundEnding: Gm,
      ZeroCurvatureEnding: Qu,
      ZeroFactor: XI,
      ZeroSlopeEnding: Ju,
      ZeroStencilOp: A5,
      createCanvasElement: PL,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
)
var dw = { exports: {} },
  mc = {}
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var o2
function SG() {
  return (
    o2 ||
      ((o2 = 1),
      (mc.ConcurrentRoot = 1),
      (mc.ContinuousEventPriority = 4),
      (mc.DefaultEventPriority = 16),
      (mc.DiscreteEventPriority = 1),
      (mc.IdleEventPriority = 536870912),
      (mc.LegacyRoot = 0)),
    mc
  )
}
var a2
function MG() {
  return a2 || ((a2 = 1), (dw.exports = SG())), dw.exports
}
var om = MG()
function EG(n) {
  let e
  const t = new Set(),
    i = (u, h) => {
      const m = typeof u == 'function' ? u(e) : u
      if (m !== e) {
        const g = e
        ;(e = h ? m : Object.assign({}, e, m)), t.forEach((y) => y(e, g))
      }
    },
    r = () => e,
    s = (u, h = r, m = Object.is) => {
      console.warn('[DEPRECATED] Please use `subscribeWithSelector` middleware')
      let g = h(e)
      function y() {
        const _ = h(e)
        if (!m(g, _)) {
          const M = g
          u((g = _), M)
        }
      }
      return t.add(y), () => t.delete(y)
    },
    c = {
      setState: i,
      getState: r,
      subscribe: (u, h, m) =>
        h || m ? s(u, h, m) : (t.add(u), () => t.delete(u)),
      destroy: () => t.clear(),
    }
  return (e = n(i, r, c)), c
}
const bG =
    typeof window > 'u' ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  l2 = bG ? X.useEffect : X.useLayoutEffect
function kN(n) {
  const e = typeof n == 'function' ? EG(n) : n,
    t = (i = e.getState, r = Object.is) => {
      const [, s] = X.useReducer((w) => w + 1, 0),
        o = e.getState(),
        a = X.useRef(o),
        c = X.useRef(i),
        u = X.useRef(r),
        h = X.useRef(!1),
        m = X.useRef()
      m.current === void 0 && (m.current = i(o))
      let g,
        y = !1
      ;(a.current !== o || c.current !== i || u.current !== r || h.current) &&
        ((g = i(o)), (y = !r(m.current, g))),
        l2(() => {
          y && (m.current = g),
            (a.current = o),
            (c.current = i),
            (u.current = r),
            (h.current = !1)
        })
      const _ = X.useRef(o)
      l2(() => {
        const w = () => {
            try {
              const T = e.getState(),
                A = c.current(T)
              u.current(m.current, A) || ((a.current = T), (m.current = A), s())
            } catch {
              ;(h.current = !0), s()
            }
          },
          x = e.subscribe(w)
        return e.getState() !== _.current && w(), x
      }, [])
      const M = y ? g : m.current
      return X.useDebugValue(M), M
    }
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        '[useStore, api] = create() is deprecated and will be removed in v4',
      )
      const i = [t, e]
      return {
        next() {
          const r = i.length <= 0
          return { value: i.shift(), done: r }
        },
      }
    }),
    t
  )
}
const TG = (n) => typeof n == 'object' && typeof n.then == 'function',
  id = []
function FN(n, e, t = (i, r) => i === r) {
  if (n === e) return !0
  if (!n || !e) return !1
  const i = n.length
  if (e.length !== i) return !1
  for (let r = 0; r < i; r++) if (!t(n[r], e[r])) return !1
  return !0
}
function UN(n, e = null, t = !1, i = {}) {
  e === null && (e = [n])
  for (const s of id)
    if (FN(e, s.keys, s.equal)) {
      if (t) return
      if (Object.prototype.hasOwnProperty.call(s, 'error')) throw s.error
      if (Object.prototype.hasOwnProperty.call(s, 'response'))
        return (
          i.lifespan &&
            i.lifespan > 0 &&
            (s.timeout && clearTimeout(s.timeout),
            (s.timeout = setTimeout(s.remove, i.lifespan))),
          s.response
        )
      if (!t) throw s.promise
    }
  const r = {
    keys: e,
    equal: i.equal,
    remove: () => {
      const s = id.indexOf(r)
      s !== -1 && id.splice(s, 1)
    },
    promise: (TG(n) ? n : n(...e))
      .then((s) => {
        ;(r.response = s),
          i.lifespan &&
            i.lifespan > 0 &&
            (r.timeout = setTimeout(r.remove, i.lifespan))
      })
      .catch((s) => (r.error = s)),
  }
  if ((id.push(r), !t)) throw r.promise
}
const AG = (n, e, t) => UN(n, e, !1, t),
  CG = (n, e, t) => void UN(n, e, !0, t),
  PG = (n) => {
    if (n === void 0 || n.length === 0) id.splice(0, id.length)
    else {
      const e = id.find((t) => FN(n, t.keys, t.equal))
      e && e.remove()
    }
  }
var fw = { exports: {} },
  hw = { exports: {} },
  pw = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var c2
function RG() {
  return (
    c2 ||
      ((c2 = 1),
      (function (n) {
        function e(V, Y) {
          var Q = V.length
          V.push(Y)
          e: for (; 0 < Q; ) {
            var q = (Q - 1) >>> 1,
              oe = V[q]
            if (0 < r(oe, Y)) (V[q] = Y), (V[Q] = oe), (Q = q)
            else break e
          }
        }
        function t(V) {
          return V.length === 0 ? null : V[0]
        }
        function i(V) {
          if (V.length === 0) return null
          var Y = V[0],
            Q = V.pop()
          if (Q !== Y) {
            V[0] = Q
            e: for (var q = 0, oe = V.length, _e = oe >>> 1; q < _e; ) {
              var he = 2 * (q + 1) - 1,
                Ce = V[he],
                Te = he + 1,
                Pe = V[Te]
              if (0 > r(Ce, Q))
                Te < oe && 0 > r(Pe, Ce)
                  ? ((V[q] = Pe), (V[Te] = Q), (q = Te))
                  : ((V[q] = Ce), (V[he] = Q), (q = he))
              else if (Te < oe && 0 > r(Pe, Q))
                (V[q] = Pe), (V[Te] = Q), (q = Te)
              else break e
            }
          }
          return Y
        }
        function r(V, Y) {
          var Q = V.sortIndex - Y.sortIndex
          return Q !== 0 ? Q : V.id - Y.id
        }
        if (
          typeof performance == 'object' &&
          typeof performance.now == 'function'
        ) {
          var s = performance
          n.unstable_now = function () {
            return s.now()
          }
        } else {
          var o = Date,
            a = o.now()
          n.unstable_now = function () {
            return o.now() - a
          }
        }
        var c = [],
          u = [],
          h = 1,
          m = null,
          g = 3,
          y = !1,
          _ = !1,
          M = !1,
          w = typeof setTimeout == 'function' ? setTimeout : null,
          x = typeof clearTimeout == 'function' ? clearTimeout : null,
          T = typeof setImmediate < 'u' ? setImmediate : null
        typeof navigator < 'u' &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling)
        function A(V) {
          for (var Y = t(u); Y !== null; ) {
            if (Y.callback === null) i(u)
            else if (Y.startTime <= V)
              i(u), (Y.sortIndex = Y.expirationTime), e(c, Y)
            else break
            Y = t(u)
          }
        }
        function P(V) {
          if (((M = !1), A(V), !_))
            if (t(c) !== null) (_ = !0), J(D)
            else {
              var Y = t(u)
              Y !== null && ne(P, Y.startTime - V)
            }
        }
        function D(V, Y) {
          ;(_ = !1), M && ((M = !1), x(F), (F = -1)), (y = !0)
          var Q = g
          try {
            for (
              A(Y), m = t(c);
              m !== null && (!(m.expirationTime > Y) || (V && !z()));

            ) {
              var q = m.callback
              if (typeof q == 'function') {
                ;(m.callback = null), (g = m.priorityLevel)
                var oe = q(m.expirationTime <= Y)
                ;(Y = n.unstable_now()),
                  typeof oe == 'function'
                    ? (m.callback = oe)
                    : m === t(c) && i(c),
                  A(Y)
              } else i(c)
              m = t(c)
            }
            if (m !== null) var _e = !0
            else {
              var he = t(u)
              he !== null && ne(P, he.startTime - Y), (_e = !1)
            }
            return _e
          } finally {
            ;(m = null), (g = Q), (y = !1)
          }
        }
        var O = !1,
          U = null,
          F = -1,
          N = 5,
          k = -1
        function z() {
          return !(n.unstable_now() - k < N)
        }
        function $() {
          if (U !== null) {
            var V = n.unstable_now()
            k = V
            var Y = !0
            try {
              Y = U(!0, V)
            } finally {
              Y ? te() : ((O = !1), (U = null))
            }
          } else O = !1
        }
        var te
        if (typeof T == 'function')
          te = function () {
            T($)
          }
        else if (typeof MessageChannel < 'u') {
          var j = new MessageChannel(),
            K = j.port2
          ;(j.port1.onmessage = $),
            (te = function () {
              K.postMessage(null)
            })
        } else
          te = function () {
            w($, 0)
          }
        function J(V) {
          ;(U = V), O || ((O = !0), te())
        }
        function ne(V, Y) {
          F = w(function () {
            V(n.unstable_now())
          }, Y)
        }
        ;(n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (V) {
            V.callback = null
          }),
          (n.unstable_continueExecution = function () {
            _ || y || ((_ = !0), J(D))
          }),
          (n.unstable_forceFrameRate = function (V) {
            0 > V || 125 < V
              ? console.error(
                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported',
                )
              : (N = 0 < V ? Math.floor(1e3 / V) : 5)
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return g
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(c)
          }),
          (n.unstable_next = function (V) {
            switch (g) {
              case 1:
              case 2:
              case 3:
                var Y = 3
                break
              default:
                Y = g
            }
            var Q = g
            g = Y
            try {
              return V()
            } finally {
              g = Q
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (V, Y) {
            switch (V) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break
              default:
                V = 3
            }
            var Q = g
            g = V
            try {
              return Y()
            } finally {
              g = Q
            }
          }),
          (n.unstable_scheduleCallback = function (V, Y, Q) {
            var q = n.unstable_now()
            switch (
              (typeof Q == 'object' && Q !== null
                ? ((Q = Q.delay),
                  (Q = typeof Q == 'number' && 0 < Q ? q + Q : q))
                : (Q = q),
              V)
            ) {
              case 1:
                var oe = -1
                break
              case 2:
                oe = 250
                break
              case 5:
                oe = 1073741823
                break
              case 4:
                oe = 1e4
                break
              default:
                oe = 5e3
            }
            return (
              (oe = Q + oe),
              (V = {
                id: h++,
                callback: Y,
                priorityLevel: V,
                startTime: Q,
                expirationTime: oe,
                sortIndex: -1,
              }),
              Q > q
                ? ((V.sortIndex = Q),
                  e(u, V),
                  t(c) === null &&
                    V === t(u) &&
                    (M ? (x(F), (F = -1)) : (M = !0), ne(P, Q - q)))
                : ((V.sortIndex = oe), e(c, V), _ || y || ((_ = !0), J(D))),
              V
            )
          }),
          (n.unstable_shouldYield = z),
          (n.unstable_wrapCallback = function (V) {
            var Y = g
            return function () {
              var Q = g
              g = Y
              try {
                return V.apply(this, arguments)
              } finally {
                g = Q
              }
            }
          })
      })(pw)),
    pw
  )
}
var u2
function IG() {
  return u2 || ((u2 = 1), (hw.exports = RG())), hw.exports
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var mw, d2
function LG() {
  return (
    d2 ||
      ((d2 = 1),
      (mw = function (e) {
        var t = {},
          i = Vs(),
          r = IG(),
          s = Object.assign
        function o(f) {
          for (
            var p =
                'https://reactjs.org/docs/error-decoder.html?invariant=' + f,
              S = 1;
            S < arguments.length;
            S++
          )
            p += '&args[]=' + encodeURIComponent(arguments[S])
          return (
            'Minified React error #' +
            f +
            '; visit ' +
            p +
            ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
          )
        }
        var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          c = Symbol.for('react.element'),
          u = Symbol.for('react.portal'),
          h = Symbol.for('react.fragment'),
          m = Symbol.for('react.strict_mode'),
          g = Symbol.for('react.profiler'),
          y = Symbol.for('react.provider'),
          _ = Symbol.for('react.context'),
          M = Symbol.for('react.forward_ref'),
          w = Symbol.for('react.suspense'),
          x = Symbol.for('react.suspense_list'),
          T = Symbol.for('react.memo'),
          A = Symbol.for('react.lazy'),
          P = Symbol.for('react.offscreen'),
          D = Symbol.iterator
        function O(f) {
          return f === null || typeof f != 'object'
            ? null
            : ((f = (D && f[D]) || f['@@iterator']),
              typeof f == 'function' ? f : null)
        }
        function U(f) {
          if (f == null) return null
          if (typeof f == 'function') return f.displayName || f.name || null
          if (typeof f == 'string') return f
          switch (f) {
            case h:
              return 'Fragment'
            case u:
              return 'Portal'
            case g:
              return 'Profiler'
            case m:
              return 'StrictMode'
            case w:
              return 'Suspense'
            case x:
              return 'SuspenseList'
          }
          if (typeof f == 'object')
            switch (f.$$typeof) {
              case _:
                return (f.displayName || 'Context') + '.Consumer'
              case y:
                return (f._context.displayName || 'Context') + '.Provider'
              case M:
                var p = f.render
                return (
                  (f = f.displayName),
                  f ||
                    ((f = p.displayName || p.name || ''),
                    (f = f !== '' ? 'ForwardRef(' + f + ')' : 'ForwardRef')),
                  f
                )
              case T:
                return (
                  (p = f.displayName || null),
                  p !== null ? p : U(f.type) || 'Memo'
                )
              case A:
                ;(p = f._payload), (f = f._init)
                try {
                  return U(f(p))
                } catch {}
            }
          return null
        }
        function F(f) {
          var p = f.type
          switch (f.tag) {
            case 24:
              return 'Cache'
            case 9:
              return (p.displayName || 'Context') + '.Consumer'
            case 10:
              return (p._context.displayName || 'Context') + '.Provider'
            case 18:
              return 'DehydratedFragment'
            case 11:
              return (
                (f = p.render),
                (f = f.displayName || f.name || ''),
                p.displayName ||
                  (f !== '' ? 'ForwardRef(' + f + ')' : 'ForwardRef')
              )
            case 7:
              return 'Fragment'
            case 5:
              return p
            case 4:
              return 'Portal'
            case 3:
              return 'Root'
            case 6:
              return 'Text'
            case 16:
              return U(p)
            case 8:
              return p === m ? 'StrictMode' : 'Mode'
            case 22:
              return 'Offscreen'
            case 12:
              return 'Profiler'
            case 21:
              return 'Scope'
            case 13:
              return 'Suspense'
            case 19:
              return 'SuspenseList'
            case 25:
              return 'TracingMarker'
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if (typeof p == 'function') return p.displayName || p.name || null
              if (typeof p == 'string') return p
          }
          return null
        }
        function N(f) {
          var p = f,
            S = f
          if (f.alternate) for (; p.return; ) p = p.return
          else {
            f = p
            do (p = f), p.flags & 4098 && (S = p.return), (f = p.return)
            while (f)
          }
          return p.tag === 3 ? S : null
        }
        function k(f) {
          if (N(f) !== f) throw Error(o(188))
        }
        function z(f) {
          var p = f.alternate
          if (!p) {
            if (((p = N(f)), p === null)) throw Error(o(188))
            return p !== f ? null : f
          }
          for (var S = f, C = p; ; ) {
            var I = S.return
            if (I === null) break
            var B = I.alternate
            if (B === null) {
              if (((C = I.return), C !== null)) {
                S = C
                continue
              }
              break
            }
            if (I.child === B.child) {
              for (B = I.child; B; ) {
                if (B === S) return k(I), f
                if (B === C) return k(I), p
                B = B.sibling
              }
              throw Error(o(188))
            }
            if (S.return !== C.return) (S = I), (C = B)
            else {
              for (var ae = !1, ye = I.child; ye; ) {
                if (ye === S) {
                  ;(ae = !0), (S = I), (C = B)
                  break
                }
                if (ye === C) {
                  ;(ae = !0), (C = I), (S = B)
                  break
                }
                ye = ye.sibling
              }
              if (!ae) {
                for (ye = B.child; ye; ) {
                  if (ye === S) {
                    ;(ae = !0), (S = B), (C = I)
                    break
                  }
                  if (ye === C) {
                    ;(ae = !0), (C = B), (S = I)
                    break
                  }
                  ye = ye.sibling
                }
                if (!ae) throw Error(o(189))
              }
            }
            if (S.alternate !== C) throw Error(o(190))
          }
          if (S.tag !== 3) throw Error(o(188))
          return S.stateNode.current === S ? f : p
        }
        function $(f) {
          return (f = z(f)), f !== null ? te(f) : null
        }
        function te(f) {
          if (f.tag === 5 || f.tag === 6) return f
          for (f = f.child; f !== null; ) {
            var p = te(f)
            if (p !== null) return p
            f = f.sibling
          }
          return null
        }
        function j(f) {
          if (f.tag === 5 || f.tag === 6) return f
          for (f = f.child; f !== null; ) {
            if (f.tag !== 4) {
              var p = j(f)
              if (p !== null) return p
            }
            f = f.sibling
          }
          return null
        }
        var K = Array.isArray,
          J = e.getPublicInstance,
          ne = e.getRootHostContext,
          V = e.getChildHostContext,
          Y = e.prepareForCommit,
          Q = e.resetAfterCommit,
          q = e.createInstance,
          oe = e.appendInitialChild,
          _e = e.finalizeInitialChildren,
          he = e.prepareUpdate,
          Ce = e.shouldSetTextContent,
          Te = e.createTextInstance,
          Pe = e.scheduleTimeout,
          Be = e.cancelTimeout,
          et = e.noTimeout,
          ft = e.isPrimaryRenderer,
          Vt = e.supportsMutation,
          je = e.supportsPersistence,
          $e = e.supportsHydration,
          se = e.getInstanceFromNode,
          Rt = e.preparePortalMount,
          Qe = e.getCurrentEventPriority,
          _t = e.detachDeletedInstance,
          rt = e.supportsMicrotasks,
          jt = e.scheduleMicrotask,
          at = e.supportsTestSelectors,
          ie = e.findFiberRoot,
          Z = e.getBoundingRect,
          Se = e.getTextContent,
          Ue = e.isHiddenSubtree,
          Ge = e.matchAccessibilityRole,
          ze = e.setFocusIfFocusable,
          Ct = e.setupIntersectionObserver,
          ct = e.appendChild,
          gt = e.appendChildToContainer,
          rn = e.commitTextUpdate,
          Je = e.commitMount,
          bt = e.commitUpdate,
          Ut = e.insertBefore,
          It = e.insertInContainerBefore,
          Mt = e.removeChild,
          en = e.removeChildFromContainer,
          Bt = e.resetTextContent,
          Kt = e.hideInstance,
          ve = e.hideTextInstance,
          Ie = e.unhideInstance,
          Le = e.unhideTextInstance,
          Ve = e.clearContainer,
          vt = e.cloneInstance,
          ht = e.createContainerChildSet,
          Qt = e.appendChildToContainerChildSet,
          Un = e.finalizeContainerChildren,
          si = e.replaceContainerChildren,
          wn = e.cloneHiddenInstance,
          zi = e.cloneHiddenTextInstance,
          Vi = e.canHydrateInstance,
          Ko = e.canHydrateTextInstance,
          js = e.canHydrateSuspenseInstance,
          ar = e.isSuspenseInstancePending,
          kr = e.isSuspenseInstanceFallback,
          Fr = e.registerSuspenseInstanceRetry,
          ji = e.getNextHydratableSibling,
          sn = e.getFirstHydratableChild,
          Ia = e.getFirstHydratableChildWithinContainer,
          Qo = e.getFirstHydratableChildWithinSuspenseInstance,
          H = e.hydrateInstance,
          ee = e.hydrateTextInstance,
          fe = e.hydrateSuspenseInstance,
          Ae = e.getNextHydratableInstanceAfterSuspenseInstance,
          De = e.commitHydratedContainer,
          Oe = e.commitHydratedSuspenseInstance,
          nt = e.clearSuspenseBoundary,
          Ze = e.clearSuspenseBoundaryFromContainer,
          G = e.shouldDeleteUnhydratedTailInstances,
          le = e.didNotMatchHydratedContainerTextInstance,
          de = e.didNotMatchHydratedTextInstance,
          ce
        function me(f) {
          if (ce === void 0)
            try {
              throw Error()
            } catch (S) {
              var p = S.stack.trim().match(/\n( *(at )?)/)
              ce = (p && p[1]) || ''
            }
          return (
            `
` +
            ce +
            f
          )
        }
        var Me = !1
        function ke(f, p) {
          if (!f || Me) return ''
          Me = !0
          var S = Error.prepareStackTrace
          Error.prepareStackTrace = void 0
          try {
            if (p)
              if (
                ((p = function () {
                  throw Error()
                }),
                Object.defineProperty(p.prototype, 'props', {
                  set: function () {
                    throw Error()
                  },
                }),
                typeof Reflect == 'object' && Reflect.construct)
              ) {
                try {
                  Reflect.construct(p, [])
                } catch (it) {
                  var C = it
                }
                Reflect.construct(f, [], p)
              } else {
                try {
                  p.call()
                } catch (it) {
                  C = it
                }
                f.call(p.prototype)
              }
            else {
              try {
                throw Error()
              } catch (it) {
                C = it
              }
              f()
            }
          } catch (it) {
            if (it && C && typeof it.stack == 'string') {
              for (
                var I = it.stack.split(`
`),
                  B = C.stack.split(`
`),
                  ae = I.length - 1,
                  ye = B.length - 1;
                1 <= ae && 0 <= ye && I[ae] !== B[ye];

              )
                ye--
              for (; 1 <= ae && 0 <= ye; ae--, ye--)
                if (I[ae] !== B[ye]) {
                  if (ae !== 1 || ye !== 1)
                    do
                      if ((ae--, ye--, 0 > ye || I[ae] !== B[ye])) {
                        var Fe =
                          `
` + I[ae].replace(' at new ', ' at ')
                        return (
                          f.displayName &&
                            Fe.includes('<anonymous>') &&
                            (Fe = Fe.replace('<anonymous>', f.displayName)),
                          Fe
                        )
                      }
                    while (1 <= ae && 0 <= ye)
                  break
                }
            }
          } finally {
            ;(Me = !1), (Error.prepareStackTrace = S)
          }
          return (f = f ? f.displayName || f.name : '') ? me(f) : ''
        }
        var He = Object.prototype.hasOwnProperty,
          Xe = [],
          ut = -1
        function ot(f) {
          return { current: f }
        }
        function We(f) {
          0 > ut || ((f.current = Xe[ut]), (Xe[ut] = null), ut--)
        }
        function pt(f, p) {
          ut++, (Xe[ut] = f.current), (f.current = p)
        }
        var mt = {},
          qt = ot(mt),
          Lt = ot(!1),
          Ot = mt
        function wt(f, p) {
          var S = f.type.contextTypes
          if (!S) return mt
          var C = f.stateNode
          if (C && C.__reactInternalMemoizedUnmaskedChildContext === p)
            return C.__reactInternalMemoizedMaskedChildContext
          var I = {},
            B
          for (B in S) I[B] = p[B]
          return (
            C &&
              ((f = f.stateNode),
              (f.__reactInternalMemoizedUnmaskedChildContext = p),
              (f.__reactInternalMemoizedMaskedChildContext = I)),
            I
          )
        }
        function fn(f) {
          return (f = f.childContextTypes), f != null
        }
        function Ht() {
          We(Lt), We(qt)
        }
        function tn(f, p, S) {
          if (qt.current !== mt) throw Error(o(168))
          pt(qt, p), pt(Lt, S)
        }
        function jn(f, p, S) {
          var C = f.stateNode
          if (
            ((p = p.childContextTypes), typeof C.getChildContext != 'function')
          )
            return S
          C = C.getChildContext()
          for (var I in C)
            if (!(I in p)) throw Error(o(108, F(f) || 'Unknown', I))
          return s({}, S, C)
        }
        function ln(f) {
          return (
            (f =
              ((f = f.stateNode) &&
                f.__reactInternalMemoizedMergedChildContext) ||
              mt),
            (Ot = qt.current),
            pt(qt, f),
            pt(Lt, Lt.current),
            !0
          )
        }
        function mn(f, p, S) {
          var C = f.stateNode
          if (!C) throw Error(o(169))
          S
            ? ((f = jn(f, p, Ot)),
              (C.__reactInternalMemoizedMergedChildContext = f),
              We(Lt),
              We(qt),
              pt(qt, f))
            : We(Lt),
            pt(Lt, S)
        }
        var Wt = Math.clz32 ? Math.clz32 : Hn,
          Kn = Math.log,
          Tn = Math.LN2
        function Hn(f) {
          return (f >>>= 0), f === 0 ? 32 : (31 - ((Kn(f) / Tn) | 0)) | 0
        }
        var ui = 64,
          Sn = 4194304
        function xr(f) {
          switch (f & -f) {
            case 1:
              return 1
            case 2:
              return 2
            case 4:
              return 4
            case 8:
              return 8
            case 16:
              return 16
            case 32:
              return 32
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return f & 4194240
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return f & 130023424
            case 134217728:
              return 134217728
            case 268435456:
              return 268435456
            case 536870912:
              return 536870912
            case 1073741824:
              return 1073741824
            default:
              return f
          }
        }
        function jc(f, p) {
          var S = f.pendingLanes
          if (S === 0) return 0
          var C = 0,
            I = f.suspendedLanes,
            B = f.pingedLanes,
            ae = S & 268435455
          if (ae !== 0) {
            var ye = ae & ~I
            ye !== 0 ? (C = xr(ye)) : ((B &= ae), B !== 0 && (C = xr(B)))
          } else (ae = S & ~I), ae !== 0 ? (C = xr(ae)) : B !== 0 && (C = xr(B))
          if (C === 0) return 0
          if (
            p !== 0 &&
            p !== C &&
            !(p & I) &&
            ((I = C & -C),
            (B = p & -p),
            I >= B || (I === 16 && (B & 4194240) !== 0))
          )
            return p
          if ((C & 4 && (C |= S & 16), (p = f.entangledLanes), p !== 0))
            for (f = f.entanglements, p &= C; 0 < p; )
              (S = 31 - Wt(p)), (I = 1 << S), (C |= f[S]), (p &= ~I)
          return C
        }
        function Fh(f, p) {
          switch (f) {
            case 1:
            case 2:
            case 4:
              return p + 250
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return p + 5e3
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1
            default:
              return -1
          }
        }
        function rv(f, p) {
          for (
            var S = f.suspendedLanes,
              C = f.pingedLanes,
              I = f.expirationTimes,
              B = f.pendingLanes;
            0 < B;

          ) {
            var ae = 31 - Wt(B),
              ye = 1 << ae,
              Fe = I[ae]
            Fe === -1
              ? (!(ye & S) || ye & C) && (I[ae] = Fh(ye, p))
              : Fe <= p && (f.expiredLanes |= ye),
              (B &= ~ye)
          }
        }
        function bd(f) {
          return (
            (f = f.pendingLanes & -1073741825),
            f !== 0 ? f : f & 1073741824 ? 1073741824 : 0
          )
        }
        function Td(f) {
          for (var p = [], S = 0; 31 > S; S++) p.push(f)
          return p
        }
        function La(f, p, S) {
          ;(f.pendingLanes |= p),
            p !== 536870912 && ((f.suspendedLanes = 0), (f.pingedLanes = 0)),
            (f = f.eventTimes),
            (p = 31 - Wt(p)),
            (f[p] = S)
        }
        function Ad(f, p) {
          var S = f.pendingLanes & ~p
          ;(f.pendingLanes = p),
            (f.suspendedLanes = 0),
            (f.pingedLanes = 0),
            (f.expiredLanes &= p),
            (f.mutableReadLanes &= p),
            (f.entangledLanes &= p),
            (p = f.entanglements)
          var C = f.eventTimes
          for (f = f.expirationTimes; 0 < S; ) {
            var I = 31 - Wt(S),
              B = 1 << I
            ;(p[I] = 0), (C[I] = -1), (f[I] = -1), (S &= ~B)
          }
        }
        function Hs(f, p) {
          var S = (f.entangledLanes |= p)
          for (f = f.entanglements; S; ) {
            var C = 31 - Wt(S),
              I = 1 << C
            ;(I & p) | (f[C] & p) && (f[C] |= p), (S &= ~I)
          }
        }
        var yn = 0
        function fo(f) {
          return (
            (f &= -f),
            1 < f ? (4 < f ? (f & 268435455 ? 16 : 536870912) : 4) : 1
          )
        }
        var Na = r.unstable_scheduleCallback,
          Ll = r.unstable_cancelCallback,
          Jo = r.unstable_shouldYield,
          V_ = r.unstable_requestPaint,
          bi = r.unstable_now,
          Da = r.unstable_ImmediatePriority,
          j_ = r.unstable_UserBlockingPriority,
          Cd = r.unstable_NormalPriority,
          Pd = r.unstable_IdlePriority,
          Hc = null,
          Gs = null
        function Gc(f) {
          if (Gs && typeof Gs.onCommitFiberRoot == 'function')
            try {
              Gs.onCommitFiberRoot(
                Hc,
                f,
                void 0,
                (f.current.flags & 128) === 128,
              )
            } catch {}
        }
        function Wc(f, p) {
          return (
            (f === p && (f !== 0 || 1 / f === 1 / p)) || (f !== f && p !== p)
          )
        }
        var lr = typeof Object.is == 'function' ? Object.is : Wc,
          is = null,
          Rd = !1,
          Uh = !1
        function Id(f) {
          is === null ? (is = [f]) : is.push(f)
        }
        function Ld(f) {
          ;(Rd = !0), Id(f)
        }
        function rs() {
          if (!Uh && is !== null) {
            Uh = !0
            var f = 0,
              p = yn
            try {
              var S = is
              for (yn = 1; f < S.length; f++) {
                var C = S[f]
                do C = C(!0)
                while (C !== null)
              }
              ;(is = null), (Rd = !1)
            } catch (I) {
              throw (is !== null && (is = is.slice(f + 1)), Na(Da, rs), I)
            } finally {
              ;(yn = p), (Uh = !1)
            }
          }
          return null
        }
        var sv = a.ReactCurrentBatchConfig
        function Ss(f, p) {
          if (lr(f, p)) return !0
          if (
            typeof f != 'object' ||
            f === null ||
            typeof p != 'object' ||
            p === null
          )
            return !1
          var S = Object.keys(f),
            C = Object.keys(p)
          if (S.length !== C.length) return !1
          for (C = 0; C < S.length; C++) {
            var I = S[C]
            if (!He.call(p, I) || !lr(f[I], p[I])) return !1
          }
          return !0
        }
        function Bh(f) {
          switch (f.tag) {
            case 5:
              return me(f.type)
            case 16:
              return me('Lazy')
            case 13:
              return me('Suspense')
            case 19:
              return me('SuspenseList')
            case 0:
            case 2:
            case 15:
              return (f = ke(f.type, !1)), f
            case 11:
              return (f = ke(f.type.render, !1)), f
            case 1:
              return (f = ke(f.type, !0)), f
            default:
              return ''
          }
        }
        function _r(f, p) {
          if (f && f.defaultProps) {
            ;(p = s({}, p)), (f = f.defaultProps)
            for (var S in f) p[S] === void 0 && (p[S] = f[S])
            return p
          }
          return p
        }
        var $c = ot(null),
          Oa = null,
          ho = null,
          Nd = null
        function cr() {
          Nd = ho = Oa = null
        }
        function ka(f, p, S) {
          ft
            ? (pt($c, p._currentValue), (p._currentValue = S))
            : (pt($c, p._currentValue2), (p._currentValue2 = S))
        }
        function Xc(f) {
          var p = $c.current
          We($c), ft ? (f._currentValue = p) : (f._currentValue2 = p)
        }
        function Fa(f, p, S) {
          for (; f !== null; ) {
            var C = f.alternate
            if (
              ((f.childLanes & p) !== p
                ? ((f.childLanes |= p), C !== null && (C.childLanes |= p))
                : C !== null && (C.childLanes & p) !== p && (C.childLanes |= p),
              f === S)
            )
              break
            f = f.return
          }
        }
        function Nl(f, p) {
          ;(Oa = f),
            (Nd = ho = null),
            (f = f.dependencies),
            f !== null &&
              f.firstContext !== null &&
              (f.lanes & p && (Oi = !0), (f.firstContext = null))
        }
        function wr(f) {
          var p = ft ? f._currentValue : f._currentValue2
          if (Nd !== f)
            if (
              ((f = { context: f, memoizedValue: p, next: null }), ho === null)
            ) {
              if (Oa === null) throw Error(o(308))
              ;(ho = f), (Oa.dependencies = { lanes: 0, firstContext: f })
            } else ho = ho.next = f
          return p
        }
        var ss = null,
          os = !1
        function Dl(f) {
          f.updateQueue = {
            baseState: f.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
          }
        }
        function zh(f, p) {
          ;(f = f.updateQueue),
            p.updateQueue === f &&
              (p.updateQueue = {
                baseState: f.baseState,
                firstBaseUpdate: f.firstBaseUpdate,
                lastBaseUpdate: f.lastBaseUpdate,
                shared: f.shared,
                effects: f.effects,
              })
        }
        function po(f, p) {
          return {
            eventTime: f,
            lane: p,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
          }
        }
        function ea(f, p) {
          var S = f.updateQueue
          S !== null &&
            ((S = S.shared),
            fi !== null && f.mode & 1 && !(hn & 2)
              ? ((f = S.interleaved),
                f === null
                  ? ((p.next = p), ss === null ? (ss = [S]) : ss.push(S))
                  : ((p.next = f.next), (f.next = p)),
                (S.interleaved = p))
              : ((f = S.pending),
                f === null ? (p.next = p) : ((p.next = f.next), (f.next = p)),
                (S.pending = p)))
        }
        function Dd(f, p, S) {
          if (
            ((p = p.updateQueue),
            p !== null && ((p = p.shared), (S & 4194240) !== 0))
          ) {
            var C = p.lanes
            ;(C &= f.pendingLanes), (S |= C), (p.lanes = S), Hs(f, S)
          }
        }
        function Od(f, p) {
          var S = f.updateQueue,
            C = f.alternate
          if (C !== null && ((C = C.updateQueue), S === C)) {
            var I = null,
              B = null
            if (((S = S.firstBaseUpdate), S !== null)) {
              do {
                var ae = {
                  eventTime: S.eventTime,
                  lane: S.lane,
                  tag: S.tag,
                  payload: S.payload,
                  callback: S.callback,
                  next: null,
                }
                B === null ? (I = B = ae) : (B = B.next = ae), (S = S.next)
              } while (S !== null)
              B === null ? (I = B = p) : (B = B.next = p)
            } else I = B = p
            ;(S = {
              baseState: C.baseState,
              firstBaseUpdate: I,
              lastBaseUpdate: B,
              shared: C.shared,
              effects: C.effects,
            }),
              (f.updateQueue = S)
            return
          }
          ;(f = S.lastBaseUpdate),
            f === null ? (S.firstBaseUpdate = p) : (f.next = p),
            (S.lastBaseUpdate = p)
        }
        function kd(f, p, S, C) {
          var I = f.updateQueue
          os = !1
          var B = I.firstBaseUpdate,
            ae = I.lastBaseUpdate,
            ye = I.shared.pending
          if (ye !== null) {
            I.shared.pending = null
            var Fe = ye,
              it = Fe.next
            ;(Fe.next = null),
              ae === null ? (B = it) : (ae.next = it),
              (ae = Fe)
            var At = f.alternate
            At !== null &&
              ((At = At.updateQueue),
              (ye = At.lastBaseUpdate),
              ye !== ae &&
                (ye === null ? (At.firstBaseUpdate = it) : (ye.next = it),
                (At.lastBaseUpdate = Fe)))
          }
          if (B !== null) {
            var on = I.baseState
            ;(ae = 0), (At = it = Fe = null), (ye = B)
            do {
              var Gt = ye.lane,
                gn = ye.eventTime
              if ((C & Gt) === Gt) {
                At !== null &&
                  (At = At.next =
                    {
                      eventTime: gn,
                      lane: 0,
                      tag: ye.tag,
                      payload: ye.payload,
                      callback: ye.callback,
                      next: null,
                    })
                e: {
                  var St = f,
                    qi = ye
                  switch (((Gt = p), (gn = S), qi.tag)) {
                    case 1:
                      if (((St = qi.payload), typeof St == 'function')) {
                        on = St.call(gn, on, Gt)
                        break e
                      }
                      on = St
                      break e
                    case 3:
                      St.flags = (St.flags & -65537) | 128
                    case 0:
                      if (
                        ((St = qi.payload),
                        (Gt =
                          typeof St == 'function' ? St.call(gn, on, Gt) : St),
                        Gt == null)
                      )
                        break e
                      on = s({}, on, Gt)
                      break e
                    case 2:
                      os = !0
                  }
                }
                ye.callback !== null &&
                  ye.lane !== 0 &&
                  ((f.flags |= 64),
                  (Gt = I.effects),
                  Gt === null ? (I.effects = [ye]) : Gt.push(ye))
              } else
                (gn = {
                  eventTime: gn,
                  lane: Gt,
                  tag: ye.tag,
                  payload: ye.payload,
                  callback: ye.callback,
                  next: null,
                }),
                  At === null
                    ? ((it = At = gn), (Fe = on))
                    : (At = At.next = gn),
                  (ae |= Gt)
              if (((ye = ye.next), ye === null)) {
                if (((ye = I.shared.pending), ye === null)) break
                ;(Gt = ye),
                  (ye = Gt.next),
                  (Gt.next = null),
                  (I.lastBaseUpdate = Gt),
                  (I.shared.pending = null)
              }
            } while (!0)
            if (
              (At === null && (Fe = on),
              (I.baseState = Fe),
              (I.firstBaseUpdate = it),
              (I.lastBaseUpdate = At),
              (p = I.shared.interleaved),
              p !== null)
            ) {
              I = p
              do (ae |= I.lane), (I = I.next)
              while (I !== p)
            } else B === null && (I.shared.lanes = 0)
            ;(qs |= ae), (f.lanes = ae), (f.memoizedState = on)
          }
        }
        function ov(f, p, S) {
          if (((f = p.effects), (p.effects = null), f !== null))
            for (p = 0; p < f.length; p++) {
              var C = f[p],
                I = C.callback
              if (I !== null) {
                if (((C.callback = null), (C = S), typeof I != 'function'))
                  throw Error(o(191, I))
                I.call(C)
              }
            }
        }
        var av = new i.Component().refs
        function Vh(f, p, S, C) {
          ;(p = f.memoizedState),
            (S = S(C, p)),
            (S = S == null ? p : s({}, p, S)),
            (f.memoizedState = S),
            f.lanes === 0 && (f.updateQueue.baseState = S)
        }
        var Fd = {
          isMounted: function (f) {
            return (f = f._reactInternals) ? N(f) === f : !1
          },
          enqueueSetState: function (f, p, S) {
            f = f._reactInternals
            var C = An(),
              I = Ps(f),
              B = po(C, I)
            ;(B.payload = p),
              S != null && (B.callback = S),
              ea(f, B),
              (p = er(f, I, C)),
              p !== null && Dd(p, f, I)
          },
          enqueueReplaceState: function (f, p, S) {
            f = f._reactInternals
            var C = An(),
              I = Ps(f),
              B = po(C, I)
            ;(B.tag = 1),
              (B.payload = p),
              S != null && (B.callback = S),
              ea(f, B),
              (p = er(f, I, C)),
              p !== null && Dd(p, f, I)
          },
          enqueueForceUpdate: function (f, p) {
            f = f._reactInternals
            var S = An(),
              C = Ps(f),
              I = po(S, C)
            ;(I.tag = 2),
              p != null && (I.callback = p),
              ea(f, I),
              (p = er(f, C, S)),
              p !== null && Dd(p, f, C)
          },
        }
        function jh(f, p, S, C, I, B, ae) {
          return (
            (f = f.stateNode),
            typeof f.shouldComponentUpdate == 'function'
              ? f.shouldComponentUpdate(C, B, ae)
              : p.prototype && p.prototype.isPureReactComponent
              ? !Ss(S, C) || !Ss(I, B)
              : !0
          )
        }
        function lv(f, p, S) {
          var C = !1,
            I = mt,
            B = p.contextType
          return (
            typeof B == 'object' && B !== null
              ? (B = wr(B))
              : ((I = fn(p) ? Ot : qt.current),
                (C = p.contextTypes),
                (B = (C = C != null) ? wt(f, I) : mt)),
            (p = new p(S, B)),
            (f.memoizedState =
              p.state !== null && p.state !== void 0 ? p.state : null),
            (p.updater = Fd),
            (f.stateNode = p),
            (p._reactInternals = f),
            C &&
              ((f = f.stateNode),
              (f.__reactInternalMemoizedUnmaskedChildContext = I),
              (f.__reactInternalMemoizedMaskedChildContext = B)),
            p
          )
        }
        function cv(f, p, S, C) {
          ;(f = p.state),
            typeof p.componentWillReceiveProps == 'function' &&
              p.componentWillReceiveProps(S, C),
            typeof p.UNSAFE_componentWillReceiveProps == 'function' &&
              p.UNSAFE_componentWillReceiveProps(S, C),
            p.state !== f && Fd.enqueueReplaceState(p, p.state, null)
        }
        function Hh(f, p, S, C) {
          var I = f.stateNode
          ;(I.props = S), (I.state = f.memoizedState), (I.refs = av), Dl(f)
          var B = p.contextType
          typeof B == 'object' && B !== null
            ? (I.context = wr(B))
            : ((B = fn(p) ? Ot : qt.current), (I.context = wt(f, B))),
            (I.state = f.memoizedState),
            (B = p.getDerivedStateFromProps),
            typeof B == 'function' &&
              (Vh(f, p, B, S), (I.state = f.memoizedState)),
            typeof p.getDerivedStateFromProps == 'function' ||
              typeof I.getSnapshotBeforeUpdate == 'function' ||
              (typeof I.UNSAFE_componentWillMount != 'function' &&
                typeof I.componentWillMount != 'function') ||
              ((p = I.state),
              typeof I.componentWillMount == 'function' &&
                I.componentWillMount(),
              typeof I.UNSAFE_componentWillMount == 'function' &&
                I.UNSAFE_componentWillMount(),
              p !== I.state && Fd.enqueueReplaceState(I, I.state, null),
              kd(f, S, I, C),
              (I.state = f.memoizedState)),
            typeof I.componentDidMount == 'function' && (f.flags |= 4194308)
        }
        var Ol = [],
          ta = 0,
          Ud = null,
          Bd = 0,
          as = [],
          Ur = 0,
          Ua = null,
          mo = 1,
          go = ''
        function Ba(f, p) {
          ;(Ol[ta++] = Bd), (Ol[ta++] = Ud), (Ud = f), (Bd = p)
        }
        function uv(f, p, S) {
          ;(as[Ur++] = mo), (as[Ur++] = go), (as[Ur++] = Ua), (Ua = f)
          var C = mo
          f = go
          var I = 32 - Wt(C) - 1
          ;(C &= ~(1 << I)), (S += 1)
          var B = 32 - Wt(p) + I
          if (30 < B) {
            var ae = I - (I % 5)
            ;(B = (C & ((1 << ae) - 1)).toString(32)),
              (C >>= ae),
              (I -= ae),
              (mo = (1 << (32 - Wt(p) + I)) | (S << I) | C),
              (go = B + f)
          } else (mo = (1 << B) | (S << I) | C), (go = f)
        }
        function Gh(f) {
          f.return !== null && (Ba(f, 1), uv(f, 1, 0))
        }
        function Wh(f) {
          for (; f === Ud; )
            (Ud = Ol[--ta]), (Ol[ta] = null), (Bd = Ol[--ta]), (Ol[ta] = null)
          for (; f === Ua; )
            (Ua = as[--Ur]),
              (as[Ur] = null),
              (go = as[--Ur]),
              (as[Ur] = null),
              (mo = as[--Ur]),
              (as[Ur] = null)
        }
        var ur = null,
          Hi = null,
          Qn = !1,
          kl = !1,
          ls = null
        function $h(f, p) {
          var S = Wr(5, null, null, 0)
          ;(S.elementType = 'DELETED'),
            (S.stateNode = p),
            (S.return = f),
            (p = f.deletions),
            p === null ? ((f.deletions = [S]), (f.flags |= 16)) : p.push(S)
        }
        function Xh(f, p) {
          switch (f.tag) {
            case 5:
              return (
                (p = Vi(p, f.type, f.pendingProps)),
                p !== null
                  ? ((f.stateNode = p), (ur = f), (Hi = sn(p)), !0)
                  : !1
              )
            case 6:
              return (
                (p = Ko(p, f.pendingProps)),
                p !== null ? ((f.stateNode = p), (ur = f), (Hi = null), !0) : !1
              )
            case 13:
              if (((p = js(p)), p !== null)) {
                var S = Ua !== null ? { id: mo, overflow: go } : null
                return (
                  (f.memoizedState = {
                    dehydrated: p,
                    treeContext: S,
                    retryLane: 1073741824,
                  }),
                  (S = Wr(18, null, null, 0)),
                  (S.stateNode = p),
                  (S.return = f),
                  (f.child = S),
                  (ur = f),
                  (Hi = null),
                  !0
                )
              }
              return !1
            default:
              return !1
          }
        }
        function zd(f) {
          return (f.mode & 1) !== 0 && (f.flags & 128) === 0
        }
        function na(f) {
          if (Qn) {
            var p = Hi
            if (p) {
              var S = p
              if (!Xh(f, p)) {
                if (zd(f)) throw Error(o(418))
                p = ji(S)
                var C = ur
                p && Xh(f, p)
                  ? $h(C, S)
                  : ((f.flags = (f.flags & -4097) | 2), (Qn = !1), (ur = f))
              }
            } else {
              if (zd(f)) throw Error(o(418))
              ;(f.flags = (f.flags & -4097) | 2), (Qn = !1), (ur = f)
            }
          }
        }
        function dv(f) {
          for (
            f = f.return;
            f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13;

          )
            f = f.return
          ur = f
        }
        function qc(f) {
          if (!$e || f !== ur) return !1
          if (!Qn) return dv(f), (Qn = !0), !1
          if (
            f.tag !== 3 &&
            (f.tag !== 5 || (G(f.type) && !Ce(f.type, f.memoizedProps)))
          ) {
            var p = Hi
            if (p) {
              if (zd(f)) {
                for (f = Hi; f; ) f = ji(f)
                throw Error(o(418))
              }
              for (; p; ) $h(f, p), (p = ji(p))
            }
          }
          if ((dv(f), f.tag === 13)) {
            if (!$e) throw Error(o(316))
            if (
              ((f = f.memoizedState),
              (f = f !== null ? f.dehydrated : null),
              !f)
            )
              throw Error(o(317))
            Hi = Ae(f)
          } else Hi = ur ? ji(f.stateNode) : null
          return !0
        }
        function Fl() {
          $e && ((Hi = ur = null), (kl = Qn = !1))
        }
        function Vd(f) {
          ls === null ? (ls = [f]) : ls.push(f)
        }
        function Ul(f, p, S) {
          if (
            ((f = S.ref),
            f !== null && typeof f != 'function' && typeof f != 'object')
          ) {
            if (S._owner) {
              if (((S = S._owner), S)) {
                if (S.tag !== 1) throw Error(o(309))
                var C = S.stateNode
              }
              if (!C) throw Error(o(147, f))
              var I = C,
                B = '' + f
              return p !== null &&
                p.ref !== null &&
                typeof p.ref == 'function' &&
                p.ref._stringRef === B
                ? p.ref
                : ((p = function (ae) {
                    var ye = I.refs
                    ye === av && (ye = I.refs = {}),
                      ae === null ? delete ye[B] : (ye[B] = ae)
                  }),
                  (p._stringRef = B),
                  p)
            }
            if (typeof f != 'string') throw Error(o(284))
            if (!S._owner) throw Error(o(290, f))
          }
          return f
        }
        function ia(f, p) {
          throw (
            ((f = Object.prototype.toString.call(p)),
            Error(
              o(
                31,
                f === '[object Object]'
                  ? 'object with keys {' + Object.keys(p).join(', ') + '}'
                  : f,
              ),
            ))
          )
        }
        function Bl(f) {
          var p = f._init
          return p(f._payload)
        }
        function fv(f) {
          function p(be, xe) {
            if (f) {
              var Ne = be.deletions
              Ne === null
                ? ((be.deletions = [xe]), (be.flags |= 16))
                : Ne.push(xe)
            }
          }
          function S(be, xe) {
            if (!f) return null
            for (; xe !== null; ) p(be, xe), (xe = xe.sibling)
            return null
          }
          function C(be, xe) {
            for (be = new Map(); xe !== null; )
              xe.key !== null ? be.set(xe.key, xe) : be.set(xe.index, xe),
                (xe = xe.sibling)
            return be
          }
          function I(be, xe) {
            return (be = Ro(be, xe)), (be.index = 0), (be.sibling = null), be
          }
          function B(be, xe, Ne) {
            return (
              (be.index = Ne),
              f
                ? ((Ne = be.alternate),
                  Ne !== null
                    ? ((Ne = Ne.index), Ne < xe ? ((be.flags |= 2), xe) : Ne)
                    : ((be.flags |= 2), xe))
                : ((be.flags |= 1048576), xe)
            )
          }
          function ae(be) {
            return f && be.alternate === null && (be.flags |= 2), be
          }
          function ye(be, xe, Ne, yt) {
            return xe === null || xe.tag !== 6
              ? ((xe = mf(Ne, be.mode, yt)), (xe.return = be), xe)
              : ((xe = I(xe, Ne)), (xe.return = be), xe)
          }
          function Fe(be, xe, Ne, yt) {
            var kt = Ne.type
            return kt === h
              ? At(be, xe, Ne.props.children, yt, Ne.key)
              : xe !== null &&
                (xe.elementType === kt ||
                  (typeof kt == 'object' &&
                    kt !== null &&
                    kt.$$typeof === A &&
                    Bl(kt) === xe.type))
              ? ((yt = I(xe, Ne.props)),
                (yt.ref = Ul(be, xe, Ne)),
                (yt.return = be),
                yt)
              : ((yt = pf(Ne.type, Ne.key, Ne.props, null, be.mode, yt)),
                (yt.ref = Ul(be, xe, Ne)),
                (yt.return = be),
                yt)
          }
          function it(be, xe, Ne, yt) {
            return xe === null ||
              xe.tag !== 4 ||
              xe.stateNode.containerInfo !== Ne.containerInfo ||
              xe.stateNode.implementation !== Ne.implementation
              ? ((xe = gf(Ne, be.mode, yt)), (xe.return = be), xe)
              : ((xe = I(xe, Ne.children || [])), (xe.return = be), xe)
          }
          function At(be, xe, Ne, yt, kt) {
            return xe === null || xe.tag !== 7
              ? ((xe = al(Ne, be.mode, yt, kt)), (xe.return = be), xe)
              : ((xe = I(xe, Ne)), (xe.return = be), xe)
          }
          function on(be, xe, Ne) {
            if ((typeof xe == 'string' && xe !== '') || typeof xe == 'number')
              return (xe = mf('' + xe, be.mode, Ne)), (xe.return = be), xe
            if (typeof xe == 'object' && xe !== null) {
              switch (xe.$$typeof) {
                case c:
                  return (
                    (Ne = pf(xe.type, xe.key, xe.props, null, be.mode, Ne)),
                    (Ne.ref = Ul(be, null, xe)),
                    (Ne.return = be),
                    Ne
                  )
                case u:
                  return (xe = gf(xe, be.mode, Ne)), (xe.return = be), xe
                case A:
                  var yt = xe._init
                  return on(be, yt(xe._payload), Ne)
              }
              if (K(xe) || O(xe))
                return (xe = al(xe, be.mode, Ne, null)), (xe.return = be), xe
              ia(be, xe)
            }
            return null
          }
          function Gt(be, xe, Ne, yt) {
            var kt = xe !== null ? xe.key : null
            if ((typeof Ne == 'string' && Ne !== '') || typeof Ne == 'number')
              return kt !== null ? null : ye(be, xe, '' + Ne, yt)
            if (typeof Ne == 'object' && Ne !== null) {
              switch (Ne.$$typeof) {
                case c:
                  return Ne.key === kt ? Fe(be, xe, Ne, yt) : null
                case u:
                  return Ne.key === kt ? it(be, xe, Ne, yt) : null
                case A:
                  return (kt = Ne._init), Gt(be, xe, kt(Ne._payload), yt)
              }
              if (K(Ne) || O(Ne))
                return kt !== null ? null : At(be, xe, Ne, yt, null)
              ia(be, Ne)
            }
            return null
          }
          function gn(be, xe, Ne, yt, kt) {
            if ((typeof yt == 'string' && yt !== '') || typeof yt == 'number')
              return (be = be.get(Ne) || null), ye(xe, be, '' + yt, kt)
            if (typeof yt == 'object' && yt !== null) {
              switch (yt.$$typeof) {
                case c:
                  return (
                    (be = be.get(yt.key === null ? Ne : yt.key) || null),
                    Fe(xe, be, yt, kt)
                  )
                case u:
                  return (
                    (be = be.get(yt.key === null ? Ne : yt.key) || null),
                    it(xe, be, yt, kt)
                  )
                case A:
                  var cn = yt._init
                  return gn(be, xe, Ne, cn(yt._payload), kt)
              }
              if (K(yt) || O(yt))
                return (be = be.get(Ne) || null), At(xe, be, yt, kt, null)
              ia(xe, yt)
            }
            return null
          }
          function St(be, xe, Ne, yt) {
            for (
              var kt = null, cn = null, an = xe, bn = (xe = 0), _i = null;
              an !== null && bn < Ne.length;
              bn++
            ) {
              an.index > bn ? ((_i = an), (an = null)) : (_i = an.sibling)
              var En = Gt(be, an, Ne[bn], yt)
              if (En === null) {
                an === null && (an = _i)
                break
              }
              f && an && En.alternate === null && p(be, an),
                (xe = B(En, xe, bn)),
                cn === null ? (kt = En) : (cn.sibling = En),
                (cn = En),
                (an = _i)
            }
            if (bn === Ne.length) return S(be, an), Qn && Ba(be, bn), kt
            if (an === null) {
              for (; bn < Ne.length; bn++)
                (an = on(be, Ne[bn], yt)),
                  an !== null &&
                    ((xe = B(an, xe, bn)),
                    cn === null ? (kt = an) : (cn.sibling = an),
                    (cn = an))
              return Qn && Ba(be, bn), kt
            }
            for (an = C(be, an); bn < Ne.length; bn++)
              (_i = gn(an, be, bn, Ne[bn], yt)),
                _i !== null &&
                  (f &&
                    _i.alternate !== null &&
                    an.delete(_i.key === null ? bn : _i.key),
                  (xe = B(_i, xe, bn)),
                  cn === null ? (kt = _i) : (cn.sibling = _i),
                  (cn = _i))
            return (
              f &&
                an.forEach(function (Io) {
                  return p(be, Io)
                }),
              Qn && Ba(be, bn),
              kt
            )
          }
          function qi(be, xe, Ne, yt) {
            var kt = O(Ne)
            if (typeof kt != 'function') throw Error(o(150))
            if (((Ne = kt.call(Ne)), Ne == null)) throw Error(o(151))
            for (
              var cn = (kt = null),
                an = xe,
                bn = (xe = 0),
                _i = null,
                En = Ne.next();
              an !== null && !En.done;
              bn++, En = Ne.next()
            ) {
              an.index > bn ? ((_i = an), (an = null)) : (_i = an.sibling)
              var Io = Gt(be, an, En.value, yt)
              if (Io === null) {
                an === null && (an = _i)
                break
              }
              f && an && Io.alternate === null && p(be, an),
                (xe = B(Io, xe, bn)),
                cn === null ? (kt = Io) : (cn.sibling = Io),
                (cn = Io),
                (an = _i)
            }
            if (En.done) return S(be, an), Qn && Ba(be, bn), kt
            if (an === null) {
              for (; !En.done; bn++, En = Ne.next())
                (En = on(be, En.value, yt)),
                  En !== null &&
                    ((xe = B(En, xe, bn)),
                    cn === null ? (kt = En) : (cn.sibling = En),
                    (cn = En))
              return Qn && Ba(be, bn), kt
            }
            for (an = C(be, an); !En.done; bn++, En = Ne.next())
              (En = gn(an, be, bn, En.value, yt)),
                En !== null &&
                  (f &&
                    En.alternate !== null &&
                    an.delete(En.key === null ? bn : En.key),
                  (xe = B(En, xe, bn)),
                  cn === null ? (kt = En) : (cn.sibling = En),
                  (cn = En))
            return (
              f &&
                an.forEach(function (Ep) {
                  return p(be, Ep)
                }),
              Qn && Ba(be, bn),
              kt
            )
          }
          function $r(be, xe, Ne, yt) {
            if (
              (typeof Ne == 'object' &&
                Ne !== null &&
                Ne.type === h &&
                Ne.key === null &&
                (Ne = Ne.props.children),
              typeof Ne == 'object' && Ne !== null)
            ) {
              switch (Ne.$$typeof) {
                case c:
                  e: {
                    for (var kt = Ne.key, cn = xe; cn !== null; ) {
                      if (cn.key === kt) {
                        if (((kt = Ne.type), kt === h)) {
                          if (cn.tag === 7) {
                            S(be, cn.sibling),
                              (xe = I(cn, Ne.props.children)),
                              (xe.return = be),
                              (be = xe)
                            break e
                          }
                        } else if (
                          cn.elementType === kt ||
                          (typeof kt == 'object' &&
                            kt !== null &&
                            kt.$$typeof === A &&
                            Bl(kt) === cn.type)
                        ) {
                          S(be, cn.sibling),
                            (xe = I(cn, Ne.props)),
                            (xe.ref = Ul(be, cn, Ne)),
                            (xe.return = be),
                            (be = xe)
                          break e
                        }
                        S(be, cn)
                        break
                      } else p(be, cn)
                      cn = cn.sibling
                    }
                    Ne.type === h
                      ? ((xe = al(Ne.props.children, be.mode, yt, Ne.key)),
                        (xe.return = be),
                        (be = xe))
                      : ((yt = pf(
                          Ne.type,
                          Ne.key,
                          Ne.props,
                          null,
                          be.mode,
                          yt,
                        )),
                        (yt.ref = Ul(be, xe, Ne)),
                        (yt.return = be),
                        (be = yt))
                  }
                  return ae(be)
                case u:
                  e: {
                    for (cn = Ne.key; xe !== null; ) {
                      if (xe.key === cn)
                        if (
                          xe.tag === 4 &&
                          xe.stateNode.containerInfo === Ne.containerInfo &&
                          xe.stateNode.implementation === Ne.implementation
                        ) {
                          S(be, xe.sibling),
                            (xe = I(xe, Ne.children || [])),
                            (xe.return = be),
                            (be = xe)
                          break e
                        } else {
                          S(be, xe)
                          break
                        }
                      else p(be, xe)
                      xe = xe.sibling
                    }
                    ;(xe = gf(Ne, be.mode, yt)), (xe.return = be), (be = xe)
                  }
                  return ae(be)
                case A:
                  return (cn = Ne._init), $r(be, xe, cn(Ne._payload), yt)
              }
              if (K(Ne)) return St(be, xe, Ne, yt)
              if (O(Ne)) return qi(be, xe, Ne, yt)
              ia(be, Ne)
            }
            return (typeof Ne == 'string' && Ne !== '') || typeof Ne == 'number'
              ? ((Ne = '' + Ne),
                xe !== null && xe.tag === 6
                  ? (S(be, xe.sibling),
                    (xe = I(xe, Ne)),
                    (xe.return = be),
                    (be = xe))
                  : (S(be, xe),
                    (xe = mf(Ne, be.mode, yt)),
                    (xe.return = be),
                    (be = xe)),
                ae(be))
              : S(be, xe)
          }
          return $r
        }
        var vo = fv(!0),
          hv = fv(!1),
          zl = {},
          Sr = ot(zl),
          za = ot(zl),
          Va = ot(zl)
        function Ms(f) {
          if (f === zl) throw Error(o(174))
          return f
        }
        function jd(f, p) {
          pt(Va, p), pt(za, f), pt(Sr, zl), (f = ne(p)), We(Sr), pt(Sr, f)
        }
        function Vl() {
          We(Sr), We(za), We(Va)
        }
        function pv(f) {
          var p = Ms(Va.current),
            S = Ms(Sr.current)
          ;(p = V(S, f.type, p)), S !== p && (pt(za, f), pt(Sr, p))
        }
        function qh(f) {
          za.current === f && (We(Sr), We(za))
        }
        var ti = ot(0)
        function Hd(f) {
          for (var p = f; p !== null; ) {
            if (p.tag === 13) {
              var S = p.memoizedState
              if (
                S !== null &&
                ((S = S.dehydrated), S === null || ar(S) || kr(S))
              )
                return p
            } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
              if (p.flags & 128) return p
            } else if (p.child !== null) {
              ;(p.child.return = p), (p = p.child)
              continue
            }
            if (p === f) break
            for (; p.sibling === null; ) {
              if (p.return === null || p.return === f) return null
              p = p.return
            }
            ;(p.sibling.return = p.return), (p = p.sibling)
          }
          return null
        }
        var Br = []
        function ja() {
          for (var f = 0; f < Br.length; f++) {
            var p = Br[f]
            ft
              ? (p._workInProgressVersionPrimary = null)
              : (p._workInProgressVersionSecondary = null)
          }
          Br.length = 0
        }
        var Yc = a.ReactCurrentDispatcher,
          zr = a.ReactCurrentBatchConfig,
          Ha = 0,
          ni = null,
          Li = null,
          Ni = null,
          Gd = !1,
          Ws = !1,
          Ga = 0,
          Zc = 0
        function Di() {
          throw Error(o(321))
        }
        function Wd(f, p) {
          if (p === null) return !1
          for (var S = 0; S < p.length && S < f.length; S++)
            if (!lr(f[S], p[S])) return !1
          return !0
        }
        function jl(f, p, S, C, I, B) {
          if (
            ((Ha = B),
            (ni = p),
            (p.memoizedState = null),
            (p.updateQueue = null),
            (p.lanes = 0),
            (Yc.current = f === null || f.memoizedState === null ? ep : tp),
            (f = S(C, I)),
            Ws)
          ) {
            B = 0
            do {
              if (((Ws = !1), (Ga = 0), 25 <= B)) throw Error(o(301))
              ;(B += 1),
                (Ni = Li = null),
                (p.updateQueue = null),
                (Yc.current = np),
                (f = S(C, I))
            } while (Ws)
          }
          if (
            ((Yc.current = $l),
            (p = Li !== null && Li.next !== null),
            (Ha = 0),
            (Ni = Li = ni = null),
            (Gd = !1),
            p)
          )
            throw Error(o(300))
          return f
        }
        function ra() {
          var f = Ga !== 0
          return (Ga = 0), f
        }
        function Es() {
          var f = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          }
          return (
            Ni === null ? (ni.memoizedState = Ni = f) : (Ni = Ni.next = f), Ni
          )
        }
        function bs() {
          if (Li === null) {
            var f = ni.alternate
            f = f !== null ? f.memoizedState : null
          } else f = Li.next
          var p = Ni === null ? ni.memoizedState : Ni.next
          if (p !== null) (Ni = p), (Li = f)
          else {
            if (f === null) throw Error(o(310))
            ;(Li = f),
              (f = {
                memoizedState: Li.memoizedState,
                baseState: Li.baseState,
                baseQueue: Li.baseQueue,
                queue: Li.queue,
                next: null,
              }),
              Ni === null ? (ni.memoizedState = Ni = f) : (Ni = Ni.next = f)
          }
          return Ni
        }
        function $s(f, p) {
          return typeof p == 'function' ? p(f) : p
        }
        function Kc(f) {
          var p = bs(),
            S = p.queue
          if (S === null) throw Error(o(311))
          S.lastRenderedReducer = f
          var C = Li,
            I = C.baseQueue,
            B = S.pending
          if (B !== null) {
            if (I !== null) {
              var ae = I.next
              ;(I.next = B.next), (B.next = ae)
            }
            ;(C.baseQueue = I = B), (S.pending = null)
          }
          if (I !== null) {
            ;(B = I.next), (C = C.baseState)
            var ye = (ae = null),
              Fe = null,
              it = B
            do {
              var At = it.lane
              if ((Ha & At) === At)
                Fe !== null &&
                  (Fe = Fe.next =
                    {
                      lane: 0,
                      action: it.action,
                      hasEagerState: it.hasEagerState,
                      eagerState: it.eagerState,
                      next: null,
                    }),
                  (C = it.hasEagerState ? it.eagerState : f(C, it.action))
              else {
                var on = {
                  lane: At,
                  action: it.action,
                  hasEagerState: it.hasEagerState,
                  eagerState: it.eagerState,
                  next: null,
                }
                Fe === null ? ((ye = Fe = on), (ae = C)) : (Fe = Fe.next = on),
                  (ni.lanes |= At),
                  (qs |= At)
              }
              it = it.next
            } while (it !== null && it !== B)
            Fe === null ? (ae = C) : (Fe.next = ye),
              lr(C, p.memoizedState) || (Oi = !0),
              (p.memoizedState = C),
              (p.baseState = ae),
              (p.baseQueue = Fe),
              (S.lastRenderedState = C)
          }
          if (((f = S.interleaved), f !== null)) {
            I = f
            do (B = I.lane), (ni.lanes |= B), (qs |= B), (I = I.next)
            while (I !== f)
          } else I === null && (S.lanes = 0)
          return [p.memoizedState, S.dispatch]
        }
        function Qc(f) {
          var p = bs(),
            S = p.queue
          if (S === null) throw Error(o(311))
          S.lastRenderedReducer = f
          var C = S.dispatch,
            I = S.pending,
            B = p.memoizedState
          if (I !== null) {
            S.pending = null
            var ae = (I = I.next)
            do (B = f(B, ae.action)), (ae = ae.next)
            while (ae !== I)
            lr(B, p.memoizedState) || (Oi = !0),
              (p.memoizedState = B),
              p.baseQueue === null && (p.baseState = B),
              (S.lastRenderedState = B)
          }
          return [B, C]
        }
        function Yh() {}
        function Zh(f, p) {
          var S = ni,
            C = bs(),
            I = p(),
            B = !lr(C.memoizedState, I)
          if (
            (B && ((C.memoizedState = I), (Oi = !0)),
            (C = C.queue),
            Hl(yo.bind(null, S, C, f), [f]),
            C.getSnapshot !== p ||
              B ||
              (Ni !== null && Ni.memoizedState.tag & 1))
          ) {
            if (
              ((S.flags |= 2048),
              eu(9, Qh.bind(null, S, C, I, p), void 0, null),
              fi === null)
            )
              throw Error(o(349))
            Ha & 30 || Kh(S, p, I)
          }
          return I
        }
        function Kh(f, p, S) {
          ;(f.flags |= 16384),
            (f = { getSnapshot: p, value: S }),
            (p = ni.updateQueue),
            p === null
              ? ((p = { lastEffect: null, stores: null }),
                (ni.updateQueue = p),
                (p.stores = [f]))
              : ((S = p.stores), S === null ? (p.stores = [f]) : S.push(f))
        }
        function Qh(f, p, S, C) {
          ;(p.value = S), (p.getSnapshot = C), $d(p) && er(f, 1, -1)
        }
        function yo(f, p, S) {
          return S(function () {
            $d(p) && er(f, 1, -1)
          })
        }
        function $d(f) {
          var p = f.getSnapshot
          f = f.value
          try {
            var S = p()
            return !lr(f, S)
          } catch {
            return !0
          }
        }
        function Jc(f) {
          var p = Es()
          return (
            typeof f == 'function' && (f = f()),
            (p.memoizedState = p.baseState = f),
            (f = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: $s,
              lastRenderedState: f,
            }),
            (p.queue = f),
            (f = f.dispatch = H_.bind(null, ni, f)),
            [p.memoizedState, f]
          )
        }
        function eu(f, p, S, C) {
          return (
            (f = { tag: f, create: p, destroy: S, deps: C, next: null }),
            (p = ni.updateQueue),
            p === null
              ? ((p = { lastEffect: null, stores: null }),
                (ni.updateQueue = p),
                (p.lastEffect = f.next = f))
              : ((S = p.lastEffect),
                S === null
                  ? (p.lastEffect = f.next = f)
                  : ((C = S.next),
                    (S.next = f),
                    (f.next = C),
                    (p.lastEffect = f))),
            f
          )
        }
        function mv() {
          return bs().memoizedState
        }
        function sa(f, p, S, C) {
          var I = Es()
          ;(ni.flags |= f),
            (I.memoizedState = eu(1 | p, S, void 0, C === void 0 ? null : C))
        }
        function Xd(f, p, S, C) {
          var I = bs()
          C = C === void 0 ? null : C
          var B = void 0
          if (Li !== null) {
            var ae = Li.memoizedState
            if (((B = ae.destroy), C !== null && Wd(C, ae.deps))) {
              I.memoizedState = eu(p, S, B, C)
              return
            }
          }
          ;(ni.flags |= f), (I.memoizedState = eu(1 | p, S, B, C))
        }
        function qd(f, p) {
          return sa(8390656, 8, f, p)
        }
        function Hl(f, p) {
          return Xd(2048, 8, f, p)
        }
        function Gn(f, p) {
          return Xd(4, 2, f, p)
        }
        function Yd(f, p) {
          return Xd(4, 4, f, p)
        }
        function tu(f, p) {
          if (typeof p == 'function')
            return (
              (f = f()),
              p(f),
              function () {
                p(null)
              }
            )
          if (p != null)
            return (
              (f = f()),
              (p.current = f),
              function () {
                p.current = null
              }
            )
        }
        function Gl(f, p, S) {
          return (
            (S = S != null ? S.concat([f]) : null),
            Xd(4, 4, tu.bind(null, p, f), S)
          )
        }
        function Zd() {}
        function Kd(f, p) {
          var S = bs()
          p = p === void 0 ? null : p
          var C = S.memoizedState
          return C !== null && p !== null && Wd(p, C[1])
            ? C[0]
            : ((S.memoizedState = [f, p]), f)
        }
        function Wl(f, p) {
          var S = bs()
          p = p === void 0 ? null : p
          var C = S.memoizedState
          return C !== null && p !== null && Wd(p, C[1])
            ? C[0]
            : ((f = f()), (S.memoizedState = [f, p]), f)
        }
        function Qd(f, p) {
          var S = yn
          ;(yn = S !== 0 && 4 > S ? S : 4), f(!0)
          var C = zr.transition
          zr.transition = {}
          try {
            f(!1), p()
          } finally {
            ;(yn = S), (zr.transition = C)
          }
        }
        function Wa() {
          return bs().memoizedState
        }
        function gv(f, p, S) {
          var C = Ps(f)
          ;(S = {
            lane: C,
            action: S,
            hasEagerState: !1,
            eagerState: null,
            next: null,
          }),
            vv(f)
              ? Jh(p, S)
              : (nu(f, p, S),
                (S = An()),
                (f = er(f, C, S)),
                f !== null && iu(f, p, C))
        }
        function H_(f, p, S) {
          var C = Ps(f),
            I = {
              lane: C,
              action: S,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            }
          if (vv(f)) Jh(p, I)
          else {
            nu(f, p, I)
            var B = f.alternate
            if (
              f.lanes === 0 &&
              (B === null || B.lanes === 0) &&
              ((B = p.lastRenderedReducer), B !== null)
            )
              try {
                var ae = p.lastRenderedState,
                  ye = B(ae, S)
                if (((I.hasEagerState = !0), (I.eagerState = ye), lr(ye, ae)))
                  return
              } catch {
              } finally {
              }
            ;(S = An()), (f = er(f, C, S)), f !== null && iu(f, p, C)
          }
        }
        function vv(f) {
          var p = f.alternate
          return f === ni || (p !== null && p === ni)
        }
        function Jh(f, p) {
          Ws = Gd = !0
          var S = f.pending
          S === null ? (p.next = p) : ((p.next = S.next), (S.next = p)),
            (f.pending = p)
        }
        function nu(f, p, S) {
          fi !== null && f.mode & 1 && !(hn & 2)
            ? ((f = p.interleaved),
              f === null
                ? ((S.next = S), ss === null ? (ss = [p]) : ss.push(p))
                : ((S.next = f.next), (f.next = S)),
              (p.interleaved = S))
            : ((f = p.pending),
              f === null ? (S.next = S) : ((S.next = f.next), (f.next = S)),
              (p.pending = S))
        }
        function iu(f, p, S) {
          if (S & 4194240) {
            var C = p.lanes
            ;(C &= f.pendingLanes), (S |= C), (p.lanes = S), Hs(f, S)
          }
        }
        var $l = {
            readContext: wr,
            useCallback: Di,
            useContext: Di,
            useEffect: Di,
            useImperativeHandle: Di,
            useInsertionEffect: Di,
            useLayoutEffect: Di,
            useMemo: Di,
            useReducer: Di,
            useRef: Di,
            useState: Di,
            useDebugValue: Di,
            useDeferredValue: Di,
            useTransition: Di,
            useMutableSource: Di,
            useSyncExternalStore: Di,
            useId: Di,
            unstable_isNewReconciler: !1,
          },
          ep = {
            readContext: wr,
            useCallback: function (f, p) {
              return (Es().memoizedState = [f, p === void 0 ? null : p]), f
            },
            useContext: wr,
            useEffect: qd,
            useImperativeHandle: function (f, p, S) {
              return (
                (S = S != null ? S.concat([f]) : null),
                sa(4194308, 4, tu.bind(null, p, f), S)
              )
            },
            useLayoutEffect: function (f, p) {
              return sa(4194308, 4, f, p)
            },
            useInsertionEffect: function (f, p) {
              return sa(4, 2, f, p)
            },
            useMemo: function (f, p) {
              var S = Es()
              return (
                (p = p === void 0 ? null : p),
                (f = f()),
                (S.memoizedState = [f, p]),
                f
              )
            },
            useReducer: function (f, p, S) {
              var C = Es()
              return (
                (p = S !== void 0 ? S(p) : p),
                (C.memoizedState = C.baseState = p),
                (f = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: f,
                  lastRenderedState: p,
                }),
                (C.queue = f),
                (f = f.dispatch = gv.bind(null, ni, f)),
                [C.memoizedState, f]
              )
            },
            useRef: function (f) {
              var p = Es()
              return (f = { current: f }), (p.memoizedState = f)
            },
            useState: Jc,
            useDebugValue: Zd,
            useDeferredValue: function (f) {
              var p = Jc(f),
                S = p[0],
                C = p[1]
              return (
                qd(
                  function () {
                    var I = zr.transition
                    zr.transition = {}
                    try {
                      C(f)
                    } finally {
                      zr.transition = I
                    }
                  },
                  [f],
                ),
                S
              )
            },
            useTransition: function () {
              var f = Jc(!1),
                p = f[0]
              return (f = Qd.bind(null, f[1])), (Es().memoizedState = f), [p, f]
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (f, p, S) {
              var C = ni,
                I = Es()
              if (Qn) {
                if (S === void 0) throw Error(o(407))
                S = S()
              } else {
                if (((S = p()), fi === null)) throw Error(o(349))
                Ha & 30 || Kh(C, p, S)
              }
              I.memoizedState = S
              var B = { value: S, getSnapshot: p }
              return (
                (I.queue = B),
                qd(yo.bind(null, C, B, f), [f]),
                (C.flags |= 2048),
                eu(9, Qh.bind(null, C, B, S, p), void 0, null),
                S
              )
            },
            useId: function () {
              var f = Es(),
                p = fi.identifierPrefix
              if (Qn) {
                var S = go,
                  C = mo
                ;(S = (C & ~(1 << (32 - Wt(C) - 1))).toString(32) + S),
                  (p = ':' + p + 'R' + S),
                  (S = Ga++),
                  0 < S && (p += 'H' + S.toString(32)),
                  (p += ':')
              } else (S = Zc++), (p = ':' + p + 'r' + S.toString(32) + ':')
              return (f.memoizedState = p)
            },
            unstable_isNewReconciler: !1,
          },
          tp = {
            readContext: wr,
            useCallback: Kd,
            useContext: wr,
            useEffect: Hl,
            useImperativeHandle: Gl,
            useInsertionEffect: Gn,
            useLayoutEffect: Yd,
            useMemo: Wl,
            useReducer: Kc,
            useRef: mv,
            useState: function () {
              return Kc($s)
            },
            useDebugValue: Zd,
            useDeferredValue: function (f) {
              var p = Kc($s),
                S = p[0],
                C = p[1]
              return (
                Hl(
                  function () {
                    var I = zr.transition
                    zr.transition = {}
                    try {
                      C(f)
                    } finally {
                      zr.transition = I
                    }
                  },
                  [f],
                ),
                S
              )
            },
            useTransition: function () {
              var f = Kc($s)[0],
                p = bs().memoizedState
              return [f, p]
            },
            useMutableSource: Yh,
            useSyncExternalStore: Zh,
            useId: Wa,
            unstable_isNewReconciler: !1,
          },
          np = {
            readContext: wr,
            useCallback: Kd,
            useContext: wr,
            useEffect: Hl,
            useImperativeHandle: Gl,
            useInsertionEffect: Gn,
            useLayoutEffect: Yd,
            useMemo: Wl,
            useReducer: Qc,
            useRef: mv,
            useState: function () {
              return Qc($s)
            },
            useDebugValue: Zd,
            useDeferredValue: function (f) {
              var p = Qc($s),
                S = p[0],
                C = p[1]
              return (
                Hl(
                  function () {
                    var I = zr.transition
                    zr.transition = {}
                    try {
                      C(f)
                    } finally {
                      zr.transition = I
                    }
                  },
                  [f],
                ),
                S
              )
            },
            useTransition: function () {
              var f = Qc($s)[0],
                p = bs().memoizedState
              return [f, p]
            },
            useMutableSource: Yh,
            useSyncExternalStore: Zh,
            useId: Wa,
            unstable_isNewReconciler: !1,
          }
        function ip(f, p) {
          try {
            var S = '',
              C = p
            do (S += Bh(C)), (C = C.return)
            while (C)
            var I = S
          } catch (B) {
            I =
              `
Error generating stack: ` +
              B.message +
              `
` +
              B.stack
          }
          return { value: f, source: p, stack: I }
        }
        function Jd(f, p) {
          try {
            console.error(p.value)
          } catch (S) {
            setTimeout(function () {
              throw S
            })
          }
        }
        var G_ = typeof WeakMap == 'function' ? WeakMap : Map
        function yv(f, p, S) {
          ;(S = po(-1, S)), (S.tag = 3), (S.payload = { element: null })
          var C = p.value
          return (
            (S.callback = function () {
              Ql || ((Ql = !0), (Zn = C)), Jd(f, p)
            }),
            S
          )
        }
        function ef(f, p, S) {
          ;(S = po(-1, S)), (S.tag = 3)
          var C = f.type.getDerivedStateFromError
          if (typeof C == 'function') {
            var I = p.value
            ;(S.payload = function () {
              return C(I)
            }),
              (S.callback = function () {
                Jd(f, p)
              })
          }
          var B = f.stateNode
          return (
            B !== null &&
              typeof B.componentDidCatch == 'function' &&
              (S.callback = function () {
                Jd(f, p),
                  typeof C != 'function' &&
                    (Cs === null ? (Cs = new Set([this])) : Cs.add(this))
                var ae = p.stack
                this.componentDidCatch(p.value, {
                  componentStack: ae !== null ? ae : '',
                })
              }),
            S
          )
        }
        function xo(f, p, S) {
          var C = f.pingCache
          if (C === null) {
            C = f.pingCache = new G_()
            var I = new Set()
            C.set(p, I)
          } else (I = C.get(p)), I === void 0 && ((I = new Set()), C.set(p, I))
          I.has(S) || (I.add(S), (f = wp.bind(null, f, p, S)), p.then(f, f))
        }
        function rp(f) {
          do {
            var p
            if (
              ((p = f.tag === 13) &&
                ((p = f.memoizedState),
                (p = p !== null ? p.dehydrated !== null : !0)),
              p)
            )
              return f
            f = f.return
          } while (f !== null)
          return null
        }
        function $a(f, p, S, C, I) {
          return f.mode & 1
            ? ((f.flags |= 65536), (f.lanes = I), f)
            : (f === p
                ? (f.flags |= 65536)
                : ((f.flags |= 128),
                  (S.flags |= 131072),
                  (S.flags &= -52805),
                  S.tag === 1 &&
                    (S.alternate === null
                      ? (S.tag = 17)
                      : ((p = po(-1, 1)), (p.tag = 2), ea(S, p))),
                  (S.lanes |= 1)),
              f)
        }
        function Ti(f) {
          f.flags |= 4
        }
        function Xl(f, p) {
          if (f !== null && f.child === p.child) return !0
          if (p.flags & 16) return !1
          for (f = p.child; f !== null; ) {
            if (f.flags & 12854 || f.subtreeFlags & 12854) return !1
            f = f.sibling
          }
          return !0
        }
        var Vr, Xa, tf, nf
        if (Vt)
          (Vr = function (f, p) {
            for (var S = p.child; S !== null; ) {
              if (S.tag === 5 || S.tag === 6) oe(f, S.stateNode)
              else if (S.tag !== 4 && S.child !== null) {
                ;(S.child.return = S), (S = S.child)
                continue
              }
              if (S === p) break
              for (; S.sibling === null; ) {
                if (S.return === null || S.return === p) return
                S = S.return
              }
              ;(S.sibling.return = S.return), (S = S.sibling)
            }
          }),
            (Xa = function () {}),
            (tf = function (f, p, S, C, I) {
              if (((f = f.memoizedProps), f !== C)) {
                var B = p.stateNode,
                  ae = Ms(Sr.current)
                ;(S = he(B, S, f, C, I, ae)), (p.updateQueue = S) && Ti(p)
              }
            }),
            (nf = function (f, p, S, C) {
              S !== C && Ti(p)
            })
        else if (je) {
          Vr = function (f, p, S, C) {
            for (var I = p.child; I !== null; ) {
              if (I.tag === 5) {
                var B = I.stateNode
                S && C && (B = wn(B, I.type, I.memoizedProps, I)), oe(f, B)
              } else if (I.tag === 6)
                (B = I.stateNode),
                  S && C && (B = zi(B, I.memoizedProps, I)),
                  oe(f, B)
              else if (I.tag !== 4) {
                if (I.tag === 22 && I.memoizedState !== null)
                  (B = I.child), B !== null && (B.return = I), Vr(f, I, !0, !0)
                else if (I.child !== null) {
                  ;(I.child.return = I), (I = I.child)
                  continue
                }
              }
              if (I === p) break
              for (; I.sibling === null; ) {
                if (I.return === null || I.return === p) return
                I = I.return
              }
              ;(I.sibling.return = I.return), (I = I.sibling)
            }
          }
          var oa = function (f, p, S, C) {
            for (var I = p.child; I !== null; ) {
              if (I.tag === 5) {
                var B = I.stateNode
                S && C && (B = wn(B, I.type, I.memoizedProps, I)), Qt(f, B)
              } else if (I.tag === 6)
                (B = I.stateNode),
                  S && C && (B = zi(B, I.memoizedProps, I)),
                  Qt(f, B)
              else if (I.tag !== 4) {
                if (I.tag === 22 && I.memoizedState !== null)
                  (B = I.child), B !== null && (B.return = I), oa(f, I, !0, !0)
                else if (I.child !== null) {
                  ;(I.child.return = I), (I = I.child)
                  continue
                }
              }
              if (I === p) break
              for (; I.sibling === null; ) {
                if (I.return === null || I.return === p) return
                I = I.return
              }
              ;(I.sibling.return = I.return), (I = I.sibling)
            }
          }
          ;(Xa = function (f, p) {
            var S = p.stateNode
            if (!Xl(f, p)) {
              f = S.containerInfo
              var C = ht(f)
              oa(C, p, !1, !1), (S.pendingChildren = C), Ti(p), Un(f, C)
            }
          }),
            (tf = function (f, p, S, C, I) {
              var B = f.stateNode,
                ae = f.memoizedProps
              if ((f = Xl(f, p)) && ae === C) p.stateNode = B
              else {
                var ye = p.stateNode,
                  Fe = Ms(Sr.current),
                  it = null
                ae !== C && (it = he(ye, S, ae, C, I, Fe)),
                  f && it === null
                    ? (p.stateNode = B)
                    : ((B = vt(B, it, S, ae, C, p, f, ye)),
                      _e(B, S, C, I, Fe) && Ti(p),
                      (p.stateNode = B),
                      f ? Ti(p) : Vr(B, p, !1, !1))
              }
            }),
            (nf = function (f, p, S, C) {
              S !== C
                ? ((f = Ms(Va.current)),
                  (S = Ms(Sr.current)),
                  (p.stateNode = Te(C, f, S, p)),
                  Ti(p))
                : (p.stateNode = f.stateNode)
            })
        } else
          (Xa = function () {}), (tf = function () {}), (nf = function () {})
        function _o(f, p) {
          if (!Qn)
            switch (f.tailMode) {
              case 'hidden':
                p = f.tail
                for (var S = null; p !== null; )
                  p.alternate !== null && (S = p), (p = p.sibling)
                S === null ? (f.tail = null) : (S.sibling = null)
                break
              case 'collapsed':
                S = f.tail
                for (var C = null; S !== null; )
                  S.alternate !== null && (C = S), (S = S.sibling)
                C === null
                  ? p || f.tail === null
                    ? (f.tail = null)
                    : (f.tail.sibling = null)
                  : (C.sibling = null)
            }
        }
        function di(f) {
          var p = f.alternate !== null && f.alternate.child === f.child,
            S = 0,
            C = 0
          if (p)
            for (var I = f.child; I !== null; )
              (S |= I.lanes | I.childLanes),
                (C |= I.subtreeFlags & 14680064),
                (C |= I.flags & 14680064),
                (I.return = f),
                (I = I.sibling)
          else
            for (I = f.child; I !== null; )
              (S |= I.lanes | I.childLanes),
                (C |= I.subtreeFlags),
                (C |= I.flags),
                (I.return = f),
                (I = I.sibling)
          return (f.subtreeFlags |= C), (f.childLanes = S), p
        }
        function rf(f, p, S) {
          var C = p.pendingProps
          switch ((Wh(p), p.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return di(p), null
            case 1:
              return fn(p.type) && Ht(), di(p), null
            case 3:
              return (
                (C = p.stateNode),
                Vl(),
                We(Lt),
                We(qt),
                ja(),
                C.pendingContext &&
                  ((C.context = C.pendingContext), (C.pendingContext = null)),
                (f === null || f.child === null) &&
                  (qc(p)
                    ? Ti(p)
                    : f === null ||
                      (f.memoizedState.isDehydrated && !(p.flags & 256)) ||
                      ((p.flags |= 1024),
                      ls !== null && (gu(ls), (ls = null)))),
                Xa(f, p),
                di(p),
                null
              )
            case 5:
              qh(p), (S = Ms(Va.current))
              var I = p.type
              if (f !== null && p.stateNode != null)
                tf(f, p, I, C, S),
                  f.ref !== p.ref && ((p.flags |= 512), (p.flags |= 2097152))
              else {
                if (!C) {
                  if (p.stateNode === null) throw Error(o(166))
                  return di(p), null
                }
                if (((f = Ms(Sr.current)), qc(p))) {
                  if (!$e) throw Error(o(175))
                  ;(f = H(p.stateNode, p.type, p.memoizedProps, S, f, p, !kl)),
                    (p.updateQueue = f),
                    f !== null && Ti(p)
                } else {
                  var B = q(I, C, S, f, p)
                  Vr(B, p, !1, !1),
                    (p.stateNode = B),
                    _e(B, I, C, S, f) && Ti(p)
                }
                p.ref !== null && ((p.flags |= 512), (p.flags |= 2097152))
              }
              return di(p), null
            case 6:
              if (f && p.stateNode != null) nf(f, p, f.memoizedProps, C)
              else {
                if (typeof C != 'string' && p.stateNode === null)
                  throw Error(o(166))
                if (((f = Ms(Va.current)), (S = Ms(Sr.current)), qc(p))) {
                  if (!$e) throw Error(o(176))
                  if (
                    ((f = p.stateNode),
                    (C = p.memoizedProps),
                    (S = ee(f, C, p, !kl)) && ((I = ur), I !== null))
                  )
                    switch (((B = (I.mode & 1) !== 0), I.tag)) {
                      case 3:
                        le(I.stateNode.containerInfo, f, C, B)
                        break
                      case 5:
                        de(I.type, I.memoizedProps, I.stateNode, f, C, B)
                    }
                  S && Ti(p)
                } else p.stateNode = Te(C, f, S, p)
              }
              return di(p), null
            case 13:
              if (
                (We(ti),
                (C = p.memoizedState),
                Qn && Hi !== null && p.mode & 1 && !(p.flags & 128))
              ) {
                for (f = Hi; f; ) f = ji(f)
                return Fl(), (p.flags |= 98560), p
              }
              if (C !== null && C.dehydrated !== null) {
                if (((C = qc(p)), f === null)) {
                  if (!C) throw Error(o(318))
                  if (!$e) throw Error(o(344))
                  if (
                    ((f = p.memoizedState),
                    (f = f !== null ? f.dehydrated : null),
                    !f)
                  )
                    throw Error(o(317))
                  fe(f, p)
                } else
                  Fl(),
                    !(p.flags & 128) && (p.memoizedState = null),
                    (p.flags |= 4)
                return di(p), null
              }
              return (
                ls !== null && (gu(ls), (ls = null)),
                p.flags & 128
                  ? ((p.lanes = S), p)
                  : ((C = C !== null),
                    (S = !1),
                    f === null ? qc(p) : (S = f.memoizedState !== null),
                    C &&
                      !S &&
                      ((p.child.flags |= 8192),
                      p.mode & 1 &&
                        (f === null || ti.current & 1
                          ? ai === 0 && (ai = 3)
                          : df())),
                    p.updateQueue !== null && (p.flags |= 4),
                    di(p),
                    null)
              )
            case 4:
              return (
                Vl(),
                Xa(f, p),
                f === null && Rt(p.stateNode.containerInfo),
                di(p),
                null
              )
            case 10:
              return Xc(p.type._context), di(p), null
            case 17:
              return fn(p.type) && Ht(), di(p), null
            case 19:
              if ((We(ti), (I = p.memoizedState), I === null))
                return di(p), null
              if (((C = (p.flags & 128) !== 0), (B = I.rendering), B === null))
                if (C) _o(I, !1)
                else {
                  if (ai !== 0 || (f !== null && f.flags & 128))
                    for (f = p.child; f !== null; ) {
                      if (((B = Hd(f)), B !== null)) {
                        for (
                          p.flags |= 128,
                            _o(I, !1),
                            f = B.updateQueue,
                            f !== null && ((p.updateQueue = f), (p.flags |= 4)),
                            p.subtreeFlags = 0,
                            f = S,
                            C = p.child;
                          C !== null;

                        )
                          (S = C),
                            (I = f),
                            (S.flags &= 14680066),
                            (B = S.alternate),
                            B === null
                              ? ((S.childLanes = 0),
                                (S.lanes = I),
                                (S.child = null),
                                (S.subtreeFlags = 0),
                                (S.memoizedProps = null),
                                (S.memoizedState = null),
                                (S.updateQueue = null),
                                (S.dependencies = null),
                                (S.stateNode = null))
                              : ((S.childLanes = B.childLanes),
                                (S.lanes = B.lanes),
                                (S.child = B.child),
                                (S.subtreeFlags = 0),
                                (S.deletions = null),
                                (S.memoizedProps = B.memoizedProps),
                                (S.memoizedState = B.memoizedState),
                                (S.updateQueue = B.updateQueue),
                                (S.type = B.type),
                                (I = B.dependencies),
                                (S.dependencies =
                                  I === null
                                    ? null
                                    : {
                                        lanes: I.lanes,
                                        firstContext: I.firstContext,
                                      })),
                            (C = C.sibling)
                        return pt(ti, (ti.current & 1) | 2), p.child
                      }
                      f = f.sibling
                    }
                  I.tail !== null &&
                    bi() > ca &&
                    ((p.flags |= 128), (C = !0), _o(I, !1), (p.lanes = 4194304))
                }
              else {
                if (!C)
                  if (((f = Hd(B)), f !== null)) {
                    if (
                      ((p.flags |= 128),
                      (C = !0),
                      (f = f.updateQueue),
                      f !== null && ((p.updateQueue = f), (p.flags |= 4)),
                      _o(I, !0),
                      I.tail === null &&
                        I.tailMode === 'hidden' &&
                        !B.alternate &&
                        !Qn)
                    )
                      return di(p), null
                  } else
                    2 * bi() - I.renderingStartTime > ca &&
                      S !== 1073741824 &&
                      ((p.flags |= 128),
                      (C = !0),
                      _o(I, !1),
                      (p.lanes = 4194304))
                I.isBackwards
                  ? ((B.sibling = p.child), (p.child = B))
                  : ((f = I.last),
                    f !== null ? (f.sibling = B) : (p.child = B),
                    (I.last = B))
              }
              return I.tail !== null
                ? ((p = I.tail),
                  (I.rendering = p),
                  (I.tail = p.sibling),
                  (I.renderingStartTime = bi()),
                  (p.sibling = null),
                  (f = ti.current),
                  pt(ti, C ? (f & 1) | 2 : f & 1),
                  p)
                : (di(p), null)
            case 22:
            case 23:
              return (
                vu(),
                (C = p.memoizedState !== null),
                f !== null &&
                  (f.memoizedState !== null) !== C &&
                  (p.flags |= 8192),
                C && p.mode & 1
                  ? Ji & 1073741824 &&
                    (di(p), Vt && p.subtreeFlags & 6 && (p.flags |= 8192))
                  : di(p),
                null
              )
            case 24:
              return null
            case 25:
              return null
          }
          throw Error(o(156, p.tag))
        }
        var sp = a.ReactCurrentOwner,
          Oi = !1
        function oi(f, p, S, C) {
          p.child = f === null ? hv(p, null, S, C) : vo(p, f.child, S, C)
        }
        function Wn(f, p, S, C, I) {
          S = S.render
          var B = p.ref
          return (
            Nl(p, I),
            (C = jl(f, p, S, C, B, I)),
            (S = ra()),
            f !== null && !Oi
              ? ((p.updateQueue = f.updateQueue),
                (p.flags &= -2053),
                (f.lanes &= ~I),
                Mr(f, p, I))
              : (Qn && S && Gh(p), (p.flags |= 1), oi(f, p, C, I), p.child)
          )
        }
        function Bn(f, p, S, C, I) {
          if (f === null) {
            var B = S.type
            return typeof B == 'function' &&
              !hf(B) &&
              B.defaultProps === void 0 &&
              S.compare === null &&
              S.defaultProps === void 0
              ? ((p.tag = 15), (p.type = B), wo(f, p, B, C, I))
              : ((f = pf(S.type, null, C, p, p.mode, I)),
                (f.ref = p.ref),
                (f.return = p),
                (p.child = f))
          }
          if (((B = f.child), !(f.lanes & I))) {
            var ae = B.memoizedProps
            if (
              ((S = S.compare),
              (S = S !== null ? S : Ss),
              S(ae, C) && f.ref === p.ref)
            )
              return Mr(f, p, I)
          }
          return (
            (p.flags |= 1),
            (f = Ro(B, C)),
            (f.ref = p.ref),
            (f.return = p),
            (p.child = f)
          )
        }
        function wo(f, p, S, C, I) {
          if (f !== null && Ss(f.memoizedProps, C) && f.ref === p.ref)
            if (((Oi = !1), (f.lanes & I) !== 0)) f.flags & 131072 && (Oi = !0)
            else return (p.lanes = f.lanes), Mr(f, p, I)
          return So(f, p, S, C, I)
        }
        function Gi(f, p, S) {
          var C = p.pendingProps,
            I = C.children,
            B = f !== null ? f.memoizedState : null
          if (C.mode === 'hidden')
            if (!(p.mode & 1))
              (p.memoizedState = { baseLanes: 0, cachePool: null }),
                pt(nl, Ji),
                (Ji |= S)
            else if (S & 1073741824)
              (p.memoizedState = { baseLanes: 0, cachePool: null }),
                (C = B !== null ? B.baseLanes : S),
                pt(nl, Ji),
                (Ji |= C)
            else
              return (
                (f = B !== null ? B.baseLanes | S : S),
                (p.lanes = p.childLanes = 1073741824),
                (p.memoizedState = { baseLanes: f, cachePool: null }),
                (p.updateQueue = null),
                pt(nl, Ji),
                (Ji |= f),
                null
              )
          else
            B !== null
              ? ((C = B.baseLanes | S), (p.memoizedState = null))
              : (C = S),
              pt(nl, Ji),
              (Ji |= C)
          return oi(f, p, I, S), p.child
        }
        function dr(f, p) {
          var S = p.ref
          ;((f === null && S !== null) || (f !== null && f.ref !== S)) &&
            ((p.flags |= 512), (p.flags |= 2097152))
        }
        function So(f, p, S, C, I) {
          var B = fn(S) ? Ot : qt.current
          return (
            (B = wt(p, B)),
            Nl(p, I),
            (S = jl(f, p, S, C, B, I)),
            (C = ra()),
            f !== null && !Oi
              ? ((p.updateQueue = f.updateQueue),
                (p.flags &= -2053),
                (f.lanes &= ~I),
                Mr(f, p, I))
              : (Qn && C && Gh(p), (p.flags |= 1), oi(f, p, S, I), p.child)
          )
        }
        function qa(f, p, S, C, I) {
          if (fn(S)) {
            var B = !0
            ln(p)
          } else B = !1
          if ((Nl(p, I), p.stateNode === null))
            f !== null &&
              ((f.alternate = null), (p.alternate = null), (p.flags |= 2)),
              lv(p, S, C),
              Hh(p, S, C, I),
              (C = !0)
          else if (f === null) {
            var ae = p.stateNode,
              ye = p.memoizedProps
            ae.props = ye
            var Fe = ae.context,
              it = S.contextType
            typeof it == 'object' && it !== null
              ? (it = wr(it))
              : ((it = fn(S) ? Ot : qt.current), (it = wt(p, it)))
            var At = S.getDerivedStateFromProps,
              on =
                typeof At == 'function' ||
                typeof ae.getSnapshotBeforeUpdate == 'function'
            on ||
              (typeof ae.UNSAFE_componentWillReceiveProps != 'function' &&
                typeof ae.componentWillReceiveProps != 'function') ||
              ((ye !== C || Fe !== it) && cv(p, ae, C, it)),
              (os = !1)
            var Gt = p.memoizedState
            ;(ae.state = Gt),
              kd(p, C, ae, I),
              (Fe = p.memoizedState),
              ye !== C || Gt !== Fe || Lt.current || os
                ? (typeof At == 'function' &&
                    (Vh(p, S, At, C), (Fe = p.memoizedState)),
                  (ye = os || jh(p, S, ye, C, Gt, Fe, it))
                    ? (on ||
                        (typeof ae.UNSAFE_componentWillMount != 'function' &&
                          typeof ae.componentWillMount != 'function') ||
                        (typeof ae.componentWillMount == 'function' &&
                          ae.componentWillMount(),
                        typeof ae.UNSAFE_componentWillMount == 'function' &&
                          ae.UNSAFE_componentWillMount()),
                      typeof ae.componentDidMount == 'function' &&
                        (p.flags |= 4194308))
                    : (typeof ae.componentDidMount == 'function' &&
                        (p.flags |= 4194308),
                      (p.memoizedProps = C),
                      (p.memoizedState = Fe)),
                  (ae.props = C),
                  (ae.state = Fe),
                  (ae.context = it),
                  (C = ye))
                : (typeof ae.componentDidMount == 'function' &&
                    (p.flags |= 4194308),
                  (C = !1))
          } else {
            ;(ae = p.stateNode),
              zh(f, p),
              (ye = p.memoizedProps),
              (it = p.type === p.elementType ? ye : _r(p.type, ye)),
              (ae.props = it),
              (on = p.pendingProps),
              (Gt = ae.context),
              (Fe = S.contextType),
              typeof Fe == 'object' && Fe !== null
                ? (Fe = wr(Fe))
                : ((Fe = fn(S) ? Ot : qt.current), (Fe = wt(p, Fe)))
            var gn = S.getDerivedStateFromProps
            ;(At =
              typeof gn == 'function' ||
              typeof ae.getSnapshotBeforeUpdate == 'function') ||
              (typeof ae.UNSAFE_componentWillReceiveProps != 'function' &&
                typeof ae.componentWillReceiveProps != 'function') ||
              ((ye !== on || Gt !== Fe) && cv(p, ae, C, Fe)),
              (os = !1),
              (Gt = p.memoizedState),
              (ae.state = Gt),
              kd(p, C, ae, I)
            var St = p.memoizedState
            ye !== on || Gt !== St || Lt.current || os
              ? (typeof gn == 'function' &&
                  (Vh(p, S, gn, C), (St = p.memoizedState)),
                (it = os || jh(p, S, it, C, Gt, St, Fe) || !1)
                  ? (At ||
                      (typeof ae.UNSAFE_componentWillUpdate != 'function' &&
                        typeof ae.componentWillUpdate != 'function') ||
                      (typeof ae.componentWillUpdate == 'function' &&
                        ae.componentWillUpdate(C, St, Fe),
                      typeof ae.UNSAFE_componentWillUpdate == 'function' &&
                        ae.UNSAFE_componentWillUpdate(C, St, Fe)),
                    typeof ae.componentDidUpdate == 'function' &&
                      (p.flags |= 4),
                    typeof ae.getSnapshotBeforeUpdate == 'function' &&
                      (p.flags |= 1024))
                  : (typeof ae.componentDidUpdate != 'function' ||
                      (ye === f.memoizedProps && Gt === f.memoizedState) ||
                      (p.flags |= 4),
                    typeof ae.getSnapshotBeforeUpdate != 'function' ||
                      (ye === f.memoizedProps && Gt === f.memoizedState) ||
                      (p.flags |= 1024),
                    (p.memoizedProps = C),
                    (p.memoizedState = St)),
                (ae.props = C),
                (ae.state = St),
                (ae.context = Fe),
                (C = it))
              : (typeof ae.componentDidUpdate != 'function' ||
                  (ye === f.memoizedProps && Gt === f.memoizedState) ||
                  (p.flags |= 4),
                typeof ae.getSnapshotBeforeUpdate != 'function' ||
                  (ye === f.memoizedProps && Gt === f.memoizedState) ||
                  (p.flags |= 1024),
                (C = !1))
          }
          return Qi(f, p, S, C, B, I)
        }
        function Qi(f, p, S, C, I, B) {
          dr(f, p)
          var ae = (p.flags & 128) !== 0
          if (!C && !ae) return I && mn(p, S, !1), Mr(f, p, B)
          ;(C = p.stateNode), (sp.current = p)
          var ye =
            ae && typeof S.getDerivedStateFromError != 'function'
              ? null
              : C.render()
          return (
            (p.flags |= 1),
            f !== null && ae
              ? ((p.child = vo(p, f.child, null, B)),
                (p.child = vo(p, null, ye, B)))
              : oi(f, p, ye, B),
            (p.memoizedState = C.state),
            I && mn(p, S, !0),
            p.child
          )
        }
        function ru(f) {
          var p = f.stateNode
          p.pendingContext
            ? tn(f, p.pendingContext, p.pendingContext !== p.context)
            : p.context && tn(f, p.context, !1),
            jd(f, p.containerInfo)
        }
        function op(f, p, S, C, I) {
          return Fl(), Vd(I), (p.flags |= 256), oi(f, p, S, C), p.child
        }
        var su = { dehydrated: null, treeContext: null, retryLane: 0 }
        function Ya(f) {
          return { baseLanes: f, cachePool: null }
        }
        function ap(f, p, S) {
          var C = p.pendingProps,
            I = ti.current,
            B = !1,
            ae = (p.flags & 128) !== 0,
            ye
          if (
            ((ye = ae) ||
              (ye =
                f !== null && f.memoizedState === null ? !1 : (I & 2) !== 0),
            ye
              ? ((B = !0), (p.flags &= -129))
              : (f === null || f.memoizedState !== null) && (I |= 1),
            pt(ti, I & 1),
            f === null)
          )
            return (
              na(p),
              (f = p.memoizedState),
              f !== null && ((f = f.dehydrated), f !== null)
                ? (p.mode & 1
                    ? kr(f)
                      ? (p.lanes = 8)
                      : (p.lanes = 1073741824)
                    : (p.lanes = 1),
                  null)
                : ((I = C.children),
                  (f = C.fallback),
                  B
                    ? ((C = p.mode),
                      (B = p.child),
                      (I = { mode: 'hidden', children: I }),
                      !(C & 1) && B !== null
                        ? ((B.childLanes = 0), (B.pendingProps = I))
                        : (B = _u(I, C, 0, null)),
                      (f = al(f, C, S, null)),
                      (B.return = p),
                      (f.return = p),
                      (B.sibling = f),
                      (p.child = B),
                      (p.child.memoizedState = Ya(S)),
                      (p.memoizedState = su),
                      f)
                    : Ts(p, I))
            )
          if (((I = f.memoizedState), I !== null)) {
            if (((ye = I.dehydrated), ye !== null)) {
              if (ae)
                return p.flags & 256
                  ? ((p.flags &= -257), au(f, p, S, Error(o(422))))
                  : p.memoizedState !== null
                  ? ((p.child = f.child), (p.flags |= 128), null)
                  : ((B = C.fallback),
                    (I = p.mode),
                    (C = _u(
                      { mode: 'visible', children: C.children },
                      I,
                      0,
                      null,
                    )),
                    (B = al(B, I, S, null)),
                    (B.flags |= 2),
                    (C.return = p),
                    (B.return = p),
                    (C.sibling = B),
                    (p.child = C),
                    p.mode & 1 && vo(p, f.child, null, S),
                    (p.child.memoizedState = Ya(S)),
                    (p.memoizedState = su),
                    B)
              if (!(p.mode & 1)) p = au(f, p, S, null)
              else if (kr(ye)) p = au(f, p, S, Error(o(419)))
              else if (((C = (S & f.childLanes) !== 0), Oi || C)) {
                if (((C = fi), C !== null)) {
                  switch (S & -S) {
                    case 4:
                      B = 2
                      break
                    case 16:
                      B = 8
                      break
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                      B = 32
                      break
                    case 536870912:
                      B = 268435456
                      break
                    default:
                      B = 0
                  }
                  ;(C = B & (C.suspendedLanes | S) ? 0 : B),
                    C !== 0 &&
                      C !== I.retryLane &&
                      ((I.retryLane = C), er(f, C, -1))
                }
                df(), (p = au(f, p, S, Error(o(421))))
              } else
                ar(ye)
                  ? ((p.flags |= 128),
                    (p.child = f.child),
                    (p = Mv.bind(null, f)),
                    Fr(ye, p),
                    (p = null))
                  : ((S = I.treeContext),
                    $e &&
                      ((Hi = Qo(ye)),
                      (ur = p),
                      (Qn = !0),
                      (ls = null),
                      (kl = !1),
                      S !== null &&
                        ((as[Ur++] = mo),
                        (as[Ur++] = go),
                        (as[Ur++] = Ua),
                        (mo = S.id),
                        (go = S.overflow),
                        (Ua = p))),
                    (p = Ts(p, p.pendingProps.children)),
                    (p.flags |= 4096))
              return p
            }
            return B
              ? ((C = sf(f, p, C.children, C.fallback, S)),
                (B = p.child),
                (I = f.child.memoizedState),
                (B.memoizedState =
                  I === null
                    ? Ya(S)
                    : { baseLanes: I.baseLanes | S, cachePool: null }),
                (B.childLanes = f.childLanes & ~S),
                (p.memoizedState = su),
                C)
              : ((S = ou(f, p, C.children, S)), (p.memoizedState = null), S)
          }
          return B
            ? ((C = sf(f, p, C.children, C.fallback, S)),
              (B = p.child),
              (I = f.child.memoizedState),
              (B.memoizedState =
                I === null
                  ? Ya(S)
                  : { baseLanes: I.baseLanes | S, cachePool: null }),
              (B.childLanes = f.childLanes & ~S),
              (p.memoizedState = su),
              C)
            : ((S = ou(f, p, C.children, S)), (p.memoizedState = null), S)
        }
        function Ts(f, p) {
          return (
            (p = _u({ mode: 'visible', children: p }, f.mode, 0, null)),
            (p.return = f),
            (f.child = p)
          )
        }
        function ou(f, p, S, C) {
          var I = f.child
          return (
            (f = I.sibling),
            (S = Ro(I, { mode: 'visible', children: S })),
            !(p.mode & 1) && (S.lanes = C),
            (S.return = p),
            (S.sibling = null),
            f !== null &&
              ((C = p.deletions),
              C === null ? ((p.deletions = [f]), (p.flags |= 16)) : C.push(f)),
            (p.child = S)
          )
        }
        function sf(f, p, S, C, I) {
          var B = p.mode
          f = f.child
          var ae = f.sibling,
            ye = { mode: 'hidden', children: S }
          return (
            !(B & 1) && p.child !== f
              ? ((S = p.child),
                (S.childLanes = 0),
                (S.pendingProps = ye),
                (p.deletions = null))
              : ((S = Ro(f, ye)), (S.subtreeFlags = f.subtreeFlags & 14680064)),
            ae !== null
              ? (C = Ro(ae, C))
              : ((C = al(C, B, I, null)), (C.flags |= 2)),
            (C.return = p),
            (S.return = p),
            (S.sibling = C),
            (p.child = S),
            C
          )
        }
        function au(f, p, S, C) {
          return (
            C !== null && Vd(C),
            vo(p, f.child, null, S),
            (f = Ts(p, p.pendingProps.children)),
            (f.flags |= 2),
            (p.memoizedState = null),
            f
          )
        }
        function xv(f, p, S) {
          f.lanes |= p
          var C = f.alternate
          C !== null && (C.lanes |= p), Fa(f.return, p, S)
        }
        function Xs(f, p, S, C, I) {
          var B = f.memoizedState
          B === null
            ? (f.memoizedState = {
                isBackwards: p,
                rendering: null,
                renderingStartTime: 0,
                last: C,
                tail: S,
                tailMode: I,
              })
            : ((B.isBackwards = p),
              (B.rendering = null),
              (B.renderingStartTime = 0),
              (B.last = C),
              (B.tail = S),
              (B.tailMode = I))
        }
        function Za(f, p, S) {
          var C = p.pendingProps,
            I = C.revealOrder,
            B = C.tail
          if ((oi(f, p, C.children, S), (C = ti.current), C & 2))
            (C = (C & 1) | 2), (p.flags |= 128)
          else {
            if (f !== null && f.flags & 128)
              e: for (f = p.child; f !== null; ) {
                if (f.tag === 13) f.memoizedState !== null && xv(f, S, p)
                else if (f.tag === 19) xv(f, S, p)
                else if (f.child !== null) {
                  ;(f.child.return = f), (f = f.child)
                  continue
                }
                if (f === p) break e
                for (; f.sibling === null; ) {
                  if (f.return === null || f.return === p) break e
                  f = f.return
                }
                ;(f.sibling.return = f.return), (f = f.sibling)
              }
            C &= 1
          }
          if ((pt(ti, C), !(p.mode & 1))) p.memoizedState = null
          else
            switch (I) {
              case 'forwards':
                for (S = p.child, I = null; S !== null; )
                  (f = S.alternate),
                    f !== null && Hd(f) === null && (I = S),
                    (S = S.sibling)
                ;(S = I),
                  S === null
                    ? ((I = p.child), (p.child = null))
                    : ((I = S.sibling), (S.sibling = null)),
                  Xs(p, !1, I, S, B)
                break
              case 'backwards':
                for (S = null, I = p.child, p.child = null; I !== null; ) {
                  if (((f = I.alternate), f !== null && Hd(f) === null)) {
                    p.child = I
                    break
                  }
                  ;(f = I.sibling), (I.sibling = S), (S = I), (I = f)
                }
                Xs(p, !0, S, null, B)
                break
              case 'together':
                Xs(p, !1, null, null, void 0)
                break
              default:
                p.memoizedState = null
            }
          return p.child
        }
        function Mr(f, p, S) {
          if (
            (f !== null && (p.dependencies = f.dependencies),
            (qs |= p.lanes),
            !(S & p.childLanes))
          )
            return null
          if (f !== null && p.child !== f.child) throw Error(o(153))
          if (p.child !== null) {
            for (
              f = p.child, S = Ro(f, f.pendingProps), p.child = S, S.return = p;
              f.sibling !== null;

            )
              (f = f.sibling),
                (S = S.sibling = Ro(f, f.pendingProps)),
                (S.return = p)
            S.sibling = null
          }
          return p.child
        }
        function of(f, p, S) {
          switch (p.tag) {
            case 3:
              ru(p), Fl()
              break
            case 5:
              pv(p)
              break
            case 1:
              fn(p.type) && ln(p)
              break
            case 4:
              jd(p, p.stateNode.containerInfo)
              break
            case 10:
              ka(p, p.type._context, p.memoizedProps.value)
              break
            case 13:
              var C = p.memoizedState
              if (C !== null)
                return C.dehydrated !== null
                  ? (pt(ti, ti.current & 1), (p.flags |= 128), null)
                  : S & p.child.childLanes
                  ? ap(f, p, S)
                  : (pt(ti, ti.current & 1),
                    (f = Mr(f, p, S)),
                    f !== null ? f.sibling : null)
              pt(ti, ti.current & 1)
              break
            case 19:
              if (((C = (S & p.childLanes) !== 0), f.flags & 128)) {
                if (C) return Za(f, p, S)
                p.flags |= 128
              }
              var I = p.memoizedState
              if (
                (I !== null &&
                  ((I.rendering = null),
                  (I.tail = null),
                  (I.lastEffect = null)),
                pt(ti, ti.current),
                C)
              )
                break
              return null
            case 22:
            case 23:
              return (p.lanes = 0), Gi(f, p, S)
          }
          return Mr(f, p, S)
        }
        function af(f, p) {
          switch ((Wh(p), p.tag)) {
            case 1:
              return (
                fn(p.type) && Ht(),
                (f = p.flags),
                f & 65536 ? ((p.flags = (f & -65537) | 128), p) : null
              )
            case 3:
              return (
                Vl(),
                We(Lt),
                We(qt),
                ja(),
                (f = p.flags),
                f & 65536 && !(f & 128)
                  ? ((p.flags = (f & -65537) | 128), p)
                  : null
              )
            case 5:
              return qh(p), null
            case 13:
              if (
                (We(ti),
                (f = p.memoizedState),
                f !== null && f.dehydrated !== null)
              ) {
                if (p.alternate === null) throw Error(o(340))
                Fl()
              }
              return (
                (f = p.flags),
                f & 65536 ? ((p.flags = (f & -65537) | 128), p) : null
              )
            case 19:
              return We(ti), null
            case 4:
              return Vl(), null
            case 10:
              return Xc(p.type._context), null
            case 22:
            case 23:
              return vu(), null
            case 24:
              return null
            default:
              return null
          }
        }
        var fr = !1,
          ki = !1,
          Ka = typeof WeakSet == 'function' ? WeakSet : Set,
          lt = null
        function cs(f, p) {
          var S = f.ref
          if (S !== null)
            if (typeof S == 'function')
              try {
                S(null)
              } catch (C) {
                pr(f, p, C)
              }
            else S.current = null
        }
        function Mo(f, p, S) {
          try {
            S()
          } catch (C) {
            pr(f, p, C)
          }
        }
        var lp = !1
        function cp(f, p) {
          for (Y(f.containerInfo), lt = p; lt !== null; )
            if (
              ((f = lt),
              (p = f.child),
              (f.subtreeFlags & 1028) !== 0 && p !== null)
            )
              (p.return = f), (lt = p)
            else
              for (; lt !== null; ) {
                f = lt
                try {
                  var S = f.alternate
                  if (f.flags & 1024)
                    switch (f.tag) {
                      case 0:
                      case 11:
                      case 15:
                        break
                      case 1:
                        if (S !== null) {
                          var C = S.memoizedProps,
                            I = S.memoizedState,
                            B = f.stateNode,
                            ae = B.getSnapshotBeforeUpdate(
                              f.elementType === f.type ? C : _r(f.type, C),
                              I,
                            )
                          B.__reactInternalSnapshotBeforeUpdate = ae
                        }
                        break
                      case 3:
                        Vt && Ve(f.stateNode.containerInfo)
                        break
                      case 5:
                      case 6:
                      case 4:
                      case 17:
                        break
                      default:
                        throw Error(o(163))
                    }
                } catch (ye) {
                  pr(f, f.return, ye)
                }
                if (((p = f.sibling), p !== null)) {
                  ;(p.return = f.return), (lt = p)
                  break
                }
                lt = f.return
              }
          return (S = lp), (lp = !1), S
        }
        function Eo(f, p, S) {
          var C = p.updateQueue
          if (((C = C !== null ? C.lastEffect : null), C !== null)) {
            var I = (C = C.next)
            do {
              if ((I.tag & f) === f) {
                var B = I.destroy
                ;(I.destroy = void 0), B !== void 0 && Mo(p, S, B)
              }
              I = I.next
            } while (I !== C)
          }
        }
        function Wi(f, p) {
          if (
            ((p = p.updateQueue),
            (p = p !== null ? p.lastEffect : null),
            p !== null)
          ) {
            var S = (p = p.next)
            do {
              if ((S.tag & f) === f) {
                var C = S.create
                S.destroy = C()
              }
              S = S.next
            } while (S !== p)
          }
        }
        function hr(f) {
          var p = f.ref
          if (p !== null) {
            var S = f.stateNode
            switch (f.tag) {
              case 5:
                f = J(S)
                break
              default:
                f = S
            }
            typeof p == 'function' ? p(f) : (p.current = f)
          }
        }
        function Yn(f, p, S) {
          if (Gs && typeof Gs.onCommitFiberUnmount == 'function')
            try {
              Gs.onCommitFiberUnmount(Hc, p)
            } catch {}
          switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              if (
                ((f = p.updateQueue),
                f !== null && ((f = f.lastEffect), f !== null))
              ) {
                var C = (f = f.next)
                do {
                  var I = C,
                    B = I.destroy
                  ;(I = I.tag),
                    B !== void 0 && (I & 2 || I & 4) && Mo(p, S, B),
                    (C = C.next)
                } while (C !== f)
              }
              break
            case 1:
              if (
                (cs(p, S),
                (f = p.stateNode),
                typeof f.componentWillUnmount == 'function')
              )
                try {
                  ;(f.props = p.memoizedProps),
                    (f.state = p.memoizedState),
                    f.componentWillUnmount()
                } catch (ae) {
                  pr(p, S, ae)
                }
              break
            case 5:
              cs(p, S)
              break
            case 4:
              Vt
                ? fp(f, p, S)
                : je &&
                  je &&
                  ((p = p.stateNode.containerInfo), (S = ht(p)), si(p, S))
          }
        }
        function us(f, p, S) {
          for (var C = p; ; )
            if ((Yn(f, C, S), C.child === null || (Vt && C.tag === 4))) {
              if (C === p) break
              for (; C.sibling === null; ) {
                if (C.return === null || C.return === p) return
                C = C.return
              }
              ;(C.sibling.return = C.return), (C = C.sibling)
            } else (C.child.return = C), (C = C.child)
        }
        function up(f) {
          var p = f.alternate
          p !== null && ((f.alternate = null), up(p)),
            (f.child = null),
            (f.deletions = null),
            (f.sibling = null),
            f.tag === 5 && ((p = f.stateNode), p !== null && _t(p)),
            (f.stateNode = null),
            (f.return = null),
            (f.dependencies = null),
            (f.memoizedProps = null),
            (f.memoizedState = null),
            (f.pendingProps = null),
            (f.stateNode = null),
            (f.updateQueue = null)
        }
        function dp(f) {
          return f.tag === 5 || f.tag === 3 || f.tag === 4
        }
        function lf(f) {
          e: for (;;) {
            for (; f.sibling === null; ) {
              if (f.return === null || dp(f.return)) return null
              f = f.return
            }
            for (
              f.sibling.return = f.return, f = f.sibling;
              f.tag !== 5 && f.tag !== 6 && f.tag !== 18;

            ) {
              if (f.flags & 2 || f.child === null || f.tag === 4) continue e
              ;(f.child.return = f), (f = f.child)
            }
            if (!(f.flags & 2)) return f.stateNode
          }
        }
        function cf(f) {
          if (Vt) {
            e: {
              for (var p = f.return; p !== null; ) {
                if (dp(p)) break e
                p = p.return
              }
              throw Error(o(160))
            }
            var S = p
            switch (S.tag) {
              case 5:
                ;(p = S.stateNode),
                  S.flags & 32 && (Bt(p), (S.flags &= -33)),
                  (S = lf(f)),
                  ql(f, S, p)
                break
              case 3:
              case 4:
                ;(p = S.stateNode.containerInfo), (S = lf(f)), uf(f, S, p)
                break
              default:
                throw Error(o(161))
            }
          }
        }
        function uf(f, p, S) {
          var C = f.tag
          if (C === 5 || C === 6) (f = f.stateNode), p ? It(S, f, p) : gt(S, f)
          else if (C !== 4 && ((f = f.child), f !== null))
            for (uf(f, p, S), f = f.sibling; f !== null; )
              uf(f, p, S), (f = f.sibling)
        }
        function ql(f, p, S) {
          var C = f.tag
          if (C === 5 || C === 6) (f = f.stateNode), p ? Ut(S, f, p) : ct(S, f)
          else if (C !== 4 && ((f = f.child), f !== null))
            for (ql(f, p, S), f = f.sibling; f !== null; )
              ql(f, p, S), (f = f.sibling)
        }
        function fp(f, p, S) {
          for (var C = p, I = !1, B, ae; ; ) {
            if (!I) {
              I = C.return
              e: for (;;) {
                if (I === null) throw Error(o(160))
                switch (((B = I.stateNode), I.tag)) {
                  case 5:
                    ae = !1
                    break e
                  case 3:
                    ;(B = B.containerInfo), (ae = !0)
                    break e
                  case 4:
                    ;(B = B.containerInfo), (ae = !0)
                    break e
                }
                I = I.return
              }
              I = !0
            }
            if (C.tag === 5 || C.tag === 6)
              us(f, C, S), ae ? en(B, C.stateNode) : Mt(B, C.stateNode)
            else if (C.tag === 18) ae ? Ze(B, C.stateNode) : nt(B, C.stateNode)
            else if (C.tag === 4) {
              if (C.child !== null) {
                ;(B = C.stateNode.containerInfo),
                  (ae = !0),
                  (C.child.return = C),
                  (C = C.child)
                continue
              }
            } else if ((Yn(f, C, S), C.child !== null)) {
              ;(C.child.return = C), (C = C.child)
              continue
            }
            if (C === p) break
            for (; C.sibling === null; ) {
              if (C.return === null || C.return === p) return
              ;(C = C.return), C.tag === 4 && (I = !1)
            }
            ;(C.sibling.return = C.return), (C = C.sibling)
          }
        }
        function aa(f, p) {
          if (Vt) {
            switch (p.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Eo(3, p, p.return), Wi(3, p), Eo(5, p, p.return)
                return
              case 1:
                return
              case 5:
                var S = p.stateNode
                if (S != null) {
                  var C = p.memoizedProps
                  f = f !== null ? f.memoizedProps : C
                  var I = p.type,
                    B = p.updateQueue
                  ;(p.updateQueue = null), B !== null && bt(S, B, I, f, C, p)
                }
                return
              case 6:
                if (p.stateNode === null) throw Error(o(162))
                ;(S = p.memoizedProps),
                  rn(p.stateNode, f !== null ? f.memoizedProps : S, S)
                return
              case 3:
                $e &&
                  f !== null &&
                  f.memoizedState.isDehydrated &&
                  De(p.stateNode.containerInfo)
                return
              case 12:
                return
              case 13:
                Yl(p)
                return
              case 19:
                Yl(p)
                return
              case 17:
                return
            }
            throw Error(o(163))
          }
          switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              Eo(3, p, p.return), Wi(3, p), Eo(5, p, p.return)
              return
            case 12:
              return
            case 13:
              Yl(p)
              return
            case 19:
              Yl(p)
              return
            case 3:
              $e &&
                f !== null &&
                f.memoizedState.isDehydrated &&
                De(p.stateNode.containerInfo)
              break
            case 22:
            case 23:
              return
          }
          e: if (je) {
            switch (p.tag) {
              case 1:
              case 5:
              case 6:
                break e
              case 3:
              case 4:
                ;(p = p.stateNode), si(p.containerInfo, p.pendingChildren)
                break e
            }
            throw Error(o(163))
          }
        }
        function Yl(f) {
          var p = f.updateQueue
          if (p !== null) {
            f.updateQueue = null
            var S = f.stateNode
            S === null && (S = f.stateNode = new Ka()),
              p.forEach(function (C) {
                var I = Ev.bind(null, f, C)
                S.has(C) || (S.add(C), C.then(I, I))
              })
          }
        }
        function W_(f, p) {
          for (lt = p; lt !== null; ) {
            p = lt
            var S = p.deletions
            if (S !== null)
              for (var C = 0; C < S.length; C++) {
                var I = S[C]
                try {
                  var B = f
                  Vt ? fp(B, I, p) : us(B, I, p)
                  var ae = I.alternate
                  ae !== null && (ae.return = null), (I.return = null)
                } catch (kt) {
                  pr(I, p, kt)
                }
              }
            if (((S = p.child), p.subtreeFlags & 12854 && S !== null))
              (S.return = p), (lt = S)
            else
              for (; lt !== null; ) {
                p = lt
                try {
                  var ye = p.flags
                  if ((ye & 32 && Vt && Bt(p.stateNode), ye & 512)) {
                    var Fe = p.alternate
                    if (Fe !== null) {
                      var it = Fe.ref
                      it !== null &&
                        (typeof it == 'function'
                          ? it(null)
                          : (it.current = null))
                    }
                  }
                  if (ye & 8192)
                    switch (p.tag) {
                      case 13:
                        if (p.memoizedState !== null) {
                          var At = p.alternate
                          ;(At === null || At.memoizedState === null) &&
                            (pu = bi())
                        }
                        break
                      case 22:
                        var on = p.memoizedState !== null,
                          Gt = p.alternate,
                          gn = Gt !== null && Gt.memoizedState !== null
                        if (((S = p), Vt)) {
                          e: if (((C = S), (I = on), (B = null), Vt))
                            for (var St = C; ; ) {
                              if (St.tag === 5) {
                                if (B === null) {
                                  B = St
                                  var qi = St.stateNode
                                  I
                                    ? Kt(qi)
                                    : Ie(St.stateNode, St.memoizedProps)
                                }
                              } else if (St.tag === 6) {
                                if (B === null) {
                                  var $r = St.stateNode
                                  I ? ve($r) : Le($r, St.memoizedProps)
                                }
                              } else if (
                                ((St.tag !== 22 && St.tag !== 23) ||
                                  St.memoizedState === null ||
                                  St === C) &&
                                St.child !== null
                              ) {
                                ;(St.child.return = St), (St = St.child)
                                continue
                              }
                              if (St === C) break
                              for (; St.sibling === null; ) {
                                if (St.return === null || St.return === C)
                                  break e
                                B === St && (B = null), (St = St.return)
                              }
                              B === St && (B = null),
                                (St.sibling.return = St.return),
                                (St = St.sibling)
                            }
                        }
                        if (on && !gn && S.mode & 1) {
                          lt = S
                          for (var be = S.child; be !== null; ) {
                            for (S = lt = be; lt !== null; ) {
                              C = lt
                              var xe = C.child
                              switch (C.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                  Eo(4, C, C.return)
                                  break
                                case 1:
                                  cs(C, C.return)
                                  var Ne = C.stateNode
                                  if (
                                    typeof Ne.componentWillUnmount == 'function'
                                  ) {
                                    var yt = C.return
                                    try {
                                      ;(Ne.props = C.memoizedProps),
                                        (Ne.state = C.memoizedState),
                                        Ne.componentWillUnmount()
                                    } catch (kt) {
                                      pr(C, yt, kt)
                                    }
                                  }
                                  break
                                case 5:
                                  cs(C, C.return)
                                  break
                                case 22:
                                  if (C.memoizedState !== null) {
                                    pp(S)
                                    continue
                                  }
                              }
                              xe !== null ? ((xe.return = C), (lt = xe)) : pp(S)
                            }
                            be = be.sibling
                          }
                        }
                    }
                  switch (ye & 4102) {
                    case 2:
                      cf(p), (p.flags &= -3)
                      break
                    case 6:
                      cf(p), (p.flags &= -3), aa(p.alternate, p)
                      break
                    case 4096:
                      p.flags &= -4097
                      break
                    case 4100:
                      ;(p.flags &= -4097), aa(p.alternate, p)
                      break
                    case 4:
                      aa(p.alternate, p)
                  }
                } catch (kt) {
                  pr(p, p.return, kt)
                }
                if (((S = p.sibling), S !== null)) {
                  ;(S.return = p.return), (lt = S)
                  break
                }
                lt = p.return
              }
          }
        }
        function lu(f, p, S) {
          ;(lt = f), cu(f)
        }
        function cu(f, p, S) {
          for (var C = (f.mode & 1) !== 0; lt !== null; ) {
            var I = lt,
              B = I.child
            if (I.tag === 22 && C) {
              var ae = I.memoizedState !== null || fr
              if (!ae) {
                var ye = I.alternate,
                  Fe = (ye !== null && ye.memoizedState !== null) || ki
                ye = fr
                var it = ki
                if (((fr = ae), (ki = Fe) && !it))
                  for (lt = I; lt !== null; )
                    (ae = lt),
                      (Fe = ae.child),
                      ae.tag === 22 && ae.memoizedState !== null
                        ? Qa(I)
                        : Fe !== null
                        ? ((Fe.return = ae), (lt = Fe))
                        : Qa(I)
                for (; B !== null; ) (lt = B), cu(B), (B = B.sibling)
                ;(lt = I), (fr = ye), (ki = it)
              }
              hp(f)
            } else
              I.subtreeFlags & 8772 && B !== null
                ? ((B.return = I), (lt = B))
                : hp(f)
          }
        }
        function hp(f) {
          for (; lt !== null; ) {
            var p = lt
            if (p.flags & 8772) {
              var S = p.alternate
              try {
                if (p.flags & 8772)
                  switch (p.tag) {
                    case 0:
                    case 11:
                    case 15:
                      ki || Wi(5, p)
                      break
                    case 1:
                      var C = p.stateNode
                      if (p.flags & 4 && !ki)
                        if (S === null) C.componentDidMount()
                        else {
                          var I =
                            p.elementType === p.type
                              ? S.memoizedProps
                              : _r(p.type, S.memoizedProps)
                          C.componentDidUpdate(
                            I,
                            S.memoizedState,
                            C.__reactInternalSnapshotBeforeUpdate,
                          )
                        }
                      var B = p.updateQueue
                      B !== null && ov(p, B, C)
                      break
                    case 3:
                      var ae = p.updateQueue
                      if (ae !== null) {
                        if (((S = null), p.child !== null))
                          switch (p.child.tag) {
                            case 5:
                              S = J(p.child.stateNode)
                              break
                            case 1:
                              S = p.child.stateNode
                          }
                        ov(p, ae, S)
                      }
                      break
                    case 5:
                      var ye = p.stateNode
                      S === null &&
                        p.flags & 4 &&
                        Je(ye, p.type, p.memoizedProps, p)
                      break
                    case 6:
                      break
                    case 4:
                      break
                    case 12:
                      break
                    case 13:
                      if ($e && p.memoizedState === null) {
                        var Fe = p.alternate
                        if (Fe !== null) {
                          var it = Fe.memoizedState
                          if (it !== null) {
                            var At = it.dehydrated
                            At !== null && Oe(At)
                          }
                        }
                      }
                      break
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                      break
                    default:
                      throw Error(o(163))
                  }
                ki || (p.flags & 512 && hr(p))
              } catch (on) {
                pr(p, p.return, on)
              }
            }
            if (p === f) {
              lt = null
              break
            }
            if (((S = p.sibling), S !== null)) {
              ;(S.return = p.return), (lt = S)
              break
            }
            lt = p.return
          }
        }
        function pp(f) {
          for (; lt !== null; ) {
            var p = lt
            if (p === f) {
              lt = null
              break
            }
            var S = p.sibling
            if (S !== null) {
              ;(S.return = p.return), (lt = S)
              break
            }
            lt = p.return
          }
        }
        function Qa(f) {
          for (; lt !== null; ) {
            var p = lt
            try {
              switch (p.tag) {
                case 0:
                case 11:
                case 15:
                  var S = p.return
                  try {
                    Wi(4, p)
                  } catch (Fe) {
                    pr(p, S, Fe)
                  }
                  break
                case 1:
                  var C = p.stateNode
                  if (typeof C.componentDidMount == 'function') {
                    var I = p.return
                    try {
                      C.componentDidMount()
                    } catch (Fe) {
                      pr(p, I, Fe)
                    }
                  }
                  var B = p.return
                  try {
                    hr(p)
                  } catch (Fe) {
                    pr(p, B, Fe)
                  }
                  break
                case 5:
                  var ae = p.return
                  try {
                    hr(p)
                  } catch (Fe) {
                    pr(p, ae, Fe)
                  }
              }
            } catch (Fe) {
              pr(p, p.return, Fe)
            }
            if (p === f) {
              lt = null
              break
            }
            var ye = p.sibling
            if (ye !== null) {
              ;(ye.return = p.return), (lt = ye)
              break
            }
            lt = p.return
          }
        }
        var uu = 0,
          Ja = 1,
          el = 2,
          bo = 3,
          Zl = 4
        if (typeof Symbol == 'function' && Symbol.for) {
          var tl = Symbol.for
          ;(uu = tl('selector.component')),
            (Ja = tl('selector.has_pseudo_class')),
            (el = tl('selector.role')),
            (bo = tl('selector.test_id')),
            (Zl = tl('selector.text'))
        }
        function du(f) {
          var p = se(f)
          if (p != null) {
            if (typeof p.memoizedProps['data-testname'] != 'string')
              throw Error(o(364))
            return p
          }
          if (((f = ie(f)), f === null)) throw Error(o(362))
          return f.stateNode.current
        }
        function fu(f, p) {
          switch (p.$$typeof) {
            case uu:
              if (f.type === p.value) return !0
              break
            case Ja:
              e: {
                ;(p = p.value), (f = [f, 0])
                for (var S = 0; S < f.length; ) {
                  var C = f[S++],
                    I = f[S++],
                    B = p[I]
                  if (C.tag !== 5 || !Ue(C)) {
                    for (; B != null && fu(C, B); ) I++, (B = p[I])
                    if (I === p.length) {
                      p = !0
                      break e
                    } else
                      for (C = C.child; C !== null; )
                        f.push(C, I), (C = C.sibling)
                  }
                }
                p = !1
              }
              return p
            case el:
              if (f.tag === 5 && Ge(f.stateNode, p.value)) return !0
              break
            case Zl:
              if (
                (f.tag === 5 || f.tag === 6) &&
                ((f = Se(f)), f !== null && 0 <= f.indexOf(p.value))
              )
                return !0
              break
            case bo:
              if (
                f.tag === 5 &&
                ((f = f.memoizedProps['data-testname']),
                typeof f == 'string' &&
                  f.toLowerCase() === p.value.toLowerCase())
              )
                return !0
              break
            default:
              throw Error(o(365))
          }
          return !1
        }
        function la(f) {
          switch (f.$$typeof) {
            case uu:
              return '<' + (U(f.value) || 'Unknown') + '>'
            case Ja:
              return ':has(' + (la(f) || '') + ')'
            case el:
              return '[role="' + f.value + '"]'
            case Zl:
              return '"' + f.value + '"'
            case bo:
              return '[data-testname="' + f.value + '"]'
            default:
              throw Error(o(365))
          }
        }
        function jr(f, p) {
          var S = []
          f = [f, 0]
          for (var C = 0; C < f.length; ) {
            var I = f[C++],
              B = f[C++],
              ae = p[B]
            if (I.tag !== 5 || !Ue(I)) {
              for (; ae != null && fu(I, ae); ) B++, (ae = p[B])
              if (B === p.length) S.push(I)
              else for (I = I.child; I !== null; ) f.push(I, B), (I = I.sibling)
            }
          }
          return S
        }
        function To(f, p) {
          if (!at) throw Error(o(363))
          ;(f = du(f)), (f = jr(f, p)), (p = []), (f = Array.from(f))
          for (var S = 0; S < f.length; ) {
            var C = f[S++]
            if (C.tag === 5) Ue(C) || p.push(C.stateNode)
            else for (C = C.child; C !== null; ) f.push(C), (C = C.sibling)
          }
          return p
        }
        var mp = Math.ceil,
          hu = a.ReactCurrentDispatcher,
          As = a.ReactCurrentOwner,
          On = a.ReactCurrentBatchConfig,
          hn = 0,
          fi = null,
          kn = null,
          Jn = 0,
          Ji = 0,
          nl = ot(0),
          ai = 0,
          Kl = null,
          qs = 0,
          Hr = 0,
          il = 0,
          Ao = null,
          xi = null,
          pu = 0,
          ca = 1 / 0
        function rl() {
          ca = bi() + 500
        }
        var Ql = !1,
          Zn = null,
          Cs = null,
          Jl = !1,
          Ys = null,
          sl = 0,
          ol = 0,
          Co = null,
          $n = -1,
          li = 0
        function An() {
          return hn & 6 ? bi() : $n !== -1 ? $n : ($n = bi())
        }
        function Ps(f) {
          return f.mode & 1
            ? hn & 2 && Jn !== 0
              ? Jn & -Jn
              : sv.transition !== null
              ? (li === 0 &&
                  ((f = ui),
                  (ui <<= 1),
                  !(ui & 4194240) && (ui = 64),
                  (li = f)),
                li)
              : ((f = yn), f !== 0 ? f : Qe())
            : 1
        }
        function er(f, p, S) {
          if (50 < ol) throw ((ol = 0), (Co = null), Error(o(185)))
          var C = ua(f, p)
          return C === null
            ? null
            : (La(C, p, S),
              (!(hn & 2) || C !== fi) &&
                (C === fi && (!(hn & 2) && (Hr |= p), ai === 4 && Xi(C, Jn)),
                Er(C, S),
                p === 1 && hn === 0 && !(f.mode & 1) && (rl(), Rd && rs())),
              C)
        }
        function ua(f, p) {
          f.lanes |= p
          var S = f.alternate
          for (S !== null && (S.lanes |= p), S = f, f = f.return; f !== null; )
            (f.childLanes |= p),
              (S = f.alternate),
              S !== null && (S.childLanes |= p),
              (S = f),
              (f = f.return)
          return S.tag === 3 ? S.stateNode : null
        }
        function Er(f, p) {
          var S = f.callbackNode
          rv(f, p)
          var C = jc(f, f === fi ? Jn : 0)
          if (C === 0)
            S !== null && Ll(S),
              (f.callbackNode = null),
              (f.callbackPriority = 0)
          else if (((p = C & -C), f.callbackPriority !== p)) {
            if ((S != null && Ll(S), p === 1))
              f.tag === 0 ? Ld(Gr.bind(null, f)) : Id(Gr.bind(null, f)),
                rt
                  ? jt(function () {
                      hn === 0 && rs()
                    })
                  : Na(Da, rs),
                (S = null)
            else {
              switch (fo(C)) {
                case 1:
                  S = Da
                  break
                case 4:
                  S = j_
                  break
                case 16:
                  S = Cd
                  break
                case 536870912:
                  S = Pd
                  break
                default:
                  S = Cd
              }
              S = ff(S, $i.bind(null, f))
            }
            ;(f.callbackPriority = p), (f.callbackNode = S)
          }
        }
        function $i(f, p) {
          if ((($n = -1), (li = 0), hn & 6)) throw Error(o(327))
          var S = f.callbackNode
          if (Zs() && f.callbackNode !== S) return null
          var C = jc(f, f === fi ? Jn : 0)
          if (C === 0) return null
          if (C & 30 || C & f.expiredLanes || p) p = yu(f, C)
          else {
            p = C
            var I = hn
            hn |= 2
            var B = yp()
            ;(fi !== f || Jn !== p) && (rl(), Po(f, p))
            do
              try {
                wv()
                break
              } catch (ye) {
                vp(f, ye)
              }
            while (!0)
            cr(),
              (hu.current = B),
              (hn = I),
              kn !== null ? (p = 0) : ((fi = null), (Jn = 0), (p = ai))
          }
          if (p !== 0) {
            if (
              (p === 2 && ((I = bd(f)), I !== 0 && ((C = I), (p = mu(f, I)))),
              p === 1)
            )
              throw ((S = Kl), Po(f, 0), Xi(f, C), Er(f, bi()), S)
            if (p === 6) Xi(f, C)
            else {
              if (
                ((I = f.current.alternate),
                !(C & 30) &&
                  !gp(I) &&
                  ((p = yu(f, C)),
                  p === 2 &&
                    ((B = bd(f)), B !== 0 && ((C = B), (p = mu(f, B)))),
                  p === 1))
              )
                throw ((S = Kl), Po(f, 0), Xi(f, C), Er(f, bi()), S)
              switch (((f.finishedWork = I), (f.finishedLanes = C), p)) {
                case 0:
                case 1:
                  throw Error(o(345))
                case 2:
                  Rs(f, xi)
                  break
                case 3:
                  if (
                    (Xi(f, C),
                    (C & 130023424) === C && ((p = pu + 500 - bi()), 10 < p))
                  ) {
                    if (jc(f, 0) !== 0) break
                    if (((I = f.suspendedLanes), (I & C) !== C)) {
                      An(), (f.pingedLanes |= f.suspendedLanes & I)
                      break
                    }
                    f.timeoutHandle = Pe(Rs.bind(null, f, xi), p)
                    break
                  }
                  Rs(f, xi)
                  break
                case 4:
                  if ((Xi(f, C), (C & 4194240) === C)) break
                  for (p = f.eventTimes, I = -1; 0 < C; ) {
                    var ae = 31 - Wt(C)
                    ;(B = 1 << ae), (ae = p[ae]), ae > I && (I = ae), (C &= ~B)
                  }
                  if (
                    ((C = I),
                    (C = bi() - C),
                    (C =
                      (120 > C
                        ? 120
                        : 480 > C
                        ? 480
                        : 1080 > C
                        ? 1080
                        : 1920 > C
                        ? 1920
                        : 3e3 > C
                        ? 3e3
                        : 4320 > C
                        ? 4320
                        : 1960 * mp(C / 1960)) - C),
                    10 < C)
                  ) {
                    f.timeoutHandle = Pe(Rs.bind(null, f, xi), C)
                    break
                  }
                  Rs(f, xi)
                  break
                case 5:
                  Rs(f, xi)
                  break
                default:
                  throw Error(o(329))
              }
            }
          }
          return Er(f, bi()), f.callbackNode === S ? $i.bind(null, f) : null
        }
        function mu(f, p) {
          var S = Ao
          return (
            f.current.memoizedState.isDehydrated && (Po(f, p).flags |= 256),
            (f = yu(f, p)),
            f !== 2 && ((p = xi), (xi = S), p !== null && gu(p)),
            f
          )
        }
        function gu(f) {
          xi === null ? (xi = f) : xi.push.apply(xi, f)
        }
        function gp(f) {
          for (var p = f; ; ) {
            if (p.flags & 16384) {
              var S = p.updateQueue
              if (S !== null && ((S = S.stores), S !== null))
                for (var C = 0; C < S.length; C++) {
                  var I = S[C],
                    B = I.getSnapshot
                  I = I.value
                  try {
                    if (!lr(B(), I)) return !1
                  } catch {
                    return !1
                  }
                }
            }
            if (((S = p.child), p.subtreeFlags & 16384 && S !== null))
              (S.return = p), (p = S)
            else {
              if (p === f) break
              for (; p.sibling === null; ) {
                if (p.return === null || p.return === f) return !0
                p = p.return
              }
              ;(p.sibling.return = p.return), (p = p.sibling)
            }
          }
          return !0
        }
        function Xi(f, p) {
          for (
            p &= ~il,
              p &= ~Hr,
              f.suspendedLanes |= p,
              f.pingedLanes &= ~p,
              f = f.expirationTimes;
            0 < p;

          ) {
            var S = 31 - Wt(p),
              C = 1 << S
            ;(f[S] = -1), (p &= ~C)
          }
        }
        function Gr(f) {
          if (hn & 6) throw Error(o(327))
          Zs()
          var p = jc(f, 0)
          if (!(p & 1)) return Er(f, bi()), null
          var S = yu(f, p)
          if (f.tag !== 0 && S === 2) {
            var C = bd(f)
            C !== 0 && ((p = C), (S = mu(f, C)))
          }
          if (S === 1) throw ((S = Kl), Po(f, 0), Xi(f, p), Er(f, bi()), S)
          if (S === 6) throw Error(o(345))
          return (
            (f.finishedWork = f.current.alternate),
            (f.finishedLanes = p),
            Rs(f, xi),
            Er(f, bi()),
            null
          )
        }
        function ec(f) {
          Ys !== null && Ys.tag === 0 && !(hn & 6) && Zs()
          var p = hn
          hn |= 1
          var S = On.transition,
            C = yn
          try {
            if (((On.transition = null), (yn = 1), f)) return f()
          } finally {
            ;(yn = C), (On.transition = S), (hn = p), !(hn & 6) && rs()
          }
        }
        function vu() {
          ;(Ji = nl.current), We(nl)
        }
        function Po(f, p) {
          ;(f.finishedWork = null), (f.finishedLanes = 0)
          var S = f.timeoutHandle
          if ((S !== et && ((f.timeoutHandle = et), Be(S)), kn !== null))
            for (S = kn.return; S !== null; ) {
              var C = S
              switch ((Wh(C), C.tag)) {
                case 1:
                  ;(C = C.type.childContextTypes), C != null && Ht()
                  break
                case 3:
                  Vl(), We(Lt), We(qt), ja()
                  break
                case 5:
                  qh(C)
                  break
                case 4:
                  Vl()
                  break
                case 13:
                  We(ti)
                  break
                case 19:
                  We(ti)
                  break
                case 10:
                  Xc(C.type._context)
                  break
                case 22:
                case 23:
                  vu()
              }
              S = S.return
            }
          if (
            ((fi = f),
            (kn = f = Ro(f.current, null)),
            (Jn = Ji = p),
            (ai = 0),
            (Kl = null),
            (il = Hr = qs = 0),
            (xi = Ao = null),
            ss !== null)
          ) {
            for (p = 0; p < ss.length; p++)
              if (((S = ss[p]), (C = S.interleaved), C !== null)) {
                S.interleaved = null
                var I = C.next,
                  B = S.pending
                if (B !== null) {
                  var ae = B.next
                  ;(B.next = I), (C.next = ae)
                }
                S.pending = C
              }
            ss = null
          }
          return f
        }
        function vp(f, p) {
          do {
            var S = kn
            try {
              if ((cr(), (Yc.current = $l), Gd)) {
                for (var C = ni.memoizedState; C !== null; ) {
                  var I = C.queue
                  I !== null && (I.pending = null), (C = C.next)
                }
                Gd = !1
              }
              if (
                ((Ha = 0),
                (Ni = Li = ni = null),
                (Ws = !1),
                (Ga = 0),
                (As.current = null),
                S === null || S.return === null)
              ) {
                ;(ai = 1), (Kl = p), (kn = null)
                break
              }
              e: {
                var B = f,
                  ae = S.return,
                  ye = S,
                  Fe = p
                if (
                  ((p = Jn),
                  (ye.flags |= 32768),
                  Fe !== null &&
                    typeof Fe == 'object' &&
                    typeof Fe.then == 'function')
                ) {
                  var it = Fe,
                    At = ye,
                    on = At.tag
                  if (!(At.mode & 1) && (on === 0 || on === 11 || on === 15)) {
                    var Gt = At.alternate
                    Gt
                      ? ((At.updateQueue = Gt.updateQueue),
                        (At.memoizedState = Gt.memoizedState),
                        (At.lanes = Gt.lanes))
                      : ((At.updateQueue = null), (At.memoizedState = null))
                  }
                  var gn = rp(ae)
                  if (gn !== null) {
                    ;(gn.flags &= -257),
                      $a(gn, ae, ye, B, p),
                      gn.mode & 1 && xo(B, it, p),
                      (p = gn),
                      (Fe = it)
                    var St = p.updateQueue
                    if (St === null) {
                      var qi = new Set()
                      qi.add(Fe), (p.updateQueue = qi)
                    } else St.add(Fe)
                    break e
                  } else {
                    if (!(p & 1)) {
                      xo(B, it, p), df()
                      break e
                    }
                    Fe = Error(o(426))
                  }
                } else if (Qn && ye.mode & 1) {
                  var $r = rp(ae)
                  if ($r !== null) {
                    !($r.flags & 65536) && ($r.flags |= 256),
                      $a($r, ae, ye, B, p),
                      Vd(Fe)
                    break e
                  }
                }
                ;(B = Fe),
                  ai !== 4 && (ai = 2),
                  Ao === null ? (Ao = [B]) : Ao.push(B),
                  (Fe = ip(Fe, ye)),
                  (ye = ae)
                do {
                  switch (ye.tag) {
                    case 3:
                      ;(ye.flags |= 65536), (p &= -p), (ye.lanes |= p)
                      var be = yv(ye, Fe, p)
                      Od(ye, be)
                      break e
                    case 1:
                      B = Fe
                      var xe = ye.type,
                        Ne = ye.stateNode
                      if (
                        !(ye.flags & 128) &&
                        (typeof xe.getDerivedStateFromError == 'function' ||
                          (Ne !== null &&
                            typeof Ne.componentDidCatch == 'function' &&
                            (Cs === null || !Cs.has(Ne))))
                      ) {
                        ;(ye.flags |= 65536), (p &= -p), (ye.lanes |= p)
                        var yt = ef(ye, B, p)
                        Od(ye, yt)
                        break e
                      }
                  }
                  ye = ye.return
                } while (ye !== null)
              }
              _p(S)
            } catch (kt) {
              ;(p = kt), kn === S && S !== null && (kn = S = S.return)
              continue
            }
            break
          } while (!0)
        }
        function yp() {
          var f = hu.current
          return (hu.current = $l), f === null ? $l : f
        }
        function df() {
          ;(ai === 0 || ai === 3 || ai === 2) && (ai = 4),
            fi === null ||
              (!(qs & 268435455) && !(Hr & 268435455)) ||
              Xi(fi, Jn)
        }
        function yu(f, p) {
          var S = hn
          hn |= 2
          var C = yp()
          ;(fi === f && Jn === p) || Po(f, p)
          do
            try {
              _v()
              break
            } catch (I) {
              vp(f, I)
            }
          while (!0)
          if ((cr(), (hn = S), (hu.current = C), kn !== null))
            throw Error(o(261))
          return (fi = null), (Jn = 0), ai
        }
        function _v() {
          for (; kn !== null; ) xp(kn)
        }
        function wv() {
          for (; kn !== null && !Jo(); ) xp(kn)
        }
        function xp(f) {
          var p = Mp(f.alternate, f, Ji)
          ;(f.memoizedProps = f.pendingProps),
            p === null ? _p(f) : (kn = p),
            (As.current = null)
        }
        function _p(f) {
          var p = f
          do {
            var S = p.alternate
            if (((f = p.return), p.flags & 32768)) {
              if (((S = af(S, p)), S !== null)) {
                ;(S.flags &= 32767), (kn = S)
                return
              }
              if (f !== null)
                (f.flags |= 32768), (f.subtreeFlags = 0), (f.deletions = null)
              else {
                ;(ai = 6), (kn = null)
                return
              }
            } else if (((S = rf(S, p, Ji)), S !== null)) {
              kn = S
              return
            }
            if (((p = p.sibling), p !== null)) {
              kn = p
              return
            }
            kn = p = f
          } while (p !== null)
          ai === 0 && (ai = 5)
        }
        function Rs(f, p) {
          var S = yn,
            C = On.transition
          try {
            ;(On.transition = null), (yn = 1), Sv(f, p, S)
          } finally {
            ;(On.transition = C), (yn = S)
          }
          return null
        }
        function Sv(f, p, S) {
          do Zs()
          while (Ys !== null)
          if (hn & 6) throw Error(o(327))
          var C = f.finishedWork,
            I = f.finishedLanes
          if (C === null) return null
          if (((f.finishedWork = null), (f.finishedLanes = 0), C === f.current))
            throw Error(o(177))
          ;(f.callbackNode = null), (f.callbackPriority = 0)
          var B = C.lanes | C.childLanes
          if (
            (Ad(f, B),
            f === fi && ((kn = fi = null), (Jn = 0)),
            (!(C.subtreeFlags & 2064) && !(C.flags & 2064)) ||
              Jl ||
              ((Jl = !0),
              ff(Cd, function () {
                return Zs(), null
              })),
            (B = (C.flags & 15990) !== 0),
            C.subtreeFlags & 15990 || B)
          ) {
            ;(B = On.transition), (On.transition = null)
            var ae = yn
            yn = 1
            var ye = hn
            ;(hn |= 4),
              (As.current = null),
              cp(f, C),
              W_(f, C),
              Q(f.containerInfo),
              (f.current = C),
              lu(C),
              V_(),
              (hn = ye),
              (yn = ae),
              (On.transition = B)
          } else f.current = C
          if (
            (Jl && ((Jl = !1), (Ys = f), (sl = I)),
            (B = f.pendingLanes),
            B === 0 && (Cs = null),
            Gc(C.stateNode),
            Er(f, bi()),
            p !== null)
          )
            for (S = f.onRecoverableError, C = 0; C < p.length; C++) S(p[C])
          if (Ql) throw ((Ql = !1), (f = Zn), (Zn = null), f)
          return (
            sl & 1 && f.tag !== 0 && Zs(),
            (B = f.pendingLanes),
            B & 1 ? (f === Co ? ol++ : ((ol = 0), (Co = f))) : (ol = 0),
            rs(),
            null
          )
        }
        function Zs() {
          if (Ys !== null) {
            var f = fo(sl),
              p = On.transition,
              S = yn
            try {
              if (((On.transition = null), (yn = 16 > f ? 16 : f), Ys === null))
                var C = !1
              else {
                if (((f = Ys), (Ys = null), (sl = 0), hn & 6))
                  throw Error(o(331))
                var I = hn
                for (hn |= 4, lt = f.current; lt !== null; ) {
                  var B = lt,
                    ae = B.child
                  if (lt.flags & 16) {
                    var ye = B.deletions
                    if (ye !== null) {
                      for (var Fe = 0; Fe < ye.length; Fe++) {
                        var it = ye[Fe]
                        for (lt = it; lt !== null; ) {
                          var At = lt
                          switch (At.tag) {
                            case 0:
                            case 11:
                            case 15:
                              Eo(8, At, B)
                          }
                          var on = At.child
                          if (on !== null) (on.return = At), (lt = on)
                          else
                            for (; lt !== null; ) {
                              At = lt
                              var Gt = At.sibling,
                                gn = At.return
                              if ((up(At), At === it)) {
                                lt = null
                                break
                              }
                              if (Gt !== null) {
                                ;(Gt.return = gn), (lt = Gt)
                                break
                              }
                              lt = gn
                            }
                        }
                      }
                      var St = B.alternate
                      if (St !== null) {
                        var qi = St.child
                        if (qi !== null) {
                          St.child = null
                          do {
                            var $r = qi.sibling
                            ;(qi.sibling = null), (qi = $r)
                          } while (qi !== null)
                        }
                      }
                      lt = B
                    }
                  }
                  if (B.subtreeFlags & 2064 && ae !== null)
                    (ae.return = B), (lt = ae)
                  else
                    e: for (; lt !== null; ) {
                      if (((B = lt), B.flags & 2048))
                        switch (B.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Eo(9, B, B.return)
                        }
                      var be = B.sibling
                      if (be !== null) {
                        ;(be.return = B.return), (lt = be)
                        break e
                      }
                      lt = B.return
                    }
                }
                var xe = f.current
                for (lt = xe; lt !== null; ) {
                  ae = lt
                  var Ne = ae.child
                  if (ae.subtreeFlags & 2064 && Ne !== null)
                    (Ne.return = ae), (lt = Ne)
                  else
                    e: for (ae = xe; lt !== null; ) {
                      if (((ye = lt), ye.flags & 2048))
                        try {
                          switch (ye.tag) {
                            case 0:
                            case 11:
                            case 15:
                              Wi(9, ye)
                          }
                        } catch (kt) {
                          pr(ye, ye.return, kt)
                        }
                      if (ye === ae) {
                        lt = null
                        break e
                      }
                      var yt = ye.sibling
                      if (yt !== null) {
                        ;(yt.return = ye.return), (lt = yt)
                        break e
                      }
                      lt = ye.return
                    }
                }
                if (
                  ((hn = I),
                  rs(),
                  Gs && typeof Gs.onPostCommitFiberRoot == 'function')
                )
                  try {
                    Gs.onPostCommitFiberRoot(Hc, f)
                  } catch {}
                C = !0
              }
              return C
            } finally {
              ;(yn = S), (On.transition = p)
            }
          }
          return !1
        }
        function xu(f, p, S) {
          ;(p = ip(S, p)),
            (p = yv(f, p, 1)),
            ea(f, p),
            (p = An()),
            (f = ua(f, 1)),
            f !== null && (La(f, 1, p), Er(f, p))
        }
        function pr(f, p, S) {
          if (f.tag === 3) xu(f, f, S)
          else
            for (; p !== null; ) {
              if (p.tag === 3) {
                xu(p, f, S)
                break
              } else if (p.tag === 1) {
                var C = p.stateNode
                if (
                  typeof p.type.getDerivedStateFromError == 'function' ||
                  (typeof C.componentDidCatch == 'function' &&
                    (Cs === null || !Cs.has(C)))
                ) {
                  ;(f = ip(S, f)),
                    (f = ef(p, f, 1)),
                    ea(p, f),
                    (f = An()),
                    (p = ua(p, 1)),
                    p !== null && (La(p, 1, f), Er(p, f))
                  break
                }
              }
              p = p.return
            }
        }
        function wp(f, p, S) {
          var C = f.pingCache
          C !== null && C.delete(p),
            (p = An()),
            (f.pingedLanes |= f.suspendedLanes & S),
            fi === f &&
              (Jn & S) === S &&
              (ai === 4 ||
              (ai === 3 && (Jn & 130023424) === Jn && 500 > bi() - pu)
                ? Po(f, 0)
                : (il |= S)),
            Er(f, p)
        }
        function Sp(f, p) {
          p === 0 &&
            (f.mode & 1
              ? ((p = Sn), (Sn <<= 1), !(Sn & 130023424) && (Sn = 4194304))
              : (p = 1))
          var S = An()
          ;(f = ua(f, p)), f !== null && (La(f, p, S), Er(f, S))
        }
        function Mv(f) {
          var p = f.memoizedState,
            S = 0
          p !== null && (S = p.retryLane), Sp(f, S)
        }
        function Ev(f, p) {
          var S = 0
          switch (f.tag) {
            case 13:
              var C = f.stateNode,
                I = f.memoizedState
              I !== null && (S = I.retryLane)
              break
            case 19:
              C = f.stateNode
              break
            default:
              throw Error(o(314))
          }
          C !== null && C.delete(p), Sp(f, S)
        }
        var Mp
        Mp = function (f, p, S) {
          if (f !== null)
            if (f.memoizedProps !== p.pendingProps || Lt.current) Oi = !0
            else {
              if (!(f.lanes & S) && !(p.flags & 128))
                return (Oi = !1), of(f, p, S)
              Oi = !!(f.flags & 131072)
            }
          else (Oi = !1), Qn && p.flags & 1048576 && uv(p, Bd, p.index)
          switch (((p.lanes = 0), p.tag)) {
            case 2:
              var C = p.type
              f !== null &&
                ((f.alternate = null), (p.alternate = null), (p.flags |= 2)),
                (f = p.pendingProps)
              var I = wt(p, qt.current)
              Nl(p, S), (I = jl(null, p, C, f, I, S))
              var B = ra()
              return (
                (p.flags |= 1),
                typeof I == 'object' &&
                I !== null &&
                typeof I.render == 'function' &&
                I.$$typeof === void 0
                  ? ((p.tag = 1),
                    (p.memoizedState = null),
                    (p.updateQueue = null),
                    fn(C) ? ((B = !0), ln(p)) : (B = !1),
                    (p.memoizedState =
                      I.state !== null && I.state !== void 0 ? I.state : null),
                    Dl(p),
                    (I.updater = Fd),
                    (p.stateNode = I),
                    (I._reactInternals = p),
                    Hh(p, C, f, S),
                    (p = Qi(null, p, C, !0, B, S)))
                  : ((p.tag = 0),
                    Qn && B && Gh(p),
                    oi(null, p, I, S),
                    (p = p.child)),
                p
              )
            case 16:
              C = p.elementType
              e: {
                switch (
                  (f !== null &&
                    ((f.alternate = null),
                    (p.alternate = null),
                    (p.flags |= 2)),
                  (f = p.pendingProps),
                  (I = C._init),
                  (C = I(C._payload)),
                  (p.type = C),
                  (I = p.tag = $_(C)),
                  (f = _r(C, f)),
                  I)
                ) {
                  case 0:
                    p = So(null, p, C, f, S)
                    break e
                  case 1:
                    p = qa(null, p, C, f, S)
                    break e
                  case 11:
                    p = Wn(null, p, C, f, S)
                    break e
                  case 14:
                    p = Bn(null, p, C, _r(C.type, f), S)
                    break e
                }
                throw Error(o(306, C, ''))
              }
              return p
            case 0:
              return (
                (C = p.type),
                (I = p.pendingProps),
                (I = p.elementType === C ? I : _r(C, I)),
                So(f, p, C, I, S)
              )
            case 1:
              return (
                (C = p.type),
                (I = p.pendingProps),
                (I = p.elementType === C ? I : _r(C, I)),
                qa(f, p, C, I, S)
              )
            case 3:
              e: {
                if ((ru(p), f === null)) throw Error(o(387))
                ;(C = p.pendingProps),
                  (B = p.memoizedState),
                  (I = B.element),
                  zh(f, p),
                  kd(p, C, null, S)
                var ae = p.memoizedState
                if (((C = ae.element), $e && B.isDehydrated))
                  if (
                    ((B = {
                      element: C,
                      isDehydrated: !1,
                      cache: ae.cache,
                      transitions: ae.transitions,
                    }),
                    (p.updateQueue.baseState = B),
                    (p.memoizedState = B),
                    p.flags & 256)
                  ) {
                    ;(I = Error(o(423))), (p = op(f, p, C, S, I))
                    break e
                  } else if (C !== I) {
                    ;(I = Error(o(424))), (p = op(f, p, C, S, I))
                    break e
                  } else
                    for (
                      $e &&
                        ((Hi = Ia(p.stateNode.containerInfo)),
                        (ur = p),
                        (Qn = !0),
                        (ls = null),
                        (kl = !1)),
                        S = hv(p, null, C, S),
                        p.child = S;
                      S;

                    )
                      (S.flags = (S.flags & -3) | 4096), (S = S.sibling)
                else {
                  if ((Fl(), C === I)) {
                    p = Mr(f, p, S)
                    break e
                  }
                  oi(f, p, C, S)
                }
                p = p.child
              }
              return p
            case 5:
              return (
                pv(p),
                f === null && na(p),
                (C = p.type),
                (I = p.pendingProps),
                (B = f !== null ? f.memoizedProps : null),
                (ae = I.children),
                Ce(C, I)
                  ? (ae = null)
                  : B !== null && Ce(C, B) && (p.flags |= 32),
                dr(f, p),
                oi(f, p, ae, S),
                p.child
              )
            case 6:
              return f === null && na(p), null
            case 13:
              return ap(f, p, S)
            case 4:
              return (
                jd(p, p.stateNode.containerInfo),
                (C = p.pendingProps),
                f === null ? (p.child = vo(p, null, C, S)) : oi(f, p, C, S),
                p.child
              )
            case 11:
              return (
                (C = p.type),
                (I = p.pendingProps),
                (I = p.elementType === C ? I : _r(C, I)),
                Wn(f, p, C, I, S)
              )
            case 7:
              return oi(f, p, p.pendingProps, S), p.child
            case 8:
              return oi(f, p, p.pendingProps.children, S), p.child
            case 12:
              return oi(f, p, p.pendingProps.children, S), p.child
            case 10:
              e: {
                if (
                  ((C = p.type._context),
                  (I = p.pendingProps),
                  (B = p.memoizedProps),
                  (ae = I.value),
                  ka(p, C, ae),
                  B !== null)
                )
                  if (lr(B.value, ae)) {
                    if (B.children === I.children && !Lt.current) {
                      p = Mr(f, p, S)
                      break e
                    }
                  } else
                    for (
                      B = p.child, B !== null && (B.return = p);
                      B !== null;

                    ) {
                      var ye = B.dependencies
                      if (ye !== null) {
                        ae = B.child
                        for (var Fe = ye.firstContext; Fe !== null; ) {
                          if (Fe.context === C) {
                            if (B.tag === 1) {
                              ;(Fe = po(-1, S & -S)), (Fe.tag = 2)
                              var it = B.updateQueue
                              if (it !== null) {
                                it = it.shared
                                var At = it.pending
                                At === null
                                  ? (Fe.next = Fe)
                                  : ((Fe.next = At.next), (At.next = Fe)),
                                  (it.pending = Fe)
                              }
                            }
                            ;(B.lanes |= S),
                              (Fe = B.alternate),
                              Fe !== null && (Fe.lanes |= S),
                              Fa(B.return, S, p),
                              (ye.lanes |= S)
                            break
                          }
                          Fe = Fe.next
                        }
                      } else if (B.tag === 10)
                        ae = B.type === p.type ? null : B.child
                      else if (B.tag === 18) {
                        if (((ae = B.return), ae === null)) throw Error(o(341))
                        ;(ae.lanes |= S),
                          (ye = ae.alternate),
                          ye !== null && (ye.lanes |= S),
                          Fa(ae, S, p),
                          (ae = B.sibling)
                      } else ae = B.child
                      if (ae !== null) ae.return = B
                      else
                        for (ae = B; ae !== null; ) {
                          if (ae === p) {
                            ae = null
                            break
                          }
                          if (((B = ae.sibling), B !== null)) {
                            ;(B.return = ae.return), (ae = B)
                            break
                          }
                          ae = ae.return
                        }
                      B = ae
                    }
                oi(f, p, I.children, S), (p = p.child)
              }
              return p
            case 9:
              return (
                (I = p.type),
                (C = p.pendingProps.children),
                Nl(p, S),
                (I = wr(I)),
                (C = C(I)),
                (p.flags |= 1),
                oi(f, p, C, S),
                p.child
              )
            case 14:
              return (
                (C = p.type),
                (I = _r(C, p.pendingProps)),
                (I = _r(C.type, I)),
                Bn(f, p, C, I, S)
              )
            case 15:
              return wo(f, p, p.type, p.pendingProps, S)
            case 17:
              return (
                (C = p.type),
                (I = p.pendingProps),
                (I = p.elementType === C ? I : _r(C, I)),
                f !== null &&
                  ((f.alternate = null), (p.alternate = null), (p.flags |= 2)),
                (p.tag = 1),
                fn(C) ? ((f = !0), ln(p)) : (f = !1),
                Nl(p, S),
                lv(p, C, I),
                Hh(p, C, I, S),
                Qi(null, p, C, !0, f, S)
              )
            case 19:
              return Za(f, p, S)
            case 22:
              return Gi(f, p, S)
          }
          throw Error(o(156, p.tag))
        }
        function ff(f, p) {
          return Na(f, p)
        }
        function bv(f, p, S, C) {
          ;(this.tag = f),
            (this.key = S),
            (this.sibling =
              this.child =
              this.return =
              this.stateNode =
              this.type =
              this.elementType =
                null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = p),
            (this.dependencies =
              this.memoizedState =
              this.updateQueue =
              this.memoizedProps =
                null),
            (this.mode = C),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null)
        }
        function Wr(f, p, S, C) {
          return new bv(f, p, S, C)
        }
        function hf(f) {
          return (f = f.prototype), !(!f || !f.isReactComponent)
        }
        function $_(f) {
          if (typeof f == 'function') return hf(f) ? 1 : 0
          if (f != null) {
            if (((f = f.$$typeof), f === M)) return 11
            if (f === T) return 14
          }
          return 2
        }
        function Ro(f, p) {
          var S = f.alternate
          return (
            S === null
              ? ((S = Wr(f.tag, p, f.key, f.mode)),
                (S.elementType = f.elementType),
                (S.type = f.type),
                (S.stateNode = f.stateNode),
                (S.alternate = f),
                (f.alternate = S))
              : ((S.pendingProps = p),
                (S.type = f.type),
                (S.flags = 0),
                (S.subtreeFlags = 0),
                (S.deletions = null)),
            (S.flags = f.flags & 14680064),
            (S.childLanes = f.childLanes),
            (S.lanes = f.lanes),
            (S.child = f.child),
            (S.memoizedProps = f.memoizedProps),
            (S.memoizedState = f.memoizedState),
            (S.updateQueue = f.updateQueue),
            (p = f.dependencies),
            (S.dependencies =
              p === null
                ? null
                : { lanes: p.lanes, firstContext: p.firstContext }),
            (S.sibling = f.sibling),
            (S.index = f.index),
            (S.ref = f.ref),
            S
          )
        }
        function pf(f, p, S, C, I, B) {
          var ae = 2
          if (((C = f), typeof f == 'function')) hf(f) && (ae = 1)
          else if (typeof f == 'string') ae = 5
          else
            e: switch (f) {
              case h:
                return al(S.children, I, B, p)
              case m:
                ;(ae = 8), (I |= 8)
                break
              case g:
                return (
                  (f = Wr(12, S, p, I | 2)),
                  (f.elementType = g),
                  (f.lanes = B),
                  f
                )
              case w:
                return (
                  (f = Wr(13, S, p, I)), (f.elementType = w), (f.lanes = B), f
                )
              case x:
                return (
                  (f = Wr(19, S, p, I)), (f.elementType = x), (f.lanes = B), f
                )
              case P:
                return _u(S, I, B, p)
              default:
                if (typeof f == 'object' && f !== null)
                  switch (f.$$typeof) {
                    case y:
                      ae = 10
                      break e
                    case _:
                      ae = 9
                      break e
                    case M:
                      ae = 11
                      break e
                    case T:
                      ae = 14
                      break e
                    case A:
                      ;(ae = 16), (C = null)
                      break e
                  }
                throw Error(o(130, f == null ? f : typeof f, ''))
            }
          return (
            (p = Wr(ae, S, p, I)),
            (p.elementType = f),
            (p.type = C),
            (p.lanes = B),
            p
          )
        }
        function al(f, p, S, C) {
          return (f = Wr(7, f, C, p)), (f.lanes = S), f
        }
        function _u(f, p, S, C) {
          return (
            (f = Wr(22, f, C, p)),
            (f.elementType = P),
            (f.lanes = S),
            (f.stateNode = {}),
            f
          )
        }
        function mf(f, p, S) {
          return (f = Wr(6, f, null, p)), (f.lanes = S), f
        }
        function gf(f, p, S) {
          return (
            (p = Wr(4, f.children !== null ? f.children : [], f.key, p)),
            (p.lanes = S),
            (p.stateNode = {
              containerInfo: f.containerInfo,
              pendingChildren: null,
              implementation: f.implementation,
            }),
            p
          )
        }
        function vf(f, p, S, C, I) {
          ;(this.tag = p),
            (this.containerInfo = f),
            (this.finishedWork =
              this.pingCache =
              this.current =
              this.pendingChildren =
                null),
            (this.timeoutHandle = et),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = Td(0)),
            (this.expirationTimes = Td(-1)),
            (this.entangledLanes =
              this.finishedLanes =
              this.mutableReadLanes =
              this.expiredLanes =
              this.pingedLanes =
              this.suspendedLanes =
              this.pendingLanes =
                0),
            (this.entanglements = Td(0)),
            (this.identifierPrefix = C),
            (this.onRecoverableError = I),
            $e && (this.mutableSourceEagerHydrationData = null)
        }
        function Tv(f, p, S, C, I, B, ae, ye, Fe) {
          return (
            (f = new vf(f, p, S, ye, Fe)),
            p === 1 ? ((p = 1), B === !0 && (p |= 8)) : (p = 0),
            (B = Wr(3, null, null, p)),
            (f.current = B),
            (B.stateNode = f),
            (B.memoizedState = {
              element: C,
              isDehydrated: S,
              cache: null,
              transitions: null,
            }),
            Dl(B),
            f
          )
        }
        function Av(f) {
          if (!f) return mt
          f = f._reactInternals
          e: {
            if (N(f) !== f || f.tag !== 1) throw Error(o(170))
            var p = f
            do {
              switch (p.tag) {
                case 3:
                  p = p.stateNode.context
                  break e
                case 1:
                  if (fn(p.type)) {
                    p = p.stateNode.__reactInternalMemoizedMergedChildContext
                    break e
                  }
              }
              p = p.return
            } while (p !== null)
            throw Error(o(171))
          }
          if (f.tag === 1) {
            var S = f.type
            if (fn(S)) return jn(f, S, p)
          }
          return p
        }
        function Cv(f) {
          var p = f._reactInternals
          if (p === void 0)
            throw typeof f.render == 'function'
              ? Error(o(188))
              : ((f = Object.keys(f).join(',')), Error(o(268, f)))
          return (f = $(p)), f === null ? null : f.stateNode
        }
        function ds(f, p) {
          if (((f = f.memoizedState), f !== null && f.dehydrated !== null)) {
            var S = f.retryLane
            f.retryLane = S !== 0 && S < p ? S : p
          }
        }
        function wu(f, p) {
          ds(f, p), (f = f.alternate) && ds(f, p)
        }
        function yf(f) {
          return (f = $(f)), f === null ? null : f.stateNode
        }
        function Pv() {
          return null
        }
        return (
          (t.attemptContinuousHydration = function (f) {
            if (f.tag === 13) {
              var p = An()
              er(f, 134217728, p), wu(f, 134217728)
            }
          }),
          (t.attemptHydrationAtCurrentPriority = function (f) {
            if (f.tag === 13) {
              var p = An(),
                S = Ps(f)
              er(f, S, p), wu(f, S)
            }
          }),
          (t.attemptSynchronousHydration = function (f) {
            switch (f.tag) {
              case 3:
                var p = f.stateNode
                if (p.current.memoizedState.isDehydrated) {
                  var S = xr(p.pendingLanes)
                  S !== 0 &&
                    (Hs(p, S | 1), Er(p, bi()), !(hn & 6) && (rl(), rs()))
                }
                break
              case 13:
                var C = An()
                ec(function () {
                  return er(f, 1, C)
                }),
                  wu(f, 1)
            }
          }),
          (t.batchedUpdates = function (f, p) {
            var S = hn
            hn |= 1
            try {
              return f(p)
            } finally {
              ;(hn = S), hn === 0 && (rl(), Rd && rs())
            }
          }),
          (t.createComponentSelector = function (f) {
            return { $$typeof: uu, value: f }
          }),
          (t.createContainer = function (f, p, S, C, I, B, ae) {
            return Tv(f, p, !1, null, S, C, I, B, ae)
          }),
          (t.createHasPseudoClassSelector = function (f) {
            return { $$typeof: Ja, value: f }
          }),
          (t.createHydrationContainer = function (
            f,
            p,
            S,
            C,
            I,
            B,
            ae,
            ye,
            Fe,
          ) {
            return (
              (f = Tv(S, C, !0, f, I, B, ae, ye, Fe)),
              (f.context = Av(null)),
              (S = f.current),
              (C = An()),
              (I = Ps(S)),
              (B = po(C, I)),
              (B.callback = p ?? null),
              ea(S, B),
              (f.current.lanes = I),
              La(f, I, C),
              Er(f, C),
              f
            )
          }),
          (t.createPortal = function (f, p, S) {
            var C =
              3 < arguments.length && arguments[3] !== void 0
                ? arguments[3]
                : null
            return {
              $$typeof: u,
              key: C == null ? null : '' + C,
              children: f,
              containerInfo: p,
              implementation: S,
            }
          }),
          (t.createRoleSelector = function (f) {
            return { $$typeof: el, value: f }
          }),
          (t.createTestNameSelector = function (f) {
            return { $$typeof: bo, value: f }
          }),
          (t.createTextSelector = function (f) {
            return { $$typeof: Zl, value: f }
          }),
          (t.deferredUpdates = function (f) {
            var p = yn,
              S = On.transition
            try {
              return (On.transition = null), (yn = 16), f()
            } finally {
              ;(yn = p), (On.transition = S)
            }
          }),
          (t.discreteUpdates = function (f, p, S, C, I) {
            var B = yn,
              ae = On.transition
            try {
              return (On.transition = null), (yn = 1), f(p, S, C, I)
            } finally {
              ;(yn = B), (On.transition = ae), hn === 0 && rl()
            }
          }),
          (t.findAllNodes = To),
          (t.findBoundingRects = function (f, p) {
            if (!at) throw Error(o(363))
            ;(p = To(f, p)), (f = [])
            for (var S = 0; S < p.length; S++) f.push(Z(p[S]))
            for (p = f.length - 1; 0 < p; p--) {
              S = f[p]
              for (
                var C = S.x,
                  I = C + S.width,
                  B = S.y,
                  ae = B + S.height,
                  ye = p - 1;
                0 <= ye;
                ye--
              )
                if (p !== ye) {
                  var Fe = f[ye],
                    it = Fe.x,
                    At = it + Fe.width,
                    on = Fe.y,
                    Gt = on + Fe.height
                  if (C >= it && B >= on && I <= At && ae <= Gt) {
                    f.splice(p, 1)
                    break
                  } else if (
                    C !== it ||
                    S.width !== Fe.width ||
                    Gt < B ||
                    on > ae
                  ) {
                    if (
                      !(B !== on || S.height !== Fe.height || At < C || it > I)
                    ) {
                      it > C && ((Fe.width += it - C), (Fe.x = C)),
                        At < I && (Fe.width = I - it),
                        f.splice(p, 1)
                      break
                    }
                  } else {
                    on > B && ((Fe.height += on - B), (Fe.y = B)),
                      Gt < ae && (Fe.height = ae - on),
                      f.splice(p, 1)
                    break
                  }
                }
            }
            return f
          }),
          (t.findHostInstance = Cv),
          (t.findHostInstanceWithNoPortals = function (f) {
            return (
              (f = z(f)),
              (f = f !== null ? j(f) : null),
              f === null ? null : f.stateNode
            )
          }),
          (t.findHostInstanceWithWarning = function (f) {
            return Cv(f)
          }),
          (t.flushControlled = function (f) {
            var p = hn
            hn |= 1
            var S = On.transition,
              C = yn
            try {
              ;(On.transition = null), (yn = 1), f()
            } finally {
              ;(yn = C), (On.transition = S), (hn = p), hn === 0 && (rl(), rs())
            }
          }),
          (t.flushPassiveEffects = Zs),
          (t.flushSync = ec),
          (t.focusWithin = function (f, p) {
            if (!at) throw Error(o(363))
            for (
              f = du(f), p = jr(f, p), p = Array.from(p), f = 0;
              f < p.length;

            ) {
              var S = p[f++]
              if (!Ue(S)) {
                if (S.tag === 5 && ze(S.stateNode)) return !0
                for (S = S.child; S !== null; ) p.push(S), (S = S.sibling)
              }
            }
            return !1
          }),
          (t.getCurrentUpdatePriority = function () {
            return yn
          }),
          (t.getFindAllNodesFailureDescription = function (f, p) {
            if (!at) throw Error(o(363))
            var S = 0,
              C = []
            f = [du(f), 0]
            for (var I = 0; I < f.length; ) {
              var B = f[I++],
                ae = f[I++],
                ye = p[ae]
              if (
                (B.tag !== 5 || !Ue(B)) &&
                (fu(B, ye) && (C.push(la(ye)), ae++, ae > S && (S = ae)),
                ae < p.length)
              )
                for (B = B.child; B !== null; ) f.push(B, ae), (B = B.sibling)
            }
            if (S < p.length) {
              for (f = []; S < p.length; S++) f.push(la(p[S]))
              return (
                `findAllNodes was able to match part of the selector:
  ` +
                (C.join(' > ') +
                  `

No matching component was found for:
  `) +
                f.join(' > ')
              )
            }
            return null
          }),
          (t.getPublicRootInstance = function (f) {
            if (((f = f.current), !f.child)) return null
            switch (f.child.tag) {
              case 5:
                return J(f.child.stateNode)
              default:
                return f.child.stateNode
            }
          }),
          (t.injectIntoDevTools = function (f) {
            if (
              ((f = {
                bundleType: f.bundleType,
                version: f.version,
                rendererPackageName: f.rendererPackageName,
                rendererConfig: f.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: a.ReactCurrentDispatcher,
                findHostInstanceByFiber: yf,
                findFiberByHostInstance: f.findFiberByHostInstance || Pv,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: '18.0.0-fc46dba67-20220329',
              }),
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u')
            )
              f = !1
            else {
              var p = __REACT_DEVTOOLS_GLOBAL_HOOK__
              if (p.isDisabled || !p.supportsFiber) f = !0
              else {
                try {
                  ;(Hc = p.inject(f)), (Gs = p)
                } catch {}
                f = !!p.checkDCE
              }
            }
            return f
          }),
          (t.isAlreadyRendering = function () {
            return !1
          }),
          (t.observeVisibleRects = function (f, p, S, C) {
            if (!at) throw Error(o(363))
            f = To(f, p)
            var I = Ct(f, S, C).disconnect
            return {
              disconnect: function () {
                I()
              },
            }
          }),
          (t.registerMutableSourceForHydration = function (f, p) {
            var S = p._getVersion
            ;(S = S(p._source)),
              f.mutableSourceEagerHydrationData == null
                ? (f.mutableSourceEagerHydrationData = [p, S])
                : f.mutableSourceEagerHydrationData.push(p, S)
          }),
          (t.runWithPriority = function (f, p) {
            var S = yn
            try {
              return (yn = f), p()
            } finally {
              yn = S
            }
          }),
          (t.shouldError = function () {
            return null
          }),
          (t.shouldSuspend = function () {
            return !1
          }),
          (t.updateContainer = function (f, p, S, C) {
            var I = p.current,
              B = An(),
              ae = Ps(I)
            return (
              (S = Av(S)),
              p.context === null ? (p.context = S) : (p.pendingContext = S),
              (p = po(B, ae)),
              (p.payload = { element: f }),
              (C = C === void 0 ? null : C),
              C !== null && (p.callback = C),
              ea(I, p),
              (f = er(I, ae, B)),
              f !== null && Dd(f, I, ae),
              ae
            )
          }),
          t
        )
      })),
    mw
  )
}
var f2
function NG() {
  return f2 || ((f2 = 1), (fw.exports = LG())), fw.exports
}
var DG = NG()
const OG = Bx(DG)
var gw = { exports: {} },
  vw = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var h2
function kG() {
  return (
    h2 ||
      ((h2 = 1),
      (function (n) {
        function e(V, Y) {
          var Q = V.length
          V.push(Y)
          e: for (; 0 < Q; ) {
            var q = (Q - 1) >>> 1,
              oe = V[q]
            if (0 < r(oe, Y)) (V[q] = Y), (V[Q] = oe), (Q = q)
            else break e
          }
        }
        function t(V) {
          return V.length === 0 ? null : V[0]
        }
        function i(V) {
          if (V.length === 0) return null
          var Y = V[0],
            Q = V.pop()
          if (Q !== Y) {
            V[0] = Q
            e: for (var q = 0, oe = V.length, _e = oe >>> 1; q < _e; ) {
              var he = 2 * (q + 1) - 1,
                Ce = V[he],
                Te = he + 1,
                Pe = V[Te]
              if (0 > r(Ce, Q))
                Te < oe && 0 > r(Pe, Ce)
                  ? ((V[q] = Pe), (V[Te] = Q), (q = Te))
                  : ((V[q] = Ce), (V[he] = Q), (q = he))
              else if (Te < oe && 0 > r(Pe, Q))
                (V[q] = Pe), (V[Te] = Q), (q = Te)
              else break e
            }
          }
          return Y
        }
        function r(V, Y) {
          var Q = V.sortIndex - Y.sortIndex
          return Q !== 0 ? Q : V.id - Y.id
        }
        if (
          typeof performance == 'object' &&
          typeof performance.now == 'function'
        ) {
          var s = performance
          n.unstable_now = function () {
            return s.now()
          }
        } else {
          var o = Date,
            a = o.now()
          n.unstable_now = function () {
            return o.now() - a
          }
        }
        var c = [],
          u = [],
          h = 1,
          m = null,
          g = 3,
          y = !1,
          _ = !1,
          M = !1,
          w = typeof setTimeout == 'function' ? setTimeout : null,
          x = typeof clearTimeout == 'function' ? clearTimeout : null,
          T = typeof setImmediate < 'u' ? setImmediate : null
        typeof navigator < 'u' &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling)
        function A(V) {
          for (var Y = t(u); Y !== null; ) {
            if (Y.callback === null) i(u)
            else if (Y.startTime <= V)
              i(u), (Y.sortIndex = Y.expirationTime), e(c, Y)
            else break
            Y = t(u)
          }
        }
        function P(V) {
          if (((M = !1), A(V), !_))
            if (t(c) !== null) (_ = !0), J(D)
            else {
              var Y = t(u)
              Y !== null && ne(P, Y.startTime - V)
            }
        }
        function D(V, Y) {
          ;(_ = !1), M && ((M = !1), x(F), (F = -1)), (y = !0)
          var Q = g
          try {
            for (
              A(Y), m = t(c);
              m !== null && (!(m.expirationTime > Y) || (V && !z()));

            ) {
              var q = m.callback
              if (typeof q == 'function') {
                ;(m.callback = null), (g = m.priorityLevel)
                var oe = q(m.expirationTime <= Y)
                ;(Y = n.unstable_now()),
                  typeof oe == 'function'
                    ? (m.callback = oe)
                    : m === t(c) && i(c),
                  A(Y)
              } else i(c)
              m = t(c)
            }
            if (m !== null) var _e = !0
            else {
              var he = t(u)
              he !== null && ne(P, he.startTime - Y), (_e = !1)
            }
            return _e
          } finally {
            ;(m = null), (g = Q), (y = !1)
          }
        }
        var O = !1,
          U = null,
          F = -1,
          N = 5,
          k = -1
        function z() {
          return !(n.unstable_now() - k < N)
        }
        function $() {
          if (U !== null) {
            var V = n.unstable_now()
            k = V
            var Y = !0
            try {
              Y = U(!0, V)
            } finally {
              Y ? te() : ((O = !1), (U = null))
            }
          } else O = !1
        }
        var te
        if (typeof T == 'function')
          te = function () {
            T($)
          }
        else if (typeof MessageChannel < 'u') {
          var j = new MessageChannel(),
            K = j.port2
          ;(j.port1.onmessage = $),
            (te = function () {
              K.postMessage(null)
            })
        } else
          te = function () {
            w($, 0)
          }
        function J(V) {
          ;(U = V), O || ((O = !0), te())
        }
        function ne(V, Y) {
          F = w(function () {
            V(n.unstable_now())
          }, Y)
        }
        ;(n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (V) {
            V.callback = null
          }),
          (n.unstable_continueExecution = function () {
            _ || y || ((_ = !0), J(D))
          }),
          (n.unstable_forceFrameRate = function (V) {
            0 > V || 125 < V
              ? console.error(
                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported',
                )
              : (N = 0 < V ? Math.floor(1e3 / V) : 5)
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return g
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(c)
          }),
          (n.unstable_next = function (V) {
            switch (g) {
              case 1:
              case 2:
              case 3:
                var Y = 3
                break
              default:
                Y = g
            }
            var Q = g
            g = Y
            try {
              return V()
            } finally {
              g = Q
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (V, Y) {
            switch (V) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break
              default:
                V = 3
            }
            var Q = g
            g = V
            try {
              return Y()
            } finally {
              g = Q
            }
          }),
          (n.unstable_scheduleCallback = function (V, Y, Q) {
            var q = n.unstable_now()
            switch (
              (typeof Q == 'object' && Q !== null
                ? ((Q = Q.delay),
                  (Q = typeof Q == 'number' && 0 < Q ? q + Q : q))
                : (Q = q),
              V)
            ) {
              case 1:
                var oe = -1
                break
              case 2:
                oe = 250
                break
              case 5:
                oe = 1073741823
                break
              case 4:
                oe = 1e4
                break
              default:
                oe = 5e3
            }
            return (
              (oe = Q + oe),
              (V = {
                id: h++,
                callback: Y,
                priorityLevel: V,
                startTime: Q,
                expirationTime: oe,
                sortIndex: -1,
              }),
              Q > q
                ? ((V.sortIndex = Q),
                  e(u, V),
                  t(c) === null &&
                    V === t(u) &&
                    (M ? (x(F), (F = -1)) : (M = !0), ne(P, Q - q)))
                : ((V.sortIndex = oe), e(c, V), _ || y || ((_ = !0), J(D))),
              V
            )
          }),
          (n.unstable_shouldYield = z),
          (n.unstable_wrapCallback = function (V) {
            var Y = g
            return function () {
              var Q = g
              g = Y
              try {
                return V.apply(this, arguments)
              } finally {
                g = Q
              }
            }
          })
      })(vw)),
    vw
  )
}
var p2
function FG() {
  return p2 || ((p2 = 1), (gw.exports = kG())), gw.exports
}
var m2 = FG()
const BE = {},
  BN = (n) => void Object.assign(BE, n)
function UG(n, e) {
  function t(h, { args: m = [], attach: g, ...y }, _) {
    let M = `${h[0].toUpperCase()}${h.slice(1)}`,
      w
    if (h === 'primitive') {
      if (y.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!")
      const x = y.object
      w = Wf(x, { type: h, root: _, attach: g, primitive: !0 })
    } else {
      const x = BE[M]
      if (!x)
        throw new Error(
          `R3F: ${M} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`,
        )
      if (!Array.isArray(m))
        throw new Error('R3F: The args prop must be an array!')
      w = Wf(new x(...m), {
        type: h,
        root: _,
        attach: g,
        memoizedProps: { args: m },
      })
    }
    return (
      w.__r3f.attach === void 0 &&
        (w.isBufferGeometry
          ? (w.__r3f.attach = 'geometry')
          : w.isMaterial && (w.__r3f.attach = 'material')),
      M !== 'inject' && _w(w, y),
      w
    )
  }
  function i(h, m) {
    let g = !1
    if (m) {
      var y, _
      ;(y = m.__r3f) != null && y.attach
        ? xw(h, m, m.__r3f.attach)
        : m.isObject3D && h.isObject3D && (h.add(m), (g = !0)),
        g || (_ = h.__r3f) == null || _.objects.push(m),
        m.__r3f || Wf(m, {}),
        (m.__r3f.parent = h),
        YS(m),
        $f(m)
    }
  }
  function r(h, m, g) {
    let y = !1
    if (m) {
      var _, M
      if ((_ = m.__r3f) != null && _.attach) xw(h, m, m.__r3f.attach)
      else if (m.isObject3D && h.isObject3D) {
        ;(m.parent = h),
          m.dispatchEvent({ type: 'added' }),
          h.dispatchEvent({ type: 'childadded', child: m })
        const w = h.children.filter((T) => T !== m),
          x = w.indexOf(g)
        ;(h.children = [...w.slice(0, x), m, ...w.slice(x)]), (y = !0)
      }
      y || (M = h.__r3f) == null || M.objects.push(m),
        m.__r3f || Wf(m, {}),
        (m.__r3f.parent = h),
        YS(m),
        $f(m)
    }
  }
  function s(h, m, g = !1) {
    h && [...h].forEach((y) => o(m, y, g))
  }
  function o(h, m, g) {
    if (m) {
      var y, _, M
      if (
        (m.__r3f && (m.__r3f.parent = null),
        (y = h.__r3f) != null &&
          y.objects &&
          (h.__r3f.objects = h.__r3f.objects.filter((P) => P !== m)),
        (_ = m.__r3f) != null && _.attach)
      )
        _2(h, m, m.__r3f.attach)
      else if (m.isObject3D && h.isObject3D) {
        var w
        h.remove(m), (w = m.__r3f) != null && w.root && WG(wy(m), m)
      }
      const T = (M = m.__r3f) == null ? void 0 : M.primitive,
        A = !T && (g === void 0 ? m.dispose !== null : g)
      if (!T) {
        var x
        s((x = m.__r3f) == null ? void 0 : x.objects, m, A), s(m.children, m, A)
      }
      if ((delete m.__r3f, A && m.dispose && m.type !== 'Scene')) {
        const P = () => {
          try {
            m.dispose()
          } catch {}
        }
        typeof IS_REACT_ACT_ENVIRONMENT > 'u'
          ? m2.unstable_scheduleCallback(m2.unstable_IdlePriority, P)
          : P()
      }
      $f(h)
    }
  }
  function a(h, m, g, y) {
    var _
    const M = (_ = h.__r3f) == null ? void 0 : _.parent
    if (!M) return
    const w = t(m, g, h.__r3f.root)
    if (h.children) {
      for (const x of h.children) x.__r3f && i(w, x)
      h.children = h.children.filter((x) => !x.__r3f)
    }
    h.__r3f.objects.forEach((x) => i(w, x)),
      (h.__r3f.objects = []),
      h.__r3f.autoRemovedBeforeAppend || o(M, h),
      w.parent && (w.__r3f.autoRemovedBeforeAppend = !0),
      i(M, w),
      w.raycast &&
        w.__r3f.eventCount &&
        wy(w).getState().internal.interaction.push(w),
      [y, y.alternate].forEach((x) => {
        x !== null &&
          ((x.stateNode = w),
          x.ref &&
            (typeof x.ref == 'function' ? x.ref(w) : (x.ref.current = w)))
      })
  }
  const c = () => {}
  return {
    reconciler: OG({
      createInstance: t,
      removeChild: o,
      appendChild: i,
      appendInitialChild: i,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, m) => {
        if (!m) return
        const g = h.getState().scene
        g.__r3f && ((g.__r3f.root = h), i(g, m))
      },
      removeChildFromContainer: (h, m) => {
        m && o(h.getState().scene, m)
      },
      insertInContainerBefore: (h, m, g) => {
        if (!m || !g) return
        const y = h.getState().scene
        y.__r3f && r(y, m, g)
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var m
        return !!((m = h == null ? void 0 : h.__r3f) != null ? m : {}).handlers
      },
      prepareUpdate(h, m, g, y) {
        var _
        if (
          ((_ = h == null ? void 0 : h.__r3f) != null ? _ : {}).primitive &&
          y.object &&
          y.object !== h
        )
          return [!0]
        {
          const { args: w = [], children: x, ...T } = y,
            { args: A = [], children: P, ...D } = g
          if (!Array.isArray(w))
            throw new Error('R3F: the args prop must be an array!')
          if (w.some((U, F) => U !== A[F])) return [!0]
          const O = $N(h, T, D, !0)
          return O.changes.length ? [!1, O] : null
        }
      },
      commitUpdate(h, [m, g], y, _, M, w) {
        m ? a(h, y, M, w) : _w(h, g)
      },
      commitMount(h, m, g, y) {
        var _
        const M = (_ = h.__r3f) != null ? _ : {}
        h.raycast &&
          M.handlers &&
          M.eventCount &&
          wy(h).getState().internal.interaction.push(h)
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => Wf(h.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var m
        const { attach: g, parent: y } = (m = h.__r3f) != null ? m : {}
        g && y && _2(y, h, g), h.isObject3D && (h.visible = !1), $f(h)
      },
      unhideInstance(h, m) {
        var g
        const { attach: y, parent: _ } = (g = h.__r3f) != null ? g : {}
        y && _ && xw(_, h, y),
          ((h.isObject3D && m.visible == null) || m.visible) &&
            (h.visible = !0),
          $f(h)
      },
      createTextInstance: c,
      hideTextInstance: c,
      unhideTextInstance: c,
      getCurrentEventPriority: () => e(),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < 'u' && ei.fun(performance.now)
          ? performance.now
          : ei.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: ei.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: ei.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: _w,
  }
}
var g2, v2
const yw = (n) => 'colorSpace' in n || 'outputColorSpace' in n,
  zN = () => {
    var n
    return (n = BE.ColorManagement) != null ? n : null
  },
  VN = (n) => n && n.isOrthographicCamera,
  BG = (n) => n && n.hasOwnProperty('current'),
  zg =
    typeof window < 'u' &&
    (((g2 = window.document) != null && g2.createElement) ||
      ((v2 = window.navigator) == null ? void 0 : v2.product) === 'ReactNative')
      ? X.useLayoutEffect
      : X.useEffect
function jN(n) {
  const e = X.useRef(n)
  return zg(() => void (e.current = n), [n]), e
}
function zG({ set: n }) {
  return zg(() => (n(new Promise(() => null)), () => n(!1)), [n]), null
}
class HN extends X.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 })
  }
  componentDidCatch(e) {
    this.props.set(e)
  }
  render() {
    return this.state.error ? null : this.props.children
  }
}
HN.getDerivedStateFromError = () => ({ error: !0 })
const GN = '__default',
  y2 = new Map(),
  VG = (n) => n && !!n.memoized && !!n.changes
function WN(n) {
  var e
  const t =
    typeof window < 'u' ? ((e = window.devicePixelRatio) != null ? e : 2) : 1
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n
}
const $p = (n) => {
  var e
  return (e = n.__r3f) == null ? void 0 : e.root.getState()
}
function wy(n) {
  let e = n.__r3f.root
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot
  return e
}
const ei = {
  obj: (n) => n === Object(n) && !ei.arr(n) && typeof n != 'function',
  fun: (n) => typeof n == 'function',
  str: (n) => typeof n == 'string',
  num: (n) => typeof n == 'number',
  boo: (n) => typeof n == 'boolean',
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = 'shallow', objects: i = 'reference', strict: r = !0 } = {},
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1
    if (ei.str(n) || ei.num(n) || ei.boo(n)) return n === e
    const s = ei.obj(n)
    if (s && i === 'reference') return n === e
    const o = ei.arr(n)
    if (o && t === 'reference') return n === e
    if ((o || s) && n === e) return !0
    let a
    for (a in n) if (!(a in e)) return !1
    if (s && t === 'shallow' && i === 'shallow') {
      for (a in r ? e : n)
        if (!ei.equ(n[a], e[a], { strict: r, objects: 'reference' })) return !1
    } else for (a in r ? e : n) if (n[a] !== e[a]) return !1
    if (ei.und(a)) {
      if (
        (o && n.length === 0 && e.length === 0) ||
        (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0
      if (n !== e) return !1
    }
    return !0
  },
}
function jG(n) {
  const e = { nodes: {}, materials: {} }
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material)
      }),
    e
  )
}
function HG(n) {
  n.dispose && n.type !== 'Scene' && n.dispose()
  for (const e in n) e.dispose == null || e.dispose(), delete n[e]
}
function Wf(n, e) {
  const t = n
  return (
    (t.__r3f = {
      type: '',
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  )
}
function qS(n, e) {
  let t = n
  if (e.includes('-')) {
    const i = e.split('-'),
      r = i.pop()
    return (t = i.reduce((s, o) => s[o], n)), { target: t, key: r }
  } else return { target: t, key: e }
}
const x2 = /-\d+$/
function xw(n, e, t) {
  if (ei.str(t)) {
    if (x2.test(t)) {
      const s = t.replace(x2, ''),
        { target: o, key: a } = qS(n, s)
      Array.isArray(o[a]) || (o[a] = [])
    }
    const { target: i, key: r } = qS(n, t)
    ;(e.__r3f.previousAttach = i[r]), (i[r] = e)
  } else e.__r3f.previousAttach = t(n, e)
}
function _2(n, e, t) {
  var i, r
  if (ei.str(t)) {
    const { target: s, key: o } = qS(n, t),
      a = e.__r3f.previousAttach
    a === void 0 ? delete s[o] : (s[o] = a)
  } else
    (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e)
  ;(r = e.__r3f) == null || delete r.previousAttach
}
function $N(
  n,
  { children: e, key: t, ref: i, ...r },
  { children: s, key: o, ref: a, ...c } = {},
  u = !1,
) {
  const h = n.__r3f,
    m = Object.entries(r),
    g = []
  if (u) {
    const _ = Object.keys(c)
    for (let M = 0; M < _.length; M++)
      r.hasOwnProperty(_[M]) || m.unshift([_[M], GN + 'remove'])
  }
  m.forEach(([_, M]) => {
    var w
    if (
      ((w = n.__r3f) != null && w.primitive && _ === 'object') ||
      ei.equ(M, c[_])
    )
      return
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(_))
      return g.push([_, M, !0, []])
    let x = []
    _.includes('-') && (x = _.split('-')), g.push([_, M, !1, x])
    for (const T in r) {
      const A = r[T]
      T.startsWith(`${_}-`) && g.push([T, A, !1, T.split('-')])
    }
  })
  const y = { ...r }
  return (
    h != null &&
      h.memoizedProps &&
      h != null &&
      h.memoizedProps.args &&
      (y.args = h.memoizedProps.args),
    h != null &&
      h.memoizedProps &&
      h != null &&
      h.memoizedProps.attach &&
      (y.attach = h.memoizedProps.attach),
    { memoized: y, changes: g }
  )
}
function _w(n, e) {
  var t
  const i = n.__r3f,
    r = i == null ? void 0 : i.root,
    s = r == null || r.getState == null ? void 0 : r.getState(),
    { memoized: o, changes: a } = VG(e) ? e : $N(n, e),
    c = i == null ? void 0 : i.eventCount
  n.__r3f && (n.__r3f.memoizedProps = o)
  for (let g = 0; g < a.length; g++) {
    let [y, _, M, w] = a[g]
    if (yw(n)) {
      const P = 'srgb',
        D = 'srgb-linear'
      y === 'encoding'
        ? ((y = 'colorSpace'), (_ = _ === 3001 ? P : D))
        : y === 'outputEncoding' &&
          ((y = 'outputColorSpace'), (_ = _ === 3001 ? P : D))
    }
    let x = n,
      T = x[y]
    if (w.length && ((T = w.reduce((A, P) => A[P], n)), !(T && T.set))) {
      const [A, ...P] = w.reverse()
      ;(x = P.reverse().reduce((D, O) => D[O], n)), (y = A)
    }
    if (_ === GN + 'remove')
      if (x.constructor) {
        let A = y2.get(x.constructor)
        A || ((A = new x.constructor()), y2.set(x.constructor, A)), (_ = A[y])
      } else _ = 0
    if (M && i)
      _ ? (i.handlers[y] = _) : delete i.handlers[y],
        (i.eventCount = Object.keys(i.handlers).length)
    else if (T && T.set && (T.copy || T instanceof cd)) {
      if (Array.isArray(_)) T.fromArray ? T.fromArray(_) : T.set(..._)
      else if (T.copy && _ && _.constructor && T.constructor === _.constructor)
        T.copy(_)
      else if (_ !== void 0) {
        var u
        const A = (u = T) == null ? void 0 : u.isColor
        !A && T.setScalar
          ? T.setScalar(_)
          : T instanceof cd && _ instanceof cd
          ? (T.mask = _.mask)
          : T.set(_),
          !zN() && s && !s.linear && A && T.convertSRGBToLinear()
      }
    } else {
      var h
      if (
        ((x[y] = _),
        (h = x[y]) != null &&
          h.isTexture &&
          x[y].format === Ii &&
          x[y].type === _s &&
          s)
      ) {
        const A = x[y]
        yw(A) && yw(s.gl)
          ? (A.colorSpace = s.gl.outputColorSpace)
          : (A.encoding = s.gl.outputEncoding)
      }
    }
    $f(n)
  }
  if (i && i.parent && n.raycast && c !== i.eventCount) {
    const g = wy(n).getState().internal,
      y = g.interaction.indexOf(n)
    y > -1 && g.interaction.splice(y, 1), i.eventCount && g.interaction.push(n)
  }
  return (
    !(a.length === 1 && a[0][0] === 'onUpdate') &&
      a.length &&
      (t = n.__r3f) != null &&
      t.parent &&
      YS(n),
    n
  )
}
function $f(n) {
  var e, t
  const i =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState()
  i && i.internal.frames === 0 && i.invalidate()
}
function YS(n) {
  n.onUpdate == null || n.onUpdate(n)
}
function XN(n, e) {
  n.manual ||
    (VN(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld())
}
function H0(n) {
  return (n.eventObject || n.object).uuid + '/' + n.index + n.instanceId
}
function GG() {
  var n
  const e = (typeof self < 'u' && self) || (typeof window < 'u' && window)
  if (!e) return om.DefaultEventPriority
  switch ((n = e.event) == null ? void 0 : n.type) {
    case 'click':
    case 'contextmenu':
    case 'dblclick':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointerup':
      return om.DiscreteEventPriority
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'pointerenter':
    case 'pointerleave':
    case 'wheel':
      return om.ContinuousEventPriority
    default:
      return om.DefaultEventPriority
  }
}
function qN(n, e, t, i) {
  const r = t.get(e)
  r &&
    (t.delete(e),
    t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)))
}
function WG(n, e) {
  const { internal: t } = n.getState()
  ;(t.interaction = t.interaction.filter((i) => i !== e)),
    (t.initialHits = t.initialHits.filter((i) => i !== e)),
    t.hovered.forEach((i, r) => {
      ;(i.eventObject === e || i.object === e) && t.hovered.delete(r)
    }),
    t.capturedMap.forEach((i, r) => {
      qN(t.capturedMap, e, i, r)
    })
}
function $G(n) {
  function e(c) {
    const { internal: u } = n.getState(),
      h = c.offsetX - u.initialClick[0],
      m = c.offsetY - u.initialClick[1]
    return Math.round(Math.sqrt(h * h + m * m))
  }
  function t(c) {
    return c.filter((u) =>
      ['Move', 'Over', 'Enter', 'Out', 'Leave'].some((h) => {
        var m
        return (m = u.__r3f) == null ? void 0 : m.handlers['onPointer' + h]
      }),
    )
  }
  function i(c, u) {
    const h = n.getState(),
      m = new Set(),
      g = [],
      y = u ? u(h.internal.interaction) : h.internal.interaction
    for (let x = 0; x < y.length; x++) {
      const T = $p(y[x])
      T && (T.raycaster.camera = void 0)
    }
    h.previousRoot || h.events.compute == null || h.events.compute(c, h)
    function _(x) {
      const T = $p(x)
      if (!T || !T.events.enabled || T.raycaster.camera === null) return []
      if (T.raycaster.camera === void 0) {
        var A
        T.events.compute == null ||
          T.events.compute(
            c,
            T,
            (A = T.previousRoot) == null ? void 0 : A.getState(),
          ),
          T.raycaster.camera === void 0 && (T.raycaster.camera = null)
      }
      return T.raycaster.camera ? T.raycaster.intersectObject(x, !0) : []
    }
    let M = y
      .flatMap(_)
      .sort((x, T) => {
        const A = $p(x.object),
          P = $p(T.object)
        return !A || !P
          ? x.distance - T.distance
          : P.events.priority - A.events.priority || x.distance - T.distance
      })
      .filter((x) => {
        const T = H0(x)
        return m.has(T) ? !1 : (m.add(T), !0)
      })
    h.events.filter && (M = h.events.filter(M, h))
    for (const x of M) {
      let T = x.object
      for (; T; ) {
        var w
        ;(w = T.__r3f) != null &&
          w.eventCount &&
          g.push({ ...x, eventObject: T }),
          (T = T.parent)
      }
    }
    if ('pointerId' in c && h.internal.capturedMap.has(c.pointerId))
      for (let x of h.internal.capturedMap.get(c.pointerId).values())
        m.has(H0(x.intersection)) || g.push(x.intersection)
    return g
  }
  function r(c, u, h, m) {
    const g = n.getState()
    if (c.length) {
      const y = { stopped: !1 }
      for (const _ of c) {
        const M = $p(_.object) || g,
          { raycaster: w, pointer: x, camera: T, internal: A } = M,
          P = new re(x.x, x.y, 0).unproject(T),
          D = (k) => {
            var z, $
            return (z =
              ($ = A.capturedMap.get(k)) == null
                ? void 0
                : $.has(_.eventObject)) != null
              ? z
              : !1
          },
          O = (k) => {
            const z = { intersection: _, target: u.target }
            A.capturedMap.has(k)
              ? A.capturedMap.get(k).set(_.eventObject, z)
              : A.capturedMap.set(k, new Map([[_.eventObject, z]])),
              u.target.setPointerCapture(k)
          },
          U = (k) => {
            const z = A.capturedMap.get(k)
            z && qN(A.capturedMap, _.eventObject, z, k)
          }
        let F = {}
        for (let k in u) {
          let z = u[k]
          typeof z != 'function' && (F[k] = z)
        }
        let N = {
          ..._,
          ...F,
          pointer: x,
          intersections: c,
          stopped: y.stopped,
          delta: h,
          unprojectedPoint: P,
          ray: w.ray,
          camera: T,
          stopPropagation() {
            const k = 'pointerId' in u && A.capturedMap.get(u.pointerId)
            if (
              (!k || k.has(_.eventObject)) &&
              ((N.stopped = y.stopped = !0),
              A.hovered.size &&
                Array.from(A.hovered.values()).find(
                  (z) => z.eventObject === _.eventObject,
                ))
            ) {
              const z = c.slice(0, c.indexOf(_))
              s([...z, _])
            }
          },
          target: {
            hasPointerCapture: D,
            setPointerCapture: O,
            releasePointerCapture: U,
          },
          currentTarget: {
            hasPointerCapture: D,
            setPointerCapture: O,
            releasePointerCapture: U,
          },
          nativeEvent: u,
        }
        if ((m(N), y.stopped === !0)) break
      }
    }
    return c
  }
  function s(c) {
    const { internal: u } = n.getState()
    for (const h of u.hovered.values())
      if (
        !c.length ||
        !c.find(
          (m) =>
            m.object === h.object &&
            m.index === h.index &&
            m.instanceId === h.instanceId,
        )
      ) {
        const g = h.eventObject.__r3f,
          y = g == null ? void 0 : g.handlers
        if ((u.hovered.delete(H0(h)), g != null && g.eventCount)) {
          const _ = { ...h, intersections: c }
          y.onPointerOut == null || y.onPointerOut(_),
            y.onPointerLeave == null || y.onPointerLeave(_)
        }
      }
  }
  function o(c, u) {
    for (let h = 0; h < u.length; h++) {
      const m = u[h].__r3f
      m == null ||
        m.handlers.onPointerMissed == null ||
        m.handlers.onPointerMissed(c)
    }
  }
  function a(c) {
    switch (c) {
      case 'onPointerLeave':
      case 'onPointerCancel':
        return () => s([])
      case 'onLostPointerCapture':
        return (u) => {
          const { internal: h } = n.getState()
          'pointerId' in u &&
            h.capturedMap.has(u.pointerId) &&
            requestAnimationFrame(() => {
              h.capturedMap.has(u.pointerId) &&
                (h.capturedMap.delete(u.pointerId), s([]))
            })
        }
    }
    return function (h) {
      const { onPointerMissed: m, internal: g } = n.getState()
      g.lastEvent.current = h
      const y = c === 'onPointerMove',
        _ = c === 'onClick' || c === 'onContextMenu' || c === 'onDoubleClick',
        w = i(h, y ? t : void 0),
        x = _ ? e(h) : 0
      c === 'onPointerDown' &&
        ((g.initialClick = [h.offsetX, h.offsetY]),
        (g.initialHits = w.map((A) => A.eventObject))),
        _ && !w.length && x <= 2 && (o(h, g.interaction), m && m(h)),
        y && s(w)
      function T(A) {
        const P = A.eventObject,
          D = P.__r3f,
          O = D == null ? void 0 : D.handlers
        if (D != null && D.eventCount)
          if (y) {
            if (
              O.onPointerOver ||
              O.onPointerEnter ||
              O.onPointerOut ||
              O.onPointerLeave
            ) {
              const U = H0(A),
                F = g.hovered.get(U)
              F
                ? F.stopped && A.stopPropagation()
                : (g.hovered.set(U, A),
                  O.onPointerOver == null || O.onPointerOver(A),
                  O.onPointerEnter == null || O.onPointerEnter(A))
            }
            O.onPointerMove == null || O.onPointerMove(A)
          } else {
            const U = O[c]
            U
              ? (!_ || g.initialHits.includes(P)) &&
                (o(
                  h,
                  g.interaction.filter((F) => !g.initialHits.includes(F)),
                ),
                U(A))
              : _ &&
                g.initialHits.includes(P) &&
                o(
                  h,
                  g.interaction.filter((F) => !g.initialHits.includes(F)),
                )
          }
      }
      r(w, h, x, T)
    }
  }
  return { handlePointer: a }
}
const XG = [
    'set',
    'get',
    'setSize',
    'setFrameloop',
    'setDpr',
    'events',
    'invalidate',
    'advance',
    'size',
    'viewport',
  ],
  YN = (n) => !!(n != null && n.render),
  zE = X.createContext(null),
  qG = (n, e) => {
    const t = kN((a, c) => {
        const u = new re(),
          h = new re(),
          m = new re()
        function g(x = c().camera, T = h, A = c().size) {
          const { width: P, height: D, top: O, left: U } = A,
            F = P / D
          T.isVector3 ? m.copy(T) : m.set(...T)
          const N = x.getWorldPosition(u).distanceTo(m)
          if (VN(x))
            return {
              width: P / x.zoom,
              height: D / x.zoom,
              top: O,
              left: U,
              factor: 1,
              distance: N,
              aspect: F,
            }
          {
            const k = (x.fov * Math.PI) / 180,
              z = 2 * Math.tan(k / 2) * N,
              $ = z * (P / D)
            return {
              width: $,
              height: z,
              top: O,
              left: U,
              factor: P / $,
              distance: N,
              aspect: F,
            }
          }
        }
        let y
        const _ = (x) =>
            a((T) => ({ performance: { ...T.performance, current: x } })),
          M = new qe()
        return {
          set: a,
          get: c,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (x = 1) => n(c(), x),
          advance: (x, T) => e(x, T, c()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new IE(),
          pointer: M,
          mouse: M,
          frameloop: 'always',
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const x = c()
              y && clearTimeout(y),
                x.performance.current !== x.performance.min &&
                  _(x.performance.min),
                (y = setTimeout(
                  () => _(c().performance.max),
                  x.performance.debounce,
                ))
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: g,
          },
          setEvents: (x) => a((T) => ({ ...T, events: { ...T.events, ...x } })),
          setSize: (x, T, A, P, D) => {
            const O = c().camera,
              U = {
                width: x,
                height: T,
                top: P || 0,
                left: D || 0,
                updateStyle: A,
              }
            a((F) => ({ size: U, viewport: { ...F.viewport, ...g(O, h, U) } }))
          },
          setDpr: (x) =>
            a((T) => {
              const A = WN(x)
              return {
                viewport: {
                  ...T.viewport,
                  dpr: A,
                  initialDpr: T.viewport.initialDpr || A,
                },
              }
            }),
          setFrameloop: (x = 'always') => {
            const T = c().clock
            T.stop(),
              (T.elapsedTime = 0),
              x !== 'never' && (T.start(), (T.elapsedTime = 0)),
              a(() => ({ frameloop: x }))
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: X.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (x, T, A) => {
              const P = c().internal
              return (
                (P.priority = P.priority + (T > 0 ? 1 : 0)),
                P.subscribers.push({ ref: x, priority: T, store: A }),
                (P.subscribers = P.subscribers.sort(
                  (D, O) => D.priority - O.priority,
                )),
                () => {
                  const D = c().internal
                  D != null &&
                    D.subscribers &&
                    ((D.priority = D.priority - (T > 0 ? 1 : 0)),
                    (D.subscribers = D.subscribers.filter((O) => O.ref !== x)))
                }
              )
            },
          },
        }
      }),
      i = t.getState()
    let r = i.size,
      s = i.viewport.dpr,
      o = i.camera
    return (
      t.subscribe(() => {
        const { camera: a, size: c, viewport: u, gl: h, set: m } = t.getState()
        if (c.width !== r.width || c.height !== r.height || u.dpr !== s) {
          var g
          ;(r = c), (s = u.dpr), XN(a, c), h.setPixelRatio(u.dpr)
          const y =
            (g = c.updateStyle) != null
              ? g
              : typeof HTMLCanvasElement < 'u' &&
                h.domElement instanceof HTMLCanvasElement
          h.setSize(c.width, c.height, y)
        }
        a !== o &&
          ((o = a),
          m((y) => ({
            viewport: { ...y.viewport, ...y.viewport.getCurrentViewport(a) },
          })))
      }),
      t.subscribe((a) => n(a)),
      t
    )
  }
function YG(n, e) {
  const t = { callback: n }
  return e.add(t), () => void e.delete(t)
}
let G0,
  ZN = new Set(),
  ZG = new Set(),
  KG = new Set()
const QG = (n) => YG(n, ZN)
function ww(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e)
}
function Xp(n, e) {
  switch (n) {
    case 'before':
      return ww(ZN, e)
    case 'after':
      return ww(ZG, e)
    case 'tail':
      return ww(KG, e)
  }
}
let Sw, Mw
function Ew(n, e, t) {
  let i = e.clock.getDelta()
  for (
    e.frameloop === 'never' &&
      typeof n == 'number' &&
      ((i = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      Sw = e.internal.subscribers,
      G0 = 0;
    G0 < Sw.length;
    G0++
  )
    (Mw = Sw[G0]), Mw.ref.current(Mw.store.getState(), i, t)
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === 'always' ? 1 : e.internal.frames
  )
}
function JG(n) {
  let e = !1,
    t = !1,
    i,
    r,
    s
  function o(u) {
    ;(r = requestAnimationFrame(o)),
      (e = !0),
      (i = 0),
      Xp('before', u),
      (t = !0)
    for (const m of n.values()) {
      var h
      ;(s = m.store.getState()),
        s.internal.active &&
          (s.frameloop === 'always' || s.internal.frames > 0) &&
          !((h = s.gl.xr) != null && h.isPresenting) &&
          (i += Ew(u, s))
    }
    if (((t = !1), Xp('after', u), i === 0))
      return Xp('tail', u), (e = !1), cancelAnimationFrame(r)
  }
  function a(u, h = 1) {
    var m
    if (!u) return n.forEach((g) => a(g.store.getState(), h))
    ;((m = u.gl.xr) != null && m.isPresenting) ||
      !u.internal.active ||
      u.frameloop === 'never' ||
      (h > 1
        ? (u.internal.frames = Math.min(60, u.internal.frames + h))
        : t
        ? (u.internal.frames = 2)
        : (u.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(o)))
  }
  function c(u, h = !0, m, g) {
    if ((h && Xp('before', u), m)) Ew(u, m, g)
    else for (const y of n.values()) Ew(u, y.store.getState())
    h && Xp('after', u)
  }
  return { loop: o, invalidate: a, advance: c }
}
function VE() {
  const n = X.useContext(zE)
  if (!n)
    throw new Error('R3F: Hooks can only be used within the Canvas component!')
  return n
}
function yh(n = (t) => t, e) {
  return VE()(n, e)
}
function Vg(n, e = 0) {
  const t = VE(),
    i = t.getState().internal.subscribe,
    r = jN(n)
  return zg(() => i(r, e, t), [e, i, t]), null
}
const w2 = new WeakMap()
function KN(n, e) {
  return function (t, ...i) {
    let r = w2.get(t)
    return (
      r || ((r = new t()), w2.set(t, r)),
      n && n(r),
      Promise.all(
        i.map(
          (s) =>
            new Promise((o, a) =>
              r.load(
                s,
                (c) => {
                  c.scene && Object.assign(c, jG(c.scene)), o(c)
                },
                e,
                (c) =>
                  a(
                    new Error(
                      `Could not load ${s}: ${c == null ? void 0 : c.message}`,
                    ),
                  ),
              ),
            ),
        ),
      )
    )
  }
}
function xh(n, e, t, i) {
  const r = Array.isArray(e) ? e : [e],
    s = AG(KN(t, i), [n, ...r], { equal: ei.equ })
  return Array.isArray(e) ? s : s[0]
}
xh.preload = function (n, e, t) {
  const i = Array.isArray(e) ? e : [e]
  return CG(KN(t), [n, ...i])
}
xh.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e]
  return PG([n, ...t])
}
const _h = new Map(),
  { invalidate: S2, advance: M2 } = JG(_h),
  { reconciler: ig, applyProps: ha } = UG(_h, GG),
  Vf = { objects: 'shallow', strict: !1 },
  e9 = (n, e) => {
    const t = typeof n == 'function' ? n(e) : n
    return YN(t)
      ? t
      : new UE({
          powerPreference: 'high-performance',
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        })
  }
function t9(n, e) {
  const t = typeof HTMLCanvasElement < 'u' && n instanceof HTMLCanvasElement
  if (e) {
    const { width: i, height: r, top: s, left: o, updateStyle: a = t } = e
    return { width: i, height: r, top: s, left: o, updateStyle: a }
  } else if (
    typeof HTMLCanvasElement < 'u' &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: i,
      height: r,
      top: s,
      left: o,
    } = n.parentElement.getBoundingClientRect()
    return { width: i, height: r, top: s, left: o, updateStyle: t }
  } else if (typeof OffscreenCanvas < 'u' && n instanceof OffscreenCanvas)
    return { width: n.width, height: n.height, top: 0, left: 0, updateStyle: t }
  return { width: 0, height: 0, top: 0, left: 0 }
}
function n9(n) {
  const e = _h.get(n),
    t = e == null ? void 0 : e.fiber,
    i = e == null ? void 0 : e.store
  e && console.warn('R3F.createRoot should only be called once!')
  const r = typeof reportError == 'function' ? reportError : console.error,
    s = i || qG(S2, M2),
    o =
      t || ig.createContainer(s, om.ConcurrentRoot, null, !1, null, '', r, null)
  e || _h.set(n, { fiber: o, store: s })
  let a,
    c = !1,
    u
  return {
    configure(h = {}) {
      let {
          gl: m,
          size: g,
          scene: y,
          events: _,
          onCreated: M,
          shadows: w = !1,
          linear: x = !1,
          flat: T = !1,
          legacy: A = !1,
          orthographic: P = !1,
          frameloop: D = 'always',
          dpr: O = [1, 2],
          performance: U,
          raycaster: F,
          camera: N,
          onPointerMissed: k,
        } = h,
        z = s.getState(),
        $ = z.gl
      z.gl || z.set({ gl: ($ = e9(m, n)) })
      let te = z.raycaster
      te || z.set({ raycaster: (te = new OE()) })
      const { params: j, ...K } = F || {}
      if (
        (ei.equ(K, te, Vf) || ha(te, { ...K }),
        ei.equ(j, te.params, Vf) || ha(te, { params: { ...te.params, ...j } }),
        !z.camera || (z.camera === u && !ei.equ(u, N, Vf)))
      ) {
        u = N
        const Q = N instanceof Rg,
          q = Q ? N : P ? new Nh(0, 0, 0, 0, 0.1, 1e3) : new sr(75, 0, 0.1, 1e3)
        Q ||
          ((q.position.z = 5),
          N &&
            (ha(q, N),
            ('aspect' in N ||
              'left' in N ||
              'right' in N ||
              'bottom' in N ||
              'top' in N) &&
              ((q.manual = !0), q.updateProjectionMatrix())),
          !z.camera && !(N != null && N.rotation) && q.lookAt(0, 0, 0)),
          z.set({ camera: q }),
          (te.camera = q)
      }
      if (!z.scene) {
        let Q
        y != null && y.isScene ? (Q = y) : ((Q = new Lg()), y && ha(Q, y)),
          z.set({ scene: Wf(Q) })
      }
      if (!z.xr) {
        var J
        const Q = (_e, he) => {
            const Ce = s.getState()
            Ce.frameloop !== 'never' && M2(_e, !0, Ce, he)
          },
          q = () => {
            const _e = s.getState()
            ;(_e.gl.xr.enabled = _e.gl.xr.isPresenting),
              _e.gl.xr.setAnimationLoop(_e.gl.xr.isPresenting ? Q : null),
              _e.gl.xr.isPresenting || S2(_e)
          },
          oe = {
            connect() {
              const _e = s.getState().gl
              _e.xr.addEventListener('sessionstart', q),
                _e.xr.addEventListener('sessionend', q)
            },
            disconnect() {
              const _e = s.getState().gl
              _e.xr.removeEventListener('sessionstart', q),
                _e.xr.removeEventListener('sessionend', q)
            },
          }
        typeof ((J = $.xr) == null ? void 0 : J.addEventListener) ==
          'function' && oe.connect(),
          z.set({ xr: oe })
      }
      if ($.shadowMap) {
        const Q = $.shadowMap.enabled,
          q = $.shadowMap.type
        if ((($.shadowMap.enabled = !!w), ei.boo(w))) $.shadowMap.type = mm
        else if (ei.str(w)) {
          var ne
          const oe = { basic: VI, percentage: jx, soft: mm, variance: Vo }
          $.shadowMap.type = (ne = oe[w]) != null ? ne : mm
        } else ei.obj(w) && Object.assign($.shadowMap, w)
        ;(Q !== $.shadowMap.enabled || q !== $.shadowMap.type) &&
          ($.shadowMap.needsUpdate = !0)
      }
      const V = zN()
      V &&
        ('enabled' in V
          ? (V.enabled = !A)
          : 'legacyMode' in V && (V.legacyMode = A)),
        c ||
          ha($, { outputEncoding: x ? 3e3 : 3001, toneMapping: T ? ya : ZM }),
        z.legacy !== A && z.set(() => ({ legacy: A })),
        z.linear !== x && z.set(() => ({ linear: x })),
        z.flat !== T && z.set(() => ({ flat: T })),
        m && !ei.fun(m) && !YN(m) && !ei.equ(m, $, Vf) && ha($, m),
        _ && !z.events.handlers && z.set({ events: _(s) })
      const Y = t9(n, g)
      return (
        ei.equ(Y, z.size, Vf) ||
          z.setSize(Y.width, Y.height, Y.updateStyle, Y.top, Y.left),
        O && z.viewport.dpr !== WN(O) && z.setDpr(O),
        z.frameloop !== D && z.setFrameloop(D),
        z.onPointerMissed || z.set({ onPointerMissed: k }),
        U &&
          !ei.equ(U, z.performance, Vf) &&
          z.set((Q) => ({ performance: { ...Q.performance, ...U } })),
        (a = M),
        (c = !0),
        this
      )
    },
    render(h) {
      return (
        c || this.configure(),
        ig.updateContainer(
          b.jsx(i9, { store: s, children: h, onCreated: a, rootElement: n }),
          o,
          null,
          () => {},
        ),
        s
      )
    },
    unmount() {
      QN(n)
    },
  }
}
function i9({ store: n, children: e, onCreated: t, rootElement: i }) {
  return (
    zg(() => {
      const r = n.getState()
      r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(r),
        n.getState().events.connected ||
          r.events.connect == null ||
          r.events.connect(i)
    }, []),
    b.jsx(zE.Provider, { value: n, children: e })
  )
}
function QN(n, e) {
  const t = _h.get(n),
    i = t == null ? void 0 : t.fiber
  if (i) {
    const r = t == null ? void 0 : t.store.getState()
    r && (r.internal.active = !1),
      ig.updateContainer(null, i, null, () => {
        r &&
          setTimeout(() => {
            try {
              var s, o, a, c
              r.events.disconnect == null || r.events.disconnect(),
                (s = r.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = r.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (c = r.gl) != null && c.xr && r.xr.disconnect(),
                HG(r),
                _h.delete(n)
            } catch {}
          }, 500)
      })
  }
}
function r9(n, e, t) {
  return b.jsx(s9, { children: n, container: e, state: t }, e.uuid)
}
function s9({ state: n = {}, children: e, container: t }) {
  const { events: i, size: r, ...s } = n,
    o = VE(),
    [a] = X.useState(() => new OE()),
    [c] = X.useState(() => new qe()),
    u = X.useCallback(
      (m, g) => {
        const y = { ...m }
        Object.keys(m).forEach((M) => {
          ;(XG.includes(M) || (m[M] !== g[M] && g[M])) && delete y[M]
        })
        let _
        if (g && r) {
          const M = g.camera
          ;(_ = m.viewport.getCurrentViewport(M, new re(), r)),
            M !== m.camera && XN(M, r)
        }
        return {
          ...y,
          scene: t,
          raycaster: a,
          pointer: c,
          mouse: c,
          previousRoot: o,
          events: { ...m.events, ...(g == null ? void 0 : g.events), ...i },
          size: { ...m.size, ...r },
          viewport: { ...m.viewport, ..._ },
          ...s,
        }
      },
      [n],
    ),
    [h] = X.useState(() => {
      const m = o.getState()
      return kN((y, _) => ({
        ...m,
        scene: t,
        raycaster: a,
        pointer: c,
        mouse: c,
        previousRoot: o,
        events: { ...m.events, ...i },
        size: { ...m.size, ...r },
        ...s,
        set: y,
        get: _,
        setEvents: (M) => y((w) => ({ ...w, events: { ...w.events, ...M } })),
      }))
    })
  return (
    X.useEffect(() => {
      const m = o.subscribe((g) => h.setState((y) => u(g, y)))
      return () => {
        m()
      }
    }, [u]),
    X.useEffect(() => {
      h.setState((m) => u(o.getState(), m))
    }, [u]),
    X.useEffect(
      () => () => {
        h.destroy()
      },
      [],
    ),
    b.jsx(b.Fragment, {
      children: ig.createPortal(
        b.jsx(zE.Provider, { value: h, children: e }),
        h,
        null,
      ),
    })
  )
}
ig.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: '@react-three/fiber',
  version: X.version,
})
const bw = {
  onClick: ['click', !1],
  onContextMenu: ['contextmenu', !1],
  onDoubleClick: ['dblclick', !1],
  onWheel: ['wheel', !0],
  onPointerDown: ['pointerdown', !0],
  onPointerUp: ['pointerup', !0],
  onPointerLeave: ['pointerleave', !0],
  onPointerMove: ['pointermove', !0],
  onPointerCancel: ['pointercancel', !0],
  onLostPointerCapture: ['lostpointercapture', !0],
}
function o9(n) {
  const { handlePointer: e } = $G(n)
  return {
    priority: 1,
    enabled: !0,
    compute(t, i, r) {
      i.pointer.set(
        (t.offsetX / i.size.width) * 2 - 1,
        -(t.offsetY / i.size.height) * 2 + 1,
      ),
        i.raycaster.setFromCamera(i.pointer, i.camera)
    },
    connected: void 0,
    handlers: Object.keys(bw).reduce((t, i) => ({ ...t, [i]: e(i) }), {}),
    update: () => {
      var t
      const { events: i, internal: r } = n.getState()
      ;(t = r.lastEvent) != null &&
        t.current &&
        i.handlers &&
        i.handlers.onPointerMove(r.lastEvent.current)
    },
    connect: (t) => {
      var i
      const { set: r, events: s } = n.getState()
      s.disconnect == null || s.disconnect(),
        r((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
          const [c, u] = bw[o]
          t.addEventListener(c, a, { passive: u })
        })
    },
    disconnect: () => {
      const { set: t, events: i } = n.getState()
      if (i.connected) {
        var r
        Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
          if (i && i.connected instanceof HTMLElement) {
            const [a] = bw[s]
            i.connected.removeEventListener(a, o)
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }))
      }
    },
  }
}
var Tw, E2
function a9() {
  if (E2) return Tw
  E2 = 1
  function n(e, t, i) {
    var r, s, o, a, c
    t == null && (t = 100)
    function u() {
      var m = Date.now() - a
      m < t && m >= 0
        ? (r = setTimeout(u, t - m))
        : ((r = null), i || ((c = e.apply(o, s)), (o = s = null)))
    }
    var h = function () {
      ;(o = this), (s = arguments), (a = Date.now())
      var m = i && !r
      return (
        r || (r = setTimeout(u, t)),
        m && ((c = e.apply(o, s)), (o = s = null)),
        c
      )
    }
    return (
      (h.clear = function () {
        r && (clearTimeout(r), (r = null))
      }),
      (h.flush = function () {
        r && ((c = e.apply(o, s)), (o = s = null), clearTimeout(r), (r = null))
      }),
      h
    )
  }
  return (n.debounce = n), (Tw = n), Tw
}
var l9 = a9()
const b2 = Bx(l9)
var c9 = Object.defineProperty,
  u9 = Object.defineProperties,
  d9 = Object.getOwnPropertyDescriptors,
  T2 = Object.getOwnPropertySymbols,
  f9 = Object.prototype.hasOwnProperty,
  h9 = Object.prototype.propertyIsEnumerable,
  A2 = (n, e, t) =>
    e in n
      ? c9(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  C2 = (n, e) => {
    for (var t in e || (e = {})) f9.call(e, t) && A2(n, t, e[t])
    if (T2) for (var t of T2(e)) h9.call(e, t) && A2(n, t, e[t])
    return n
  },
  p9 = (n, e) => u9(n, d9(e)),
  P2,
  R2
typeof window < 'u' &&
(((P2 = window.document) != null && P2.createElement) ||
  ((R2 = window.navigator) == null ? void 0 : R2.product) === 'ReactNative')
  ? X.useLayoutEffect
  : X.useEffect
function JN(n, e, t) {
  if (!n) return
  if (t(n) === !0) return n
  let i = n.child
  for (; i; ) {
    const r = JN(i, e, t)
    if (r) return r
    i = i.sibling
  }
}
function eD(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null
        },
        set() {},
      },
    })
  } catch {
    return n
  }
}
const I2 = console.error
console.error = function () {
  const n = [...arguments].join('')
  if (n != null && n.startsWith('Warning:') && n.includes('useContext')) {
    console.error = I2
    return
  }
  return I2.apply(this, arguments)
}
const jE = eD(X.createContext(null))
class tD extends X.Component {
  render() {
    return X.createElement(
      jE.Provider,
      { value: this._reactInternals },
      this.props.children,
    )
  }
}
function m9() {
  const n = X.useContext(jE)
  if (n === null)
    throw new Error(
      'its-fine: useFiber must be called within a <FiberProvider />!',
    )
  const e = X.useId()
  return X.useMemo(() => {
    for (const i of [n, n == null ? void 0 : n.alternate]) {
      if (!i) continue
      const r = JN(i, !1, (s) => {
        let o = s.memoizedState
        for (; o; ) {
          if (o.memoizedState === e) return !0
          o = o.next
        }
      })
      if (r) return r
    }
  }, [n, e])
}
function g9() {
  const n = m9(),
    [e] = X.useState(() => new Map())
  e.clear()
  let t = n
  for (; t; ) {
    if (t.type && typeof t.type == 'object') {
      const r =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context
      r && r !== jE && !e.has(r) && e.set(r, X.useContext(eD(r)))
    }
    t = t.return
  }
  return e
}
function v9() {
  const n = g9()
  return X.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (i) =>
          X.createElement(
            e,
            null,
            X.createElement(t.Provider, p9(C2({}, i), { value: n.get(t) })),
          ),
        (e) => X.createElement(tD, C2({}, e)),
      ),
    [n],
  )
}
function y9(
  { debounce: n, scroll: e, polyfill: t, offsetSize: i } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  },
) {
  const r = t || (typeof window < 'u' && window.ResizeObserver),
    [s, o] = X.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    })
  if (!r) return (s.width = 1280), (s.height = 800), [() => {}, s, () => {}]
  const a = X.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: s,
      orientationHandler: null,
    }),
    c = n ? (typeof n == 'number' ? n : n.scroll) : null,
    u = n ? (typeof n == 'number' ? n : n.resize) : null,
    h = X.useRef(!1)
  X.useEffect(() => ((h.current = !0), () => void (h.current = !1)))
  const [m, g, y] = X.useMemo(() => {
    const x = () => {
      if (!a.current.element) return
      const {
          left: T,
          top: A,
          width: P,
          height: D,
          bottom: O,
          right: U,
          x: F,
          y: N,
        } = a.current.element.getBoundingClientRect(),
        k = {
          left: T,
          top: A,
          width: P,
          height: D,
          bottom: O,
          right: U,
          x: F,
          y: N,
        }
      a.current.element instanceof HTMLElement &&
        i &&
        ((k.height = a.current.element.offsetHeight),
        (k.width = a.current.element.offsetWidth)),
        Object.freeze(k),
        h.current &&
          !S9(a.current.lastBounds, k) &&
          o((a.current.lastBounds = k))
    }
    return [x, u ? b2(x, u) : x, c ? b2(x, c) : x]
  }, [o, i, c, u])
  function _() {
    a.current.scrollContainers &&
      (a.current.scrollContainers.forEach((x) =>
        x.removeEventListener('scroll', y, !0),
      ),
      (a.current.scrollContainers = null)),
      a.current.resizeObserver &&
        (a.current.resizeObserver.disconnect(),
        (a.current.resizeObserver = null)),
      a.current.orientationHandler &&
        ('orientation' in screen && 'removeEventListener' in screen.orientation
          ? screen.orientation.removeEventListener(
              'change',
              a.current.orientationHandler,
            )
          : 'onorientationchange' in window &&
            window.removeEventListener(
              'orientationchange',
              a.current.orientationHandler,
            ))
  }
  function M() {
    var x
    a.current.element &&
      ((a.current.resizeObserver = new r(g)),
      (x = a.current.resizeObserver) == null || x.observe(a.current.element),
      e &&
        a.current.scrollContainers &&
        a.current.scrollContainers.forEach((T) =>
          T.addEventListener('scroll', y, { capture: !0, passive: !0 }),
        ),
      (a.current.orientationHandler = () => {
        y()
      }),
      'orientation' in screen && 'addEventListener' in screen.orientation
        ? screen.orientation.addEventListener(
            'change',
            a.current.orientationHandler,
          )
        : 'onorientationchange' in window &&
          window.addEventListener(
            'orientationchange',
            a.current.orientationHandler,
          ))
  }
  const w = (x) => {
    !x ||
      x === a.current.element ||
      (_(), (a.current.element = x), (a.current.scrollContainers = nD(x)), M())
  }
  return (
    _9(y, !!e),
    x9(g),
    X.useEffect(() => {
      _(), M()
    }, [e, y, g]),
    X.useEffect(() => _, []),
    [w, s, m]
  )
}
function x9(n) {
  X.useEffect(() => {
    const e = n
    return (
      window.addEventListener('resize', e),
      () => void window.removeEventListener('resize', e)
    )
  }, [n])
}
function _9(n, e) {
  X.useEffect(() => {
    if (e) {
      const t = n
      return (
        window.addEventListener('scroll', t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener('scroll', t, !0)
      )
    }
  }, [n, e])
}
function nD(n) {
  const e = []
  if (!n || n === document.body) return e
  const { overflow: t, overflowX: i, overflowY: r } = window.getComputedStyle(n)
  return (
    [t, i, r].some((s) => s === 'auto' || s === 'scroll') && e.push(n),
    [...e, ...nD(n.parentElement)]
  )
}
const w9 = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'],
  S9 = (n, e) => w9.every((t) => n[t] === e[t]),
  M9 = X.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: i,
      style: r,
      gl: s,
      events: o = o9,
      eventSource: a,
      eventPrefix: c,
      shadows: u,
      linear: h,
      flat: m,
      legacy: g,
      orthographic: y,
      frameloop: _,
      dpr: M,
      performance: w,
      raycaster: x,
      camera: T,
      scene: A,
      onPointerMissed: P,
      onCreated: D,
      ...O
    },
    U,
  ) {
    X.useMemo(() => BN(ON), [])
    const F = v9(),
      [N, k] = y9({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }),
      z = X.useRef(null),
      $ = X.useRef(null)
    X.useImperativeHandle(U, () => z.current)
    const te = jN(P),
      [j, K] = X.useState(!1),
      [J, ne] = X.useState(!1)
    if (j) throw j
    if (J) throw J
    const V = X.useRef(null)
    zg(() => {
      const Q = z.current
      k.width > 0 &&
        k.height > 0 &&
        Q &&
        (V.current || (V.current = n9(Q)),
        V.current.configure({
          gl: s,
          events: o,
          shadows: u,
          linear: h,
          flat: m,
          legacy: g,
          orthographic: y,
          frameloop: _,
          dpr: M,
          performance: w,
          raycaster: x,
          camera: T,
          scene: A,
          size: k,
          onPointerMissed: (...q) =>
            te.current == null ? void 0 : te.current(...q),
          onCreated: (q) => {
            q.events.connect == null ||
              q.events.connect(a ? (BG(a) ? a.current : a) : $.current),
              c &&
                q.setEvents({
                  compute: (oe, _e) => {
                    const he = oe[c + 'X'],
                      Ce = oe[c + 'Y']
                    _e.pointer.set(
                      (he / _e.size.width) * 2 - 1,
                      -(Ce / _e.size.height) * 2 + 1,
                    ),
                      _e.raycaster.setFromCamera(_e.pointer, _e.camera)
                  },
                }),
              D == null || D(q)
          },
        }),
        V.current.render(
          b.jsx(F, {
            children: b.jsx(HN, {
              set: ne,
              children: b.jsx(X.Suspense, {
                fallback: b.jsx(zG, { set: K }),
                children: e,
              }),
            }),
          }),
        ))
    }),
      X.useEffect(() => {
        const Q = z.current
        if (Q) return () => QN(Q)
      }, [])
    const Y = a ? 'none' : 'auto'
    return b.jsx('div', {
      ref: $,
      style: {
        position: 'relative',
        width: '100%',
        height: '100%',
        overflow: 'hidden',
        pointerEvents: Y,
        ...r,
      },
      ...O,
      children: b.jsx('div', {
        ref: N,
        style: { width: '100%', height: '100%' },
        children: b.jsx('canvas', {
          ref: z,
          style: { display: 'block' },
          children: t,
        }),
      }),
    })
  }),
  HE = X.forwardRef(function (e, t) {
    return b.jsx(tD, { children: b.jsx(M9, { ...e, ref: t }) })
  })
function wh() {
  return (
    (wh = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e]
            for (var i in t) ({}).hasOwnProperty.call(t, i) && (n[i] = t[i])
          }
          return n
        }),
    wh.apply(null, arguments)
  )
}
var GE = Hg(),
  dn = (n) => jg(n, GE),
  WE = Hg()
dn.write = (n) => jg(n, WE)
var x_ = Hg()
dn.onStart = (n) => jg(n, x_)
var $E = Hg()
dn.onFrame = (n) => jg(n, $E)
var XE = Hg()
dn.onFinish = (n) => jg(n, XE)
var uh = []
dn.setTimeout = (n, e) => {
  const t = dn.now() + e,
    i = () => {
      const s = uh.findIndex((o) => o.cancel == i)
      ~s && uh.splice(s, 1), (Ec -= ~s ? 1 : 0)
    },
    r = { time: t, handler: n, cancel: i }
  return uh.splice(iD(t), 0, r), (Ec += 1), rD(), r
}
var iD = (n) => ~(~uh.findIndex((e) => e.time > n) || ~uh.length)
dn.cancel = (n) => {
  x_.delete(n), $E.delete(n), XE.delete(n), GE.delete(n), WE.delete(n)
}
dn.sync = (n) => {
  ;(ZS = !0), dn.batchedUpdates(n), (ZS = !1)
}
dn.throttle = (n) => {
  let e
  function t() {
    try {
      n(...e)
    } finally {
      e = null
    }
  }
  function i(...r) {
    ;(e = r), dn.onStart(t)
  }
  return (
    (i.handler = n),
    (i.cancel = () => {
      x_.delete(t), (e = null)
    }),
    i
  )
}
var qE = typeof window < 'u' ? window.requestAnimationFrame : () => {}
dn.use = (n) => (qE = n)
dn.now = typeof performance < 'u' ? () => performance.now() : Date.now
dn.batchedUpdates = (n) => n()
dn.catch = console.error
dn.frameLoop = 'always'
dn.advance = () => {
  dn.frameLoop !== 'demand'
    ? console.warn(
        'Cannot call the manual advancement of rafz whilst frameLoop is not set as demand',
      )
    : oD()
}
var Mc = -1,
  Ec = 0,
  ZS = !1
function jg(n, e) {
  ZS ? (e.delete(n), n(0)) : (e.add(n), rD())
}
function rD() {
  Mc < 0 && ((Mc = 0), dn.frameLoop !== 'demand' && qE(sD))
}
function E9() {
  Mc = -1
}
function sD() {
  ~Mc && (qE(sD), dn.batchedUpdates(oD))
}
function oD() {
  const n = Mc
  Mc = dn.now()
  const e = iD(Mc)
  if ((e && (aD(uh.splice(0, e), (t) => t.handler()), (Ec -= e)), !Ec)) {
    E9()
    return
  }
  x_.flush(),
    GE.flush(n ? Math.min(64, Mc - n) : 16.667),
    $E.flush(),
    WE.flush(),
    XE.flush()
}
function Hg() {
  let n = new Set(),
    e = n
  return {
    add(t) {
      ;(Ec += e == n && !n.has(t) ? 1 : 0), n.add(t)
    },
    delete(t) {
      return (Ec -= e == n && n.has(t) ? 1 : 0), n.delete(t)
    },
    flush(t) {
      e.size &&
        ((n = new Set()),
        (Ec -= e.size),
        aD(e, (i) => i(t) && n.add(i)),
        (Ec += n.size),
        (e = n))
    },
  }
}
function aD(n, e) {
  n.forEach((t) => {
    try {
      e(t)
    } catch (i) {
      dn.catch(i)
    }
  })
}
var b9 = Object.defineProperty,
  T9 = (n, e) => {
    for (var t in e) b9(n, t, { get: e[t], enumerable: !0 })
  },
  Xo = {}
T9(Xo, {
  assign: () => C9,
  colors: () => Tc,
  createStringInterpolator: () => ZE,
  skipAnimation: () => cD,
  to: () => lD,
  willAdvance: () => KE,
})
function KS() {}
var A9 = (n, e, t) =>
    Object.defineProperty(n, e, { value: t, writable: !0, configurable: !0 }),
  dt = {
    arr: Array.isArray,
    obj: (n) => !!n && n.constructor.name === 'Object',
    fun: (n) => typeof n == 'function',
    str: (n) => typeof n == 'string',
    num: (n) => typeof n == 'number',
    und: (n) => n === void 0,
  }
function gl(n, e) {
  if (dt.arr(n)) {
    if (!dt.arr(e) || n.length !== e.length) return !1
    for (let t = 0; t < n.length; t++) if (n[t] !== e[t]) return !1
    return !0
  }
  return n === e
}
var Fn = (n, e) => n.forEach(e)
function Al(n, e, t) {
  if (dt.arr(n)) {
    for (let i = 0; i < n.length; i++) e.call(t, n[i], `${i}`)
    return
  }
  for (const i in n) n.hasOwnProperty(i) && e.call(t, n[i], i)
}
var co = (n) => (dt.und(n) ? [] : dt.arr(n) ? n : [n])
function bm(n, e) {
  if (n.size) {
    const t = Array.from(n)
    n.clear(), Fn(t, e)
  }
}
var am = (n, ...e) => bm(n, (t) => t(...e)),
  YE = () =>
    typeof window > 'u' ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  ZE,
  lD,
  Tc = null,
  cD = !1,
  KE = KS,
  C9 = (n) => {
    n.to && (lD = n.to),
      n.now && (dn.now = n.now),
      n.colors !== void 0 && (Tc = n.colors),
      n.skipAnimation != null && (cD = n.skipAnimation),
      n.createStringInterpolator && (ZE = n.createStringInterpolator),
      n.requestAnimationFrame && dn.use(n.requestAnimationFrame),
      n.batchedUpdates && (dn.batchedUpdates = n.batchedUpdates),
      n.willAdvance && (KE = n.willAdvance),
      n.frameLoop && (dn.frameLoop = n.frameLoop)
  },
  Tm = new Set(),
  ao = [],
  Aw = [],
  vx = 0,
  __ = {
    get idle() {
      return !Tm.size && !ao.length
    },
    start(n) {
      vx > n.priority ? (Tm.add(n), dn.onStart(P9)) : (uD(n), dn(QS))
    },
    advance: QS,
    sort(n) {
      if (vx) dn.onFrame(() => __.sort(n))
      else {
        const e = ao.indexOf(n)
        ~e && (ao.splice(e, 1), dD(n))
      }
    },
    clear() {
      ;(ao = []), Tm.clear()
    },
  }
function P9() {
  Tm.forEach(uD), Tm.clear(), dn(QS)
}
function uD(n) {
  ao.includes(n) || dD(n)
}
function dD(n) {
  ao.splice(
    R9(ao, (e) => e.priority > n.priority),
    0,
    n,
  )
}
function QS(n) {
  const e = Aw
  for (let t = 0; t < ao.length; t++) {
    const i = ao[t]
    ;(vx = i.priority), i.idle || (KE(i), i.advance(n), i.idle || e.push(i))
  }
  return (vx = 0), (Aw = ao), (Aw.length = 0), (ao = e), ao.length > 0
}
function R9(n, e) {
  const t = n.findIndex(e)
  return t < 0 ? n.length : t
}
var I9 = (n, e, t) => Math.min(Math.max(t, n), e),
  L9 = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199,
  },
  Wo = '[-+]?\\d*\\.?\\d+',
  yx = Wo + '%'
function w_(...n) {
  return '\\(\\s*(' + n.join(')\\s*,\\s*(') + ')\\s*\\)'
}
var N9 = new RegExp('rgb' + w_(Wo, Wo, Wo)),
  D9 = new RegExp('rgba' + w_(Wo, Wo, Wo, Wo)),
  O9 = new RegExp('hsl' + w_(Wo, yx, yx)),
  k9 = new RegExp('hsla' + w_(Wo, yx, yx, Wo)),
  F9 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  U9 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  B9 = /^#([0-9a-fA-F]{6})$/,
  z9 = /^#([0-9a-fA-F]{8})$/
function V9(n) {
  let e
  return typeof n == 'number'
    ? n >>> 0 === n && n >= 0 && n <= 4294967295
      ? n
      : null
    : (e = B9.exec(n))
    ? parseInt(e[1] + 'ff', 16) >>> 0
    : Tc && Tc[n] !== void 0
    ? Tc[n]
    : (e = N9.exec(n))
    ? ((jf(e[1]) << 24) | (jf(e[2]) << 16) | (jf(e[3]) << 8) | 255) >>> 0
    : (e = D9.exec(n))
    ? ((jf(e[1]) << 24) | (jf(e[2]) << 16) | (jf(e[3]) << 8) | D2(e[4])) >>> 0
    : (e = F9.exec(n))
    ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + 'ff', 16) >>> 0
    : (e = z9.exec(n))
    ? parseInt(e[1], 16) >>> 0
    : (e = U9.exec(n))
    ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0
    : (e = O9.exec(n))
    ? (L2(N2(e[1]), W0(e[2]), W0(e[3])) | 255) >>> 0
    : (e = k9.exec(n))
    ? (L2(N2(e[1]), W0(e[2]), W0(e[3])) | D2(e[4])) >>> 0
    : null
}
function Cw(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  )
}
function L2(n, e, t) {
  const i = t < 0.5 ? t * (1 + e) : t + e - t * e,
    r = 2 * t - i,
    s = Cw(r, i, n + 1 / 3),
    o = Cw(r, i, n),
    a = Cw(r, i, n - 1 / 3)
  return (
    (Math.round(s * 255) << 24) |
    (Math.round(o * 255) << 16) |
    (Math.round(a * 255) << 8)
  )
}
function jf(n) {
  const e = parseInt(n, 10)
  return e < 0 ? 0 : e > 255 ? 255 : e
}
function N2(n) {
  return (((parseFloat(n) % 360) + 360) % 360) / 360
}
function D2(n) {
  const e = parseFloat(n)
  return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255)
}
function W0(n) {
  const e = parseFloat(n)
  return e < 0 ? 0 : e > 100 ? 1 : e / 100
}
function O2(n) {
  let e = V9(n)
  if (e === null) return n
  e = e || 0
  const t = (e & 4278190080) >>> 24,
    i = (e & 16711680) >>> 16,
    r = (e & 65280) >>> 8,
    s = (e & 255) / 255
  return `rgba(${t}, ${i}, ${r}, ${s})`
}
var rg = (n, e, t) => {
  if (dt.fun(n)) return n
  if (dt.arr(n)) return rg({ range: n, output: e, extrapolate: t })
  if (dt.str(n.output[0])) return ZE(n)
  const i = n,
    r = i.output,
    s = i.range || [0, 1],
    o = i.extrapolateLeft || i.extrapolate || 'extend',
    a = i.extrapolateRight || i.extrapolate || 'extend',
    c = i.easing || ((u) => u)
  return (u) => {
    const h = H9(u, s)
    return j9(u, s[h], s[h + 1], r[h], r[h + 1], c, o, a, i.map)
  }
}
function j9(n, e, t, i, r, s, o, a, c) {
  let u = c ? c(n) : n
  if (u < e) {
    if (o === 'identity') return u
    o === 'clamp' && (u = e)
  }
  if (u > t) {
    if (a === 'identity') return u
    a === 'clamp' && (u = t)
  }
  return i === r
    ? i
    : e === t
    ? n <= e
      ? i
      : r
    : (e === -1 / 0
        ? (u = -u)
        : t === 1 / 0
        ? (u = u - e)
        : (u = (u - e) / (t - e)),
      (u = s(u)),
      i === -1 / 0
        ? (u = -u)
        : r === 1 / 0
        ? (u = u + i)
        : (u = u * (r - i) + i),
      u)
}
function H9(n, e) {
  for (var t = 1; t < e.length - 1 && !(e[t] >= n); ++t);
  return t - 1
}
var G9 =
    (n, e = 'end') =>
    (t) => {
      t = e === 'end' ? Math.min(t, 0.999) : Math.max(t, 0.001)
      const i = t * n,
        r = e === 'end' ? Math.floor(i) : Math.ceil(i)
      return I9(0, 1, r / n)
    },
  xx = 1.70158,
  $0 = xx * 1.525,
  k2 = xx + 1,
  F2 = (2 * Math.PI) / 3,
  U2 = (2 * Math.PI) / 4.5,
  X0 = (n) =>
    n < 1 / 2.75
      ? 7.5625 * n * n
      : n < 2 / 2.75
      ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75
      : n < 2.5 / 2.75
      ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375
      : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375,
  W9 = {
    linear: (n) => n,
    easeInQuad: (n) => n * n,
    easeOutQuad: (n) => 1 - (1 - n) * (1 - n),
    easeInOutQuad: (n) =>
      n < 0.5 ? 2 * n * n : 1 - Math.pow(-2 * n + 2, 2) / 2,
    easeInCubic: (n) => n * n * n,
    easeOutCubic: (n) => 1 - Math.pow(1 - n, 3),
    easeInOutCubic: (n) =>
      n < 0.5 ? 4 * n * n * n : 1 - Math.pow(-2 * n + 2, 3) / 2,
    easeInQuart: (n) => n * n * n * n,
    easeOutQuart: (n) => 1 - Math.pow(1 - n, 4),
    easeInOutQuart: (n) =>
      n < 0.5 ? 8 * n * n * n * n : 1 - Math.pow(-2 * n + 2, 4) / 2,
    easeInQuint: (n) => n * n * n * n * n,
    easeOutQuint: (n) => 1 - Math.pow(1 - n, 5),
    easeInOutQuint: (n) =>
      n < 0.5 ? 16 * n * n * n * n * n : 1 - Math.pow(-2 * n + 2, 5) / 2,
    easeInSine: (n) => 1 - Math.cos((n * Math.PI) / 2),
    easeOutSine: (n) => Math.sin((n * Math.PI) / 2),
    easeInOutSine: (n) => -(Math.cos(Math.PI * n) - 1) / 2,
    easeInExpo: (n) => (n === 0 ? 0 : Math.pow(2, 10 * n - 10)),
    easeOutExpo: (n) => (n === 1 ? 1 : 1 - Math.pow(2, -10 * n)),
    easeInOutExpo: (n) =>
      n === 0
        ? 0
        : n === 1
        ? 1
        : n < 0.5
        ? Math.pow(2, 20 * n - 10) / 2
        : (2 - Math.pow(2, -20 * n + 10)) / 2,
    easeInCirc: (n) => 1 - Math.sqrt(1 - Math.pow(n, 2)),
    easeOutCirc: (n) => Math.sqrt(1 - Math.pow(n - 1, 2)),
    easeInOutCirc: (n) =>
      n < 0.5
        ? (1 - Math.sqrt(1 - Math.pow(2 * n, 2))) / 2
        : (Math.sqrt(1 - Math.pow(-2 * n + 2, 2)) + 1) / 2,
    easeInBack: (n) => k2 * n * n * n - xx * n * n,
    easeOutBack: (n) => 1 + k2 * Math.pow(n - 1, 3) + xx * Math.pow(n - 1, 2),
    easeInOutBack: (n) =>
      n < 0.5
        ? (Math.pow(2 * n, 2) * (($0 + 1) * 2 * n - $0)) / 2
        : (Math.pow(2 * n - 2, 2) * (($0 + 1) * (n * 2 - 2) + $0) + 2) / 2,
    easeInElastic: (n) =>
      n === 0
        ? 0
        : n === 1
        ? 1
        : -Math.pow(2, 10 * n - 10) * Math.sin((n * 10 - 10.75) * F2),
    easeOutElastic: (n) =>
      n === 0
        ? 0
        : n === 1
        ? 1
        : Math.pow(2, -10 * n) * Math.sin((n * 10 - 0.75) * F2) + 1,
    easeInOutElastic: (n) =>
      n === 0
        ? 0
        : n === 1
        ? 1
        : n < 0.5
        ? -(Math.pow(2, 20 * n - 10) * Math.sin((20 * n - 11.125) * U2)) / 2
        : (Math.pow(2, -20 * n + 10) * Math.sin((20 * n - 11.125) * U2)) / 2 +
          1,
    easeInBounce: (n) => 1 - X0(1 - n),
    easeOutBounce: X0,
    easeInOutBounce: (n) =>
      n < 0.5 ? (1 - X0(1 - 2 * n)) / 2 : (1 + X0(2 * n - 1)) / 2,
    steps: G9,
  },
  sg = Symbol.for('FluidValue.get'),
  Sh = Symbol.for('FluidValue.observers'),
  pa = (n) => !!(n && n[sg]),
  ro = (n) => (n && n[sg] ? n[sg]() : n),
  B2 = (n) => n[Sh] || null
function $9(n, e) {
  n.eventObserved ? n.eventObserved(e) : n(e)
}
function _x(n, e) {
  const t = n[Sh]
  t &&
    t.forEach((i) => {
      $9(i, e)
    })
}
var X9 = class {
    constructor(n) {
      if (!n && !(n = this.get)) throw Error('Unknown getter')
      q9(this, n)
    }
  },
  q9 = (n, e) => fD(n, sg, e)
function Gg(n, e) {
  if (n[sg]) {
    let t = n[Sh]
    t || fD(n, Sh, (t = new Set())),
      t.has(e) || (t.add(e), n.observerAdded && n.observerAdded(t.size, e))
  }
  return e
}
function wx(n, e) {
  const t = n[Sh]
  if (t && t.has(e)) {
    const i = t.size - 1
    i ? t.delete(e) : (n[Sh] = null),
      n.observerRemoved && n.observerRemoved(i, e)
  }
}
var fD = (n, e, t) =>
    Object.defineProperty(n, e, { value: t, writable: !0, configurable: !0 }),
  Sy = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
  Y9 =
    /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi,
  z2 = new RegExp(`(${Sy.source})(%|[a-z]+)`, 'i'),
  Z9 = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi,
  S_ = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/,
  hD = (n) => {
    const [e, t] = K9(n)
    if (!e || YE()) return n
    const i = window
      .getComputedStyle(document.documentElement)
      .getPropertyValue(e)
    if (i) return i.trim()
    if (t && t.startsWith('--')) {
      const r = window
        .getComputedStyle(document.documentElement)
        .getPropertyValue(t)
      return r || n
    } else {
      if (t && S_.test(t)) return hD(t)
      if (t) return t
    }
    return n
  },
  K9 = (n) => {
    const e = S_.exec(n)
    if (!e) return [,]
    const [, t, i] = e
    return [t, i]
  },
  Pw,
  Q9 = (n, e, t, i, r) =>
    `rgba(${Math.round(e)}, ${Math.round(t)}, ${Math.round(i)}, ${r})`,
  pD = (n) => {
    Pw ||
      (Pw = Tc
        ? new RegExp(`(${Object.keys(Tc).join('|')})(?!\\w)`, 'g')
        : /^\b$/)
    const e = n.output.map((s) =>
        ro(s).replace(S_, hD).replace(Y9, O2).replace(Pw, O2),
      ),
      t = e.map((s) => s.match(Sy).map(Number)),
      r = t[0]
        .map((s, o) =>
          t.map((a) => {
            if (!(o in a))
              throw Error('The arity of each "output" value must be equal')
            return a[o]
          }),
        )
        .map((s) => rg({ ...n, output: s }))
    return (s) => {
      var c
      const o =
        !z2.test(e[0]) &&
        ((c = e.find((u) => z2.test(u))) == null ? void 0 : c.replace(Sy, ''))
      let a = 0
      return e[0].replace(Sy, () => `${r[a++](s)}${o || ''}`).replace(Z9, Q9)
    }
  },
  QE = 'react-spring: ',
  mD = (n) => {
    const e = n
    let t = !1
    if (typeof e != 'function')
      throw new TypeError(`${QE}once requires a function parameter`)
    return (...i) => {
      t || (e(...i), (t = !0))
    }
  },
  J9 = mD(console.warn)
function eW() {
  J9(`${QE}The "interpolate" function is deprecated in v9 (use "to" instead)`)
}
var tW = mD(console.warn)
function nW() {
  tW(
    `${QE}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`,
  )
}
function M_(n) {
  return (
    dt.str(n) &&
    (n[0] == '#' || /\d/.test(n) || (!YE() && S_.test(n)) || n in (Tc || {}))
  )
}
var JE = YE() ? X.useEffect : X.useLayoutEffect,
  iW = () => {
    const n = X.useRef(!1)
    return (
      JE(
        () => (
          (n.current = !0),
          () => {
            n.current = !1
          }
        ),
        [],
      ),
      n
    )
  }
function gD() {
  const n = X.useState()[1],
    e = iW()
  return () => {
    e.current && n(Math.random())
  }
}
function rW(n, e) {
  const [t] = X.useState(() => ({ inputs: e, result: n() })),
    i = X.useRef(),
    r = i.current
  let s = r
  return (
    s
      ? (s.inputs && sW(e, s.inputs)) || (s = { inputs: e, result: n() })
      : (s = t),
    X.useEffect(() => {
      ;(i.current = s), r == t && (t.inputs = t.result = void 0)
    }, [s]),
    s.result
  )
}
function sW(n, e) {
  if (n.length !== e.length) return !1
  for (let t = 0; t < n.length; t++) if (n[t] !== e[t]) return !1
  return !0
}
var vD = (n) => X.useEffect(n, oW),
  oW = []
function V2(n) {
  const e = X.useRef()
  return (
    X.useEffect(() => {
      e.current = n
    }),
    e.current
  )
}
var og = Symbol.for('Animated:node'),
  aW = (n) => !!n && n[og] === n,
  fa = (n) => n && n[og],
  eb = (n, e) => A9(n, og, e),
  E_ = (n) => n && n[og] && n[og].getPayload(),
  yD = class {
    constructor() {
      eb(this, this)
    }
    getPayload() {
      return this.payload || []
    }
  },
  Wg = class extends yD {
    constructor(n) {
      super(),
        (this._value = n),
        (this.done = !0),
        (this.durationProgress = 0),
        dt.num(this._value) && (this.lastPosition = this._value)
    }
    static create(n) {
      return new Wg(n)
    }
    getPayload() {
      return [this]
    }
    getValue() {
      return this._value
    }
    setValue(n, e) {
      return (
        dt.num(n) &&
          ((this.lastPosition = n),
          e &&
            ((n = Math.round(n / e) * e),
            this.done && (this.lastPosition = n))),
        this._value === n ? !1 : ((this._value = n), !0)
      )
    }
    reset() {
      const { done: n } = this
      ;(this.done = !1),
        dt.num(this._value) &&
          ((this.elapsedTime = 0),
          (this.durationProgress = 0),
          (this.lastPosition = this._value),
          n && (this.lastVelocity = null),
          (this.v0 = null))
    }
  },
  ag = class extends Wg {
    constructor(n) {
      super(0), (this._string = null), (this._toString = rg({ output: [n, n] }))
    }
    static create(n) {
      return new ag(n)
    }
    getValue() {
      const n = this._string
      return n ?? (this._string = this._toString(this._value))
    }
    setValue(n) {
      if (dt.str(n)) {
        if (n == this._string) return !1
        ;(this._string = n), (this._value = 1)
      } else if (super.setValue(n)) this._string = null
      else return !1
      return !0
    }
    reset(n) {
      n && (this._toString = rg({ output: [this.getValue(), n] })),
        (this._value = 0),
        super.reset()
    }
  },
  Sx = { dependencies: null },
  tb = class extends yD {
    constructor(n) {
      super(), (this.source = n), this.setValue(n)
    }
    getValue(n) {
      const e = {}
      return (
        Al(this.source, (t, i) => {
          aW(t)
            ? (e[i] = t.getValue(n))
            : pa(t)
            ? (e[i] = ro(t))
            : n || (e[i] = t)
        }),
        e
      )
    }
    setValue(n) {
      ;(this.source = n), (this.payload = this._makePayload(n))
    }
    reset() {
      this.payload && Fn(this.payload, (n) => n.reset())
    }
    _makePayload(n) {
      if (n) {
        const e = new Set()
        return Al(n, this._addToPayload, e), Array.from(e)
      }
    }
    _addToPayload(n) {
      Sx.dependencies && pa(n) && Sx.dependencies.add(n)
      const e = E_(n)
      e && Fn(e, (t) => this.add(t))
    }
  },
  xD = class extends tb {
    constructor(n) {
      super(n)
    }
    static create(n) {
      return new xD(n)
    }
    getValue() {
      return this.source.map((n) => n.getValue())
    }
    setValue(n) {
      const e = this.getPayload()
      return n.length == e.length
        ? e.map((t, i) => t.setValue(n[i])).some(Boolean)
        : (super.setValue(n.map(lW)), !0)
    }
  }
function lW(n) {
  return (M_(n) ? ag : Wg).create(n)
}
function JS(n) {
  const e = fa(n)
  return e ? e.constructor : dt.arr(n) ? xD : M_(n) ? ag : Wg
}
var j2 = (n, e) => {
    const t = !dt.fun(n) || (n.prototype && n.prototype.isReactComponent)
    return X.forwardRef((i, r) => {
      const s = X.useRef(null),
        o =
          t &&
          X.useCallback(
            (_) => {
              s.current = dW(r, _)
            },
            [r],
          ),
        [a, c] = uW(i, e),
        u = gD(),
        h = () => {
          const _ = s.current
          if (t && !_) return
          ;(_ ? e.applyAnimatedValues(_, a.getValue(!0)) : !1) === !1 && u()
        },
        m = new cW(h, c),
        g = X.useRef()
      JE(
        () => (
          (g.current = m),
          Fn(c, (_) => Gg(_, m)),
          () => {
            g.current &&
              (Fn(g.current.deps, (_) => wx(_, g.current)),
              dn.cancel(g.current.update))
          }
        ),
      ),
        X.useEffect(h, []),
        vD(() => () => {
          const _ = g.current
          Fn(_.deps, (M) => wx(M, _))
        })
      const y = e.getComponentProps(a.getValue())
      return X.createElement(n, { ...y, ref: o })
    })
  },
  cW = class {
    constructor(n, e) {
      ;(this.update = n), (this.deps = e)
    }
    eventObserved(n) {
      n.type == 'change' && dn.write(this.update)
    }
  }
function uW(n, e) {
  const t = new Set()
  return (
    (Sx.dependencies = t),
    n.style && (n = { ...n, style: e.createAnimatedStyle(n.style) }),
    (n = new tb(n)),
    (Sx.dependencies = null),
    [n, t]
  )
}
function dW(n, e) {
  return n && (dt.fun(n) ? n(e) : (n.current = e)), e
}
var H2 = Symbol.for('AnimatedComponent'),
  fW = (
    n,
    {
      applyAnimatedValues: e = () => !1,
      createAnimatedStyle: t = (r) => new tb(r),
      getComponentProps: i = (r) => r,
    } = {},
  ) => {
    const r = {
        applyAnimatedValues: e,
        createAnimatedStyle: t,
        getComponentProps: i,
      },
      s = (o) => {
        const a = G2(o) || 'Anonymous'
        return (
          dt.str(o)
            ? (o = s[o] || (s[o] = j2(o, r)))
            : (o = o[H2] || (o[H2] = j2(o, r))),
          (o.displayName = `Animated(${a})`),
          o
        )
      }
    return (
      Al(n, (o, a) => {
        dt.arr(n) && (a = G2(o)), (s[a] = s(o))
      }),
      { animated: s }
    )
  },
  G2 = (n) =>
    dt.str(n)
      ? n
      : n && dt.str(n.displayName)
      ? n.displayName
      : (dt.fun(n) && n.name) || null
function Zu(n, ...e) {
  return dt.fun(n) ? n(...e) : n
}
var Am = (n, e) =>
    n === !0 || !!(e && n && (dt.fun(n) ? n(e) : co(n).includes(e))),
  _D = (n, e) => (dt.obj(n) ? e && n[e] : n),
  wD = (n, e) => (n.default === !0 ? n[e] : n.default ? n.default[e] : void 0),
  hW = (n) => n,
  nb = (n, e = hW) => {
    let t = pW
    n.default && n.default !== !0 && ((n = n.default), (t = Object.keys(n)))
    const i = {}
    for (const r of t) {
      const s = e(n[r], r)
      dt.und(s) || (i[r] = s)
    }
    return i
  },
  pW = [
    'config',
    'onProps',
    'onStart',
    'onChange',
    'onPause',
    'onResume',
    'onRest',
  ],
  mW = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1,
  }
function gW(n) {
  const e = {}
  let t = 0
  if (
    (Al(n, (i, r) => {
      mW[r] || ((e[r] = i), t++)
    }),
    t)
  )
    return e
}
function SD(n) {
  const e = gW(n)
  if (e) {
    const t = { to: e }
    return Al(n, (i, r) => r in e || (t[r] = i)), t
  }
  return { ...n }
}
function lg(n) {
  return (
    (n = ro(n)),
    dt.arr(n)
      ? n.map(lg)
      : M_(n)
      ? Xo.createStringInterpolator({ range: [0, 1], output: [n, n] })(1)
      : n
  )
}
function vW(n) {
  for (const e in n) return !0
  return !1
}
function eM(n) {
  return dt.fun(n) || (dt.arr(n) && dt.obj(n[0]))
}
function yW(n, e) {
  var t
  ;(t = n.ref) == null || t.delete(n), e == null || e.delete(n)
}
function xW(n, e) {
  var t
  e &&
    n.ref !== e &&
    ((t = n.ref) == null || t.delete(n), e.add(n), (n.ref = e))
}
var _W = {
    default: { tension: 170, friction: 26 },
    gentle: { tension: 120, friction: 14 },
    wobbly: { tension: 180, friction: 12 },
    stiff: { tension: 210, friction: 20 },
    slow: { tension: 280, friction: 60 },
    molasses: { tension: 280, friction: 120 },
  },
  tM = { ..._W.default, mass: 1, damping: 1, easing: W9.linear, clamp: !1 },
  wW = class {
    constructor() {
      ;(this.velocity = 0), Object.assign(this, tM)
    }
  }
function SW(n, e, t) {
  t && ((t = { ...t }), W2(t, e), (e = { ...t, ...e })),
    W2(n, e),
    Object.assign(n, e)
  for (const o in tM) n[o] == null && (n[o] = tM[o])
  let { frequency: i, damping: r } = n
  const { mass: s } = n
  return (
    dt.und(i) ||
      (i < 0.01 && (i = 0.01),
      r < 0 && (r = 0),
      (n.tension = Math.pow((2 * Math.PI) / i, 2) * s),
      (n.friction = (4 * Math.PI * r * s) / i)),
    n
  )
}
function W2(n, e) {
  if (!dt.und(e.decay)) n.duration = void 0
  else {
    const t = !dt.und(e.tension) || !dt.und(e.friction)
    ;(t || !dt.und(e.frequency) || !dt.und(e.damping) || !dt.und(e.mass)) &&
      ((n.duration = void 0), (n.decay = void 0)),
      t && (n.frequency = void 0)
  }
}
var $2 = [],
  MW = class {
    constructor() {
      ;(this.changed = !1),
        (this.values = $2),
        (this.toValues = null),
        (this.fromValues = $2),
        (this.config = new wW()),
        (this.immediate = !1)
    }
  }
function MD(n, { key: e, props: t, defaultProps: i, state: r, actions: s }) {
  return new Promise((o, a) => {
    let c,
      u,
      h = Am(t.cancel ?? (i == null ? void 0 : i.cancel), e)
    if (h) y()
    else {
      dt.und(t.pause) || (r.paused = Am(t.pause, e))
      let _ = i == null ? void 0 : i.pause
      _ !== !0 && (_ = r.paused || Am(_, e)),
        (c = Zu(t.delay || 0, e)),
        _ ? (r.resumeQueue.add(g), s.pause()) : (s.resume(), g())
    }
    function m() {
      r.resumeQueue.add(g),
        r.timeouts.delete(u),
        u.cancel(),
        (c = u.time - dn.now())
    }
    function g() {
      c > 0 && !Xo.skipAnimation
        ? ((r.delayed = !0),
          (u = dn.setTimeout(y, c)),
          r.pauseQueue.add(m),
          r.timeouts.add(u))
        : y()
    }
    function y() {
      r.delayed && (r.delayed = !1),
        r.pauseQueue.delete(m),
        r.timeouts.delete(u),
        n <= (r.cancelId || 0) && (h = !0)
      try {
        s.start({ ...t, callId: n, cancel: h }, o)
      } catch (_) {
        a(_)
      }
    }
  })
}
var ib = (n, e) =>
    e.length == 1
      ? e[0]
      : e.some((t) => t.cancelled)
      ? dh(n.get())
      : e.every((t) => t.noop)
      ? ED(n.get())
      : Ho(
          n.get(),
          e.every((t) => t.finished),
        ),
  ED = (n) => ({ value: n, noop: !0, finished: !0, cancelled: !1 }),
  Ho = (n, e, t = !1) => ({ value: n, finished: e, cancelled: t }),
  dh = (n) => ({ value: n, cancelled: !0, finished: !1 })
function bD(n, e, t, i) {
  const { callId: r, parentId: s, onRest: o } = e,
    { asyncTo: a, promise: c } = t
  return !s && n === a && !e.reset
    ? c
    : (t.promise = (async () => {
        ;(t.asyncId = r), (t.asyncTo = n)
        const u = nb(e, (w, x) => (x === 'onRest' ? void 0 : w))
        let h, m
        const g = new Promise((w, x) => ((h = w), (m = x))),
          y = (w) => {
            const x =
              (r <= (t.cancelId || 0) && dh(i)) ||
              (r !== t.asyncId && Ho(i, !1))
            if (x) throw ((w.result = x), m(w), w)
          },
          _ = (w, x) => {
            const T = new X2(),
              A = new q2()
            return (async () => {
              if (Xo.skipAnimation)
                throw (cg(t), (A.result = Ho(i, !1)), m(A), A)
              y(T)
              const P = dt.obj(w) ? { ...w } : { ...x, to: w }
              ;(P.parentId = r),
                Al(u, (O, U) => {
                  dt.und(P[U]) && (P[U] = O)
                })
              const D = await i.start(P)
              return (
                y(T),
                t.paused &&
                  (await new Promise((O) => {
                    t.resumeQueue.add(O)
                  })),
                D
              )
            })()
          }
        let M
        if (Xo.skipAnimation) return cg(t), Ho(i, !1)
        try {
          let w
          dt.arr(n)
            ? (w = (async (x) => {
                for (const T of x) await _(T)
              })(n))
            : (w = Promise.resolve(n(_, i.stop.bind(i)))),
            await Promise.all([w.then(h), g]),
            (M = Ho(i.get(), !0, !1))
        } catch (w) {
          if (w instanceof X2) M = w.result
          else if (w instanceof q2) M = w.result
          else throw w
        } finally {
          r == t.asyncId &&
            ((t.asyncId = s),
            (t.asyncTo = s ? a : void 0),
            (t.promise = s ? c : void 0))
        }
        return (
          dt.fun(o) &&
            dn.batchedUpdates(() => {
              o(M, i, i.item)
            }),
          M
        )
      })())
}
function cg(n, e) {
  bm(n.timeouts, (t) => t.cancel()),
    n.pauseQueue.clear(),
    n.resumeQueue.clear(),
    (n.asyncId = n.asyncTo = n.promise = void 0),
    e && (n.cancelId = e)
}
var X2 = class extends Error {
    constructor() {
      super(
        'An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.',
      )
    }
  },
  q2 = class extends Error {
    constructor() {
      super('SkipAnimationSignal')
    }
  },
  nM = (n) => n instanceof rb,
  EW = 1,
  rb = class extends X9 {
    constructor() {
      super(...arguments), (this.id = EW++), (this._priority = 0)
    }
    get priority() {
      return this._priority
    }
    set priority(n) {
      this._priority != n && ((this._priority = n), this._onPriorityChange(n))
    }
    get() {
      const n = fa(this)
      return n && n.getValue()
    }
    to(...n) {
      return Xo.to(this, n)
    }
    interpolate(...n) {
      return eW(), Xo.to(this, n)
    }
    toJSON() {
      return this.get()
    }
    observerAdded(n) {
      n == 1 && this._attach()
    }
    observerRemoved(n) {
      n == 0 && this._detach()
    }
    _attach() {}
    _detach() {}
    _onChange(n, e = !1) {
      _x(this, { type: 'change', parent: this, value: n, idle: e })
    }
    _onPriorityChange(n) {
      this.idle || __.sort(this),
        _x(this, { type: 'priority', parent: this, priority: n })
    }
  },
  yd = Symbol.for('SpringPhase'),
  TD = 1,
  iM = 2,
  rM = 4,
  Rw = (n) => (n[yd] & TD) > 0,
  gc = (n) => (n[yd] & iM) > 0,
  qp = (n) => (n[yd] & rM) > 0,
  Y2 = (n, e) => (e ? (n[yd] |= iM | TD) : (n[yd] &= ~iM)),
  Z2 = (n, e) => (e ? (n[yd] |= rM) : (n[yd] &= ~rM)),
  bW = class extends rb {
    constructor(n, e) {
      if (
        (super(),
        (this.animation = new MW()),
        (this.defaultProps = {}),
        (this._state = {
          paused: !1,
          delayed: !1,
          pauseQueue: new Set(),
          resumeQueue: new Set(),
          timeouts: new Set(),
        }),
        (this._pendingCalls = new Set()),
        (this._lastCallId = 0),
        (this._lastToId = 0),
        (this._memoizedDuration = 0),
        !dt.und(n) || !dt.und(e))
      ) {
        const t = dt.obj(n) ? { ...n } : { ...e, from: n }
        dt.und(t.default) && (t.default = !0), this.start(t)
      }
    }
    get idle() {
      return !(gc(this) || this._state.asyncTo) || qp(this)
    }
    get goal() {
      return ro(this.animation.to)
    }
    get velocity() {
      const n = fa(this)
      return n instanceof Wg
        ? n.lastVelocity || 0
        : n.getPayload().map((e) => e.lastVelocity || 0)
    }
    get hasAnimated() {
      return Rw(this)
    }
    get isAnimating() {
      return gc(this)
    }
    get isPaused() {
      return qp(this)
    }
    get isDelayed() {
      return this._state.delayed
    }
    advance(n) {
      let e = !0,
        t = !1
      const i = this.animation
      let { toValues: r } = i
      const { config: s } = i,
        o = E_(i.to)
      !o && pa(i.to) && (r = co(ro(i.to))),
        i.values.forEach((u, h) => {
          if (u.done) return
          const m = u.constructor == ag ? 1 : o ? o[h].lastPosition : r[h]
          let g = i.immediate,
            y = m
          if (!g) {
            if (((y = u.lastPosition), s.tension <= 0)) {
              u.done = !0
              return
            }
            let _ = (u.elapsedTime += n)
            const M = i.fromValues[h],
              w =
                u.v0 != null
                  ? u.v0
                  : (u.v0 = dt.arr(s.velocity) ? s.velocity[h] : s.velocity)
            let x
            const T =
              s.precision ||
              (M == m ? 0.005 : Math.min(1, Math.abs(m - M) * 0.001))
            if (dt.und(s.duration))
              if (s.decay) {
                const A = s.decay === !0 ? 0.998 : s.decay,
                  P = Math.exp(-(1 - A) * _)
                ;(y = M + (w / (1 - A)) * (1 - P)),
                  (g = Math.abs(u.lastPosition - y) <= T),
                  (x = w * P)
              } else {
                x = u.lastVelocity == null ? w : u.lastVelocity
                const A = s.restVelocity || T / 10,
                  P = s.clamp ? 0 : s.bounce,
                  D = !dt.und(P),
                  O = M == m ? u.v0 > 0 : M < m
                let U,
                  F = !1
                const N = 1,
                  k = Math.ceil(n / N)
                for (
                  let z = 0;
                  z < k &&
                  ((U = Math.abs(x) > A),
                  !(!U && ((g = Math.abs(m - y) <= T), g)));
                  ++z
                ) {
                  D &&
                    ((F = y == m || y > m == O), F && ((x = -x * P), (y = m)))
                  const $ = -s.tension * 1e-6 * (y - m),
                    te = -s.friction * 0.001 * x,
                    j = ($ + te) / s.mass
                  ;(x = x + j * N), (y = y + x * N)
                }
              }
            else {
              let A = 1
              s.duration > 0 &&
                (this._memoizedDuration !== s.duration &&
                  ((this._memoizedDuration = s.duration),
                  u.durationProgress > 0 &&
                    ((u.elapsedTime = s.duration * u.durationProgress),
                    (_ = u.elapsedTime += n))),
                (A = (s.progress || 0) + _ / this._memoizedDuration),
                (A = A > 1 ? 1 : A < 0 ? 0 : A),
                (u.durationProgress = A)),
                (y = M + s.easing(A) * (m - M)),
                (x = (y - u.lastPosition) / n),
                (g = A == 1)
            }
            ;(u.lastVelocity = x),
              Number.isNaN(y) &&
                (console.warn('Got NaN while animating:', this), (g = !0))
          }
          o && !o[h].done && (g = !1),
            g ? (u.done = !0) : (e = !1),
            u.setValue(y, s.round) && (t = !0)
        })
      const a = fa(this),
        c = a.getValue()
      if (e) {
        const u = ro(i.to)
        ;(c !== u || t) && !s.decay
          ? (a.setValue(u), this._onChange(u))
          : t && s.decay && this._onChange(c),
          this._stop()
      } else t && this._onChange(c)
    }
    set(n) {
      return (
        dn.batchedUpdates(() => {
          this._stop(), this._focus(n), this._set(n)
        }),
        this
      )
    }
    pause() {
      this._update({ pause: !0 })
    }
    resume() {
      this._update({ pause: !1 })
    }
    finish() {
      if (gc(this)) {
        const { to: n, config: e } = this.animation
        dn.batchedUpdates(() => {
          this._onStart(), e.decay || this._set(n, !1), this._stop()
        })
      }
      return this
    }
    update(n) {
      return (this.queue || (this.queue = [])).push(n), this
    }
    start(n, e) {
      let t
      return (
        dt.und(n)
          ? ((t = this.queue || []), (this.queue = []))
          : (t = [dt.obj(n) ? n : { ...e, to: n }]),
        Promise.all(t.map((i) => this._update(i))).then((i) => ib(this, i))
      )
    }
    stop(n) {
      const { to: e } = this.animation
      return (
        this._focus(this.get()),
        cg(this._state, n && this._lastCallId),
        dn.batchedUpdates(() => this._stop(e, n)),
        this
      )
    }
    reset() {
      this._update({ reset: !0 })
    }
    eventObserved(n) {
      n.type == 'change'
        ? this._start()
        : n.type == 'priority' && (this.priority = n.priority + 1)
    }
    _prepareNode(n) {
      const e = this.key || ''
      let { to: t, from: i } = n
      ;(t = dt.obj(t) ? t[e] : t),
        (t == null || eM(t)) && (t = void 0),
        (i = dt.obj(i) ? i[e] : i),
        i == null && (i = void 0)
      const r = { to: t, from: i }
      return (
        Rw(this) ||
          (n.reverse && ([t, i] = [i, t]),
          (i = ro(i)),
          dt.und(i) ? fa(this) || this._set(t) : this._set(i)),
        r
      )
    }
    _update({ ...n }, e) {
      const { key: t, defaultProps: i } = this
      n.default &&
        Object.assign(
          i,
          nb(n, (o, a) => (/^on/.test(a) ? _D(o, t) : o)),
        ),
        Q2(this, n, 'onProps'),
        Zp(this, 'onProps', n, this)
      const r = this._prepareNode(n)
      if (Object.isFrozen(this))
        throw Error(
          'Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?',
        )
      const s = this._state
      return MD(++this._lastCallId, {
        key: t,
        props: n,
        defaultProps: i,
        state: s,
        actions: {
          pause: () => {
            qp(this) ||
              (Z2(this, !0),
              am(s.pauseQueue),
              Zp(this, 'onPause', Ho(this, Yp(this, this.animation.to)), this))
          },
          resume: () => {
            qp(this) &&
              (Z2(this, !1),
              gc(this) && this._resume(),
              am(s.resumeQueue),
              Zp(this, 'onResume', Ho(this, Yp(this, this.animation.to)), this))
          },
          start: this._merge.bind(this, r),
        },
      }).then((o) => {
        if (n.loop && o.finished && !(e && o.noop)) {
          const a = AD(n)
          if (a) return this._update(a, !0)
        }
        return o
      })
    }
    _merge(n, e, t) {
      if (e.cancel) return this.stop(!0), t(dh(this))
      const i = !dt.und(n.to),
        r = !dt.und(n.from)
      if (i || r)
        if (e.callId > this._lastToId) this._lastToId = e.callId
        else return t(dh(this))
      const { key: s, defaultProps: o, animation: a } = this,
        { to: c, from: u } = a
      let { to: h = c, from: m = u } = n
      r && !i && (!e.default || dt.und(h)) && (h = m),
        e.reverse && ([h, m] = [m, h])
      const g = !gl(m, u)
      g && (a.from = m), (m = ro(m))
      const y = !gl(h, c)
      y && this._focus(h)
      const _ = eM(e.to),
        { config: M } = a,
        { decay: w, velocity: x } = M
      ;(i || r) && (M.velocity = 0),
        e.config &&
          !_ &&
          SW(
            M,
            Zu(e.config, s),
            e.config !== o.config ? Zu(o.config, s) : void 0,
          )
      let T = fa(this)
      if (!T || dt.und(h)) return t(Ho(this, !0))
      const A = dt.und(e.reset)
          ? r && !e.default
          : !dt.und(m) && Am(e.reset, s),
        P = A ? m : this.get(),
        D = lg(h),
        O = dt.num(D) || dt.arr(D) || M_(D),
        U = !_ && (!O || Am(o.immediate || e.immediate, s))
      if (y) {
        const z = JS(h)
        if (z !== T.constructor)
          if (U) T = this._set(D)
          else
            throw Error(
              `Cannot animate between ${T.constructor.name} and ${z.name}, as the "to" prop suggests`,
            )
      }
      const F = T.constructor
      let N = pa(h),
        k = !1
      if (!N) {
        const z = A || (!Rw(this) && g)
        ;(y || z) && ((k = gl(lg(P), D)), (N = !k)),
          ((!gl(a.immediate, U) && !U) ||
            !gl(M.decay, w) ||
            !gl(M.velocity, x)) &&
            (N = !0)
      }
      if (
        (k && gc(this) && (a.changed && !A ? (N = !0) : N || this._stop(c)),
        !_ &&
          ((N || pa(c)) &&
            ((a.values = T.getPayload()),
            (a.toValues = pa(h) ? null : F == ag ? [1] : co(D))),
          a.immediate != U && ((a.immediate = U), !U && !A && this._set(c)),
          N))
      ) {
        const { onRest: z } = a
        Fn(AW, (te) => Q2(this, e, te))
        const $ = Ho(this, Yp(this, c))
        am(this._pendingCalls, $),
          this._pendingCalls.add(t),
          a.changed &&
            dn.batchedUpdates(() => {
              var te
              ;(a.changed = !A),
                z == null || z($, this),
                A
                  ? Zu(o.onRest, $)
                  : (te = a.onStart) == null || te.call(a, $, this)
            })
      }
      A && this._set(P),
        _
          ? t(bD(e.to, e, this._state, this))
          : N
          ? this._start()
          : gc(this) && !y
          ? this._pendingCalls.add(t)
          : t(ED(P))
    }
    _focus(n) {
      const e = this.animation
      n !== e.to &&
        (B2(this) && this._detach(), (e.to = n), B2(this) && this._attach())
    }
    _attach() {
      let n = 0
      const { to: e } = this.animation
      pa(e) && (Gg(e, this), nM(e) && (n = e.priority + 1)), (this.priority = n)
    }
    _detach() {
      const { to: n } = this.animation
      pa(n) && wx(n, this)
    }
    _set(n, e = !0) {
      const t = ro(n)
      if (!dt.und(t)) {
        const i = fa(this)
        if (!i || !gl(t, i.getValue())) {
          const r = JS(t)
          !i || i.constructor != r ? eb(this, r.create(t)) : i.setValue(t),
            i &&
              dn.batchedUpdates(() => {
                this._onChange(t, e)
              })
        }
      }
      return fa(this)
    }
    _onStart() {
      const n = this.animation
      n.changed ||
        ((n.changed = !0), Zp(this, 'onStart', Ho(this, Yp(this, n.to)), this))
    }
    _onChange(n, e) {
      e || (this._onStart(), Zu(this.animation.onChange, n, this)),
        Zu(this.defaultProps.onChange, n, this),
        super._onChange(n, e)
    }
    _start() {
      const n = this.animation
      fa(this).reset(ro(n.to)),
        n.immediate || (n.fromValues = n.values.map((e) => e.lastPosition)),
        gc(this) || (Y2(this, !0), qp(this) || this._resume())
    }
    _resume() {
      Xo.skipAnimation ? this.finish() : __.start(this)
    }
    _stop(n, e) {
      if (gc(this)) {
        Y2(this, !1)
        const t = this.animation
        Fn(t.values, (r) => {
          r.done = !0
        }),
          t.toValues && (t.onChange = t.onPause = t.onResume = void 0),
          _x(this, { type: 'idle', parent: this })
        const i = e ? dh(this.get()) : Ho(this.get(), Yp(this, n ?? t.to))
        am(this._pendingCalls, i),
          t.changed && ((t.changed = !1), Zp(this, 'onRest', i, this))
      }
    }
  }
function Yp(n, e) {
  const t = lg(e),
    i = lg(n.get())
  return gl(i, t)
}
function AD(n, e = n.loop, t = n.to) {
  const i = Zu(e)
  if (i) {
    const r = i !== !0 && SD(i),
      s = (r || n).reverse,
      o = !r || r.reset
    return ug({
      ...n,
      loop: e,
      default: !1,
      pause: void 0,
      to: !s || eM(t) ? t : void 0,
      from: o ? n.from : void 0,
      reset: o,
      ...r,
    })
  }
}
function ug(n) {
  const { to: e, from: t } = (n = SD(n)),
    i = new Set()
  return (
    dt.obj(e) && K2(e, i),
    dt.obj(t) && K2(t, i),
    (n.keys = i.size ? Array.from(i) : null),
    n
  )
}
function TW(n) {
  const e = ug(n)
  return dt.und(e.default) && (e.default = nb(e)), e
}
function K2(n, e) {
  Al(n, (t, i) => t != null && e.add(i))
}
var AW = ['onStart', 'onRest', 'onChange', 'onPause', 'onResume']
function Q2(n, e, t) {
  n.animation[t] = e[t] !== wD(e, t) ? _D(e[t], n.key) : void 0
}
function Zp(n, e, ...t) {
  var i, r, s, o
  ;(r = (i = n.animation)[e]) == null || r.call(i, ...t),
    (o = (s = n.defaultProps)[e]) == null || o.call(s, ...t)
}
var CW = ['onStart', 'onChange', 'onRest'],
  PW = 1,
  RW = class {
    constructor(n, e) {
      ;(this.id = PW++),
        (this.springs = {}),
        (this.queue = []),
        (this._lastAsyncId = 0),
        (this._active = new Set()),
        (this._changed = new Set()),
        (this._started = !1),
        (this._state = {
          paused: !1,
          pauseQueue: new Set(),
          resumeQueue: new Set(),
          timeouts: new Set(),
        }),
        (this._events = {
          onStart: new Map(),
          onChange: new Map(),
          onRest: new Map(),
        }),
        (this._onFrame = this._onFrame.bind(this)),
        e && (this._flush = e),
        n && this.start({ default: !0, ...n })
    }
    get idle() {
      return (
        !this._state.asyncTo &&
        Object.values(this.springs).every(
          (n) => n.idle && !n.isDelayed && !n.isPaused,
        )
      )
    }
    get item() {
      return this._item
    }
    set item(n) {
      this._item = n
    }
    get() {
      const n = {}
      return this.each((e, t) => (n[t] = e.get())), n
    }
    set(n) {
      for (const e in n) {
        const t = n[e]
        dt.und(t) || this.springs[e].set(t)
      }
    }
    update(n) {
      return n && this.queue.push(ug(n)), this
    }
    start(n) {
      let { queue: e } = this
      return (
        n ? (e = co(n).map(ug)) : (this.queue = []),
        this._flush ? this._flush(this, e) : (LD(this, e), sM(this, e))
      )
    }
    stop(n, e) {
      if ((n !== !!n && (e = n), e)) {
        const t = this.springs
        Fn(co(e), (i) => t[i].stop(!!n))
      } else cg(this._state, this._lastAsyncId), this.each((t) => t.stop(!!n))
      return this
    }
    pause(n) {
      if (dt.und(n)) this.start({ pause: !0 })
      else {
        const e = this.springs
        Fn(co(n), (t) => e[t].pause())
      }
      return this
    }
    resume(n) {
      if (dt.und(n)) this.start({ pause: !1 })
      else {
        const e = this.springs
        Fn(co(n), (t) => e[t].resume())
      }
      return this
    }
    each(n) {
      Al(this.springs, n)
    }
    _onFrame() {
      const { onStart: n, onChange: e, onRest: t } = this._events,
        i = this._active.size > 0,
        r = this._changed.size > 0
      ;((i && !this._started) || (r && !this._started)) &&
        ((this._started = !0),
        bm(n, ([a, c]) => {
          ;(c.value = this.get()), a(c, this, this._item)
        }))
      const s = !i && this._started,
        o = r || (s && t.size) ? this.get() : null
      r &&
        e.size &&
        bm(e, ([a, c]) => {
          ;(c.value = o), a(c, this, this._item)
        }),
        s &&
          ((this._started = !1),
          bm(t, ([a, c]) => {
            ;(c.value = o), a(c, this, this._item)
          }))
    }
    eventObserved(n) {
      if (n.type == 'change')
        this._changed.add(n.parent), n.idle || this._active.add(n.parent)
      else if (n.type == 'idle') this._active.delete(n.parent)
      else return
      dn.onFrame(this._onFrame)
    }
  }
function sM(n, e) {
  return Promise.all(e.map((t) => CD(n, t))).then((t) => ib(n, t))
}
async function CD(n, e, t) {
  const { keys: i, to: r, from: s, loop: o, onRest: a, onResolve: c } = e,
    u = dt.obj(e.default) && e.default
  o && (e.loop = !1), r === !1 && (e.to = null), s === !1 && (e.from = null)
  const h = dt.arr(r) || dt.fun(r) ? r : void 0
  h
    ? ((e.to = void 0), (e.onRest = void 0), u && (u.onRest = void 0))
    : Fn(CW, (M) => {
        const w = e[M]
        if (dt.fun(w)) {
          const x = n._events[M]
          ;(e[M] = ({ finished: T, cancelled: A }) => {
            const P = x.get(w)
            P
              ? (T || (P.finished = !1), A && (P.cancelled = !0))
              : x.set(w, { value: null, finished: T || !1, cancelled: A || !1 })
          }),
            u && (u[M] = e[M])
        }
      })
  const m = n._state
  e.pause === !m.paused
    ? ((m.paused = e.pause), am(e.pause ? m.pauseQueue : m.resumeQueue))
    : m.paused && (e.pause = !0)
  const g = (i || Object.keys(n.springs)).map((M) => n.springs[M].start(e)),
    y = e.cancel === !0 || wD(e, 'cancel') === !0
  ;(h || (y && m.asyncId)) &&
    g.push(
      MD(++n._lastAsyncId, {
        props: e,
        state: m,
        actions: {
          pause: KS,
          resume: KS,
          start(M, w) {
            y
              ? (cg(m, n._lastAsyncId), w(dh(n)))
              : ((M.onRest = a), w(bD(h, M, m, n)))
          },
        },
      }),
    ),
    m.paused &&
      (await new Promise((M) => {
        m.resumeQueue.add(M)
      }))
  const _ = ib(n, await Promise.all(g))
  if (o && _.finished && !(t && _.noop)) {
    const M = AD(e, o, r)
    if (M) return LD(n, [M]), CD(n, M, !0)
  }
  return c && dn.batchedUpdates(() => c(_, n, n.item)), _
}
function J2(n, e) {
  const t = { ...n.springs }
  return (
    e &&
      Fn(co(e), (i) => {
        dt.und(i.keys) && (i = ug(i)),
          dt.obj(i.to) || (i = { ...i, to: void 0 }),
          ID(t, i, (r) => RD(r))
      }),
    PD(n, t),
    t
  )
}
function PD(n, e) {
  Al(e, (t, i) => {
    n.springs[i] || ((n.springs[i] = t), Gg(t, n))
  })
}
function RD(n, e) {
  const t = new bW()
  return (t.key = n), e && Gg(t, e), t
}
function ID(n, e, t) {
  e.keys &&
    Fn(e.keys, (i) => {
      ;(n[i] || (n[i] = t(i)))._prepareNode(e)
    })
}
function LD(n, e) {
  Fn(e, (t) => {
    ID(n.springs, t, (i) => RD(i, n))
  })
}
var b_ = ({ children: n, ...e }) => {
    const t = X.useContext(Mx),
      i = e.pause || !!t.pause,
      r = e.immediate || !!t.immediate
    e = rW(() => ({ pause: i, immediate: r }), [i, r])
    const { Provider: s } = Mx
    return X.createElement(s, { value: e }, n)
  },
  Mx = IW(b_, {})
b_.Provider = Mx.Provider
b_.Consumer = Mx.Consumer
function IW(n, e) {
  return (
    Object.assign(n, X.createContext(e)),
    (n.Provider._context = n),
    (n.Consumer._context = n),
    n
  )
}
var LW = () => {
  const n = [],
    e = function (i) {
      nW()
      const r = []
      return (
        Fn(n, (s, o) => {
          if (dt.und(i)) r.push(s.start())
          else {
            const a = t(i, s, o)
            a && r.push(s.start(a))
          }
        }),
        r
      )
    }
  ;(e.current = n),
    (e.add = function (i) {
      n.includes(i) || n.push(i)
    }),
    (e.delete = function (i) {
      const r = n.indexOf(i)
      ~r && n.splice(r, 1)
    }),
    (e.pause = function () {
      return Fn(n, (i) => i.pause(...arguments)), this
    }),
    (e.resume = function () {
      return Fn(n, (i) => i.resume(...arguments)), this
    }),
    (e.set = function (i) {
      Fn(n, (r, s) => {
        const o = dt.fun(i) ? i(s, r) : i
        o && r.set(o)
      })
    }),
    (e.start = function (i) {
      const r = []
      return (
        Fn(n, (s, o) => {
          if (dt.und(i)) r.push(s.start())
          else {
            const a = this._getProps(i, s, o)
            a && r.push(s.start(a))
          }
        }),
        r
      )
    }),
    (e.stop = function () {
      return Fn(n, (i) => i.stop(...arguments)), this
    }),
    (e.update = function (i) {
      return Fn(n, (r, s) => r.update(this._getProps(i, r, s))), this
    })
  const t = function (i, r, s) {
    return dt.fun(i) ? i(s, r) : i
  }
  return (e._getProps = t), e
}
function NW(n, e, t) {
  const i = dt.fun(e) && e
  i && !t && (t = [])
  const r = X.useMemo(() => (i || arguments.length == 3 ? LW() : void 0), []),
    s = X.useRef(0),
    o = gD(),
    a = X.useMemo(
      () => ({
        ctrls: [],
        queue: [],
        flush(x, T) {
          const A = J2(x, T)
          return s.current > 0 &&
            !a.queue.length &&
            !Object.keys(A).some((D) => !x.springs[D])
            ? sM(x, T)
            : new Promise((D) => {
                PD(x, A),
                  a.queue.push(() => {
                    D(sM(x, T))
                  }),
                  o()
              })
        },
      }),
      [],
    ),
    c = X.useRef([...a.ctrls]),
    u = [],
    h = V2(n) || 0
  X.useMemo(() => {
    Fn(c.current.slice(n, h), (x) => {
      yW(x, r), x.stop(!0)
    }),
      (c.current.length = n),
      m(h, n)
  }, [n]),
    X.useMemo(() => {
      m(0, Math.min(h, n))
    }, t)
  function m(x, T) {
    for (let A = x; A < T; A++) {
      const P = c.current[A] || (c.current[A] = new RW(null, a.flush)),
        D = i ? i(A, P) : e[A]
      D && (u[A] = TW(D))
    }
  }
  const g = c.current.map((x, T) => J2(x, u[T])),
    y = X.useContext(b_),
    _ = V2(y),
    M = y !== _ && vW(y)
  JE(() => {
    s.current++, (a.ctrls = c.current)
    const { queue: x } = a
    x.length && ((a.queue = []), Fn(x, (T) => T())),
      Fn(c.current, (T, A) => {
        r == null || r.add(T), M && T.start({ default: y })
        const P = u[A]
        P && (xW(T, P.ref), T.ref ? T.queue.push(P) : T.start(P))
      })
  }),
    vD(() => () => {
      Fn(a.ctrls, (x) => x.stop(!0))
    })
  const w = g.map((x) => ({ ...x }))
  return r ? [w, r] : w
}
function DW(n, e) {
  const t = dt.fun(n),
    [[i], r] = NW(1, t ? n : [n], e)
  return t || arguments.length == 2 ? [i, r] : i
}
var OW = class extends rb {
  constructor(n, e) {
    super(),
      (this.source = n),
      (this.idle = !0),
      (this._active = new Set()),
      (this.calc = rg(...e))
    const t = this._get(),
      i = JS(t)
    eb(this, i.create(t))
  }
  advance(n) {
    const e = this._get(),
      t = this.get()
    gl(e, t) || (fa(this).setValue(e), this._onChange(e, this.idle)),
      !this.idle && eP(this._active) && Iw(this)
  }
  _get() {
    const n = dt.arr(this.source) ? this.source.map(ro) : co(ro(this.source))
    return this.calc(...n)
  }
  _start() {
    this.idle &&
      !eP(this._active) &&
      ((this.idle = !1),
      Fn(E_(this), (n) => {
        n.done = !1
      }),
      Xo.skipAnimation
        ? (dn.batchedUpdates(() => this.advance()), Iw(this))
        : __.start(this))
  }
  _attach() {
    let n = 1
    Fn(co(this.source), (e) => {
      pa(e) && Gg(e, this),
        nM(e) &&
          (e.idle || this._active.add(e), (n = Math.max(n, e.priority + 1)))
    }),
      (this.priority = n),
      this._start()
  }
  _detach() {
    Fn(co(this.source), (n) => {
      pa(n) && wx(n, this)
    }),
      this._active.clear(),
      Iw(this)
  }
  eventObserved(n) {
    n.type == 'change'
      ? n.idle
        ? this.advance()
        : (this._active.add(n.parent), this._start())
      : n.type == 'idle'
      ? this._active.delete(n.parent)
      : n.type == 'priority' &&
        (this.priority = co(this.source).reduce(
          (e, t) => Math.max(e, (nM(t) ? t.priority : 0) + 1),
          0,
        ))
  }
}
function kW(n) {
  return n.idle !== !1
}
function eP(n) {
  return !n.size || Array.from(n).every(kW)
}
function Iw(n) {
  n.idle ||
    ((n.idle = !0),
    Fn(E_(n), (e) => {
      e.done = !0
    }),
    _x(n, { type: 'idle', parent: n }))
}
Xo.assign({ createStringInterpolator: pD, to: (n, e) => new OW(n, e) })
var FW = ['primitive'].concat(
  Object.keys(ON)
    .filter((n) => /^[A-Z]/.test(n))
    .map((n) => n[0].toLowerCase() + n.slice(1)),
)
Xo.assign({ createStringInterpolator: pD, colors: L9, frameLoop: 'demand' })
QG(() => {
  dn.advance()
})
var UW = fW(FW, { applyAnimatedValues: ha }),
  tP = UW.animated
const ND = parseInt(Eg.replace(/\D+/g, ''))
var lo = Uint8Array,
  bc = Uint16Array,
  oM = Uint32Array,
  DD = new lo([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  OD = new lo([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  BW = new lo([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  kD = function (n, e) {
    for (var t = new bc(31), i = 0; i < 31; ++i) t[i] = e += 1 << n[i - 1]
    for (var r = new oM(t[30]), i = 1; i < 30; ++i)
      for (var s = t[i]; s < t[i + 1]; ++s) r[s] = ((s - t[i]) << 5) | i
    return [t, r]
  },
  FD = kD(DD, 2),
  UD = FD[0],
  zW = FD[1]
;(UD[28] = 258), (zW[258] = 28)
var VW = kD(OD, 0),
  jW = VW[0],
  aM = new bc(32768)
for (var ii = 0; ii < 32768; ++ii) {
  var vc = ((ii & 43690) >>> 1) | ((ii & 21845) << 1)
  ;(vc = ((vc & 52428) >>> 2) | ((vc & 13107) << 2)),
    (vc = ((vc & 61680) >>> 4) | ((vc & 3855) << 4)),
    (aM[ii] = (((vc & 65280) >>> 8) | ((vc & 255) << 8)) >>> 1)
}
var Cm = function (n, e, t) {
    for (var i = n.length, r = 0, s = new bc(e); r < i; ++r) ++s[n[r] - 1]
    var o = new bc(e)
    for (r = 0; r < e; ++r) o[r] = (o[r - 1] + s[r - 1]) << 1
    var a
    if (t) {
      a = new bc(1 << e)
      var c = 15 - e
      for (r = 0; r < i; ++r)
        if (n[r])
          for (
            var u = (r << 4) | n[r],
              h = e - n[r],
              m = o[n[r] - 1]++ << h,
              g = m | ((1 << h) - 1);
            m <= g;
            ++m
          )
            a[aM[m] >>> c] = u
    } else
      for (a = new bc(i), r = 0; r < i; ++r)
        n[r] && (a[r] = aM[o[n[r] - 1]++] >>> (15 - n[r]))
    return a
  },
  $g = new lo(288)
for (var ii = 0; ii < 144; ++ii) $g[ii] = 8
for (var ii = 144; ii < 256; ++ii) $g[ii] = 9
for (var ii = 256; ii < 280; ++ii) $g[ii] = 7
for (var ii = 280; ii < 288; ++ii) $g[ii] = 8
var BD = new lo(32)
for (var ii = 0; ii < 32; ++ii) BD[ii] = 5
var HW = Cm($g, 9, 1),
  GW = Cm(BD, 5, 1),
  Lw = function (n) {
    for (var e = n[0], t = 1; t < n.length; ++t) n[t] > e && (e = n[t])
    return e
  },
  Uo = function (n, e, t) {
    var i = (e / 8) | 0
    return ((n[i] | (n[i + 1] << 8)) >> (e & 7)) & t
  },
  Nw = function (n, e) {
    var t = (e / 8) | 0
    return (n[t] | (n[t + 1] << 8) | (n[t + 2] << 16)) >> (e & 7)
  },
  WW = function (n) {
    return ((n / 8) | 0) + (n & 7 && 1)
  },
  $W = function (n, e, t) {
    ;(t == null || t > n.length) && (t = n.length)
    var i = new (n instanceof bc ? bc : n instanceof oM ? oM : lo)(t - e)
    return i.set(n.subarray(e, t)), i
  },
  XW = function (n, e, t) {
    var i = n.length
    if (!i || (t && !t.l && i < 5)) return e || new lo(0)
    var r = !e || t,
      s = !t || t.i
    t || (t = {}), e || (e = new lo(i * 3))
    var o = function (Te) {
        var Pe = e.length
        if (Te > Pe) {
          var Be = new lo(Math.max(Pe * 2, Te))
          Be.set(e), (e = Be)
        }
      },
      a = t.f || 0,
      c = t.p || 0,
      u = t.b || 0,
      h = t.l,
      m = t.d,
      g = t.m,
      y = t.n,
      _ = i * 8
    do {
      if (!h) {
        t.f = a = Uo(n, c, 1)
        var M = Uo(n, c + 1, 3)
        if (((c += 3), M))
          if (M == 1) (h = HW), (m = GW), (g = 9), (y = 5)
          else if (M == 2) {
            var A = Uo(n, c, 31) + 257,
              P = Uo(n, c + 10, 15) + 4,
              D = A + Uo(n, c + 5, 31) + 1
            c += 14
            for (var O = new lo(D), U = new lo(19), F = 0; F < P; ++F)
              U[BW[F]] = Uo(n, c + F * 3, 7)
            c += P * 3
            for (
              var N = Lw(U), k = (1 << N) - 1, z = Cm(U, N, 1), F = 0;
              F < D;

            ) {
              var $ = z[Uo(n, c, k)]
              c += $ & 15
              var w = $ >>> 4
              if (w < 16) O[F++] = w
              else {
                var te = 0,
                  j = 0
                for (
                  w == 16
                    ? ((j = 3 + Uo(n, c, 3)), (c += 2), (te = O[F - 1]))
                    : w == 17
                    ? ((j = 3 + Uo(n, c, 7)), (c += 3))
                    : w == 18 && ((j = 11 + Uo(n, c, 127)), (c += 7));
                  j--;

                )
                  O[F++] = te
              }
            }
            var K = O.subarray(0, A),
              J = O.subarray(A)
            ;(g = Lw(K)), (y = Lw(J)), (h = Cm(K, g, 1)), (m = Cm(J, y, 1))
          } else throw 'invalid block type'
        else {
          var w = WW(c) + 4,
            x = n[w - 4] | (n[w - 3] << 8),
            T = w + x
          if (T > i) {
            if (s) throw 'unexpected EOF'
            break
          }
          r && o(u + x),
            e.set(n.subarray(w, T), u),
            (t.b = u += x),
            (t.p = c = T * 8)
          continue
        }
        if (c > _) {
          if (s) throw 'unexpected EOF'
          break
        }
      }
      r && o(u + 131072)
      for (var ne = (1 << g) - 1, V = (1 << y) - 1, Y = c; ; Y = c) {
        var te = h[Nw(n, c) & ne],
          Q = te >>> 4
        if (((c += te & 15), c > _)) {
          if (s) throw 'unexpected EOF'
          break
        }
        if (!te) throw 'invalid length/literal'
        if (Q < 256) e[u++] = Q
        else if (Q == 256) {
          ;(Y = c), (h = null)
          break
        } else {
          var q = Q - 254
          if (Q > 264) {
            var F = Q - 257,
              oe = DD[F]
            ;(q = Uo(n, c, (1 << oe) - 1) + UD[F]), (c += oe)
          }
          var _e = m[Nw(n, c) & V],
            he = _e >>> 4
          if (!_e) throw 'invalid distance'
          c += _e & 15
          var J = jW[he]
          if (he > 3) {
            var oe = OD[he]
            ;(J += Nw(n, c) & ((1 << oe) - 1)), (c += oe)
          }
          if (c > _) {
            if (s) throw 'unexpected EOF'
            break
          }
          r && o(u + 131072)
          for (var Ce = u + q; u < Ce; u += 4)
            (e[u] = e[u - J]),
              (e[u + 1] = e[u + 1 - J]),
              (e[u + 2] = e[u + 2 - J]),
              (e[u + 3] = e[u + 3 - J])
          u = Ce
        }
      }
      ;(t.l = h),
        (t.p = Y),
        (t.b = u),
        h && ((a = 1), (t.m = g), (t.d = m), (t.n = y))
    } while (!a)
    return u == e.length ? e : $W(e, 0, u)
  },
  qW = new lo(0),
  YW = function (n) {
    if ((n[0] & 15) != 8 || n[0] >>> 4 > 7 || ((n[0] << 8) | n[1]) % 31)
      throw 'invalid zlib data'
    if (n[1] & 32) throw 'invalid zlib data: preset dictionaries not supported'
  }
function q0(n, e) {
  return XW((YW(n), n.subarray(2, -4)), e)
}
var ZW = typeof TextDecoder < 'u' && new TextDecoder(),
  KW = 0
try {
  ZW.decode(qW, { stream: !0 }), (KW = 1)
} catch {}
const QW = (n) => n && n.isCubeTexture
class JW extends vi {
  constructor(e, t) {
    var i, r
    const s = QW(e),
      a =
        ((r = s
          ? (i = e.image[0]) == null
            ? void 0
            : i.width
          : e.image.width) != null
          ? r
          : 1024) / 4,
      c = Math.floor(Math.log2(a)),
      u = Math.pow(2, c),
      h = 3 * Math.max(u, 16 * 7),
      m = 4 * u,
      g = [
        s ? '#define ENVMAP_TYPE_CUBE' : '',
        `#define CUBEUV_TEXEL_WIDTH ${1 / h}`,
        `#define CUBEUV_TEXEL_HEIGHT ${1 / m}`,
        `#define CUBEUV_MAX_MIP ${c}.0`,
      ],
      y = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
      _ =
        g.join(`
`) +
        `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${
              ND >= 154 ? 'colorspace_fragment' : 'encodings_fragment'
            }>
        }
        `,
      M = {
        map: { value: e },
        height: { value: (t == null ? void 0 : t.height) || 15 },
        radius: { value: (t == null ? void 0 : t.radius) || 100 },
      },
      w = new Og(1, 16),
      x = new ws({ uniforms: M, fragmentShader: _, vertexShader: y, side: oo })
    super(w, x)
  }
  set radius(e) {
    this.material.uniforms.radius.value = e
  }
  get radius() {
    return this.material.uniforms.radius.value
  }
  set height(e) {
    this.material.uniforms.height.value = e
  }
  get height() {
    return this.material.uniforms.height.value
  }
}
class e7 extends CE {
  constructor(e) {
    super(e), (this.type = or)
  }
  parse(e) {
    const o = function (F, N) {
        switch (F) {
          case 1:
            throw new Error('THREE.RGBELoader: Read Error: ' + (N || ''))
          case 2:
            throw new Error('THREE.RGBELoader: Write Error: ' + (N || ''))
          case 3:
            throw new Error('THREE.RGBELoader: Bad File Format: ' + (N || ''))
          default:
          case 4:
            throw new Error('THREE.RGBELoader: Memory Error: ' + (N || ''))
        }
      },
      h = `
`,
      m = function (F, N, k) {
        N = N || 1024
        let $ = F.pos,
          te = -1,
          j = 0,
          K = '',
          J = String.fromCharCode.apply(
            null,
            new Uint16Array(F.subarray($, $ + 128)),
          )
        for (; 0 > (te = J.indexOf(h)) && j < N && $ < F.byteLength; )
          (K += J),
            (j += J.length),
            ($ += 128),
            (J += String.fromCharCode.apply(
              null,
              new Uint16Array(F.subarray($, $ + 128)),
            ))
        return -1 < te ? ((F.pos += j + te + 1), K + J.slice(0, te)) : !1
      },
      g = function (F) {
        const N = /^#\?(\S+)/,
          k = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          z = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          $ = /^\s*FORMAT=(\S+)\s*$/,
          te = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          j = {
            valid: 0,
            string: '',
            comments: '',
            programtype: 'RGBE',
            format: '',
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          }
        let K, J
        for (
          (F.pos >= F.byteLength || !(K = m(F))) && o(1, 'no header found'),
            (J = K.match(N)) || o(3, 'bad initial token'),
            j.valid |= 1,
            j.programtype = J[1],
            j.string +=
              K +
              `
`;
          (K = m(F)), K !== !1;

        ) {
          if (
            ((j.string +=
              K +
              `
`),
            K.charAt(0) === '#')
          ) {
            j.comments +=
              K +
              `
`
            continue
          }
          if (
            ((J = K.match(k)) && (j.gamma = parseFloat(J[1])),
            (J = K.match(z)) && (j.exposure = parseFloat(J[1])),
            (J = K.match($)) && ((j.valid |= 2), (j.format = J[1])),
            (J = K.match(te)) &&
              ((j.valid |= 4),
              (j.height = parseInt(J[1], 10)),
              (j.width = parseInt(J[2], 10))),
            j.valid & 2 && j.valid & 4)
          )
            break
        }
        return (
          j.valid & 2 || o(3, 'missing format specifier'),
          j.valid & 4 || o(3, 'missing image size specifier'),
          j
        )
      },
      y = function (F, N, k) {
        const z = N
        if (z < 8 || z > 32767 || F[0] !== 2 || F[1] !== 2 || F[2] & 128)
          return new Uint8Array(F)
        z !== ((F[2] << 8) | F[3]) && o(3, 'wrong scanline width')
        const $ = new Uint8Array(4 * N * k)
        $.length || o(4, 'unable to allocate buffer space')
        let te = 0,
          j = 0
        const K = 4 * z,
          J = new Uint8Array(4),
          ne = new Uint8Array(K)
        let V = k
        for (; V > 0 && j < F.byteLength; ) {
          j + 4 > F.byteLength && o(1),
            (J[0] = F[j++]),
            (J[1] = F[j++]),
            (J[2] = F[j++]),
            (J[3] = F[j++]),
            (J[0] != 2 || J[1] != 2 || ((J[2] << 8) | J[3]) != z) &&
              o(3, 'bad rgbe scanline format')
          let Y = 0,
            Q
          for (; Y < K && j < F.byteLength; ) {
            Q = F[j++]
            const oe = Q > 128
            if (
              (oe && (Q -= 128),
              (Q === 0 || Y + Q > K) && o(3, 'bad scanline data'),
              oe)
            ) {
              const _e = F[j++]
              for (let he = 0; he < Q; he++) ne[Y++] = _e
            } else ne.set(F.subarray(j, j + Q), Y), (Y += Q), (j += Q)
          }
          const q = z
          for (let oe = 0; oe < q; oe++) {
            let _e = 0
            ;($[te] = ne[oe + _e]),
              (_e += z),
              ($[te + 1] = ne[oe + _e]),
              (_e += z),
              ($[te + 2] = ne[oe + _e]),
              (_e += z),
              ($[te + 3] = ne[oe + _e]),
              (te += 4)
          }
          V--
        }
        return $
      },
      _ = function (F, N, k, z) {
        const $ = F[N + 3],
          te = Math.pow(2, $ - 128) / 255
        ;(k[z + 0] = F[N + 0] * te),
          (k[z + 1] = F[N + 1] * te),
          (k[z + 2] = F[N + 2] * te),
          (k[z + 3] = 1)
      },
      M = function (F, N, k, z) {
        const $ = F[N + 3],
          te = Math.pow(2, $ - 128) / 255
        ;(k[z + 0] = td.toHalfFloat(Math.min(F[N + 0] * te, 65504))),
          (k[z + 1] = td.toHalfFloat(Math.min(F[N + 1] * te, 65504))),
          (k[z + 2] = td.toHalfFloat(Math.min(F[N + 2] * te, 65504))),
          (k[z + 3] = td.toHalfFloat(1))
      },
      w = new Uint8Array(e)
    w.pos = 0
    const x = g(w),
      T = x.width,
      A = x.height,
      P = y(w.subarray(w.pos), T, A)
    let D, O, U
    switch (this.type) {
      case gi:
        U = P.length / 4
        const F = new Float32Array(U * 4)
        for (let k = 0; k < U; k++) _(P, k * 4, F, k * 4)
        ;(D = F), (O = gi)
        break
      case or:
        U = P.length / 4
        const N = new Uint16Array(U * 4)
        for (let k = 0; k < U; k++) M(P, k * 4, N, k * 4)
        ;(D = N), (O = or)
        break
      default:
        throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type)
    }
    return {
      width: T,
      height: A,
      data: D,
      header: x.string,
      gamma: x.gamma,
      exposure: x.exposure,
      type: O,
    }
  }
  setDataType(e) {
    return (this.type = e), this
  }
  load(e, t, i, r) {
    function s(o, a) {
      switch (o.type) {
        case gi:
        case or:
          'colorSpace' in o
            ? (o.colorSpace = 'srgb-linear')
            : (o.encoding = 3e3),
            (o.minFilter = Vn),
            (o.magFilter = Vn),
            (o.generateMipmaps = !1),
            (o.flipY = !0)
          break
      }
      t && t(o, a)
    }
    return super.load(e, s, i, r)
  }
}
const Kp = ND >= 152
class t7 extends CE {
  constructor(e) {
    super(e), (this.type = or)
  }
  parse(e) {
    const N = Math.pow(2.7182818, 2.2)
    function k(H, ee) {
      for (var fe = 0, Ae = 0; Ae < 65536; ++Ae)
        (Ae == 0 || H[Ae >> 3] & (1 << (Ae & 7))) && (ee[fe++] = Ae)
      for (var De = fe - 1; fe < 65536; ) ee[fe++] = 0
      return De
    }
    function z(H) {
      for (var ee = 0; ee < 16384; ee++)
        (H[ee] = {}), (H[ee].len = 0), (H[ee].lit = 0), (H[ee].p = null)
    }
    const $ = { l: 0, c: 0, lc: 0 }
    function te(H, ee, fe, Ae, De) {
      for (; fe < H; ) (ee = (ee << 8) | Mt(Ae, De)), (fe += 8)
      ;(fe -= H), ($.l = (ee >> fe) & ((1 << H) - 1)), ($.c = ee), ($.lc = fe)
    }
    const j = new Array(59)
    function K(H) {
      for (var ee = 0; ee <= 58; ++ee) j[ee] = 0
      for (var ee = 0; ee < 65537; ++ee) j[H[ee]] += 1
      for (var fe = 0, ee = 58; ee > 0; --ee) {
        var Ae = (fe + j[ee]) >> 1
        ;(j[ee] = fe), (fe = Ae)
      }
      for (var ee = 0; ee < 65537; ++ee) {
        var De = H[ee]
        De > 0 && (H[ee] = De | (j[De]++ << 6))
      }
    }
    function J(H, ee, fe, Ae, De, Oe, nt) {
      for (var Ze = fe, G = 0, le = 0; De <= Oe; De++) {
        if (Ze.value - fe.value > Ae) return !1
        te(6, G, le, H, Ze)
        var de = $.l
        if (((G = $.c), (le = $.lc), (nt[De] = de), de == 63)) {
          if (Ze.value - fe.value > Ae)
            throw 'Something wrong with hufUnpackEncTable'
          te(8, G, le, H, Ze)
          var ce = $.l + 6
          if (((G = $.c), (le = $.lc), De + ce > Oe + 1))
            throw 'Something wrong with hufUnpackEncTable'
          for (; ce--; ) nt[De++] = 0
          De--
        } else if (de >= 59) {
          var ce = de - 59 + 2
          if (De + ce > Oe + 1) throw 'Something wrong with hufUnpackEncTable'
          for (; ce--; ) nt[De++] = 0
          De--
        }
      }
      K(nt)
    }
    function ne(H) {
      return H & 63
    }
    function V(H) {
      return H >> 6
    }
    function Y(H, ee, fe, Ae) {
      for (; ee <= fe; ee++) {
        var De = V(H[ee]),
          Oe = ne(H[ee])
        if (De >> Oe) throw 'Invalid table entry'
        if (Oe > 14) {
          var nt = Ae[De >> (Oe - 14)]
          if (nt.len) throw 'Invalid table entry'
          if ((nt.lit++, nt.p)) {
            var Ze = nt.p
            nt.p = new Array(nt.lit)
            for (var G = 0; G < nt.lit - 1; ++G) nt.p[G] = Ze[G]
          } else nt.p = new Array(1)
          nt.p[nt.lit - 1] = ee
        } else if (Oe)
          for (var le = 0, G = 1 << (14 - Oe); G > 0; G--) {
            var nt = Ae[(De << (14 - Oe)) + le]
            if (nt.len || nt.p) throw 'Invalid table entry'
            ;(nt.len = Oe), (nt.lit = ee), le++
          }
      }
      return !0
    }
    const Q = { c: 0, lc: 0 }
    function q(H, ee, fe, Ae) {
      ;(H = (H << 8) | Mt(fe, Ae)), (ee += 8), (Q.c = H), (Q.lc = ee)
    }
    const oe = { c: 0, lc: 0 }
    function _e(H, ee, fe, Ae, De, Oe, nt, Ze, G, le) {
      if (H == ee) {
        Ae < 8 && (q(fe, Ae, De, nt), (fe = Q.c), (Ae = Q.lc)), (Ae -= 8)
        var de = fe >> Ae,
          de = new Uint8Array([de])[0]
        if (G.value + de > le) return !1
        for (var ce = Ze[G.value - 1]; de-- > 0; ) Ze[G.value++] = ce
      } else if (G.value < le) Ze[G.value++] = H
      else return !1
      ;(oe.c = fe), (oe.lc = Ae)
    }
    function he(H) {
      return H & 65535
    }
    function Ce(H) {
      var ee = he(H)
      return ee > 32767 ? ee - 65536 : ee
    }
    const Te = { a: 0, b: 0 }
    function Pe(H, ee) {
      var fe = Ce(H),
        Ae = Ce(ee),
        De = Ae,
        Oe = fe + (De & 1) + (De >> 1),
        nt = Oe,
        Ze = Oe - De
      ;(Te.a = nt), (Te.b = Ze)
    }
    function Be(H, ee) {
      var fe = he(H),
        Ae = he(ee),
        De = (fe - (Ae >> 1)) & 65535,
        Oe = (Ae + De - 32768) & 65535
      ;(Te.a = Oe), (Te.b = De)
    }
    function et(H, ee, fe, Ae, De, Oe, nt) {
      for (var Ze = nt < 16384, G = fe > De ? De : fe, le = 1, de; le <= G; )
        le <<= 1
      for (le >>= 1, de = le, le >>= 1; le >= 1; ) {
        for (
          var ce = 0,
            me = ce + Oe * (De - de),
            Me = Oe * le,
            ke = Oe * de,
            He = Ae * le,
            Xe = Ae * de,
            ut,
            ot,
            We,
            pt;
          ce <= me;
          ce += ke
        ) {
          for (var mt = ce, qt = ce + Ae * (fe - de); mt <= qt; mt += Xe) {
            var Lt = mt + He,
              Ot = mt + Me,
              wt = Ot + He
            Ze
              ? (Pe(H[mt + ee], H[Ot + ee]),
                (ut = Te.a),
                (We = Te.b),
                Pe(H[Lt + ee], H[wt + ee]),
                (ot = Te.a),
                (pt = Te.b),
                Pe(ut, ot),
                (H[mt + ee] = Te.a),
                (H[Lt + ee] = Te.b),
                Pe(We, pt),
                (H[Ot + ee] = Te.a),
                (H[wt + ee] = Te.b))
              : (Be(H[mt + ee], H[Ot + ee]),
                (ut = Te.a),
                (We = Te.b),
                Be(H[Lt + ee], H[wt + ee]),
                (ot = Te.a),
                (pt = Te.b),
                Be(ut, ot),
                (H[mt + ee] = Te.a),
                (H[Lt + ee] = Te.b),
                Be(We, pt),
                (H[Ot + ee] = Te.a),
                (H[wt + ee] = Te.b))
          }
          if (fe & le) {
            var Ot = mt + Me
            Ze ? Pe(H[mt + ee], H[Ot + ee]) : Be(H[mt + ee], H[Ot + ee]),
              (ut = Te.a),
              (H[Ot + ee] = Te.b),
              (H[mt + ee] = ut)
          }
        }
        if (De & le)
          for (var mt = ce, qt = ce + Ae * (fe - de); mt <= qt; mt += Xe) {
            var Lt = mt + He
            Ze ? Pe(H[mt + ee], H[Lt + ee]) : Be(H[mt + ee], H[Lt + ee]),
              (ut = Te.a),
              (H[Lt + ee] = Te.b),
              (H[mt + ee] = ut)
          }
        ;(de = le), (le >>= 1)
      }
      return ce
    }
    function ft(H, ee, fe, Ae, De, Oe, nt, Ze, G, le) {
      for (
        var de = 0, ce = 0, me = Ze, Me = Math.trunc(De.value + (Oe + 7) / 8);
        De.value < Me;

      )
        for (q(de, ce, fe, De), de = Q.c, ce = Q.lc; ce >= 14; ) {
          var ke = (de >> (ce - 14)) & 16383,
            He = ee[ke]
          if (He.len)
            (ce -= He.len),
              _e(He.lit, nt, de, ce, fe, Ae, De, G, le, me),
              (de = oe.c),
              (ce = oe.lc)
          else {
            if (!He.p) throw 'hufDecode issues'
            var Xe
            for (Xe = 0; Xe < He.lit; Xe++) {
              for (var ut = ne(H[He.p[Xe]]); ce < ut && De.value < Me; )
                q(de, ce, fe, De), (de = Q.c), (ce = Q.lc)
              if (
                ce >= ut &&
                V(H[He.p[Xe]]) == ((de >> (ce - ut)) & ((1 << ut) - 1))
              ) {
                ;(ce -= ut),
                  _e(He.p[Xe], nt, de, ce, fe, Ae, De, G, le, me),
                  (de = oe.c),
                  (ce = oe.lc)
                break
              }
            }
            if (Xe == He.lit) throw 'hufDecode issues'
          }
        }
      var ot = (8 - Oe) & 7
      for (de >>= ot, ce -= ot; ce > 0; ) {
        var He = ee[(de << (14 - ce)) & 16383]
        if (He.len)
          (ce -= He.len),
            _e(He.lit, nt, de, ce, fe, Ae, De, G, le, me),
            (de = oe.c),
            (ce = oe.lc)
        else throw 'hufDecode issues'
      }
      return !0
    }
    function Vt(H, ee, fe, Ae, De, Oe) {
      var nt = { value: 0 },
        Ze = fe.value,
        G = It(ee, fe),
        le = It(ee, fe)
      fe.value += 4
      var de = It(ee, fe)
      if (((fe.value += 4), G < 0 || G >= 65537 || le < 0 || le >= 65537))
        throw 'Something wrong with HUF_ENCSIZE'
      var ce = new Array(65537),
        me = new Array(16384)
      z(me)
      var Me = Ae - (fe.value - Ze)
      if ((J(H, ee, fe, Me, G, le, ce), de > 8 * (Ae - (fe.value - Ze))))
        throw 'Something wrong with hufUncompress'
      Y(ce, G, le, me), ft(ce, me, H, ee, fe, de, le, Oe, De, nt)
    }
    function je(H, ee, fe) {
      for (var Ae = 0; Ae < fe; ++Ae) ee[Ae] = H[ee[Ae]]
    }
    function $e(H) {
      for (var ee = 1; ee < H.length; ee++) {
        var fe = H[ee - 1] + H[ee] - 128
        H[ee] = fe
      }
    }
    function se(H, ee) {
      for (
        var fe = 0,
          Ae = Math.floor((H.length + 1) / 2),
          De = 0,
          Oe = H.length - 1;
        !(De > Oe || ((ee[De++] = H[fe++]), De > Oe));

      )
        ee[De++] = H[Ae++]
    }
    function Rt(H) {
      for (
        var ee = H.byteLength, fe = new Array(), Ae = 0, De = new DataView(H);
        ee > 0;

      ) {
        var Oe = De.getInt8(Ae++)
        if (Oe < 0) {
          var nt = -Oe
          ee -= nt + 1
          for (var Ze = 0; Ze < nt; Ze++) fe.push(De.getUint8(Ae++))
        } else {
          var nt = Oe
          ee -= 2
          for (var G = De.getUint8(Ae++), Ze = 0; Ze < nt + 1; Ze++) fe.push(G)
        }
      }
      return fe
    }
    function Qe(H, ee, fe, Ae, De, Oe) {
      var Lt = new DataView(Oe.buffer),
        nt = fe[H.idx[0]].width,
        Ze = fe[H.idx[0]].height,
        G = 3,
        le = Math.floor(nt / 8),
        de = Math.ceil(nt / 8),
        ce = Math.ceil(Ze / 8),
        me = nt - (de - 1) * 8,
        Me = Ze - (ce - 1) * 8,
        ke = { value: 0 },
        He = new Array(G),
        Xe = new Array(G),
        ut = new Array(G),
        ot = new Array(G),
        We = new Array(G)
      for (let tn = 0; tn < G; ++tn)
        (We[tn] = ee[H.idx[tn]]),
          (He[tn] = tn < 1 ? 0 : He[tn - 1] + de * ce),
          (Xe[tn] = new Float32Array(64)),
          (ut[tn] = new Uint16Array(64)),
          (ot[tn] = new Uint16Array(de * 64))
      for (let tn = 0; tn < ce; ++tn) {
        var pt = 8
        tn == ce - 1 && (pt = Me)
        var mt = 8
        for (let ln = 0; ln < de; ++ln) {
          ln == de - 1 && (mt = me)
          for (let mn = 0; mn < G; ++mn)
            ut[mn].fill(0),
              (ut[mn][0] = De[He[mn]++]),
              _t(ke, Ae, ut[mn]),
              rt(ut[mn], Xe[mn]),
              jt(Xe[mn])
          at(Xe)
          for (let mn = 0; mn < G; ++mn) ie(Xe[mn], ot[mn], ln * 64)
        }
        let jn = 0
        for (let ln = 0; ln < G; ++ln) {
          const mn = fe[H.idx[ln]].type
          for (let Wt = 8 * tn; Wt < 8 * tn + pt; ++Wt) {
            jn = We[ln][Wt]
            for (let Kn = 0; Kn < le; ++Kn) {
              const Tn = Kn * 64 + (Wt & 7) * 8
              Lt.setUint16(jn + 0 * 2 * mn, ot[ln][Tn + 0], !0),
                Lt.setUint16(jn + 1 * 2 * mn, ot[ln][Tn + 1], !0),
                Lt.setUint16(jn + 2 * 2 * mn, ot[ln][Tn + 2], !0),
                Lt.setUint16(jn + 3 * 2 * mn, ot[ln][Tn + 3], !0),
                Lt.setUint16(jn + 4 * 2 * mn, ot[ln][Tn + 4], !0),
                Lt.setUint16(jn + 5 * 2 * mn, ot[ln][Tn + 5], !0),
                Lt.setUint16(jn + 6 * 2 * mn, ot[ln][Tn + 6], !0),
                Lt.setUint16(jn + 7 * 2 * mn, ot[ln][Tn + 7], !0),
                (jn += 8 * 2 * mn)
            }
          }
          if (le != de)
            for (let Wt = 8 * tn; Wt < 8 * tn + pt; ++Wt) {
              const Kn = We[ln][Wt] + 8 * le * 2 * mn,
                Tn = le * 64 + (Wt & 7) * 8
              for (let Hn = 0; Hn < mt; ++Hn)
                Lt.setUint16(Kn + Hn * 2 * mn, ot[ln][Tn + Hn], !0)
            }
        }
      }
      for (
        var qt = new Uint16Array(nt), Lt = new DataView(Oe.buffer), Ot = 0;
        Ot < G;
        ++Ot
      ) {
        fe[H.idx[Ot]].decoded = !0
        var wt = fe[H.idx[Ot]].type
        if (fe[Ot].type == 2)
          for (var fn = 0; fn < Ze; ++fn) {
            const tn = We[Ot][fn]
            for (var Ht = 0; Ht < nt; ++Ht)
              qt[Ht] = Lt.getUint16(tn + Ht * 2 * wt, !0)
            for (var Ht = 0; Ht < nt; ++Ht)
              Lt.setFloat32(tn + Ht * 2 * wt, Ie(qt[Ht]), !0)
          }
      }
    }
    function _t(H, ee, fe) {
      for (var Ae, De = 1; De < 64; )
        (Ae = ee[H.value]),
          Ae == 65280
            ? (De = 64)
            : Ae >> 8 == 255
            ? (De += Ae & 255)
            : ((fe[De] = Ae), De++),
          H.value++
    }
    function rt(H, ee) {
      ;(ee[0] = Ie(H[0])),
        (ee[1] = Ie(H[1])),
        (ee[2] = Ie(H[5])),
        (ee[3] = Ie(H[6])),
        (ee[4] = Ie(H[14])),
        (ee[5] = Ie(H[15])),
        (ee[6] = Ie(H[27])),
        (ee[7] = Ie(H[28])),
        (ee[8] = Ie(H[2])),
        (ee[9] = Ie(H[4])),
        (ee[10] = Ie(H[7])),
        (ee[11] = Ie(H[13])),
        (ee[12] = Ie(H[16])),
        (ee[13] = Ie(H[26])),
        (ee[14] = Ie(H[29])),
        (ee[15] = Ie(H[42])),
        (ee[16] = Ie(H[3])),
        (ee[17] = Ie(H[8])),
        (ee[18] = Ie(H[12])),
        (ee[19] = Ie(H[17])),
        (ee[20] = Ie(H[25])),
        (ee[21] = Ie(H[30])),
        (ee[22] = Ie(H[41])),
        (ee[23] = Ie(H[43])),
        (ee[24] = Ie(H[9])),
        (ee[25] = Ie(H[11])),
        (ee[26] = Ie(H[18])),
        (ee[27] = Ie(H[24])),
        (ee[28] = Ie(H[31])),
        (ee[29] = Ie(H[40])),
        (ee[30] = Ie(H[44])),
        (ee[31] = Ie(H[53])),
        (ee[32] = Ie(H[10])),
        (ee[33] = Ie(H[19])),
        (ee[34] = Ie(H[23])),
        (ee[35] = Ie(H[32])),
        (ee[36] = Ie(H[39])),
        (ee[37] = Ie(H[45])),
        (ee[38] = Ie(H[52])),
        (ee[39] = Ie(H[54])),
        (ee[40] = Ie(H[20])),
        (ee[41] = Ie(H[22])),
        (ee[42] = Ie(H[33])),
        (ee[43] = Ie(H[38])),
        (ee[44] = Ie(H[46])),
        (ee[45] = Ie(H[51])),
        (ee[46] = Ie(H[55])),
        (ee[47] = Ie(H[60])),
        (ee[48] = Ie(H[21])),
        (ee[49] = Ie(H[34])),
        (ee[50] = Ie(H[37])),
        (ee[51] = Ie(H[47])),
        (ee[52] = Ie(H[50])),
        (ee[53] = Ie(H[56])),
        (ee[54] = Ie(H[59])),
        (ee[55] = Ie(H[61])),
        (ee[56] = Ie(H[35])),
        (ee[57] = Ie(H[36])),
        (ee[58] = Ie(H[48])),
        (ee[59] = Ie(H[49])),
        (ee[60] = Ie(H[57])),
        (ee[61] = Ie(H[58])),
        (ee[62] = Ie(H[62])),
        (ee[63] = Ie(H[63]))
    }
    function jt(H) {
      const ee = 0.5 * Math.cos(0.7853975),
        fe = 0.5 * Math.cos(3.14159 / 16),
        Ae = 0.5 * Math.cos(3.14159 / 8),
        De = 0.5 * Math.cos((3 * 3.14159) / 16),
        Oe = 0.5 * Math.cos((5 * 3.14159) / 16),
        nt = 0.5 * Math.cos((3 * 3.14159) / 8),
        Ze = 0.5 * Math.cos((7 * 3.14159) / 16)
      for (
        var G = new Array(4),
          le = new Array(4),
          de = new Array(4),
          ce = new Array(4),
          me = 0;
        me < 8;
        ++me
      ) {
        var Me = me * 8
        ;(G[0] = Ae * H[Me + 2]),
          (G[1] = nt * H[Me + 2]),
          (G[2] = Ae * H[Me + 6]),
          (G[3] = nt * H[Me + 6]),
          (le[0] =
            fe * H[Me + 1] + De * H[Me + 3] + Oe * H[Me + 5] + Ze * H[Me + 7]),
          (le[1] =
            De * H[Me + 1] - Ze * H[Me + 3] - fe * H[Me + 5] - Oe * H[Me + 7]),
          (le[2] =
            Oe * H[Me + 1] - fe * H[Me + 3] + Ze * H[Me + 5] + De * H[Me + 7]),
          (le[3] =
            Ze * H[Me + 1] - Oe * H[Me + 3] + De * H[Me + 5] - fe * H[Me + 7]),
          (de[0] = ee * (H[Me + 0] + H[Me + 4])),
          (de[3] = ee * (H[Me + 0] - H[Me + 4])),
          (de[1] = G[0] + G[3]),
          (de[2] = G[1] - G[2]),
          (ce[0] = de[0] + de[1]),
          (ce[1] = de[3] + de[2]),
          (ce[2] = de[3] - de[2]),
          (ce[3] = de[0] - de[1]),
          (H[Me + 0] = ce[0] + le[0]),
          (H[Me + 1] = ce[1] + le[1]),
          (H[Me + 2] = ce[2] + le[2]),
          (H[Me + 3] = ce[3] + le[3]),
          (H[Me + 4] = ce[3] - le[3]),
          (H[Me + 5] = ce[2] - le[2]),
          (H[Me + 6] = ce[1] - le[1]),
          (H[Me + 7] = ce[0] - le[0])
      }
      for (var ke = 0; ke < 8; ++ke)
        (G[0] = Ae * H[16 + ke]),
          (G[1] = nt * H[16 + ke]),
          (G[2] = Ae * H[48 + ke]),
          (G[3] = nt * H[48 + ke]),
          (le[0] =
            fe * H[8 + ke] +
            De * H[24 + ke] +
            Oe * H[40 + ke] +
            Ze * H[56 + ke]),
          (le[1] =
            De * H[8 + ke] -
            Ze * H[24 + ke] -
            fe * H[40 + ke] -
            Oe * H[56 + ke]),
          (le[2] =
            Oe * H[8 + ke] -
            fe * H[24 + ke] +
            Ze * H[40 + ke] +
            De * H[56 + ke]),
          (le[3] =
            Ze * H[8 + ke] -
            Oe * H[24 + ke] +
            De * H[40 + ke] -
            fe * H[56 + ke]),
          (de[0] = ee * (H[ke] + H[32 + ke])),
          (de[3] = ee * (H[ke] - H[32 + ke])),
          (de[1] = G[0] + G[3]),
          (de[2] = G[1] - G[2]),
          (ce[0] = de[0] + de[1]),
          (ce[1] = de[3] + de[2]),
          (ce[2] = de[3] - de[2]),
          (ce[3] = de[0] - de[1]),
          (H[0 + ke] = ce[0] + le[0]),
          (H[8 + ke] = ce[1] + le[1]),
          (H[16 + ke] = ce[2] + le[2]),
          (H[24 + ke] = ce[3] + le[3]),
          (H[32 + ke] = ce[3] - le[3]),
          (H[40 + ke] = ce[2] - le[2]),
          (H[48 + ke] = ce[1] - le[1]),
          (H[56 + ke] = ce[0] - le[0])
    }
    function at(H) {
      for (var ee = 0; ee < 64; ++ee) {
        var fe = H[0][ee],
          Ae = H[1][ee],
          De = H[2][ee]
        ;(H[0][ee] = fe + 1.5747 * De),
          (H[1][ee] = fe - 0.1873 * Ae - 0.4682 * De),
          (H[2][ee] = fe + 1.8556 * Ae)
      }
    }
    function ie(H, ee, fe) {
      for (var Ae = 0; Ae < 64; ++Ae) ee[fe + Ae] = td.toHalfFloat(Z(H[Ae]))
    }
    function Z(H) {
      return H <= 1
        ? Math.sign(H) * Math.pow(Math.abs(H), 2.2)
        : Math.sign(H) * Math.pow(N, Math.abs(H) - 1)
    }
    function Se(H) {
      return new DataView(H.array.buffer, H.offset.value, H.size)
    }
    function Ue(H) {
      var ee = H.viewer.buffer.slice(H.offset.value, H.offset.value + H.size),
        fe = new Uint8Array(Rt(ee)),
        Ae = new Uint8Array(fe.length)
      return $e(fe), se(fe, Ae), new DataView(Ae.buffer)
    }
    function Ge(H) {
      var ee = H.array.slice(H.offset.value, H.offset.value + H.size),
        fe = q0(ee),
        Ae = new Uint8Array(fe.length)
      return $e(fe), se(fe, Ae), new DataView(Ae.buffer)
    }
    function ze(H) {
      for (
        var ee = H.viewer,
          fe = { value: H.offset.value },
          Ae = new Uint16Array(
            H.width * H.scanlineBlockSize * (H.channels * H.type),
          ),
          De = new Uint8Array(8192),
          Oe = 0,
          nt = new Array(H.channels),
          Ze = 0;
        Ze < H.channels;
        Ze++
      )
        (nt[Ze] = {}),
          (nt[Ze].start = Oe),
          (nt[Ze].end = nt[Ze].start),
          (nt[Ze].nx = H.width),
          (nt[Ze].ny = H.lines),
          (nt[Ze].size = H.type),
          (Oe += nt[Ze].nx * nt[Ze].ny * nt[Ze].size)
      var G = Le(ee, fe),
        le = Le(ee, fe)
      if (le >= 8192)
        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'
      if (G <= le)
        for (var Ze = 0; Ze < le - G + 1; Ze++) De[Ze + G] = en(ee, fe)
      var de = new Uint16Array(65536),
        ce = k(De, de),
        me = It(ee, fe)
      Vt(H.array, ee, fe, me, Ae, Oe)
      for (var Ze = 0; Ze < H.channels; ++Ze)
        for (var Me = nt[Ze], ke = 0; ke < nt[Ze].size; ++ke)
          et(Ae, Me.start + ke, Me.nx, Me.size, Me.ny, Me.nx * Me.size, ce)
      je(de, Ae, Oe)
      for (
        var He = 0, Xe = new Uint8Array(Ae.buffer.byteLength), ut = 0;
        ut < H.lines;
        ut++
      )
        for (var ot = 0; ot < H.channels; ot++) {
          var Me = nt[ot],
            We = Me.nx * Me.size,
            pt = new Uint8Array(Ae.buffer, Me.end * 2, We * 2)
          Xe.set(pt, He), (He += We * 2), (Me.end += We)
        }
      return new DataView(Xe.buffer)
    }
    function Ct(H) {
      var ee = H.array.slice(H.offset.value, H.offset.value + H.size),
        fe = q0(ee)
      const Ae = H.lines * H.channels * H.width,
        De = H.type == 1 ? new Uint16Array(Ae) : new Uint32Array(Ae)
      let Oe = 0,
        nt = 0
      const Ze = new Array(4)
      for (let G = 0; G < H.lines; G++)
        for (let le = 0; le < H.channels; le++) {
          let de = 0
          switch (H.type) {
            case 1:
              ;(Ze[0] = Oe), (Ze[1] = Ze[0] + H.width), (Oe = Ze[1] + H.width)
              for (let ce = 0; ce < H.width; ++ce) {
                const me = (fe[Ze[0]++] << 8) | fe[Ze[1]++]
                ;(de += me), (De[nt] = de), nt++
              }
              break
            case 2:
              ;(Ze[0] = Oe),
                (Ze[1] = Ze[0] + H.width),
                (Ze[2] = Ze[1] + H.width),
                (Oe = Ze[2] + H.width)
              for (let ce = 0; ce < H.width; ++ce) {
                const me =
                  (fe[Ze[0]++] << 24) | (fe[Ze[1]++] << 16) | (fe[Ze[2]++] << 8)
                ;(de += me), (De[nt] = de), nt++
              }
              break
          }
        }
      return new DataView(De.buffer)
    }
    function ct(H) {
      var ee = H.viewer,
        fe = { value: H.offset.value },
        Ae = new Uint8Array(H.width * H.lines * (H.channels * H.type * 2)),
        De = {
          version: Bt(ee, fe),
          unknownUncompressedSize: Bt(ee, fe),
          unknownCompressedSize: Bt(ee, fe),
          acCompressedSize: Bt(ee, fe),
          dcCompressedSize: Bt(ee, fe),
          rleCompressedSize: Bt(ee, fe),
          rleUncompressedSize: Bt(ee, fe),
          rleRawSize: Bt(ee, fe),
          totalAcUncompressedCount: Bt(ee, fe),
          totalDcUncompressedCount: Bt(ee, fe),
          acCompression: Bt(ee, fe),
        }
      if (De.version < 2)
        throw (
          'EXRLoader.parse: ' +
          ji.compression +
          ' version ' +
          De.version +
          ' is unsupported'
        )
      for (var Oe = new Array(), nt = Le(ee, fe) - 2; nt > 0; ) {
        var Ze = gt(ee.buffer, fe),
          G = en(ee, fe),
          le = (G >> 2) & 3,
          de = (G >> 4) - 1,
          ce = new Int8Array([de])[0],
          me = en(ee, fe)
        Oe.push({ name: Ze, index: ce, type: me, compression: le }),
          (nt -= Ze.length + 3)
      }
      for (
        var Me = ji.channels, ke = new Array(H.channels), He = 0;
        He < H.channels;
        ++He
      ) {
        var Xe = (ke[He] = {}),
          ut = Me[He]
        ;(Xe.name = ut.name),
          (Xe.compression = 0),
          (Xe.decoded = !1),
          (Xe.type = ut.pixelType),
          (Xe.pLinear = ut.pLinear),
          (Xe.width = H.width),
          (Xe.height = H.lines)
      }
      for (var ot = { idx: new Array(3) }, We = 0; We < H.channels; ++We)
        for (var Xe = ke[We], He = 0; He < Oe.length; ++He) {
          var pt = Oe[He]
          Xe.name == pt.name &&
            ((Xe.compression = pt.compression),
            pt.index >= 0 && (ot.idx[pt.index] = We),
            (Xe.offset = We))
        }
      if (De.acCompressedSize > 0)
        switch (De.acCompression) {
          case 0:
            var Lt = new Uint16Array(De.totalAcUncompressedCount)
            Vt(
              H.array,
              ee,
              fe,
              De.acCompressedSize,
              Lt,
              De.totalAcUncompressedCount,
            )
            break
          case 1:
            var mt = H.array.slice(
                fe.value,
                fe.value + De.totalAcUncompressedCount,
              ),
              qt = q0(mt),
              Lt = new Uint16Array(qt.buffer)
            fe.value += De.totalAcUncompressedCount
            break
        }
      if (De.dcCompressedSize > 0) {
        var Ot = { array: H.array, offset: fe, size: De.dcCompressedSize },
          wt = new Uint16Array(Ge(Ot).buffer)
        fe.value += De.dcCompressedSize
      }
      if (De.rleRawSize > 0) {
        var mt = H.array.slice(fe.value, fe.value + De.rleCompressedSize),
          qt = q0(mt),
          fn = Rt(qt.buffer)
        fe.value += De.rleCompressedSize
      }
      for (var Ht = 0, tn = new Array(ke.length), He = 0; He < tn.length; ++He)
        tn[He] = new Array()
      for (var jn = 0; jn < H.lines; ++jn)
        for (var ln = 0; ln < ke.length; ++ln)
          tn[ln].push(Ht), (Ht += ke[ln].width * H.type * 2)
      Qe(ot, tn, ke, Lt, wt, Ae)
      for (var He = 0; He < ke.length; ++He) {
        var Xe = ke[He]
        if (!Xe.decoded)
          switch (Xe.compression) {
            case 2:
              for (var mn = 0, Wt = 0, jn = 0; jn < H.lines; ++jn) {
                for (var Kn = tn[He][mn], Tn = 0; Tn < Xe.width; ++Tn) {
                  for (var Hn = 0; Hn < 2 * Xe.type; ++Hn)
                    Ae[Kn++] = fn[Wt + Hn * Xe.width * Xe.height]
                  Wt++
                }
                mn++
              }
              break
            case 1:
            default:
              throw 'EXRLoader.parse: unsupported channel compression'
          }
      }
      return new DataView(Ae.buffer)
    }
    function gt(H, ee) {
      for (var fe = new Uint8Array(H), Ae = 0; fe[ee.value + Ae] != 0; ) Ae += 1
      var De = new TextDecoder().decode(fe.slice(ee.value, ee.value + Ae))
      return (ee.value = ee.value + Ae + 1), De
    }
    function rn(H, ee, fe) {
      var Ae = new TextDecoder().decode(
        new Uint8Array(H).slice(ee.value, ee.value + fe),
      )
      return (ee.value = ee.value + fe), Ae
    }
    function Je(H, ee) {
      var fe = Ut(H, ee),
        Ae = It(H, ee)
      return [fe, Ae]
    }
    function bt(H, ee) {
      var fe = It(H, ee),
        Ae = It(H, ee)
      return [fe, Ae]
    }
    function Ut(H, ee) {
      var fe = H.getInt32(ee.value, !0)
      return (ee.value = ee.value + 4), fe
    }
    function It(H, ee) {
      var fe = H.getUint32(ee.value, !0)
      return (ee.value = ee.value + 4), fe
    }
    function Mt(H, ee) {
      var fe = H[ee.value]
      return (ee.value = ee.value + 1), fe
    }
    function en(H, ee) {
      var fe = H.getUint8(ee.value)
      return (ee.value = ee.value + 1), fe
    }
    const Bt = function (H, ee) {
      let fe
      return (
        'getBigInt64' in DataView.prototype
          ? (fe = Number(H.getBigInt64(ee.value, !0)))
          : (fe =
              H.getUint32(ee.value + 4, !0) +
              Number(H.getUint32(ee.value, !0) << 32)),
        (ee.value += 8),
        fe
      )
    }
    function Kt(H, ee) {
      var fe = H.getFloat32(ee.value, !0)
      return (ee.value += 4), fe
    }
    function ve(H, ee) {
      return td.toHalfFloat(Kt(H, ee))
    }
    function Ie(H) {
      var ee = (H & 31744) >> 10,
        fe = H & 1023
      return (
        (H >> 15 ? -1 : 1) *
        (ee
          ? ee === 31
            ? fe
              ? NaN
              : 1 / 0
            : Math.pow(2, ee - 15) * (1 + fe / 1024)
          : 6103515625e-14 * (fe / 1024))
      )
    }
    function Le(H, ee) {
      var fe = H.getUint16(ee.value, !0)
      return (ee.value += 2), fe
    }
    function Ve(H, ee) {
      return Ie(Le(H, ee))
    }
    function vt(H, ee, fe, Ae) {
      for (var De = fe.value, Oe = []; fe.value < De + Ae - 1; ) {
        var nt = gt(ee, fe),
          Ze = Ut(H, fe),
          G = en(H, fe)
        fe.value += 3
        var le = Ut(H, fe),
          de = Ut(H, fe)
        Oe.push({
          name: nt,
          pixelType: Ze,
          pLinear: G,
          xSampling: le,
          ySampling: de,
        })
      }
      return (fe.value += 1), Oe
    }
    function ht(H, ee) {
      var fe = Kt(H, ee),
        Ae = Kt(H, ee),
        De = Kt(H, ee),
        Oe = Kt(H, ee),
        nt = Kt(H, ee),
        Ze = Kt(H, ee),
        G = Kt(H, ee),
        le = Kt(H, ee)
      return {
        redX: fe,
        redY: Ae,
        greenX: De,
        greenY: Oe,
        blueX: nt,
        blueY: Ze,
        whiteX: G,
        whiteY: le,
      }
    }
    function Qt(H, ee) {
      var fe = [
          'NO_COMPRESSION',
          'RLE_COMPRESSION',
          'ZIPS_COMPRESSION',
          'ZIP_COMPRESSION',
          'PIZ_COMPRESSION',
          'PXR24_COMPRESSION',
          'B44_COMPRESSION',
          'B44A_COMPRESSION',
          'DWAA_COMPRESSION',
          'DWAB_COMPRESSION',
        ],
        Ae = en(H, ee)
      return fe[Ae]
    }
    function Un(H, ee) {
      var fe = It(H, ee),
        Ae = It(H, ee),
        De = It(H, ee),
        Oe = It(H, ee)
      return { xMin: fe, yMin: Ae, xMax: De, yMax: Oe }
    }
    function si(H, ee) {
      var fe = ['INCREASING_Y'],
        Ae = en(H, ee)
      return fe[Ae]
    }
    function wn(H, ee) {
      var fe = Kt(H, ee),
        Ae = Kt(H, ee)
      return [fe, Ae]
    }
    function zi(H, ee) {
      var fe = Kt(H, ee),
        Ae = Kt(H, ee),
        De = Kt(H, ee)
      return [fe, Ae, De]
    }
    function Vi(H, ee, fe, Ae, De) {
      if (Ae === 'string' || Ae === 'stringvector' || Ae === 'iccProfile')
        return rn(ee, fe, De)
      if (Ae === 'chlist') return vt(H, ee, fe, De)
      if (Ae === 'chromaticities') return ht(H, fe)
      if (Ae === 'compression') return Qt(H, fe)
      if (Ae === 'box2i') return Un(H, fe)
      if (Ae === 'lineOrder') return si(H, fe)
      if (Ae === 'float') return Kt(H, fe)
      if (Ae === 'v2f') return wn(H, fe)
      if (Ae === 'v3f') return zi(H, fe)
      if (Ae === 'int') return Ut(H, fe)
      if (Ae === 'rational') return Je(H, fe)
      if (Ae === 'timecode') return bt(H, fe)
      if (Ae === 'preview') return (fe.value += De), 'skipped'
      fe.value += De
    }
    function Ko(H, ee, fe) {
      const Ae = {}
      if (H.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format."
      Ae.version = H.getUint8(4)
      const De = H.getUint8(5)
      ;(Ae.spec = {
        singleTile: !!(De & 2),
        longName: !!(De & 4),
        deepFormat: !!(De & 8),
        multiPart: !!(De & 16),
      }),
        (fe.value = 8)
      for (var Oe = !0; Oe; ) {
        var nt = gt(ee, fe)
        if (nt == 0) Oe = !1
        else {
          var Ze = gt(ee, fe),
            G = It(H, fe),
            le = Vi(H, ee, fe, Ze, G)
          le === void 0
            ? console.warn(
                `EXRLoader.parse: skipped unknown header attribute type '${Ze}'.`,
              )
            : (Ae[nt] = le)
        }
      }
      if (De & -5)
        throw (
          (console.error('EXRHeader:', Ae),
          'THREE.EXRLoader: provided file is currently unsupported.')
        )
      return Ae
    }
    function js(H, ee, fe, Ae, De) {
      const Oe = {
        size: 0,
        viewer: ee,
        array: fe,
        offset: Ae,
        width: H.dataWindow.xMax - H.dataWindow.xMin + 1,
        height: H.dataWindow.yMax - H.dataWindow.yMin + 1,
        channels: H.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: H.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [Kp ? 'colorSpace' : 'encoding']: null,
      }
      switch (H.compression) {
        case 'NO_COMPRESSION':
          ;(Oe.lines = 1), (Oe.uncompress = Se)
          break
        case 'RLE_COMPRESSION':
          ;(Oe.lines = 1), (Oe.uncompress = Ue)
          break
        case 'ZIPS_COMPRESSION':
          ;(Oe.lines = 1), (Oe.uncompress = Ge)
          break
        case 'ZIP_COMPRESSION':
          ;(Oe.lines = 16), (Oe.uncompress = Ge)
          break
        case 'PIZ_COMPRESSION':
          ;(Oe.lines = 32), (Oe.uncompress = ze)
          break
        case 'PXR24_COMPRESSION':
          ;(Oe.lines = 16), (Oe.uncompress = Ct)
          break
        case 'DWAA_COMPRESSION':
          ;(Oe.lines = 32), (Oe.uncompress = ct)
          break
        case 'DWAB_COMPRESSION':
          ;(Oe.lines = 256), (Oe.uncompress = ct)
          break
        default:
          throw 'EXRLoader.parse: ' + H.compression + ' is unsupported'
      }
      if (((Oe.scanlineBlockSize = Oe.lines), Oe.type == 1))
        switch (De) {
          case gi:
            ;(Oe.getter = Ve), (Oe.inputSize = 2)
            break
          case or:
            ;(Oe.getter = Le), (Oe.inputSize = 2)
            break
        }
      else if (Oe.type == 2)
        switch (De) {
          case gi:
            ;(Oe.getter = Kt), (Oe.inputSize = 4)
            break
          case or:
            ;(Oe.getter = ve), (Oe.inputSize = 4)
        }
      else
        throw (
          'EXRLoader.parse: unsupported pixelType ' +
          Oe.type +
          ' for ' +
          H.compression +
          '.'
        )
      Oe.blockCount = (H.dataWindow.yMax + 1) / Oe.scanlineBlockSize
      for (var nt = 0; nt < Oe.blockCount; nt++) Bt(ee, Ae)
      Oe.outputChannels = Oe.channels == 3 ? 4 : Oe.channels
      const Ze = Oe.width * Oe.height * Oe.outputChannels
      switch (De) {
        case gi:
          ;(Oe.byteArray = new Float32Array(Ze)),
            Oe.channels < Oe.outputChannels && Oe.byteArray.fill(1, 0, Ze)
          break
        case or:
          ;(Oe.byteArray = new Uint16Array(Ze)),
            Oe.channels < Oe.outputChannels && Oe.byteArray.fill(15360, 0, Ze)
          break
        default:
          console.error('THREE.EXRLoader: unsupported type: ', De)
          break
      }
      return (
        (Oe.bytesPerLine = Oe.width * Oe.inputSize * Oe.channels),
        Oe.outputChannels == 4 ? (Oe.format = Ii) : (Oe.format = Ag),
        Kp ? (Oe.colorSpace = 'srgb-linear') : (Oe.encoding = 3e3),
        Oe
      )
    }
    const ar = new DataView(e),
      kr = new Uint8Array(e),
      Fr = { value: 0 },
      ji = Ko(ar, e, Fr),
      sn = js(ji, ar, kr, Fr, this.type),
      Ia = { value: 0 },
      Qo = { R: 0, G: 1, B: 2, A: 3, Y: 0 }
    for (let H = 0; H < sn.height / sn.scanlineBlockSize; H++) {
      const ee = It(ar, Fr)
      ;(sn.size = It(ar, Fr)),
        (sn.lines =
          ee + sn.scanlineBlockSize > sn.height
            ? sn.height - ee
            : sn.scanlineBlockSize)
      const Ae =
        sn.size < sn.lines * sn.bytesPerLine ? sn.uncompress(sn) : Se(sn)
      Fr.value += sn.size
      for (let De = 0; De < sn.scanlineBlockSize; De++) {
        const Oe = De + H * sn.scanlineBlockSize
        if (Oe >= sn.height) break
        for (let nt = 0; nt < sn.channels; nt++) {
          const Ze = Qo[ji.channels[nt].name]
          for (let G = 0; G < sn.width; G++) {
            Ia.value =
              (De * (sn.channels * sn.width) + nt * sn.width + G) * sn.inputSize
            const le =
              (sn.height - 1 - Oe) * (sn.width * sn.outputChannels) +
              G * sn.outputChannels +
              Ze
            sn.byteArray[le] = sn.getter(Ae, Ia)
          }
        }
      }
    }
    return {
      header: ji,
      width: sn.width,
      height: sn.height,
      data: sn.byteArray,
      format: sn.format,
      [Kp ? 'colorSpace' : 'encoding']: sn[Kp ? 'colorSpace' : 'encoding'],
      type: this.type,
    }
  }
  setDataType(e) {
    return (this.type = e), this
  }
  load(e, t, i, r) {
    function s(o, a) {
      Kp ? (o.colorSpace = a.colorSpace) : (o.encoding = a.encoding),
        (o.minFilter = Vn),
        (o.magFilter = Vn),
        (o.generateMipmaps = !1),
        (o.flipY = !1),
        t && t(o, a)
    }
    return super.load(e, s, i, r)
  }
}
const n7 = 'modulepreload',
  i7 = function (n) {
    return '/' + n
  },
  nP = {},
  vs = function (e, t, i) {
    let r = Promise.resolve()
    if (t && t.length > 0) {
      document.getElementsByTagName('link')
      const o = document.querySelector('meta[property=csp-nonce]'),
        a =
          (o == null ? void 0 : o.nonce) ||
          (o == null ? void 0 : o.getAttribute('nonce'))
      r = Promise.allSettled(
        t.map((c) => {
          if (((c = i7(c)), c in nP)) return
          nP[c] = !0
          const u = c.endsWith('.css'),
            h = u ? '[rel="stylesheet"]' : ''
          if (document.querySelector(`link[href="${c}"]${h}`)) return
          const m = document.createElement('link')
          if (
            ((m.rel = u ? 'stylesheet' : n7),
            u || (m.as = 'script'),
            (m.crossOrigin = ''),
            (m.href = c),
            a && m.setAttribute('nonce', a),
            document.head.appendChild(m),
            u)
          )
            return new Promise((g, y) => {
              m.addEventListener('load', g),
                m.addEventListener('error', () =>
                  y(new Error(`Unable to preload CSS for ${c}`)),
                )
            })
        }),
      )
    }
    function s(o) {
      const a = new Event('vite:preloadError', { cancelable: !0 })
      if (((a.payload = o), window.dispatchEvent(a), !a.defaultPrevented))
        throw o
    }
    return r.then((o) => {
      for (const a of o || []) a.status === 'rejected' && s(a.reason)
      return e().catch(s)
    })
  }
var Dw = { exports: {} },
  Ow,
  iP
function r7() {
  if (iP) return Ow
  iP = 1
  var n = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'
  return (Ow = n), Ow
}
var kw, rP
function s7() {
  if (rP) return kw
  rP = 1
  var n = r7()
  function e() {}
  function t() {}
  return (
    (t.resetWarningCache = e),
    (kw = function () {
      function i(o, a, c, u, h, m) {
        if (m !== n) {
          var g = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types',
          )
          throw ((g.name = 'Invariant Violation'), g)
        }
      }
      i.isRequired = i
      function r() {
        return i
      }
      var s = {
        array: i,
        bigint: i,
        bool: i,
        func: i,
        number: i,
        object: i,
        string: i,
        symbol: i,
        any: i,
        arrayOf: r,
        element: i,
        elementType: i,
        instanceOf: r,
        node: i,
        objectOf: r,
        oneOf: r,
        oneOfType: r,
        shape: r,
        exact: r,
        checkPropTypes: t,
        resetWarningCache: e,
      }
      return (s.PropTypes = s), s
    }),
    kw
  )
}
var sP
function Xg() {
  return sP || ((sP = 1), (Dw.exports = s7()())), Dw.exports
}
const o7 = 3e3,
  a7 = 3001
var l7 = `#define GLSLIFY 1
vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}`
class c7 extends SE {
  constructor(e = {}) {
    super(e),
      this.setValues(e),
      (this._time = { value: 0 }),
      (this._distort = { value: 0.4 }),
      (this._radius = { value: 1 })
  }
  onBeforeCompile(e) {
    ;(e.uniforms.time = this._time),
      (e.uniforms.radius = this._radius),
      (e.uniforms.distort = this._distort),
      (e.vertexShader = `
      uniform float time;
      uniform float radius;
      uniform float distort;
      ${l7}
      ${e.vertexShader}
    `),
      (e.vertexShader = e.vertexShader.replace(
        '#include <begin_vertex>',
        `
        float updateTime = time / 50.0;
        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));
        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));
        `,
      ))
  }
  get time() {
    return this._time.value
  }
  set time(e) {
    this._time.value = e
  }
  get distort() {
    return this._distort.value
  }
  set distort(e) {
    this._distort.value = e
  }
  get radius() {
    return this._radius.value
  }
  set radius(e) {
    this._radius.value = e
  }
}
const u7 = X.forwardRef(({ speed: n = 1, ...e }, t) => {
    const [i] = X.useState(() => new c7())
    return (
      Vg((r) => i && (i.time = r.clock.getElapsedTime() * n)),
      X.createElement(
        'primitive',
        wh({ object: i, ref: t, attach: 'material' }, e),
      )
    )
  }),
  zD = (n, e, t) => {
    let i
    switch (n) {
      case _s:
        i = new Uint8ClampedArray(e * t * 4)
        break
      case or:
        i = new Uint16Array(e * t * 4)
        break
      case Ta:
        i = new Uint32Array(e * t * 4)
        break
      case Hx:
        i = new Int8Array(e * t * 4)
        break
      case Gx:
        i = new Int16Array(e * t * 4)
        break
      case Tg:
        i = new Int32Array(e * t * 4)
        break
      case gi:
        i = new Float32Array(e * t * 4)
        break
      default:
        throw new Error('Unsupported data type')
    }
    return i
  }
let Y0
const d7 = (n, e, t, i) => {
  if (Y0 !== void 0) return Y0
  const r = new uo(1, 1, i)
  e.setRenderTarget(r)
  const s = new vi(new Uc(), new Il({ color: 16777215 }))
  e.render(s, t), e.setRenderTarget(null)
  const o = zD(n, r.width, r.height)
  return (
    e.readRenderTargetPixels(r, 0, 0, r.width, r.height, o),
    r.dispose(),
    s.geometry.dispose(),
    s.material.dispose(),
    (Y0 = o[0] !== 0),
    Y0
  )
}
class sb {
  constructor(e) {
    var t, i, r, s, o, a, c, u, h, m, g, y, _, M, w, x
    ;(this._rendererIsDisposable = !1),
      (this._supportsReadPixels = !0),
      (this.render = () => {
        this._renderer.setRenderTarget(this._renderTarget)
        try {
          this._renderer.render(this._scene, this._camera)
        } catch (A) {
          throw (this._renderer.setRenderTarget(null), A)
        }
        this._renderer.setRenderTarget(null)
      }),
      (this._width = e.width),
      (this._height = e.height),
      (this._type = e.type),
      (this._colorSpace = e.colorSpace)
    const T = {
      format: Ii,
      depthBuffer: !1,
      stencilBuffer: !1,
      type: this._type,
      colorSpace: this._colorSpace,
      anisotropy:
        ((t = e.renderTargetOptions) === null || t === void 0
          ? void 0
          : t.anisotropy) !== void 0
          ? (i = e.renderTargetOptions) === null || i === void 0
            ? void 0
            : i.anisotropy
          : 1,
      generateMipmaps:
        ((r = e.renderTargetOptions) === null || r === void 0
          ? void 0
          : r.generateMipmaps) !== void 0
          ? (s = e.renderTargetOptions) === null || s === void 0
            ? void 0
            : s.generateMipmaps
          : !1,
      magFilter:
        ((o = e.renderTargetOptions) === null || o === void 0
          ? void 0
          : o.magFilter) !== void 0
          ? (a = e.renderTargetOptions) === null || a === void 0
            ? void 0
            : a.magFilter
          : Vn,
      minFilter:
        ((c = e.renderTargetOptions) === null || c === void 0
          ? void 0
          : c.minFilter) !== void 0
          ? (u = e.renderTargetOptions) === null || u === void 0
            ? void 0
            : u.minFilter
          : Vn,
      samples:
        ((h = e.renderTargetOptions) === null || h === void 0
          ? void 0
          : h.samples) !== void 0
          ? (m = e.renderTargetOptions) === null || m === void 0
            ? void 0
            : m.samples
          : void 0,
      wrapS:
        ((g = e.renderTargetOptions) === null || g === void 0
          ? void 0
          : g.wrapS) !== void 0
          ? (y = e.renderTargetOptions) === null || y === void 0
            ? void 0
            : y.wrapS
          : Bi,
      wrapT:
        ((_ = e.renderTargetOptions) === null || _ === void 0
          ? void 0
          : _.wrapT) !== void 0
          ? (M = e.renderTargetOptions) === null || M === void 0
            ? void 0
            : M.wrapT
          : Bi,
    }
    if (
      ((this._material = e.material),
      e.renderer
        ? (this._renderer = e.renderer)
        : ((this._renderer = sb.instantiateRenderer()),
          (this._rendererIsDisposable = !0)),
      (this._scene = new Lg()),
      (this._camera = new Nh()),
      this._camera.position.set(0, 0, 10),
      (this._camera.left = -0.5),
      (this._camera.right = 0.5),
      (this._camera.top = 0.5),
      (this._camera.bottom = -0.5),
      this._camera.updateProjectionMatrix(),
      !d7(this._type, this._renderer, this._camera, T))
    ) {
      let A
      switch (this._type) {
        case or:
          A = this._renderer.extensions.has('EXT_color_buffer_float')
            ? gi
            : void 0
          break
      }
      A !== void 0
        ? (console.warn(
            `This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${gi}`,
          ),
          (this._type = A))
        : ((this._supportsReadPixels = !1),
          console.warn(
            'This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown',
          ))
    }
    ;(this._quad = new vi(new Uc(), this._material)),
      this._quad.geometry.computeBoundingBox(),
      this._scene.add(this._quad),
      (this._renderTarget = new uo(this.width, this.height, T)),
      (this._renderTarget.texture.mapping =
        ((w = e.renderTargetOptions) === null || w === void 0
          ? void 0
          : w.mapping) !== void 0
          ? (x = e.renderTargetOptions) === null || x === void 0
            ? void 0
            : x.mapping
          : Cc)
  }
  static instantiateRenderer() {
    const e = new UE()
    return e.setSize(128, 128), e
  }
  toArray() {
    if (!this._supportsReadPixels)
      throw new Error("Can't read pixels in this browser")
    const e = zD(this._type, this._width, this._height)
    return (
      this._renderer.readRenderTargetPixels(
        this._renderTarget,
        0,
        0,
        this._width,
        this._height,
        e,
      ),
      e
    )
  }
  toDataTexture(e) {
    const t = new $o(
      this.toArray(),
      this.width,
      this.height,
      Ii,
      this._type,
      (e == null ? void 0 : e.mapping) || Cc,
      (e == null ? void 0 : e.wrapS) || Bi,
      (e == null ? void 0 : e.wrapT) || Bi,
      (e == null ? void 0 : e.magFilter) || Vn,
      (e == null ? void 0 : e.minFilter) || Vn,
      (e == null ? void 0 : e.anisotropy) || 1,
      Aa,
    )
    return (
      (t.generateMipmaps =
        (e == null ? void 0 : e.generateMipmaps) !== void 0
          ? e == null
            ? void 0
            : e.generateMipmaps
          : !1),
      t
    )
  }
  disposeOnDemandRenderer() {
    this._renderer.setRenderTarget(null),
      this._rendererIsDisposable &&
        (this._renderer.dispose(), this._renderer.forceContextLoss())
  }
  dispose(e) {
    this.disposeOnDemandRenderer(),
      e && this.renderTarget.dispose(),
      this.material instanceof ws &&
        Object.values(this.material.uniforms).forEach((t) => {
          t.value instanceof Xn && t.value.dispose()
        }),
      Object.values(this.material).forEach((t) => {
        t instanceof Xn && t.dispose()
      }),
      this.material.dispose(),
      this._quad.geometry.dispose()
  }
  get width() {
    return this._width
  }
  set width(e) {
    ;(this._width = e), this._renderTarget.setSize(this._width, this._height)
  }
  get height() {
    return this._height
  }
  set height(e) {
    ;(this._height = e), this._renderTarget.setSize(this._width, this._height)
  }
  get renderer() {
    return this._renderer
  }
  get renderTarget() {
    return this._renderTarget
  }
  set renderTarget(e) {
    ;(this._renderTarget = e),
      (this._width = e.width),
      (this._height = e.height)
  }
  get material() {
    return this._material
  }
  get type() {
    return this._type
  }
  get colorSpace() {
    return this._colorSpace
  }
}
const f7 = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
  h7 = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`
class p7 extends ws {
  constructor({
    gamma: e,
    offsetHdr: t,
    offsetSdr: i,
    gainMapMin: r,
    gainMapMax: s,
    maxDisplayBoost: o,
    hdrCapacityMin: a,
    hdrCapacityMax: c,
    sdr: u,
    gainMap: h,
  }) {
    super({
      name: 'GainMapDecoderMaterial',
      vertexShader: f7,
      fragmentShader: h7,
      uniforms: {
        sdr: { value: u },
        gainMap: { value: h },
        gamma: { value: new re(1 / e[0], 1 / e[1], 1 / e[2]) },
        offsetHdr: { value: new re().fromArray(t) },
        offsetSdr: { value: new re().fromArray(i) },
        gainMapMin: { value: new re().fromArray(r) },
        gainMapMax: { value: new re().fromArray(s) },
        weightFactor: { value: (Math.log2(o) - a) / (c - a) },
      },
      blending: va,
      depthTest: !1,
      depthWrite: !1,
    }),
      (this._maxDisplayBoost = o),
      (this._hdrCapacityMin = a),
      (this._hdrCapacityMax = c),
      (this.needsUpdate = !0),
      (this.uniformsNeedUpdate = !0)
  }
  get sdr() {
    return this.uniforms.sdr.value
  }
  set sdr(e) {
    this.uniforms.sdr.value = e
  }
  get gainMap() {
    return this.uniforms.gainMap.value
  }
  set gainMap(e) {
    this.uniforms.gainMap.value = e
  }
  get offsetHdr() {
    return this.uniforms.offsetHdr.value.toArray()
  }
  set offsetHdr(e) {
    this.uniforms.offsetHdr.value.fromArray(e)
  }
  get offsetSdr() {
    return this.uniforms.offsetSdr.value.toArray()
  }
  set offsetSdr(e) {
    this.uniforms.offsetSdr.value.fromArray(e)
  }
  get gainMapMin() {
    return this.uniforms.gainMapMin.value.toArray()
  }
  set gainMapMin(e) {
    this.uniforms.gainMapMin.value.fromArray(e)
  }
  get gainMapMax() {
    return this.uniforms.gainMapMax.value.toArray()
  }
  set gainMapMax(e) {
    this.uniforms.gainMapMax.value.fromArray(e)
  }
  get gamma() {
    const e = this.uniforms.gamma.value
    return [1 / e.x, 1 / e.y, 1 / e.z]
  }
  set gamma(e) {
    const t = this.uniforms.gamma.value
    ;(t.x = 1 / e[0]), (t.y = 1 / e[1]), (t.z = 1 / e[2])
  }
  get hdrCapacityMin() {
    return this._hdrCapacityMin
  }
  set hdrCapacityMin(e) {
    ;(this._hdrCapacityMin = e), this.calculateWeight()
  }
  get hdrCapacityMax() {
    return this._hdrCapacityMax
  }
  set hdrCapacityMax(e) {
    ;(this._hdrCapacityMax = e), this.calculateWeight()
  }
  get maxDisplayBoost() {
    return this._maxDisplayBoost
  }
  set maxDisplayBoost(e) {
    ;(this._maxDisplayBoost = Math.max(1, Math.min(65504, e))),
      this.calculateWeight()
  }
  calculateWeight() {
    const e =
      (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) /
      (this._hdrCapacityMax - this._hdrCapacityMin)
    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e))
  }
}
class VD extends Error {}
class jD extends Error {}
const Qp = (n, e, t) => {
    const i = new RegExp(`${e}="([^"]*)"`, 'i').exec(n)
    if (i) return i[1]
    const r = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`, 'i').exec(n)
    if (r) {
      const s = r[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g)
      return s && s.length === 3
        ? s.map((o) => o.replace(/<\/?rdf:li>/g, ''))
        : r[1].trim()
    }
    if (t !== void 0) return t
    throw new Error(`Can't find ${e} in gainmap metadata`)
  },
  m7 = (n) => {
    let e
    typeof TextDecoder < 'u'
      ? (e = new TextDecoder().decode(n))
      : (e = n.toString())
    let t = e.indexOf('<x:xmpmeta')
    for (; t !== -1; ) {
      const i = e.indexOf('x:xmpmeta>', t),
        r = e.slice(t, i + 10)
      try {
        const s = Qp(r, 'hdrgm:GainMapMin', '0'),
          o = Qp(r, 'hdrgm:GainMapMax'),
          a = Qp(r, 'hdrgm:Gamma', '1'),
          c = Qp(r, 'hdrgm:OffsetSDR', '0.015625'),
          u = Qp(r, 'hdrgm:OffsetHDR', '0.015625'),
          h = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(r),
          m = h ? h[1] : '0',
          g = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(r)
        if (!g) throw new Error('Incomplete gainmap metadata')
        const y = g[1]
        return {
          gainMapMin: Array.isArray(s)
            ? s.map((_) => parseFloat(_))
            : [parseFloat(s), parseFloat(s), parseFloat(s)],
          gainMapMax: Array.isArray(o)
            ? o.map((_) => parseFloat(_))
            : [parseFloat(o), parseFloat(o), parseFloat(o)],
          gamma: Array.isArray(a)
            ? a.map((_) => parseFloat(_))
            : [parseFloat(a), parseFloat(a), parseFloat(a)],
          offsetSdr: Array.isArray(c)
            ? c.map((_) => parseFloat(_))
            : [parseFloat(c), parseFloat(c), parseFloat(c)],
          offsetHdr: Array.isArray(u)
            ? u.map((_) => parseFloat(_))
            : [parseFloat(u), parseFloat(u), parseFloat(u)],
          hdrCapacityMin: parseFloat(m),
          hdrCapacityMax: parseFloat(y),
        }
      } catch {}
      t = e.indexOf('<x:xmpmeta', i)
    }
  }
class g7 {
  constructor(e) {
    this.options = {
      debug: e && e.debug !== void 0 ? e.debug : !1,
      extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0,
      extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0,
    }
  }
  extract(e) {
    return new Promise((t, i) => {
      const r = this.options.debug,
        s = new DataView(e.buffer)
      if (s.getUint16(0) !== 65496) {
        i(new Error('Not a valid jpeg'))
        return
      }
      const o = s.byteLength
      let a = 2,
        c = 0,
        u
      for (; a < o; ) {
        if (++c > 250) {
          i(new Error(`Found no marker after ${c} loops 😵`))
          return
        }
        if (s.getUint8(a) !== 255) {
          i(
            new Error(
              `Not a valid marker at offset 0x${a.toString(16)}, found: 0x${s
                .getUint8(a)
                .toString(16)}`,
            ),
          )
          return
        }
        if (
          ((u = s.getUint8(a + 1)),
          r && console.log(`Marker: ${u.toString(16)}`),
          u === 226)
        ) {
          r && console.log('Found APP2 marker (0xffe2)')
          const h = a + 4
          if (s.getUint32(h) === 1297106432) {
            const m = h + 4
            let g
            if (s.getUint16(m) === 18761) g = !1
            else if (s.getUint16(m) === 19789) g = !0
            else {
              i(new Error('No valid endianness marker found in TIFF header'))
              return
            }
            if (s.getUint16(m + 2, !g) !== 42) {
              i(new Error('Not valid TIFF data! (no 0x002A marker)'))
              return
            }
            const y = s.getUint32(m + 4, !g)
            if (y < 8) {
              i(new Error('Not valid TIFF data! (First offset less than 8)'))
              return
            }
            const _ = m + y,
              M = s.getUint16(_, !g),
              w = _ + 2
            let x = 0
            for (let D = w; D < w + 12 * M; D += 12)
              s.getUint16(D, !g) === 45057 && (x = s.getUint32(D + 8, !g))
            const A = _ + 2 + M * 12 + 4,
              P = []
            for (let D = A; D < A + x * 16; D += 16) {
              const O = {
                MPType: s.getUint32(D, !g),
                size: s.getUint32(D + 4, !g),
                dataOffset: s.getUint32(D + 8, !g),
                dependantImages: s.getUint32(D + 12, !g),
                start: -1,
                end: -1,
                isFII: !1,
              }
              O.dataOffset
                ? ((O.start = m + O.dataOffset), (O.isFII = !1))
                : ((O.start = 0), (O.isFII = !0)),
                (O.end = O.start + O.size),
                P.push(O)
            }
            if (this.options.extractNonFII && P.length) {
              const D = new Blob([s]),
                O = []
              for (const U of P) {
                if (U.isFII && !this.options.extractFII) continue
                const F = D.slice(U.start, U.end + 1, 'image/jpeg')
                O.push(F)
              }
              t(O)
            }
          }
        }
        a += 2 + s.getUint16(a + 2)
      }
    })
  }
}
const v7 = async (n) => {
    const e = m7(n)
    if (!e) throw new jD('Gain map XMP metadata not found')
    const i = await new g7({ extractFII: !0, extractNonFII: !0 }).extract(n)
    if (i.length !== 2) throw new VD('Gain map recovery image not found')
    return {
      sdr: new Uint8Array(await i[0].arrayBuffer()),
      gainMap: new Uint8Array(await i[1].arrayBuffer()),
      metadata: e,
    }
  },
  oP = (n) =>
    new Promise((e, t) => {
      const i = document.createElement('img')
      ;(i.onload = () => {
        e(i)
      }),
        (i.onerror = (r) => {
          t(r)
        }),
        (i.src = URL.createObjectURL(n))
    })
class HD extends ns {
  constructor(e, t) {
    super(t),
      e && (this._renderer = e),
      (this._internalLoadingManager = new g_())
  }
  setRenderer(e) {
    return (this._renderer = e), this
  }
  setRenderTargetOptions(e) {
    return (this._renderTargetOptions = e), this
  }
  prepareQuadRenderer() {
    this._renderer ||
      console.warn(
        'WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.',
      )
    const e = new p7({
      gainMapMax: [1, 1, 1],
      gainMapMin: [0, 0, 0],
      gamma: [1, 1, 1],
      offsetHdr: [1, 1, 1],
      offsetSdr: [1, 1, 1],
      hdrCapacityMax: 1,
      hdrCapacityMin: 0,
      maxDisplayBoost: 1,
      gainMap: new Xn(),
      sdr: new Xn(),
    })
    return new sb({
      width: 16,
      height: 16,
      type: or,
      colorSpace: Aa,
      material: e,
      renderer: this._renderer,
      renderTargetOptions: this._renderTargetOptions,
    })
  }
  async render(e, t, i, r) {
    const s = r ? new Blob([r], { type: 'image/jpeg' }) : void 0,
      o = new Blob([i], { type: 'image/jpeg' })
    let a,
      c,
      u = !1
    if (typeof createImageBitmap > 'u') {
      const g = await Promise.all([s ? oP(s) : Promise.resolve(void 0), oP(o)])
      ;(c = g[0]), (a = g[1]), (u = !0)
    } else {
      const g = await Promise.all([
        s
          ? createImageBitmap(s, { imageOrientation: 'flipY' })
          : Promise.resolve(void 0),
        createImageBitmap(o, { imageOrientation: 'flipY' }),
      ])
      ;(c = g[0]), (a = g[1])
    }
    const h = new Xn(
      c || new ImageData(2, 2),
      Cc,
      Bi,
      Bi,
      Vn,
      kS,
      Ii,
      _s,
      1,
      Aa,
    )
    ;(h.flipY = u), (h.needsUpdate = !0)
    const m = new Xn(a, Cc, Bi, Bi, Vn, kS, Ii, _s, 1, Zr)
    ;(m.flipY = u),
      (m.needsUpdate = !0),
      (e.width = a.width),
      (e.height = a.height),
      (e.material.gainMap = h),
      (e.material.sdr = m),
      (e.material.gainMapMin = t.gainMapMin),
      (e.material.gainMapMax = t.gainMapMax),
      (e.material.offsetHdr = t.offsetHdr),
      (e.material.offsetSdr = t.offsetSdr),
      (e.material.gamma = t.gamma),
      (e.material.hdrCapacityMin = t.hdrCapacityMin),
      (e.material.hdrCapacityMax = t.hdrCapacityMax),
      (e.material.maxDisplayBoost = Math.pow(2, t.hdrCapacityMax)),
      (e.material.needsUpdate = !0),
      e.render()
  }
}
class y7 extends HD {
  load([e, t, i], r, s, o) {
    const a = this.prepareQuadRenderer()
    let c, u, h
    const m = async () => {
      if (c && u && h) {
        try {
          await this.render(a, h, c, u)
        } catch (N) {
          this.manager.itemError(e),
            this.manager.itemError(t),
            this.manager.itemError(i),
            typeof o == 'function' && o(N),
            a.disposeOnDemandRenderer()
          return
        }
        typeof r == 'function' && r(a),
          this.manager.itemEnd(e),
          this.manager.itemEnd(t),
          this.manager.itemEnd(i),
          a.disposeOnDemandRenderer()
      }
    }
    let g = !0,
      y = 0,
      _ = 0,
      M = !0,
      w = 0,
      x = 0,
      T = !0,
      A = 0,
      P = 0
    const D = () => {
      if (typeof s == 'function') {
        const N = y + w + A,
          k = _ + x + P,
          z = g && M && T
        s(
          new ProgressEvent('progress', {
            lengthComputable: z,
            loaded: k,
            total: N,
          }),
        )
      }
    }
    this.manager.itemStart(e),
      this.manager.itemStart(t),
      this.manager.itemStart(i)
    const O = new Os(this._internalLoadingManager)
    O.setResponseType('arraybuffer'),
      O.setRequestHeader(this.requestHeader),
      O.setPath(this.path),
      O.setWithCredentials(this.withCredentials),
      O.load(
        e,
        async (N) => {
          if (typeof N == 'string') throw new Error('Invalid sdr buffer')
          ;(c = N), await m()
        },
        (N) => {
          ;(g = N.lengthComputable), (_ = N.loaded), (y = N.total), D()
        },
        (N) => {
          this.manager.itemError(e), typeof o == 'function' && o(N)
        },
      )
    const U = new Os(this._internalLoadingManager)
    U.setResponseType('arraybuffer'),
      U.setRequestHeader(this.requestHeader),
      U.setPath(this.path),
      U.setWithCredentials(this.withCredentials),
      U.load(
        t,
        async (N) => {
          if (typeof N == 'string') throw new Error('Invalid gainmap buffer')
          ;(u = N), await m()
        },
        (N) => {
          ;(M = N.lengthComputable), (x = N.loaded), (w = N.total), D()
        },
        (N) => {
          this.manager.itemError(t), typeof o == 'function' && o(N)
        },
      )
    const F = new Os(this._internalLoadingManager)
    return (
      F.setRequestHeader(this.requestHeader),
      F.setPath(this.path),
      F.setWithCredentials(this.withCredentials),
      F.load(
        i,
        async (N) => {
          if (typeof N != 'string') throw new Error('Invalid metadata string')
          ;(h = JSON.parse(N)), await m()
        },
        (N) => {
          ;(T = N.lengthComputable), (P = N.loaded), (A = N.total), D()
        },
        (N) => {
          this.manager.itemError(i), typeof o == 'function' && o(N)
        },
      ),
      a
    )
  }
}
class x7 extends HD {
  load(e, t, i, r) {
    const s = this.prepareQuadRenderer(),
      o = new Os(this._internalLoadingManager)
    return (
      o.setResponseType('arraybuffer'),
      o.setRequestHeader(this.requestHeader),
      o.setPath(this.path),
      o.setWithCredentials(this.withCredentials),
      this.manager.itemStart(e),
      o.load(
        e,
        async (a) => {
          if (typeof a == 'string')
            throw new Error(
              'Invalid buffer, received [string], was expecting [ArrayBuffer]',
            )
          const c = new Uint8Array(a)
          let u, h, m
          try {
            const g = await v7(c)
            ;(u = g.sdr), (h = g.gainMap), (m = g.metadata)
          } catch (g) {
            if (g instanceof jD || g instanceof VD)
              console.warn(
                `Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`,
              ),
                (m = {
                  gainMapMin: [0, 0, 0],
                  gainMapMax: [1, 1, 1],
                  gamma: [1, 1, 1],
                  hdrCapacityMin: 0,
                  hdrCapacityMax: 1,
                  offsetHdr: [0, 0, 0],
                  offsetSdr: [0, 0, 0],
                }),
                (u = c)
            else throw g
          }
          try {
            await this.render(s, m, u, h)
          } catch (g) {
            this.manager.itemError(e),
              typeof r == 'function' && r(g),
              s.disposeOnDemandRenderer()
            return
          }
          typeof t == 'function' && t(s),
            this.manager.itemEnd(e),
            s.disposeOnDemandRenderer()
        },
        i,
        (a) => {
          this.manager.itemError(e), typeof r == 'function' && r(a)
        },
      ),
      s
    )
  }
}
const dg = {
    apartment: 'lebombo_1k.hdr',
    city: 'potsdamer_platz_1k.hdr',
    dawn: 'kiara_1_dawn_1k.hdr',
    forest: 'forest_slope_1k.hdr',
    lobby: 'st_fagans_interior_1k.hdr',
    night: 'dikhololo_night_1k.hdr',
    park: 'rooitou_park_1k.hdr',
    studio: 'studio_small_03_1k.hdr',
    sunset: 'venice_sunset_1k.hdr',
    warehouse: 'empty_warehouse_01_1k.hdr',
  },
  GD =
    'https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/',
  fh = (n) => Array.isArray(n),
  ob = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png']
function T_({
  files: n = ob,
  path: e = '',
  preset: t = void 0,
  encoding: i = void 0,
  extensions: r,
} = {}) {
  let s = null,
    o = !1
  t && (ab(t), (n = dg[t]), (e = GD)), (o = fh(n))
  const { extension: a, isCubemap: c } = lb(n)
  if (((s = cb(a)), !s))
    throw new Error('useEnvironment: Unrecognized file extension: ' + n)
  const u = yh((y) => y.gl)
  X.useLayoutEffect(() => {
    if (a !== 'webp' && a !== 'jpg' && a !== 'jpeg') return
    function y() {
      xh.clear(s, o ? [n] : n)
    }
    u.domElement.addEventListener('webglcontextlost', y, { once: !0 })
  }, [n, u.domElement])
  const h = xh(s, o ? [n] : n, (y) => {
    ;(a === 'webp' || a === 'jpg' || a === 'jpeg') && y.setRenderer(u),
      y.setPath == null || y.setPath(e),
      r && r(y)
  })
  let m = o ? h[0] : h
  if (a === 'jpg' || a === 'jpeg' || a === 'webp') {
    var g
    m = (g = m.renderTarget) == null ? void 0 : g.texture
  }
  return (
    (m.mapping = c ? ba : hh),
    'colorSpace' in m
      ? (m.colorSpace = i ?? c ? 'srgb' : 'srgb-linear')
      : (m.encoding = i ?? c ? a7 : o7),
    m
  )
}
const _7 = { files: ob, path: '', preset: void 0, extensions: void 0 }
T_.preload = (n) => {
  const e = { ..._7, ...n }
  let { files: t, path: i = '' } = e
  const { preset: r, extensions: s } = e
  r && (ab(r), (t = dg[r]), (i = GD))
  const { extension: o } = lb(t)
  if (o === 'webp' || o === 'jpg' || o === 'jpeg')
    throw new Error('useEnvironment: Preloading gainmaps is not supported')
  const a = cb(o)
  if (!a) throw new Error('useEnvironment: Unrecognized file extension: ' + t)
  xh.preload(a, fh(t) ? [t] : t, (c) => {
    c.setPath == null || c.setPath(i), s && s(c)
  })
}
const w7 = { files: ob, preset: void 0 }
T_.clear = (n) => {
  const e = { ...w7, ...n }
  let { files: t } = e
  const { preset: i } = e
  i && (ab(i), (t = dg[i]))
  const { extension: r } = lb(t),
    s = cb(r)
  if (!s) throw new Error('useEnvironment: Unrecognized file extension: ' + t)
  xh.clear(s, fh(t) ? [t] : t)
}
function ab(n) {
  if (!(n in dg))
    throw new Error('Preset must be one of: ' + Object.keys(dg).join(', '))
}
function lb(n) {
  var e
  const t = fh(n) && n.length === 6,
    i = fh(n) && n.length === 3 && n.some((o) => o.endsWith('json')),
    r = fh(n) ? n[0] : n
  return {
    extension: t
      ? 'cube'
      : i
      ? 'webp'
      : r.startsWith('data:application/exr')
      ? 'exr'
      : r.startsWith('data:application/hdr')
      ? 'hdr'
      : r.startsWith('data:image/jpeg')
      ? 'jpg'
      : (e = r.split('.').pop()) == null ||
        (e = e.split('?')) == null ||
        (e = e.shift()) == null
      ? void 0
      : e.toLowerCase(),
    isCubemap: t,
    isGainmap: i,
  }
}
function cb(n) {
  return n === 'cube'
    ? hN
    : n === 'hdr'
    ? e7
    : n === 'exr'
    ? t7
    : n === 'jpg' || n === 'jpeg'
    ? x7
    : n === 'webp'
    ? y7
    : null
}
const S7 = (n) => n.current && n.current.isScene,
  M7 = (n) => (S7(n) ? n.current : n)
function ub(n, e, t, i, r = {}) {
  var s, o, a, c
  r = {
    backgroundBlurriness: 0,
    backgroundIntensity: 1,
    backgroundRotation: [0, 0, 0],
    environmentIntensity: 1,
    environmentRotation: [0, 0, 0],
    ...r,
  }
  const u = M7(e || t),
    h = u.background,
    m = u.environment,
    g = {
      backgroundBlurriness: u.backgroundBlurriness,
      backgroundIntensity: u.backgroundIntensity,
      backgroundRotation:
        (s =
          (o = u.backgroundRotation) == null || o.clone == null
            ? void 0
            : o.clone()) !== null && s !== void 0
          ? s
          : [0, 0, 0],
      environmentIntensity: u.environmentIntensity,
      environmentRotation:
        (a =
          (c = u.environmentRotation) == null || c.clone == null
            ? void 0
            : c.clone()) !== null && a !== void 0
          ? a
          : [0, 0, 0],
    }
  return (
    n !== 'only' && (u.environment = i),
    n && (u.background = i),
    ha(u, r),
    () => {
      n !== 'only' && (u.environment = m), n && (u.background = h), ha(u, g)
    }
  )
}
function db({ scene: n, background: e = !1, map: t, ...i }) {
  const r = yh((s) => s.scene)
  return (
    X.useLayoutEffect(() => {
      if (t) return ub(e, n, r, t, i)
    }),
    null
  )
}
function WD({
  background: n = !1,
  scene: e,
  blur: t,
  backgroundBlurriness: i,
  backgroundIntensity: r,
  backgroundRotation: s,
  environmentIntensity: o,
  environmentRotation: a,
  ...c
}) {
  const u = T_(c),
    h = yh((m) => m.scene)
  return (
    X.useLayoutEffect(() =>
      ub(n, e, h, u, {
        backgroundBlurriness: t ?? i,
        backgroundIntensity: r,
        backgroundRotation: s,
        environmentIntensity: o,
        environmentRotation: a,
      }),
    ),
    X.useEffect(
      () => () => {
        u.dispose()
      },
      [u],
    ),
    null
  )
}
function E7({
  children: n,
  near: e = 0.1,
  far: t = 1e3,
  resolution: i = 256,
  frames: r = 1,
  map: s,
  background: o = !1,
  blur: a,
  backgroundBlurriness: c,
  backgroundIntensity: u,
  backgroundRotation: h,
  environmentIntensity: m,
  environmentRotation: g,
  scene: y,
  files: _,
  path: M,
  preset: w = void 0,
  extensions: x,
}) {
  const T = yh((F) => F.gl),
    A = yh((F) => F.scene),
    P = X.useRef(null),
    [D] = X.useState(() => new Lg()),
    O = X.useMemo(() => {
      const F = new uE(i)
      return (F.texture.type = or), F
    }, [i])
  X.useEffect(
    () => () => {
      O.dispose()
    },
    [O],
  ),
    X.useLayoutEffect(() => {
      if (r === 1) {
        const F = T.autoClear
        ;(T.autoClear = !0), P.current.update(T, D), (T.autoClear = F)
      }
      return ub(o, y, A, O.texture, {
        backgroundBlurriness: a ?? c,
        backgroundIntensity: u,
        backgroundRotation: h,
        environmentIntensity: m,
        environmentRotation: g,
      })
    }, [n, D, O.texture, y, A, o, r, T])
  let U = 1
  return (
    Vg(() => {
      if (r === 1 / 0 || U < r) {
        const F = T.autoClear
        ;(T.autoClear = !0), P.current.update(T, D), (T.autoClear = F), U++
      }
    }),
    X.createElement(
      X.Fragment,
      null,
      r9(
        X.createElement(
          X.Fragment,
          null,
          n,
          X.createElement('cubeCamera', { ref: P, args: [e, t, O] }),
          _ || w
            ? X.createElement(WD, {
                background: !0,
                files: _,
                preset: w,
                path: M,
                extensions: x,
              })
            : s
            ? X.createElement(db, { background: !0, map: s, extensions: x })
            : null,
        ),
        D,
      ),
    )
  )
}
function b7(n) {
  var e, t, i, r
  const s = T_(n),
    o = n.map || s
  X.useMemo(() => BN({ GroundProjectedEnvImpl: JW }), []),
    X.useEffect(
      () => () => {
        s.dispose()
      },
      [s],
    )
  const a = X.useMemo(() => [o], [o]),
    c = (e = n.ground) == null ? void 0 : e.height,
    u = (t = n.ground) == null ? void 0 : t.radius,
    h =
      (i = (r = n.ground) == null ? void 0 : r.scale) !== null && i !== void 0
        ? i
        : 1e3
  return X.createElement(
    X.Fragment,
    null,
    X.createElement(db, wh({}, n, { map: o })),
    X.createElement('groundProjectedEnvImpl', {
      args: a,
      scale: h,
      height: c,
      radius: u,
    }),
  )
}
function T7(n) {
  return n.ground
    ? X.createElement(b7, n)
    : n.map
    ? X.createElement(db, n)
    : n.children
    ? X.createElement(E7, n)
    : X.createElement(WD, n)
}
const aP = X.forwardRef(
    (
      {
        light: n,
        args: e,
        map: t,
        toneMapped: i = !1,
        color: r = 'white',
        form: s = 'rect',
        intensity: o = 1,
        scale: a = 1,
        target: c = [0, 0, 0],
        children: u,
        ...h
      },
      m,
    ) => {
      const g = X.useRef(null)
      return (
        X.useImperativeHandle(m, () => g.current, []),
        X.useLayoutEffect(() => {
          !u &&
            !h.material &&
            (ha(g.current.material, { color: r }),
            g.current.material.color.multiplyScalar(o))
        }, [r, o, u, h.material]),
        X.useLayoutEffect(() => {
          h.rotation || g.current.quaternion.identity(),
            c &&
              !h.rotation &&
              (typeof c == 'boolean'
                ? g.current.lookAt(0, 0, 0)
                : g.current.lookAt(Array.isArray(c) ? new re(...c) : c))
        }, [c, h.rotation]),
        (a = Array.isArray(a) && a.length === 2 ? [a[0], a[1], 1] : a),
        X.createElement(
          'mesh',
          wh({ ref: g, scale: a }, h),
          s === 'circle'
            ? X.createElement('ringGeometry', { args: e || [0, 0.5, 64] })
            : s === 'ring'
            ? X.createElement('ringGeometry', { args: e || [0.25, 0.5, 64] })
            : s === 'rect' || s === 'plane'
            ? X.createElement('planeGeometry', { args: e || [1, 1] })
            : s === 'box'
            ? X.createElement('boxGeometry', { args: e || [1, 1, 1] })
            : X.createElement(s, { args: e }),
          u ||
            X.createElement('meshBasicMaterial', {
              toneMapped: i,
              map: t,
              side: oo,
            }),
          n && X.createElement('pointLight', wh({ castShadow: !0 }, n)),
        )
      )
    },
  ),
  A7 = ({ lightRef: n }) => {
    const e = tP(u7),
      [{ wobble: t, color: i, coat: r, env: s, thickness: o }] = DW(
        {
          wobble: 1.1,
          color: '#FFFFFF',
          coat: 0.1,
          env: 0.5,
          thickness: 2,
          config: { mass: 2, tension: 100, friction: 10 },
        },
        [],
      )
    return b.jsx('group', {
      position: [0, 0, -5],
      children: b.jsxs(tP.mesh, {
        scale: t,
        children: [
          b.jsx('sphereGeometry', { args: [1, 32, 32] }),
          b.jsx(e, {
            distort: 0.25,
            speed: 2,
            clearcoat: r,
            metalness: 0.2,
            color: i,
            envMapIntensity: s,
            opacity: 0.2,
            transparent: !0,
            refractionRatio: 0.98,
            transmission: 1,
            backside: !0,
            backsideThickness: 1,
            thickness: o,
            roughness: 0,
            chromaticAberration: 0,
          }),
        ],
      }),
    })
  },
  C7 = () => {
    const [n, e] = X.useState([0, 0, -5.5]),
      [t, i] = X.useState(!1)
    X.useEffect(() => {
      const s = () => {
        i(window.innerWidth <= 768)
      }
      return (
        s(),
        window.addEventListener('resize', s),
        () => window.removeEventListener('resize', s)
      )
    }, [])
    const r = (s) => {
      if (t) return
      const { clientX: o, clientY: a, target: c } = s,
        u = c.getBoundingClientRect(),
        h = (o - u.left) / u.width - 0.5,
        m = (a - u.top) / u.height - 0.5
      e([h * 5, -m, -5.5])
    }
    return b.jsxs(HE, {
      style: { height: '100vh', width: '100vw' },
      onPointerMove: r,
      camera: { position: [0, 0, 0], fov: 40 },
      children: [
        b.jsx('ambientLight', { intensity: 2 }),
        b.jsx('pointLight', {
          intensity: 1,
          color: '#FE923A',
          position: n,
          decay: 10,
        }),
        b.jsx(A7, {}),
        b.jsxs('mesh', {
          receiveShadow: !0,
          position: [0, 0, -6],
          children: [
            b.jsx('planeGeometry', { args: [20, 20] }),
            b.jsx('meshStandardMaterial', { color: '#FFFFFF' }),
          ],
        }),
        b.jsx(T7, {
          resolution: 256,
          children: b.jsxs('group', {
            rotation: [-Math.PI / 2, 0, 0],
            children: [
              b.jsx(aP, {
                intensity: 4,
                'rotation-x': Math.PI / 2,
                position: [0, 5, -9],
                scale: [10, 10, 1],
              }),
              [2, 0, 2].map((s, o) =>
                b.jsx(
                  aP,
                  {
                    form: 'circle',
                    intensity: 4,
                    rotation: [Math.PI / 2, 0, 0],
                    position: [s, 4, o * 4],
                    scale: [4, 1, 1],
                  },
                  o,
                ),
              ),
            ],
          }),
        }),
      ],
    })
  }
function Ic({ theme: n, color: e }) {
  return b.jsx(Fs, {
    to: '/',
    children: b.jsx('div', {
      'data-theme': n,
      className: `
            z-50 w-[5%] max-w-[25px] xl:max-w-none xl:w-[1.5%] md:block fixed top-4 left-4 xl:top-[3%] xl:left-[2.65%] 
            ${e ? `${e}` : 'text-primary'} 
        `,
      children: b.jsxs('svg', {
        id: 'Layer_1',
        'data-name': 'Layer 1',
        xmlns: 'http://www.w3.org/2000/svg',
        viewBox: '0 0 143 166',
        children: [
          b.jsx('path', {
            className: 'cls-1',
            d: 'M83.26,83.27c0,15.38,9.23,25.7,25.63,25.7s25.63-10.33,25.63-25.7-9.24-25.47-25.63-25.47-25.63,10.33-25.63,25.47Z',
            fill: '#ff0',
          }),
          b.jsx('path', {
            className: 'cls-1',
            d: 'M143,58.14V.76H-.85L19.7,13.15V162.33H1.23v3.67H143v-57.38h-.23c-21.71,39.93-45.03,53.25-72.27,53.7V4.43c27.24,.23,50.57,14.23,72.27,53.71h.23Z',
            fill: '#f00',
          }),
        ],
      }),
    }),
  })
}
var ci = {},
  Z0 = {},
  K0 = {},
  Q0 = {},
  Fw,
  lP
function P7() {
  if (lP) return Fw
  lP = 1
  var n = 'Expected a function',
    e = NaN,
    t = '[object Symbol]',
    i = /^\s+|\s+$/g,
    r = /^[-+]0x[0-9a-f]+$/i,
    s = /^0b[01]+$/i,
    o = /^0o[0-7]+$/i,
    a = parseInt,
    c = typeof Ku == 'object' && Ku && Ku.Object === Object && Ku,
    u = typeof self == 'object' && self && self.Object === Object && self,
    h = c || u || Function('return this')(),
    m = Object.prototype,
    g = m.toString,
    y = Math.max,
    _ = Math.min,
    M = function () {
      return h.Date.now()
    }
  function w(O, U, F) {
    var N,
      k,
      z,
      $,
      te,
      j,
      K = 0,
      J = !1,
      ne = !1,
      V = !0
    if (typeof O != 'function') throw new TypeError(n)
    ;(U = D(U) || 0),
      T(F) &&
        ((J = !!F.leading),
        (ne = 'maxWait' in F),
        (z = ne ? y(D(F.maxWait) || 0, U) : z),
        (V = 'trailing' in F ? !!F.trailing : V))
    function Y(Be) {
      var et = N,
        ft = k
      return (N = k = void 0), (K = Be), ($ = O.apply(ft, et)), $
    }
    function Q(Be) {
      return (K = Be), (te = setTimeout(_e, U)), J ? Y(Be) : $
    }
    function q(Be) {
      var et = Be - j,
        ft = Be - K,
        Vt = U - et
      return ne ? _(Vt, z - ft) : Vt
    }
    function oe(Be) {
      var et = Be - j,
        ft = Be - K
      return j === void 0 || et >= U || et < 0 || (ne && ft >= z)
    }
    function _e() {
      var Be = M()
      if (oe(Be)) return he(Be)
      te = setTimeout(_e, q(Be))
    }
    function he(Be) {
      return (te = void 0), V && N ? Y(Be) : ((N = k = void 0), $)
    }
    function Ce() {
      te !== void 0 && clearTimeout(te), (K = 0), (N = j = k = te = void 0)
    }
    function Te() {
      return te === void 0 ? $ : he(M())
    }
    function Pe() {
      var Be = M(),
        et = oe(Be)
      if (((N = arguments), (k = this), (j = Be), et)) {
        if (te === void 0) return Q(j)
        if (ne) return (te = setTimeout(_e, U)), Y(j)
      }
      return te === void 0 && (te = setTimeout(_e, U)), $
    }
    return (Pe.cancel = Ce), (Pe.flush = Te), Pe
  }
  function x(O, U, F) {
    var N = !0,
      k = !0
    if (typeof O != 'function') throw new TypeError(n)
    return (
      T(F) &&
        ((N = 'leading' in F ? !!F.leading : N),
        (k = 'trailing' in F ? !!F.trailing : k)),
      w(O, U, { leading: N, maxWait: U, trailing: k })
    )
  }
  function T(O) {
    var U = typeof O
    return !!O && (U == 'object' || U == 'function')
  }
  function A(O) {
    return !!O && typeof O == 'object'
  }
  function P(O) {
    return typeof O == 'symbol' || (A(O) && g.call(O) == t)
  }
  function D(O) {
    if (typeof O == 'number') return O
    if (P(O)) return e
    if (T(O)) {
      var U = typeof O.valueOf == 'function' ? O.valueOf() : O
      O = T(U) ? U + '' : U
    }
    if (typeof O != 'string') return O === 0 ? O : +O
    O = O.replace(i, '')
    var F = s.test(O)
    return F || o.test(O) ? a(O.slice(2), F ? 2 : 8) : r.test(O) ? e : +O
  }
  return (Fw = x), Fw
}
var Jp = {},
  cP
function fb() {
  if (cP) return Jp
  ;(cP = 1),
    Object.defineProperty(Jp, '__esModule', { value: !0 }),
    (Jp.addPassiveEventListener = function (t, i, r) {
      var s = r.name
      s || ((s = i), console.warn('Listener must be a named function.')),
        n.has(i) || n.set(i, new Set())
      var o = n.get(i)
      if (!o.has(s)) {
        var a = (function () {
          var c = !1
          try {
            var u = Object.defineProperty({}, 'passive', {
              get: function () {
                c = !0
              },
            })
            window.addEventListener('test', null, u)
          } catch {}
          return c
        })()
        t.addEventListener(i, r, a ? { passive: !0 } : !1), o.add(s)
      }
    }),
    (Jp.removePassiveEventListener = function (t, i, r) {
      t.removeEventListener(i, r), n.get(i).delete(r.name || i)
    })
  var n = new Map()
  return Jp
}
var uP
function hb() {
  if (uP) return Q0
  ;(uP = 1), Object.defineProperty(Q0, '__esModule', { value: !0 })
  var n = P7(),
    e = i(n),
    t = fb()
  function i(o) {
    return o && o.__esModule ? o : { default: o }
  }
  var r = function (a) {
      var c =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66
      return (0, e.default)(a, c)
    },
    s = {
      spyCallbacks: [],
      spySetState: [],
      scrollSpyContainers: [],
      mount: function (a, c) {
        if (a) {
          var u = r(function (h) {
            s.scrollHandler(a)
          }, c)
          s.scrollSpyContainers.push(a),
            (0, t.addPassiveEventListener)(a, 'scroll', u)
        }
      },
      isMounted: function (a) {
        return s.scrollSpyContainers.indexOf(a) !== -1
      },
      currentPositionX: function (a) {
        if (a === document) {
          var c = window.pageYOffset !== void 0,
            u = (document.compatMode || '') === 'CSS1Compat'
          return c
            ? window.pageXOffset
            : u
            ? document.documentElement.scrollLeft
            : document.body.scrollLeft
        } else return a.scrollLeft
      },
      currentPositionY: function (a) {
        if (a === document) {
          var c = window.pageXOffset !== void 0,
            u = (document.compatMode || '') === 'CSS1Compat'
          return c
            ? window.pageYOffset
            : u
            ? document.documentElement.scrollTop
            : document.body.scrollTop
        } else return a.scrollTop
      },
      scrollHandler: function (a) {
        var c =
          s.scrollSpyContainers[s.scrollSpyContainers.indexOf(a)]
            .spyCallbacks || []
        c.forEach(function (u) {
          return u(s.currentPositionX(a), s.currentPositionY(a))
        })
      },
      addStateHandler: function (a) {
        s.spySetState.push(a)
      },
      addSpyHandler: function (a, c) {
        var u = s.scrollSpyContainers[s.scrollSpyContainers.indexOf(c)]
        u.spyCallbacks || (u.spyCallbacks = []),
          u.spyCallbacks.push(a),
          a(s.currentPositionX(c), s.currentPositionY(c))
      },
      updateStates: function () {
        s.spySetState.forEach(function (a) {
          return a()
        })
      },
      unmount: function (a, c) {
        s.scrollSpyContainers.forEach(function (u) {
          return (
            u.spyCallbacks &&
            u.spyCallbacks.length &&
            u.spyCallbacks.indexOf(c) > -1 &&
            u.spyCallbacks.splice(u.spyCallbacks.indexOf(c), 1)
          )
        }),
          s.spySetState &&
            s.spySetState.length &&
            s.spySetState.indexOf(a) > -1 &&
            s.spySetState.splice(s.spySetState.indexOf(a), 1),
          document.removeEventListener('scroll', s.scrollHandler)
      },
      update: function () {
        return s.scrollSpyContainers.forEach(function (a) {
          return s.scrollHandler(a)
        })
      },
    }
  return (Q0.default = s), Q0
}
var J0 = {},
  ey = {},
  dP
function A_() {
  if (dP) return ey
  ;(dP = 1), Object.defineProperty(ey, '__esModule', { value: !0 })
  var n = function (a, c) {
      var u = a.indexOf('#') === 0 ? a.substring(1) : a,
        h = u ? '#' + u : '',
        m = window && window.location,
        g = h ? m.pathname + m.search + h : m.pathname + m.search
      c
        ? history.pushState(history.state, '', g)
        : history.replaceState(history.state, '', g)
    },
    e = function () {
      return window.location.hash.replace(/^#/, '')
    },
    t = function (a) {
      return function (c) {
        return a.contains
          ? a != c && a.contains(c)
          : !!(a.compareDocumentPosition(c) & 16)
      }
    },
    i = function (a) {
      return getComputedStyle(a).position !== 'static'
    },
    r = function (a, c) {
      for (var u = a.offsetTop, h = a.offsetParent; h && !c(h); )
        (u += h.offsetTop), (h = h.offsetParent)
      return { offsetTop: u, offsetParent: h }
    },
    s = function (a, c, u) {
      if (u)
        return a === document
          ? c.getBoundingClientRect().left +
              (window.scrollX || window.pageXOffset)
          : getComputedStyle(a).position !== 'static'
          ? c.offsetLeft
          : c.offsetLeft - a.offsetLeft
      if (a === document)
        return (
          c.getBoundingClientRect().top + (window.scrollY || window.pageYOffset)
        )
      if (i(a)) {
        if (c.offsetParent !== a) {
          var h = function (w) {
              return w === a || w === document
            },
            m = r(c, h),
            g = m.offsetTop,
            y = m.offsetParent
          if (y !== a)
            throw new Error(
              'Seems containerElement is not an ancestor of the Element',
            )
          return g
        }
        return c.offsetTop
      }
      if (c.offsetParent === a.offsetParent) return c.offsetTop - a.offsetTop
      var _ = function (w) {
        return w === document
      }
      return r(c, _).offsetTop - r(a, _).offsetTop
    }
  return (
    (ey.default = {
      updateHash: n,
      getHash: e,
      filterElementInContainer: t,
      scrollOffset: s,
    }),
    ey
  )
}
var ty = {},
  ny = {},
  fP
function R7() {
  return (
    fP ||
      ((fP = 1),
      Object.defineProperty(ny, '__esModule', { value: !0 }),
      (ny.default = {
        defaultEasing: function (e) {
          return e < 0.5
            ? Math.pow(e * 2, 2) / 2
            : 1 - Math.pow((1 - e) * 2, 2) / 2
        },
        linear: function (e) {
          return e
        },
        easeInQuad: function (e) {
          return e * e
        },
        easeOutQuad: function (e) {
          return e * (2 - e)
        },
        easeInOutQuad: function (e) {
          return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e
        },
        easeInCubic: function (e) {
          return e * e * e
        },
        easeOutCubic: function (e) {
          return --e * e * e + 1
        },
        easeInOutCubic: function (e) {
          return e < 0.5
            ? 4 * e * e * e
            : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1
        },
        easeInQuart: function (e) {
          return e * e * e * e
        },
        easeOutQuart: function (e) {
          return 1 - --e * e * e * e
        },
        easeInOutQuart: function (e) {
          return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e
        },
        easeInQuint: function (e) {
          return e * e * e * e * e
        },
        easeOutQuint: function (e) {
          return 1 + --e * e * e * e * e
        },
        easeInOutQuint: function (e) {
          return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e
        },
      })),
    ny
  )
}
var iy = {},
  hP
function I7() {
  if (hP) return iy
  ;(hP = 1), Object.defineProperty(iy, '__esModule', { value: !0 })
  var n = fb(),
    e = ['mousedown', 'mousewheel', 'touchmove', 'keydown']
  return (
    (iy.default = {
      subscribe: function (i) {
        return (
          typeof document < 'u' &&
          e.forEach(function (r) {
            return (0, n.addPassiveEventListener)(document, r, i)
          })
        )
      },
    }),
    iy
  )
}
var ry = {},
  pP
function pb() {
  if (pP) return ry
  ;(pP = 1), Object.defineProperty(ry, '__esModule', { value: !0 })
  var n = {
    registered: {},
    scrollEvent: {
      register: function (t, i) {
        n.registered[t] = i
      },
      remove: function (t) {
        n.registered[t] = null
      },
    },
  }
  return (ry.default = n), ry
}
var mP
function $D() {
  if (mP) return ty
  ;(mP = 1), Object.defineProperty(ty, '__esModule', { value: !0 })
  var n =
      Object.assign ||
      function (k) {
        for (var z = 1; z < arguments.length; z++) {
          var $ = arguments[z]
          for (var te in $)
            Object.prototype.hasOwnProperty.call($, te) && (k[te] = $[te])
        }
        return k
      },
    e = A_()
  c(e)
  var t = R7(),
    i = c(t),
    r = I7(),
    s = c(r),
    o = pb(),
    a = c(o)
  function c(k) {
    return k && k.__esModule ? k : { default: k }
  }
  var u = function (z) {
      return i.default[z.smooth] || i.default.defaultEasing
    },
    h = function (z) {
      return typeof z == 'function'
        ? z
        : function () {
            return z
          }
    },
    m = function () {
      if (typeof window < 'u')
        return (
          window.requestAnimationFrame || window.webkitRequestAnimationFrame
        )
    },
    g = (function () {
      return (
        m() ||
        function (k, z, $) {
          window.setTimeout(k, $ || 1e3 / 60, new Date().getTime())
        }
      )
    })(),
    y = function () {
      return {
        currentPosition: 0,
        startPosition: 0,
        targetPosition: 0,
        progress: 0,
        duration: 0,
        cancel: !1,
        target: null,
        containerElement: null,
        to: null,
        start: null,
        delta: null,
        percent: null,
        delayTimeout: null,
      }
    },
    _ = function (z) {
      var $ = z.data.containerElement
      if ($ && $ !== document && $ !== document.body) return $.scrollLeft
      var te = window.pageXOffset !== void 0,
        j = (document.compatMode || '') === 'CSS1Compat'
      return te
        ? window.pageXOffset
        : j
        ? document.documentElement.scrollLeft
        : document.body.scrollLeft
    },
    M = function (z) {
      var $ = z.data.containerElement
      if ($ && $ !== document && $ !== document.body) return $.scrollTop
      var te = window.pageXOffset !== void 0,
        j = (document.compatMode || '') === 'CSS1Compat'
      return te
        ? window.pageYOffset
        : j
        ? document.documentElement.scrollTop
        : document.body.scrollTop
    },
    w = function (z) {
      var $ = z.data.containerElement
      if ($ && $ !== document && $ !== document.body)
        return $.scrollWidth - $.offsetWidth
      var te = document.body,
        j = document.documentElement
      return Math.max(
        te.scrollWidth,
        te.offsetWidth,
        j.clientWidth,
        j.scrollWidth,
        j.offsetWidth,
      )
    },
    x = function (z) {
      var $ = z.data.containerElement
      if ($ && $ !== document && $ !== document.body)
        return $.scrollHeight - $.offsetHeight
      var te = document.body,
        j = document.documentElement
      return Math.max(
        te.scrollHeight,
        te.offsetHeight,
        j.clientHeight,
        j.scrollHeight,
        j.offsetHeight,
      )
    },
    T = function k(z, $, te) {
      var j = $.data
      if (!$.ignoreCancelEvents && j.cancel) {
        a.default.registered.end &&
          a.default.registered.end(j.to, j.target, j.currentPositionY)
        return
      }
      if (
        ((j.delta = Math.round(j.targetPosition - j.startPosition)),
        j.start === null && (j.start = te),
        (j.progress = te - j.start),
        (j.percent = j.progress >= j.duration ? 1 : z(j.progress / j.duration)),
        (j.currentPosition = j.startPosition + Math.ceil(j.delta * j.percent)),
        j.containerElement &&
        j.containerElement !== document &&
        j.containerElement !== document.body
          ? $.horizontal
            ? (j.containerElement.scrollLeft = j.currentPosition)
            : (j.containerElement.scrollTop = j.currentPosition)
          : $.horizontal
          ? window.scrollTo(j.currentPosition, 0)
          : window.scrollTo(0, j.currentPosition),
        j.percent < 1)
      ) {
        var K = k.bind(null, z, $)
        g.call(window, K)
        return
      }
      a.default.registered.end &&
        a.default.registered.end(j.to, j.target, j.currentPosition)
    },
    A = function (z) {
      z.data.containerElement = z
        ? z.containerId
          ? document.getElementById(z.containerId)
          : z.container && z.container.nodeType
          ? z.container
          : document
        : null
    },
    P = function (z, $, te, j) {
      ;($.data = $.data || y()), window.clearTimeout($.data.delayTimeout)
      var K = function () {
        $.data.cancel = !0
      }
      if (
        (s.default.subscribe(K),
        A($),
        ($.data.start = null),
        ($.data.cancel = !1),
        ($.data.startPosition = $.horizontal ? _($) : M($)),
        ($.data.targetPosition = $.absolute ? z : z + $.data.startPosition),
        $.data.startPosition === $.data.targetPosition)
      ) {
        a.default.registered.end &&
          a.default.registered.end(
            $.data.to,
            $.data.target,
            $.data.currentPosition,
          )
        return
      }
      ;($.data.delta = Math.round(
        $.data.targetPosition - $.data.startPosition,
      )),
        ($.data.duration = h($.duration)($.data.delta)),
        ($.data.duration = isNaN(parseFloat($.data.duration))
          ? 1e3
          : parseFloat($.data.duration)),
        ($.data.to = te),
        ($.data.target = j)
      var J = u($),
        ne = T.bind(null, J, $)
      if ($ && $.delay > 0) {
        $.data.delayTimeout = window.setTimeout(function () {
          a.default.registered.begin &&
            a.default.registered.begin($.data.to, $.data.target),
            g.call(window, ne)
        }, $.delay)
        return
      }
      a.default.registered.begin &&
        a.default.registered.begin($.data.to, $.data.target),
        g.call(window, ne)
    },
    D = function (z) {
      return (z = n({}, z)), (z.data = z.data || y()), (z.absolute = !0), z
    },
    O = function (z) {
      P(0, D(z))
    },
    U = function (z, $) {
      P(z, D($))
    },
    F = function (z) {
      ;(z = D(z)), A(z), P(z.horizontal ? w(z) : x(z), z)
    },
    N = function (z, $) {
      ;($ = D($)), A($)
      var te = $.horizontal ? _($) : M($)
      P(z + te, $)
    }
  return (
    (ty.default = {
      animateTopScroll: P,
      getAnimationType: u,
      scrollToTop: O,
      scrollToBottom: F,
      scrollTo: U,
      scrollMore: N,
    }),
    ty
  )
}
var gP
function C_() {
  if (gP) return J0
  ;(gP = 1), Object.defineProperty(J0, '__esModule', { value: !0 })
  var n =
      Object.assign ||
      function (h) {
        for (var m = 1; m < arguments.length; m++) {
          var g = arguments[m]
          for (var y in g)
            Object.prototype.hasOwnProperty.call(g, y) && (h[y] = g[y])
        }
        return h
      },
    e = A_(),
    t = a(e),
    i = $D(),
    r = a(i),
    s = pb(),
    o = a(s)
  function a(h) {
    return h && h.__esModule ? h : { default: h }
  }
  var c = {},
    u = void 0
  return (
    (J0.default = {
      unmount: function () {
        c = {}
      },
      register: function (m, g) {
        c[m] = g
      },
      unregister: function (m) {
        delete c[m]
      },
      get: function (m) {
        return (
          c[m] ||
          document.getElementById(m) ||
          document.getElementsByName(m)[0] ||
          document.getElementsByClassName(m)[0]
        )
      },
      setActiveLink: function (m) {
        return (u = m)
      },
      getActiveLink: function () {
        return u
      },
      scrollTo: function (m, g) {
        var y = this.get(m)
        if (!y) {
          console.warn('target Element not found')
          return
        }
        g = n({}, g, { absolute: !1 })
        var _ = g.containerId,
          M = g.container,
          w = void 0
        _
          ? (w = document.getElementById(_))
          : M && M.nodeType
          ? (w = M)
          : (w = document),
          (g.absolute = !0)
        var x = g.horizontal,
          T = t.default.scrollOffset(w, y, x) + (g.offset || 0)
        if (!g.smooth) {
          o.default.registered.begin && o.default.registered.begin(m, y),
            w === document
              ? g.horizontal
                ? window.scrollTo(T, 0)
                : window.scrollTo(0, T)
              : (w.scrollTop = T),
            o.default.registered.end && o.default.registered.end(m, y)
          return
        }
        r.default.animateTopScroll(T, g, m, y)
      },
    }),
    J0
  )
}
var sy = {},
  vP
function XD() {
  if (vP) return sy
  ;(vP = 1), Object.defineProperty(sy, '__esModule', { value: !0 }), fb()
  var n = A_(),
    e = t(n)
  function t(r) {
    return r && r.__esModule ? r : { default: r }
  }
  var i = {
    mountFlag: !1,
    initialized: !1,
    scroller: null,
    containers: {},
    mount: function (s) {
      ;(this.scroller = s),
        (this.handleHashChange = this.handleHashChange.bind(this)),
        window.addEventListener('hashchange', this.handleHashChange),
        this.initStateFromHash(),
        (this.mountFlag = !0)
    },
    mapContainer: function (s, o) {
      this.containers[s] = o
    },
    isMounted: function () {
      return this.mountFlag
    },
    isInitialized: function () {
      return this.initialized
    },
    initStateFromHash: function () {
      var s = this,
        o = this.getHash()
      o
        ? window.setTimeout(function () {
            s.scrollTo(o, !0), (s.initialized = !0)
          }, 10)
        : (this.initialized = !0)
    },
    scrollTo: function (s, o) {
      var a = this.scroller,
        c = a.get(s)
      if (c && (o || s !== a.getActiveLink())) {
        var u = this.containers[s] || document
        a.scrollTo(s, { container: u })
      }
    },
    getHash: function () {
      return e.default.getHash()
    },
    changeHash: function (s, o) {
      this.isInitialized() &&
        e.default.getHash() !== s &&
        e.default.updateHash(s, o)
    },
    handleHashChange: function () {
      this.scrollTo(this.getHash())
    },
    unmount: function () {
      ;(this.scroller = null),
        (this.containers = null),
        window.removeEventListener('hashchange', this.handleHashChange)
    },
  }
  return (sy.default = i), sy
}
var yP
function mb() {
  if (yP) return K0
  ;(yP = 1), Object.defineProperty(K0, '__esModule', { value: !0 })
  var n =
      Object.assign ||
      function (x) {
        for (var T = 1; T < arguments.length; T++) {
          var A = arguments[T]
          for (var P in A)
            Object.prototype.hasOwnProperty.call(A, P) && (x[P] = A[P])
        }
        return x
      },
    e = (function () {
      function x(T, A) {
        for (var P = 0; P < A.length; P++) {
          var D = A[P]
          ;(D.enumerable = D.enumerable || !1),
            (D.configurable = !0),
            'value' in D && (D.writable = !0),
            Object.defineProperty(T, D.key, D)
        }
      }
      return function (T, A, P) {
        return A && x(T.prototype, A), P && x(T, P), T
      }
    })(),
    t = Vs(),
    i = g(t),
    r = hb(),
    s = g(r),
    o = C_(),
    a = g(o),
    c = Xg(),
    u = g(c),
    h = XD(),
    m = g(h)
  function g(x) {
    return x && x.__esModule ? x : { default: x }
  }
  function y(x, T) {
    if (!(x instanceof T))
      throw new TypeError('Cannot call a class as a function')
  }
  function _(x, T) {
    if (!x)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      )
    return T && (typeof T == 'object' || typeof T == 'function') ? T : x
  }
  function M(x, T) {
    if (typeof T != 'function' && T !== null)
      throw new TypeError(
        'Super expression must either be null or a function, not ' + typeof T,
      )
    ;(x.prototype = Object.create(T && T.prototype, {
      constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 },
    })),
      T &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(x, T)
          : (x.__proto__ = T))
  }
  var w = {
    to: u.default.string.isRequired,
    containerId: u.default.string,
    container: u.default.object,
    activeClass: u.default.string,
    activeStyle: u.default.object,
    spy: u.default.bool,
    horizontal: u.default.bool,
    smooth: u.default.oneOfType([u.default.bool, u.default.string]),
    offset: u.default.number,
    delay: u.default.number,
    isDynamic: u.default.bool,
    onClick: u.default.func,
    duration: u.default.oneOfType([u.default.number, u.default.func]),
    absolute: u.default.bool,
    onSetActive: u.default.func,
    onSetInactive: u.default.func,
    ignoreCancelEvents: u.default.bool,
    hashSpy: u.default.bool,
    saveHashHistory: u.default.bool,
    spyThrottle: u.default.number,
  }
  return (
    (K0.default = function (x, T) {
      var A = T || a.default,
        P = (function (O) {
          M(U, O)
          function U(F) {
            y(this, U)
            var N = _(
              this,
              (U.__proto__ || Object.getPrototypeOf(U)).call(this, F),
            )
            return D.call(N), (N.state = { active: !1 }), N
          }
          return (
            e(U, [
              {
                key: 'getScrollSpyContainer',
                value: function () {
                  var N = this.props.containerId,
                    k = this.props.container
                  return N && !k
                    ? document.getElementById(N)
                    : k && k.nodeType
                    ? k
                    : document
                },
              },
              {
                key: 'componentDidMount',
                value: function () {
                  if (this.props.spy || this.props.hashSpy) {
                    var N = this.getScrollSpyContainer()
                    s.default.isMounted(N) ||
                      s.default.mount(N, this.props.spyThrottle),
                      this.props.hashSpy &&
                        (m.default.isMounted() || m.default.mount(A),
                        m.default.mapContainer(this.props.to, N)),
                      s.default.addSpyHandler(this.spyHandler, N),
                      this.setState({ container: N })
                  }
                },
              },
              {
                key: 'componentWillUnmount',
                value: function () {
                  s.default.unmount(this.stateHandler, this.spyHandler)
                },
              },
              {
                key: 'render',
                value: function () {
                  var N = ''
                  this.state && this.state.active
                    ? (N = (
                        (this.props.className || '') +
                        ' ' +
                        (this.props.activeClass || 'active')
                      ).trim())
                    : (N = this.props.className)
                  var k = {}
                  this.state && this.state.active
                    ? (k = n({}, this.props.style, this.props.activeStyle))
                    : (k = n({}, this.props.style))
                  var z = n({}, this.props)
                  for (var $ in w) z.hasOwnProperty($) && delete z[$]
                  return (
                    (z.className = N),
                    (z.style = k),
                    (z.onClick = this.handleClick),
                    i.default.createElement(x, z)
                  )
                },
              },
            ]),
            U
          )
        })(i.default.PureComponent),
        D = function () {
          var U = this
          ;(this.scrollTo = function (F, N) {
            A.scrollTo(F, n({}, U.state, N))
          }),
            (this.handleClick = function (F) {
              U.props.onClick && U.props.onClick(F),
                F.stopPropagation && F.stopPropagation(),
                F.preventDefault && F.preventDefault(),
                U.scrollTo(U.props.to, U.props)
            }),
            (this.spyHandler = function (F, N) {
              var k = U.getScrollSpyContainer()
              if (!(m.default.isMounted() && !m.default.isInitialized())) {
                var z = U.props.horizontal,
                  $ = U.props.to,
                  te = null,
                  j = void 0,
                  K = void 0
                if (z) {
                  var J = 0,
                    ne = 0,
                    V = 0
                  if (k.getBoundingClientRect) {
                    var Y = k.getBoundingClientRect()
                    V = Y.left
                  }
                  if (!te || U.props.isDynamic) {
                    if (((te = A.get($)), !te)) return
                    var Q = te.getBoundingClientRect()
                    ;(J = Q.left - V + F), (ne = J + Q.width)
                  }
                  var q = F - U.props.offset
                  ;(j = q >= Math.floor(J) && q < Math.floor(ne)),
                    (K = q < Math.floor(J) || q >= Math.floor(ne))
                } else {
                  var oe = 0,
                    _e = 0,
                    he = 0
                  if (k.getBoundingClientRect) {
                    var Ce = k.getBoundingClientRect()
                    he = Ce.top
                  }
                  if (!te || U.props.isDynamic) {
                    if (((te = A.get($)), !te)) return
                    var Te = te.getBoundingClientRect()
                    ;(oe = Te.top - he + N), (_e = oe + Te.height)
                  }
                  var Pe = N - U.props.offset
                  ;(j = Pe >= Math.floor(oe) && Pe < Math.floor(_e)),
                    (K = Pe < Math.floor(oe) || Pe >= Math.floor(_e))
                }
                var Be = A.getActiveLink()
                if (K) {
                  if (
                    ($ === Be && A.setActiveLink(void 0),
                    U.props.hashSpy && m.default.getHash() === $)
                  ) {
                    var et = U.props.saveHashHistory,
                      ft = et === void 0 ? !1 : et
                    m.default.changeHash('', ft)
                  }
                  U.props.spy &&
                    U.state.active &&
                    (U.setState({ active: !1 }),
                    U.props.onSetInactive && U.props.onSetInactive($, te))
                }
                if (j && (Be !== $ || U.state.active === !1)) {
                  A.setActiveLink($)
                  var Vt = U.props.saveHashHistory,
                    je = Vt === void 0 ? !1 : Vt
                  U.props.hashSpy && m.default.changeHash($, je),
                    U.props.spy &&
                      (U.setState({ active: !0 }),
                      U.props.onSetActive && U.props.onSetActive($, te))
                }
              }
            })
        }
      return (P.propTypes = w), (P.defaultProps = { offset: 0 }), P
    }),
    K0
  )
}
var xP
function L7() {
  if (xP) return Z0
  ;(xP = 1), Object.defineProperty(Z0, '__esModule', { value: !0 })
  var n = Vs(),
    e = r(n),
    t = mb(),
    i = r(t)
  function r(u) {
    return u && u.__esModule ? u : { default: u }
  }
  function s(u, h) {
    if (!(u instanceof h))
      throw new TypeError('Cannot call a class as a function')
  }
  function o(u, h) {
    if (!u)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      )
    return h && (typeof h == 'object' || typeof h == 'function') ? h : u
  }
  function a(u, h) {
    if (typeof h != 'function' && h !== null)
      throw new TypeError(
        'Super expression must either be null or a function, not ' + typeof h,
      )
    ;(u.prototype = Object.create(h && h.prototype, {
      constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 },
    })),
      h &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(u, h)
          : (u.__proto__ = h))
  }
  var c = (function (u) {
    a(h, u)
    function h() {
      var m, g, y, _
      s(this, h)
      for (var M = arguments.length, w = Array(M), x = 0; x < M; x++)
        w[x] = arguments[x]
      return (
        (_ =
          ((g =
            ((y = o(
              this,
              (m = h.__proto__ || Object.getPrototypeOf(h)).call.apply(
                m,
                [this].concat(w),
              ),
            )),
            y)),
          (y.render = function () {
            return e.default.createElement('a', y.props, y.props.children)
          }),
          g)),
        o(y, _)
      )
    }
    return h
  })(e.default.Component)
  return (Z0.default = (0, i.default)(c)), Z0
}
var oy = {},
  _P
function N7() {
  if (_P) return oy
  ;(_P = 1), Object.defineProperty(oy, '__esModule', { value: !0 })
  var n = (function () {
      function h(m, g) {
        for (var y = 0; y < g.length; y++) {
          var _ = g[y]
          ;(_.enumerable = _.enumerable || !1),
            (_.configurable = !0),
            'value' in _ && (_.writable = !0),
            Object.defineProperty(m, _.key, _)
        }
      }
      return function (m, g, y) {
        return g && h(m.prototype, g), y && h(m, y), m
      }
    })(),
    e = Vs(),
    t = s(e),
    i = mb(),
    r = s(i)
  function s(h) {
    return h && h.__esModule ? h : { default: h }
  }
  function o(h, m) {
    if (!(h instanceof m))
      throw new TypeError('Cannot call a class as a function')
  }
  function a(h, m) {
    if (!h)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      )
    return m && (typeof m == 'object' || typeof m == 'function') ? m : h
  }
  function c(h, m) {
    if (typeof m != 'function' && m !== null)
      throw new TypeError(
        'Super expression must either be null or a function, not ' + typeof m,
      )
    ;(h.prototype = Object.create(m && m.prototype, {
      constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 },
    })),
      m &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(h, m)
          : (h.__proto__ = m))
  }
  var u = (function (h) {
    c(m, h)
    function m() {
      return (
        o(this, m),
        a(
          this,
          (m.__proto__ || Object.getPrototypeOf(m)).apply(this, arguments),
        )
      )
    }
    return (
      n(m, [
        {
          key: 'render',
          value: function () {
            return t.default.createElement(
              'button',
              this.props,
              this.props.children,
            )
          },
        },
      ]),
      m
    )
  })(t.default.Component)
  return (oy.default = (0, r.default)(u)), oy
}
var ay = {},
  ly = {},
  wP
function qD() {
  if (wP) return ly
  ;(wP = 1), Object.defineProperty(ly, '__esModule', { value: !0 })
  var n =
      Object.assign ||
      function (y) {
        for (var _ = 1; _ < arguments.length; _++) {
          var M = arguments[_]
          for (var w in M)
            Object.prototype.hasOwnProperty.call(M, w) && (y[w] = M[w])
        }
        return y
      },
    e = (function () {
      function y(_, M) {
        for (var w = 0; w < M.length; w++) {
          var x = M[w]
          ;(x.enumerable = x.enumerable || !1),
            (x.configurable = !0),
            'value' in x && (x.writable = !0),
            Object.defineProperty(_, x.key, x)
        }
      }
      return function (_, M, w) {
        return M && y(_.prototype, M), w && y(_, w), _
      }
    })(),
    t = Vs(),
    i = u(t),
    r = GM()
  u(r)
  var s = C_(),
    o = u(s),
    a = Xg(),
    c = u(a)
  function u(y) {
    return y && y.__esModule ? y : { default: y }
  }
  function h(y, _) {
    if (!(y instanceof _))
      throw new TypeError('Cannot call a class as a function')
  }
  function m(y, _) {
    if (!y)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      )
    return _ && (typeof _ == 'object' || typeof _ == 'function') ? _ : y
  }
  function g(y, _) {
    if (typeof _ != 'function' && _ !== null)
      throw new TypeError(
        'Super expression must either be null or a function, not ' + typeof _,
      )
    ;(y.prototype = Object.create(_ && _.prototype, {
      constructor: { value: y, enumerable: !1, writable: !0, configurable: !0 },
    })),
      _ &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(y, _)
          : (y.__proto__ = _))
  }
  return (
    (ly.default = function (y) {
      var _ = (function (M) {
        g(w, M)
        function w(x) {
          h(this, w)
          var T = m(
            this,
            (w.__proto__ || Object.getPrototypeOf(w)).call(this, x),
          )
          return (T.childBindings = { domNode: null }), T
        }
        return (
          e(w, [
            {
              key: 'componentDidMount',
              value: function () {
                if (typeof window > 'u') return !1
                this.registerElems(this.props.name)
              },
            },
            {
              key: 'componentDidUpdate',
              value: function (T) {
                this.props.name !== T.name &&
                  this.registerElems(this.props.name)
              },
            },
            {
              key: 'componentWillUnmount',
              value: function () {
                if (typeof window > 'u') return !1
                o.default.unregister(this.props.name)
              },
            },
            {
              key: 'registerElems',
              value: function (T) {
                o.default.register(T, this.childBindings.domNode)
              },
            },
            {
              key: 'render',
              value: function () {
                return i.default.createElement(
                  y,
                  n({}, this.props, { parentBindings: this.childBindings }),
                )
              },
            },
          ]),
          w
        )
      })(i.default.Component)
      return (_.propTypes = { name: c.default.string, id: c.default.string }), _
    }),
    ly
  )
}
var SP
function D7() {
  if (SP) return ay
  ;(SP = 1), Object.defineProperty(ay, '__esModule', { value: !0 })
  var n =
      Object.assign ||
      function (y) {
        for (var _ = 1; _ < arguments.length; _++) {
          var M = arguments[_]
          for (var w in M)
            Object.prototype.hasOwnProperty.call(M, w) && (y[w] = M[w])
        }
        return y
      },
    e = (function () {
      function y(_, M) {
        for (var w = 0; w < M.length; w++) {
          var x = M[w]
          ;(x.enumerable = x.enumerable || !1),
            (x.configurable = !0),
            'value' in x && (x.writable = !0),
            Object.defineProperty(_, x.key, x)
        }
      }
      return function (_, M, w) {
        return M && y(_.prototype, M), w && y(_, w), _
      }
    })(),
    t = Vs(),
    i = c(t),
    r = qD(),
    s = c(r),
    o = Xg(),
    a = c(o)
  function c(y) {
    return y && y.__esModule ? y : { default: y }
  }
  function u(y, _) {
    if (!(y instanceof _))
      throw new TypeError('Cannot call a class as a function')
  }
  function h(y, _) {
    if (!y)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      )
    return _ && (typeof _ == 'object' || typeof _ == 'function') ? _ : y
  }
  function m(y, _) {
    if (typeof _ != 'function' && _ !== null)
      throw new TypeError(
        'Super expression must either be null or a function, not ' + typeof _,
      )
    ;(y.prototype = Object.create(_ && _.prototype, {
      constructor: { value: y, enumerable: !1, writable: !0, configurable: !0 },
    })),
      _ &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(y, _)
          : (y.__proto__ = _))
  }
  var g = (function (y) {
    m(_, y)
    function _() {
      return (
        u(this, _),
        h(
          this,
          (_.__proto__ || Object.getPrototypeOf(_)).apply(this, arguments),
        )
      )
    }
    return (
      e(_, [
        {
          key: 'render',
          value: function () {
            var w = this,
              x = n({}, this.props)
            return (
              delete x.name,
              x.parentBindings && delete x.parentBindings,
              i.default.createElement(
                'div',
                n({}, x, {
                  ref: function (A) {
                    w.props.parentBindings.domNode = A
                  },
                }),
                this.props.children,
              )
            )
          },
        },
      ]),
      _
    )
  })(i.default.Component)
  return (
    (g.propTypes = { name: a.default.string, id: a.default.string }),
    (ay.default = (0, s.default)(g)),
    ay
  )
}
var Uw, MP
function O7() {
  if (MP) return Uw
  MP = 1
  var n =
      Object.assign ||
      function (g) {
        for (var y = 1; y < arguments.length; y++) {
          var _ = arguments[y]
          for (var M in _)
            Object.prototype.hasOwnProperty.call(_, M) && (g[M] = _[M])
        }
        return g
      },
    e = (function () {
      function g(y, _) {
        for (var M = 0; M < _.length; M++) {
          var w = _[M]
          ;(w.enumerable = w.enumerable || !1),
            (w.configurable = !0),
            'value' in w && (w.writable = !0),
            Object.defineProperty(y, w.key, w)
        }
      }
      return function (y, _, M) {
        return _ && g(y.prototype, _), M && g(y, M), y
      }
    })()
  function t(g, y) {
    if (!(g instanceof y))
      throw new TypeError('Cannot call a class as a function')
  }
  function i(g, y) {
    if (!g)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      )
    return y && (typeof y == 'object' || typeof y == 'function') ? y : g
  }
  function r(g, y) {
    if (typeof y != 'function' && y !== null)
      throw new TypeError(
        'Super expression must either be null or a function, not ' + typeof y,
      )
    ;(g.prototype = Object.create(y && y.prototype, {
      constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 },
    })),
      y &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(g, y)
          : (g.__proto__ = y))
  }
  var s = Vs()
  GM(), A_()
  var o = hb(),
    a = C_(),
    c = Xg(),
    u = XD(),
    h = {
      to: c.string.isRequired,
      containerId: c.string,
      container: c.object,
      activeClass: c.string,
      spy: c.bool,
      smooth: c.oneOfType([c.bool, c.string]),
      offset: c.number,
      delay: c.number,
      isDynamic: c.bool,
      onClick: c.func,
      duration: c.oneOfType([c.number, c.func]),
      absolute: c.bool,
      onSetActive: c.func,
      onSetInactive: c.func,
      ignoreCancelEvents: c.bool,
      hashSpy: c.bool,
      spyThrottle: c.number,
    },
    m = {
      Scroll: function (y, _) {
        console.warn('Helpers.Scroll is deprecated since v1.7.0')
        var M = _ || a,
          w = (function (T) {
            r(A, T)
            function A(P) {
              t(this, A)
              var D = i(
                this,
                (A.__proto__ || Object.getPrototypeOf(A)).call(this, P),
              )
              return x.call(D), (D.state = { active: !1 }), D
            }
            return (
              e(A, [
                {
                  key: 'getScrollSpyContainer',
                  value: function () {
                    var D = this.props.containerId,
                      O = this.props.container
                    return D
                      ? document.getElementById(D)
                      : O && O.nodeType
                      ? O
                      : document
                  },
                },
                {
                  key: 'componentDidMount',
                  value: function () {
                    if (this.props.spy || this.props.hashSpy) {
                      var D = this.getScrollSpyContainer()
                      o.isMounted(D) || o.mount(D, this.props.spyThrottle),
                        this.props.hashSpy &&
                          (u.isMounted() || u.mount(M),
                          u.mapContainer(this.props.to, D)),
                        this.props.spy && o.addStateHandler(this.stateHandler),
                        o.addSpyHandler(this.spyHandler, D),
                        this.setState({ container: D })
                    }
                  },
                },
                {
                  key: 'componentWillUnmount',
                  value: function () {
                    o.unmount(this.stateHandler, this.spyHandler)
                  },
                },
                {
                  key: 'render',
                  value: function () {
                    var D = ''
                    this.state && this.state.active
                      ? (D = (
                          (this.props.className || '') +
                          ' ' +
                          (this.props.activeClass || 'active')
                        ).trim())
                      : (D = this.props.className)
                    var O = n({}, this.props)
                    for (var U in h) O.hasOwnProperty(U) && delete O[U]
                    return (
                      (O.className = D),
                      (O.onClick = this.handleClick),
                      s.createElement(y, O)
                    )
                  },
                },
              ]),
              A
            )
          })(s.Component),
          x = function () {
            var A = this
            ;(this.scrollTo = function (P, D) {
              M.scrollTo(P, n({}, A.state, D))
            }),
              (this.handleClick = function (P) {
                A.props.onClick && A.props.onClick(P),
                  P.stopPropagation && P.stopPropagation(),
                  P.preventDefault && P.preventDefault(),
                  A.scrollTo(A.props.to, A.props)
              }),
              (this.stateHandler = function () {
                M.getActiveLink() !== A.props.to &&
                  (A.state !== null &&
                    A.state.active &&
                    A.props.onSetInactive &&
                    A.props.onSetInactive(),
                  A.setState({ active: !1 }))
              }),
              (this.spyHandler = function (P) {
                var D = A.getScrollSpyContainer()
                if (!(u.isMounted() && !u.isInitialized())) {
                  var O = A.props.to,
                    U = null,
                    F = 0,
                    N = 0,
                    k = 0
                  if (D.getBoundingClientRect) {
                    var z = D.getBoundingClientRect()
                    k = z.top
                  }
                  if (!U || A.props.isDynamic) {
                    if (((U = M.get(O)), !U)) return
                    var $ = U.getBoundingClientRect()
                    ;(F = $.top - k + P), (N = F + $.height)
                  }
                  var te = P - A.props.offset,
                    j = te >= Math.floor(F) && te < Math.floor(N),
                    K = te < Math.floor(F) || te >= Math.floor(N),
                    J = M.getActiveLink()
                  if (K)
                    return (
                      O === J && M.setActiveLink(void 0),
                      A.props.hashSpy && u.getHash() === O && u.changeHash(),
                      A.props.spy &&
                        A.state.active &&
                        (A.setState({ active: !1 }),
                        A.props.onSetInactive && A.props.onSetInactive()),
                      o.updateStates()
                    )
                  if (j && J !== O)
                    return (
                      M.setActiveLink(O),
                      A.props.hashSpy && u.changeHash(O),
                      A.props.spy &&
                        (A.setState({ active: !0 }),
                        A.props.onSetActive && A.props.onSetActive(O)),
                      o.updateStates()
                    )
                }
              })
          }
        return (w.propTypes = h), (w.defaultProps = { offset: 0 }), w
      },
      Element: function (y) {
        console.warn('Helpers.Element is deprecated since v1.7.0')
        var _ = (function (M) {
          r(w, M)
          function w(x) {
            t(this, w)
            var T = i(
              this,
              (w.__proto__ || Object.getPrototypeOf(w)).call(this, x),
            )
            return (T.childBindings = { domNode: null }), T
          }
          return (
            e(w, [
              {
                key: 'componentDidMount',
                value: function () {
                  if (typeof window > 'u') return !1
                  this.registerElems(this.props.name)
                },
              },
              {
                key: 'componentDidUpdate',
                value: function (T) {
                  this.props.name !== T.name &&
                    this.registerElems(this.props.name)
                },
              },
              {
                key: 'componentWillUnmount',
                value: function () {
                  if (typeof window > 'u') return !1
                  a.unregister(this.props.name)
                },
              },
              {
                key: 'registerElems',
                value: function (T) {
                  a.register(T, this.childBindings.domNode)
                },
              },
              {
                key: 'render',
                value: function () {
                  return s.createElement(
                    y,
                    n({}, this.props, { parentBindings: this.childBindings }),
                  )
                },
              },
            ]),
            w
          )
        })(s.Component)
        return (_.propTypes = { name: c.string, id: c.string }), _
      },
    }
  return (Uw = m), Uw
}
var EP
function k7() {
  if (EP) return ci
  ;(EP = 1),
    Object.defineProperty(ci, '__esModule', { value: !0 }),
    (ci.Helpers =
      ci.ScrollElement =
      ci.ScrollLink =
      ci.animateScroll =
      ci.scrollSpy =
      ci.Events =
      ci.scroller =
      ci.Element =
      ci.Button =
      ci.Link =
        void 0)
  var n = L7(),
    e = P(n),
    t = N7(),
    i = P(t),
    r = D7(),
    s = P(r),
    o = C_(),
    a = P(o),
    c = pb(),
    u = P(c),
    h = hb(),
    m = P(h),
    g = $D(),
    y = P(g),
    _ = mb(),
    M = P(_),
    w = qD(),
    x = P(w),
    T = O7(),
    A = P(T)
  function P(D) {
    return D && D.__esModule ? D : { default: D }
  }
  return (
    (ci.Link = e.default),
    (ci.Button = i.default),
    (ci.Element = s.default),
    (ci.scroller = a.default),
    (ci.Events = u.default),
    (ci.scrollSpy = m.default),
    (ci.animateScroll = y.default),
    (ci.ScrollLink = M.default),
    (ci.ScrollElement = x.default),
    (ci.Helpers = A.default),
    (ci.default = {
      Link: e.default,
      Button: i.default,
      Element: s.default,
      scroller: a.default,
      Events: u.default,
      scrollSpy: m.default,
      animateScroll: y.default,
      ScrollLink: M.default,
      ScrollElement: x.default,
      Helpers: A.default,
    }),
    ci
  )
}
var YD = k7()
function ZD() {
  const [n, e] = X.useState('Copy Email'),
    t = 'kevinshangjd@outlook.com',
    i = () => {
      navigator.clipboard.writeText(t).then(() => {
        e('Copied!'),
          setTimeout(() => {
            e('Copy Email')
          }, 2e3)
      })
    }
  return b.jsxs('div', {
    className:
      'max-w-[6vw] relative inline-flex items-center whitespace-nowrap ',
    children: [
      b.jsx('button', {
        onClick: i,
        className:
          'relative z-10 rounded-full text-sm bg-borderColor bg-opacity-70 px-2 py-1',
        children: n,
      }),
      b.jsx('span', { className: 'absolute inset-0 rounded-full z-0' }),
    ],
  })
}
function KD({ sidebarItems: n, defaultVisible: e = !1 }) {
  const [t, i] = X.useState(e || !1)
  return (
    X.useEffect(() => {
      const r = () => {
        const s = window.scrollY,
          o = window.innerHeight
        e || (s >= (o * 2) / 4 ? i(!0) : i(!1))
      }
      return (
        window.addEventListener('scroll', r),
        () => {
          window.removeEventListener('scroll', r)
        }
      )
    }, []),
    b.jsxs('div', {
      className: `xl:w-[7%] hidden xl:flex fixed top-0 left-0 h-[100vh] z-40 text-[#5A5A5A] flex-col justify-between max-w-[7%] ${
        t ? 'border-r-[1px] border-[#CCCCCC]' : ''
      }`,
      children: [
        b.jsx('div', {
          className: 'pt-4 pl-4',
          children: b.jsx(Ic, { color: 'text-[#8D8D8D]' }),
        }),
        b.jsx('div', {
          className:
            'flex flex-col items-center text-center space-y-6 flex-grow justify-center ',
          children: n.map((r) =>
            r.id.startsWith('/')
              ? b.jsxs(
                  Fs,
                  {
                    to: r.id,
                    className:
                      'cursor-pointer text-gray-500 hover:underline relative flex items-center capitalize',
                    children: [
                      b.jsx('span', {
                        className: 'text-sm px-2',
                        children: r.label,
                      }),
                      b.jsx('span', {
                        className:
                          'absolute right-0 w-2 h-2 bg-black opacity-0 group-hover:opacity-100',
                        style: {
                          transform: 'translateX(100%)',
                          transition: 'opacity 0.2s',
                        },
                      }),
                    ],
                  },
                  r.id,
                )
              : b.jsxs(
                  YD.Link,
                  {
                    to: r.id,
                    smooth: !0,
                    duration: 100,
                    offset: r.offset || 0,
                    spy: !0,
                    activeClass: 'text-primary',
                    className:
                      'cursor-pointer text-gray-500 hover:underline relative flex items-center capitalize',
                    children: [
                      b.jsx('span', {
                        className: 'text-sm px-2',
                        children: r.label,
                      }),
                      b.jsx('span', {
                        className:
                          'absolute right-0 w-2 h-2 bg-black opacity-0 group-hover:opacity-100',
                        style: {
                          transform: 'translateX(100%)',
                          transition: 'opacity 0.2s',
                        },
                      }),
                    ],
                  },
                  r.id,
                ),
          ),
        }),
        b.jsxs('div', {
          className: 'pb-8 space-y-6 flex flex-col items-center',
          children: [
            b.jsx(Fs, {
              to: '/resume',
              children: b.jsxs('span', {
                className:
                  'flex flex-row hover:underline text-gray-500 items-center',
                children: [
                  b.jsx('p', {
                    className: 'font-light text-sm text-center',
                    children: ' Resume ',
                  }),
                  b.jsx('svg', {
                    xmlns: 'http://www.w3.org/2000/svg',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    strokeWidth: 1.5,
                    stroke: 'currentColor',
                    className: 'size-3 ml-1',
                    children: b.jsx('path', {
                      strokeLinecap: 'round',
                      strokeLinejoin: 'round',
                      d: 'm4.5 19.5 15-15m0 0H8.25m11.25 0v11.25',
                    }),
                  }),
                ],
              }),
            }),
            b.jsx(ZD, {}),
          ],
        }),
      ],
    })
  )
}
function P_(n) {
  return n !== null && typeof n == 'object' && typeof n.start == 'function'
}
const lM = (n) => Array.isArray(n)
function QD(n, e) {
  if (!Array.isArray(e)) return !1
  const t = e.length
  if (t !== n.length) return !1
  for (let i = 0; i < t; i++) if (e[i] !== n[i]) return !1
  return !0
}
function fg(n) {
  return typeof n == 'string' || Array.isArray(n)
}
function bP(n) {
  const e = [{}, {}]
  return (
    n == null ||
      n.values.forEach((t, i) => {
        ;(e[0][i] = t.get()), (e[1][i] = t.getVelocity())
      }),
    e
  )
}
function gb(n, e, t, i) {
  if (typeof e == 'function') {
    const [r, s] = bP(i)
    e = e(t !== void 0 ? t : n.custom, r, s)
  }
  if (
    (typeof e == 'string' && (e = n.variants && n.variants[e]),
    typeof e == 'function')
  ) {
    const [r, s] = bP(i)
    e = e(t !== void 0 ? t : n.custom, r, s)
  }
  return e
}
function R_(n, e, t) {
  const i = n.getProps()
  return gb(i, e, t !== void 0 ? t : i.custom, n)
}
const vb = [
    'animate',
    'whileInView',
    'whileFocus',
    'whileHover',
    'whileTap',
    'whileDrag',
    'exit',
  ],
  yb = ['initial', ...vb],
  es = (n) => n
let F7 = es,
  cM = es
function xb(n, e) {
  return n ? n[e] || n.default || n : void 0
}
const qg = [
    'transformPerspective',
    'x',
    'y',
    'z',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY',
  ],
  Md = new Set(qg),
  U7 = (n) => !!(n && typeof n == 'object' && n.mix && n.toValue),
  B7 = (n) => (lM(n) ? n[n.length - 1] || 0 : n),
  z7 = { skipAnimations: !1, useManualTiming: !1 }
function V7(n) {
  let e = new Set(),
    t = new Set(),
    i = !1,
    r = !1
  const s = new WeakSet()
  let o = { delta: 0, timestamp: 0, isProcessing: !1 }
  function a(u) {
    s.has(u) && (c.schedule(u), n()), u(o)
  }
  const c = {
    schedule: (u, h = !1, m = !1) => {
      const y = m && i ? e : t
      return h && s.add(u), y.has(u) || y.add(u), u
    },
    cancel: (u) => {
      t.delete(u), s.delete(u)
    },
    process: (u) => {
      if (((o = u), i)) {
        r = !0
        return
      }
      ;(i = !0),
        ([e, t] = [t, e]),
        e.forEach(a),
        e.clear(),
        (i = !1),
        r && ((r = !1), c.process(u))
    },
  }
  return c
}
const cy = [
    'read',
    'resolveKeyframes',
    'update',
    'preRender',
    'render',
    'postRender',
  ],
  j7 = 40
function JD(n, e) {
  let t = !1,
    i = !0
  const r = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = () => (t = !0),
    o = cy.reduce((x, T) => ((x[T] = V7(s)), x), {}),
    {
      read: a,
      resolveKeyframes: c,
      update: u,
      preRender: h,
      render: m,
      postRender: g,
    } = o,
    y = () => {
      const x = performance.now()
      ;(t = !1),
        (r.delta = i ? 1e3 / 60 : Math.max(Math.min(x - r.timestamp, j7), 1)),
        (r.timestamp = x),
        (r.isProcessing = !0),
        a.process(r),
        c.process(r),
        u.process(r),
        h.process(r),
        m.process(r),
        g.process(r),
        (r.isProcessing = !1),
        t && e && ((i = !1), n(y))
    },
    _ = () => {
      ;(t = !0), (i = !0), r.isProcessing || n(y)
    }
  return {
    schedule: cy.reduce((x, T) => {
      const A = o[T]
      return (x[T] = (P, D = !1, O = !1) => (t || _(), A.schedule(P, D, O))), x
    }, {}),
    cancel: (x) => {
      for (let T = 0; T < cy.length; T++) o[cy[T]].cancel(x)
    },
    state: r,
    steps: o,
  }
}
const {
  schedule: Dn,
  cancel: qo,
  state: rr,
  steps: Bw,
} = JD(typeof requestAnimationFrame < 'u' ? requestAnimationFrame : es, !0)
let My
function H7() {
  My = void 0
}
const _a = {
  now: () => (
    My === void 0 &&
      _a.set(
        rr.isProcessing || z7.useManualTiming
          ? rr.timestamp
          : performance.now(),
      ),
    My
  ),
  set: (n) => {
    ;(My = n), queueMicrotask(H7)
  },
}
function _b(n, e) {
  n.indexOf(e) === -1 && n.push(e)
}
function wb(n, e) {
  const t = n.indexOf(e)
  t > -1 && n.splice(t, 1)
}
let Sb = class {
  constructor() {
    this.subscriptions = []
  }
  add(e) {
    return _b(this.subscriptions, e), () => wb(this.subscriptions, e)
  }
  notify(e, t, i) {
    const r = this.subscriptions.length
    if (r)
      if (r === 1) this.subscriptions[0](e, t, i)
      else
        for (let s = 0; s < r; s++) {
          const o = this.subscriptions[s]
          o && o(e, t, i)
        }
  }
  getSize() {
    return this.subscriptions.length
  }
  clear() {
    this.subscriptions.length = 0
  }
}
function Mb(n, e) {
  return e ? n * (1e3 / e) : 0
}
const TP = 30,
  G7 = (n) => !isNaN(parseFloat(n)),
  Pm = { current: void 0 }
let W7 = class {
  constructor(e, t = {}) {
    ;(this.version = '11.16.0'),
      (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (i, r = !0) => {
        const s = _a.now()
        this.updatedAt !== s && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(i),
          this.current !== this.prev &&
            this.events.change &&
            this.events.change.notify(this.current),
          r &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current)
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = t.owner)
  }
  setCurrent(e) {
    ;(this.current = e),
      (this.updatedAt = _a.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = G7(this.current))
  }
  setPrevFrameValue(e = this.current) {
    ;(this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt)
  }
  onChange(e) {
    return this.on('change', e)
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new Sb())
    const i = this.events[e].add(t)
    return e === 'change'
      ? () => {
          i(),
            Dn.read(() => {
              this.events.change.getSize() || this.stop()
            })
        }
      : i
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear()
  }
  attach(e, t) {
    ;(this.passiveEffect = e), (this.stopPassiveEffect = t)
  }
  set(e, t = !0) {
    !t || !this.passiveEffect
      ? this.updateAndNotify(e, t)
      : this.passiveEffect(e, this.updateAndNotify)
  }
  setWithVelocity(e, t, i) {
    this.set(t),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - i)
  }
  jump(e, t = !0) {
    this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      t && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
  get() {
    return Pm.current && Pm.current.push(this), this.current
  }
  getPrevious() {
    return this.prev
  }
  getVelocity() {
    const e = _a.now()
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > TP
    )
      return 0
    const t = Math.min(this.updatedAt - this.prevUpdatedAt, TP)
    return Mb(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        ;(this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify()
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation()
      })
    )
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation()
  }
  isAnimating() {
    return !!this.animation
  }
  clearAnimation() {
    delete this.animation
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
}
function ga(n, e) {
  return new W7(n, e)
}
function $7(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, ga(t))
}
function X7(n, e) {
  const t = R_(n, e)
  let { transitionEnd: i = {}, transition: r = {}, ...s } = t || {}
  s = { ...s, ...i }
  for (const o in s) {
    const a = B7(s[o])
    $7(n, o, a)
  }
}
const Lr = (n) => !!(n && n.getVelocity)
function q7(n) {
  return !!(Lr(n) && n.add)
}
function uM(n, e) {
  const t = n.getValue('willChange')
  if (q7(t)) return t.add(e)
}
const Eb = (n) => n.replace(/([a-z])([A-Z])/gu, '$1-$2').toLowerCase(),
  Y7 = 'framerAppearId',
  eO = 'data-' + Eb(Y7)
function tO(n) {
  return n.props[eO]
}
function bb(n) {
  let e
  return () => (e === void 0 && (e = n()), e)
}
const nO = bb(() => window.ScrollTimeline !== void 0)
let Z7 = class {
    constructor(e) {
      ;(this.stop = () => this.runAll('stop')),
        (this.animations = e.filter(Boolean))
    }
    get finished() {
      return Promise.all(
        this.animations.map((e) => ('finished' in e ? e.finished : e)),
      )
    }
    getAll(e) {
      return this.animations[0][e]
    }
    setAll(e, t) {
      for (let i = 0; i < this.animations.length; i++) this.animations[i][e] = t
    }
    attachTimeline(e, t) {
      const i = this.animations.map((r) =>
        nO() && r.attachTimeline ? r.attachTimeline(e) : t(r),
      )
      return () => {
        i.forEach((r, s) => {
          r && r(), this.animations[s].stop()
        })
      }
    }
    get time() {
      return this.getAll('time')
    }
    set time(e) {
      this.setAll('time', e)
    }
    get speed() {
      return this.getAll('speed')
    }
    set speed(e) {
      this.setAll('speed', e)
    }
    get startTime() {
      return this.getAll('startTime')
    }
    get duration() {
      let e = 0
      for (let t = 0; t < this.animations.length; t++)
        e = Math.max(e, this.animations[t].duration)
      return e
    }
    runAll(e) {
      this.animations.forEach((t) => t[e]())
    }
    flatten() {
      this.runAll('flatten')
    }
    play() {
      this.runAll('play')
    }
    pause() {
      this.runAll('pause')
    }
    cancel() {
      this.runAll('cancel')
    }
    complete() {
      this.runAll('complete')
    }
  },
  K7 = class extends Z7 {
    then(e, t) {
      return Promise.all(this.animations).then(e).catch(t)
    }
  }
const Sl = (n) => n * 1e3,
  Ml = (n) => n / 1e3
function Tb(n) {
  return typeof n == 'function'
}
function AP(n, e) {
  ;(n.timeline = e), (n.onfinish = null)
}
const Ab = (n) => Array.isArray(n) && typeof n[0] == 'number',
  Q7 = { linearEasing: void 0 }
function J7(n, e) {
  const t = bb(n)
  return () => {
    var i
    return (i = Q7[e]) !== null && i !== void 0 ? i : t()
  }
}
const Ex = J7(() => {
    try {
      document
        .createElement('div')
        .animate({ opacity: 0 }, { easing: 'linear(0, 1)' })
    } catch {
      return !1
    }
    return !0
  }, 'linearEasing'),
  xd = (n, e, t) => {
    const i = e - n
    return i === 0 ? 1 : (t - n) / i
  },
  iO = (n, e, t = 10) => {
    let i = ''
    const r = Math.max(Math.round(e / t), 2)
    for (let s = 0; s < r; s++) i += n(xd(0, r - 1, s)) + ', '
    return `linear(${i.substring(0, i.length - 2)})`
  }
function rO(n) {
  return !!(
    (typeof n == 'function' && Ex()) ||
    !n ||
    (typeof n == 'string' && (n in dM || Ex())) ||
    Ab(n) ||
    (Array.isArray(n) && n.every(rO))
  )
}
const lm = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
  dM = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'ease-in',
    easeOut: 'ease-out',
    easeInOut: 'ease-in-out',
    circIn: lm([0, 0.65, 0.55, 1]),
    circOut: lm([0.55, 0, 1, 0.45]),
    backIn: lm([0.31, 0.01, 0.66, -0.59]),
    backOut: lm([0.33, 1.53, 0.69, 0.99]),
  }
function sO(n, e) {
  if (n)
    return typeof n == 'function' && Ex()
      ? iO(n, e)
      : Ab(n)
      ? lm(n)
      : Array.isArray(n)
      ? n.map((t) => sO(t, e) || dM.easeOut)
      : dM[n]
}
const oO = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  e$ = 1e-7,
  t$ = 12
function n$(n, e, t, i, r) {
  let s,
    o,
    a = 0
  do (o = e + (t - e) / 2), (s = oO(o, i, r) - n), s > 0 ? (t = o) : (e = o)
  while (Math.abs(s) > e$ && ++a < t$)
  return o
}
function Yg(n, e, t, i) {
  if (n === e && t === i) return es
  const r = (s) => n$(s, 0, 1, n, t)
  return (s) => (s === 0 || s === 1 ? s : oO(r(s), e, i))
}
const aO = (n) => (e) => e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
  lO = (n) => (e) => 1 - n(1 - e),
  cO = Yg(0.33, 1.53, 0.69, 0.99),
  Cb = lO(cO),
  uO = aO(Cb),
  dO = (n) =>
    (n *= 2) < 1 ? 0.5 * Cb(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  Pb = (n) => 1 - Math.sin(Math.acos(n)),
  fO = lO(Pb),
  hO = aO(Pb),
  pO = (n) => /^0[^.\s]+$/u.test(n)
function i$(n) {
  return typeof n == 'number'
    ? n === 0
    : n !== null
    ? n === 'none' || n === '0' || pO(n)
    : !0
}
const mO = (n) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n),
  gO = (n) => (e) => typeof e == 'string' && e.startsWith(n),
  vO = gO('--'),
  r$ = gO('var(--'),
  Rb = (n) => (r$(n) ? s$.test(n.split('/*')[0].trim()) : !1),
  s$ =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  o$ = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
function a$(n) {
  const e = o$.exec(n)
  if (!e) return [,]
  const [, t, i, r] = e
  return [`--${t ?? i}`, r]
}
function yO(n, e, t = 1) {
  const [i, r] = a$(n)
  if (!i) return
  const s = window.getComputedStyle(e).getPropertyValue(i)
  if (s) {
    const o = s.trim()
    return mO(o) ? parseFloat(o) : o
  }
  return Rb(r) ? yO(r, e, t + 1) : r
}
const Cl = (n, e, t) => (t > e ? e : t < n ? n : t),
  Oh = {
    test: (n) => typeof n == 'number',
    parse: parseFloat,
    transform: (n) => n,
  },
  hg = { ...Oh, transform: (n) => Cl(0, 1, n) },
  uy = { ...Oh, default: 1 },
  Zg = (n) => ({
    test: (e) =>
      typeof e == 'string' && e.endsWith(n) && e.split(' ').length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  yc = Zg('deg'),
  wa = Zg('%'),
  Yt = Zg('px'),
  l$ = Zg('vh'),
  c$ = Zg('vw'),
  CP = {
    ...wa,
    parse: (n) => wa.parse(n) / 100,
    transform: (n) => wa.transform(n * 100),
  },
  u$ = new Set([
    'width',
    'height',
    'top',
    'left',
    'right',
    'bottom',
    'x',
    'y',
    'translateX',
    'translateY',
  ]),
  PP = (n) => n === Oh || n === Yt,
  RP = (n, e) => parseFloat(n.split(', ')[e]),
  IP =
    (n, e) =>
    (t, { transform: i }) => {
      if (i === 'none' || !i) return 0
      const r = i.match(/^matrix3d\((.+)\)$/u)
      if (r) return RP(r[1], e)
      {
        const s = i.match(/^matrix\((.+)\)$/u)
        return s ? RP(s[1], n) : 0
      }
    },
  d$ = new Set(['x', 'y', 'z']),
  f$ = qg.filter((n) => !d$.has(n))
function h$(n) {
  const e = []
  return (
    f$.forEach((t) => {
      const i = n.getValue(t)
      i !== void 0 &&
        (e.push([t, i.get()]), i.set(t.startsWith('scale') ? 1 : 0))
    }),
    e
  )
}
const Mh = {
  width: ({ x: n }, { paddingLeft: e = '0', paddingRight: t = '0' }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  height: ({ y: n }, { paddingTop: e = '0', paddingBottom: t = '0' }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  top: (n, { top: e }) => parseFloat(e),
  left: (n, { left: e }) => parseFloat(e),
  bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
  right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
  x: IP(4, 13),
  y: IP(5, 14),
}
Mh.translateX = Mh.x
Mh.translateY = Mh.y
const xO = (n) => (e) => e.test(n),
  p$ = { test: (n) => n === 'auto', parse: (n) => n },
  _O = [Oh, Yt, wa, yc, c$, l$, p$],
  LP = (n) => _O.find(xO(n)),
  dd = new Set()
let fM = !1,
  hM = !1
function wO() {
  if (hM) {
    const n = Array.from(dd).filter((i) => i.needsMeasurement),
      e = new Set(n.map((i) => i.element)),
      t = new Map()
    e.forEach((i) => {
      const r = h$(i)
      r.length && (t.set(i, r), i.render())
    }),
      n.forEach((i) => i.measureInitialState()),
      e.forEach((i) => {
        i.render()
        const r = t.get(i)
        r &&
          r.forEach(([s, o]) => {
            var a
            ;(a = i.getValue(s)) === null || a === void 0 || a.set(o)
          })
      }),
      n.forEach((i) => i.measureEndState()),
      n.forEach((i) => {
        i.suspendedScrollY !== void 0 && window.scrollTo(0, i.suspendedScrollY)
      })
  }
  ;(hM = !1), (fM = !1), dd.forEach((n) => n.complete()), dd.clear()
}
function SO() {
  dd.forEach((n) => {
    n.readKeyframes(), n.needsMeasurement && (hM = !0)
  })
}
function m$() {
  SO(), wO()
}
let Ib = class {
  constructor(e, t, i, r, s, o = !1) {
    ;(this.isComplete = !1),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.isScheduled = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = t),
      (this.name = i),
      (this.motionValue = r),
      (this.element = s),
      (this.isAsync = o)
  }
  scheduleResolve() {
    ;(this.isScheduled = !0),
      this.isAsync
        ? (dd.add(this),
          fM || ((fM = !0), Dn.read(SO), Dn.resolveKeyframes(wO)))
        : (this.readKeyframes(), this.complete())
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: t, element: i, motionValue: r } = this
    for (let s = 0; s < e.length; s++)
      if (e[s] === null)
        if (s === 0) {
          const o = r == null ? void 0 : r.get(),
            a = e[e.length - 1]
          if (o !== void 0) e[0] = o
          else if (i && t) {
            const c = i.readValue(t, a)
            c != null && (e[0] = c)
          }
          e[0] === void 0 && (e[0] = a), r && o === void 0 && r.set(e[0])
        } else e[s] = e[s - 1]
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    ;(this.isComplete = !0),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
      dd.delete(this)
  }
  cancel() {
    this.isComplete || ((this.isScheduled = !1), dd.delete(this))
  }
  resume() {
    this.isComplete || this.scheduleResolve()
  }
}
const Rm = (n) => Math.round(n * 1e5) / 1e5,
  Lb = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu
function g$(n) {
  return n == null
}
const v$ =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  Nb = (n, e) => (t) =>
    !!(
      (typeof t == 'string' && v$.test(t) && t.startsWith(n)) ||
      (e && !g$(t) && Object.prototype.hasOwnProperty.call(t, e))
    ),
  MO = (n, e, t) => (i) => {
    if (typeof i != 'string') return i
    const [r, s, o, a] = i.match(Lb)
    return {
      [n]: parseFloat(r),
      [e]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    }
  },
  y$ = (n) => Cl(0, 255, n),
  zw = { ...Oh, transform: (n) => Math.round(y$(n)) },
  rd = {
    test: Nb('rgb', 'red'),
    parse: MO('red', 'green', 'blue'),
    transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) =>
      'rgba(' +
      zw.transform(n) +
      ', ' +
      zw.transform(e) +
      ', ' +
      zw.transform(t) +
      ', ' +
      Rm(hg.transform(i)) +
      ')',
  }
function x$(n) {
  let e = '',
    t = '',
    i = '',
    r = ''
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (i = n.substring(5, 7)),
        (r = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (i = n.substring(3, 4)),
        (r = n.substring(4, 5)),
        (e += e),
        (t += t),
        (i += i),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  )
}
const pM = { test: Nb('#'), parse: x$, transform: rd.transform },
  Qf = {
    test: Nb('hsl', 'hue'),
    parse: MO('hue', 'saturation', 'lightness'),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) =>
      'hsla(' +
      Math.round(n) +
      ', ' +
      wa.transform(Rm(e)) +
      ', ' +
      wa.transform(Rm(t)) +
      ', ' +
      Rm(hg.transform(i)) +
      ')',
  },
  Rr = {
    test: (n) => rd.test(n) || pM.test(n) || Qf.test(n),
    parse: (n) =>
      rd.test(n) ? rd.parse(n) : Qf.test(n) ? Qf.parse(n) : pM.parse(n),
    transform: (n) =>
      typeof n == 'string'
        ? n
        : n.hasOwnProperty('red')
        ? rd.transform(n)
        : Qf.transform(n),
  },
  _$ =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu
function w$(n) {
  var e, t
  return (
    isNaN(n) &&
    typeof n == 'string' &&
    (((e = n.match(Lb)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((t = n.match(_$)) === null || t === void 0 ? void 0 : t.length) || 0) >
      0
  )
}
const EO = 'number',
  bO = 'color',
  S$ = 'var',
  M$ = 'var(',
  NP = '${}',
  E$ =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu
function pg(n) {
  const e = n.toString(),
    t = [],
    i = { color: [], number: [], var: [] },
    r = []
  let s = 0
  const a = e
    .replace(
      E$,
      (c) => (
        Rr.test(c)
          ? (i.color.push(s), r.push(bO), t.push(Rr.parse(c)))
          : c.startsWith(M$)
          ? (i.var.push(s), r.push(S$), t.push(c))
          : (i.number.push(s), r.push(EO), t.push(parseFloat(c))),
        ++s,
        NP
      ),
    )
    .split(NP)
  return { values: t, split: a, indexes: i, types: r }
}
function TO(n) {
  return pg(n).values
}
function AO(n) {
  const { split: e, types: t } = pg(n),
    i = e.length
  return (r) => {
    let s = ''
    for (let o = 0; o < i; o++)
      if (((s += e[o]), r[o] !== void 0)) {
        const a = t[o]
        a === EO
          ? (s += Rm(r[o]))
          : a === bO
          ? (s += Rr.transform(r[o]))
          : (s += r[o])
      }
    return s
  }
}
const b$ = (n) => (typeof n == 'number' ? 0 : n)
function T$(n) {
  const e = TO(n)
  return AO(n)(e.map(b$))
}
const Lc = {
    test: w$,
    parse: TO,
    createTransformer: AO,
    getAnimatableNone: T$,
  },
  A$ = new Set(['brightness', 'contrast', 'saturate', 'opacity'])
function C$(n) {
  const [e, t] = n.slice(0, -1).split('(')
  if (e === 'drop-shadow') return n
  const [i] = t.match(Lb) || []
  if (!i) return n
  const r = t.replace(i, '')
  let s = A$.has(e) ? 1 : 0
  return i !== t && (s *= 100), e + '(' + s + r + ')'
}
const P$ = /\b([a-z-]*)\(.*?\)/gu,
  mM = {
    ...Lc,
    getAnimatableNone: (n) => {
      const e = n.match(P$)
      return e ? e.map(C$).join(' ') : n
    },
  },
  R$ = {
    borderWidth: Yt,
    borderTopWidth: Yt,
    borderRightWidth: Yt,
    borderBottomWidth: Yt,
    borderLeftWidth: Yt,
    borderRadius: Yt,
    radius: Yt,
    borderTopLeftRadius: Yt,
    borderTopRightRadius: Yt,
    borderBottomRightRadius: Yt,
    borderBottomLeftRadius: Yt,
    width: Yt,
    maxWidth: Yt,
    height: Yt,
    maxHeight: Yt,
    top: Yt,
    right: Yt,
    bottom: Yt,
    left: Yt,
    padding: Yt,
    paddingTop: Yt,
    paddingRight: Yt,
    paddingBottom: Yt,
    paddingLeft: Yt,
    margin: Yt,
    marginTop: Yt,
    marginRight: Yt,
    marginBottom: Yt,
    marginLeft: Yt,
    backgroundPositionX: Yt,
    backgroundPositionY: Yt,
  },
  I$ = {
    rotate: yc,
    rotateX: yc,
    rotateY: yc,
    rotateZ: yc,
    scale: uy,
    scaleX: uy,
    scaleY: uy,
    scaleZ: uy,
    skew: yc,
    skewX: yc,
    skewY: yc,
    distance: Yt,
    translateX: Yt,
    translateY: Yt,
    translateZ: Yt,
    x: Yt,
    y: Yt,
    z: Yt,
    perspective: Yt,
    transformPerspective: Yt,
    opacity: hg,
    originX: CP,
    originY: CP,
    originZ: Yt,
  },
  DP = { ...Oh, transform: Math.round },
  Db = {
    ...R$,
    ...I$,
    zIndex: DP,
    size: Yt,
    fillOpacity: hg,
    strokeOpacity: hg,
    numOctaves: DP,
  },
  L$ = {
    ...Db,
    color: Rr,
    backgroundColor: Rr,
    outlineColor: Rr,
    fill: Rr,
    stroke: Rr,
    borderColor: Rr,
    borderTopColor: Rr,
    borderRightColor: Rr,
    borderBottomColor: Rr,
    borderLeftColor: Rr,
    filter: mM,
    WebkitFilter: mM,
  },
  Ob = (n) => L$[n]
function CO(n, e) {
  let t = Ob(n)
  return (
    t !== mM && (t = Lc), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  )
}
const N$ = new Set(['auto', 'none', '0'])
function D$(n, e, t) {
  let i = 0,
    r
  for (; i < n.length && !r; ) {
    const s = n[i]
    typeof s == 'string' && !N$.has(s) && pg(s).values.length && (r = n[i]), i++
  }
  if (r && t) for (const s of e) n[s] = CO(t, r)
}
let PO = class extends Ib {
  constructor(e, t, i, r, s) {
    super(e, t, i, r, s, !0)
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: t, name: i } = this
    if (!t || !t.current) return
    super.readKeyframes()
    for (let c = 0; c < e.length; c++) {
      let u = e[c]
      if (typeof u == 'string' && ((u = u.trim()), Rb(u))) {
        const h = yO(u, t.current)
        h !== void 0 && (e[c] = h),
          c === e.length - 1 && (this.finalKeyframe = u)
      }
    }
    if ((this.resolveNoneKeyframes(), !u$.has(i) || e.length !== 2)) return
    const [r, s] = e,
      o = LP(r),
      a = LP(s)
    if (o !== a)
      if (PP(o) && PP(a))
        for (let c = 0; c < e.length; c++) {
          const u = e[c]
          typeof u == 'string' && (e[c] = parseFloat(u))
        }
      else this.needsMeasurement = !0
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: t } = this,
      i = []
    for (let r = 0; r < e.length; r++) i$(e[r]) && i.push(r)
    i.length && D$(e, i, t)
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: t, name: i } = this
    if (!e || !e.current) return
    i === 'height' && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = Mh[i](
        e.measureViewportBox(),
        window.getComputedStyle(e.current),
      )),
      (t[0] = this.measuredOrigin)
    const r = t[t.length - 1]
    r !== void 0 && e.getValue(i, r).jump(r, !1)
  }
  measureEndState() {
    var e
    const { element: t, name: i, unresolvedKeyframes: r } = this
    if (!t || !t.current) return
    const s = t.getValue(i)
    s && s.jump(this.measuredOrigin, !1)
    const o = r.length - 1,
      a = r[o]
    ;(r[o] = Mh[i](t.measureViewportBox(), window.getComputedStyle(t.current))),
      a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a),
      !((e = this.removedTransforms) === null || e === void 0) &&
        e.length &&
        this.removedTransforms.forEach(([c, u]) => {
          t.getValue(c).set(u)
        }),
      this.resolveNoneKeyframes()
  }
}
const OP = (n, e) =>
  e === 'zIndex'
    ? !1
    : !!(
        typeof n == 'number' ||
        Array.isArray(n) ||
        (typeof n == 'string' &&
          (Lc.test(n) || n === '0') &&
          !n.startsWith('url('))
      )
function O$(n) {
  const e = n[0]
  if (n.length === 1) return !0
  for (let t = 0; t < n.length; t++) if (n[t] !== e) return !0
}
function k$(n, e, t, i) {
  const r = n[0]
  if (r === null) return !1
  if (e === 'display' || e === 'visibility') return !0
  const s = n[n.length - 1],
    o = OP(r, e),
    a = OP(s, e)
  return !o || !a ? !1 : O$(n) || ((t === 'spring' || Tb(t)) && i)
}
const F$ = (n) => n !== null
function I_(n, { repeat: e, repeatType: t = 'loop' }, i) {
  const r = n.filter(F$),
    s = e && t !== 'loop' && e % 2 === 1 ? 0 : r.length - 1
  return !s || i === void 0 ? r[s] : i
}
const U$ = 40
let RO = class {
  constructor({
    autoplay: e = !0,
    delay: t = 0,
    type: i = 'keyframes',
    repeat: r = 0,
    repeatDelay: s = 0,
    repeatType: o = 'loop',
    ...a
  }) {
    ;(this.isStopped = !1),
      (this.hasAttemptedResolve = !1),
      (this.createdAt = _a.now()),
      (this.options = {
        autoplay: e,
        delay: t,
        type: i,
        repeat: r,
        repeatDelay: s,
        repeatType: o,
        ...a,
      }),
      this.updateFinishedPromise()
  }
  calcStartTime() {
    return this.resolvedAt
      ? this.resolvedAt - this.createdAt > U$
        ? this.resolvedAt
        : this.createdAt
      : this.createdAt
  }
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && m$(), this._resolved
  }
  onKeyframesResolved(e, t) {
    ;(this.resolvedAt = _a.now()), (this.hasAttemptedResolve = !0)
    const {
      name: i,
      type: r,
      velocity: s,
      delay: o,
      onComplete: a,
      onUpdate: c,
      isGenerator: u,
    } = this.options
    if (!u && !k$(e, i, r, s))
      if (o) this.options.duration = 0
      else {
        c == null || c(I_(e, this.options, t)),
          a == null || a(),
          this.resolveFinishedPromise()
        return
      }
    const h = this.initPlayback(e, t)
    h !== !1 &&
      ((this._resolved = { keyframes: e, finalKeyframe: t, ...h }),
      this.onPostResolved())
  }
  onPostResolved() {}
  then(e, t) {
    return this.currentFinishedPromise.then(e, t)
  }
  flatten() {
    ;(this.options.type = 'keyframes'), (this.options.ease = 'linear')
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e
    })
  }
}
const gM = 2e4
function IO(n) {
  let e = 0
  const t = 50
  let i = n.next(e)
  for (; !i.done && e < gM; ) (e += t), (i = n.next(e))
  return e >= gM ? 1 / 0 : e
}
const pi = (n, e, t) => n + (e - n) * t
function Vw(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  )
}
function B$({ hue: n, saturation: e, lightness: t, alpha: i }) {
  ;(n /= 360), (e /= 100), (t /= 100)
  let r = 0,
    s = 0,
    o = 0
  if (!e) r = s = o = t
  else {
    const a = t < 0.5 ? t * (1 + e) : t + e - t * e,
      c = 2 * t - a
    ;(r = Vw(c, a, n + 1 / 3)), (s = Vw(c, a, n)), (o = Vw(c, a, n - 1 / 3))
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: i,
  }
}
function bx(n, e) {
  return (t) => (t > 0 ? e : n)
}
const jw = (n, e, t) => {
    const i = n * n,
      r = t * (e * e - i) + i
    return r < 0 ? 0 : Math.sqrt(r)
  },
  z$ = [pM, rd, Qf],
  V$ = (n) => z$.find((e) => e.test(n))
function kP(n) {
  const e = V$(n)
  if (!e) return !1
  let t = e.parse(n)
  return e === Qf && (t = B$(t)), t
}
const FP = (n, e) => {
    const t = kP(n),
      i = kP(e)
    if (!t || !i) return bx(n, e)
    const r = { ...t }
    return (s) => (
      (r.red = jw(t.red, i.red, s)),
      (r.green = jw(t.green, i.green, s)),
      (r.blue = jw(t.blue, i.blue, s)),
      (r.alpha = pi(t.alpha, i.alpha, s)),
      rd.transform(r)
    )
  },
  j$ = (n, e) => (t) => e(n(t)),
  Kg = (...n) => n.reduce(j$),
  vM = new Set(['none', 'hidden'])
function H$(n, e) {
  return vM.has(n) ? (t) => (t <= 0 ? n : e) : (t) => (t >= 1 ? e : n)
}
function G$(n, e) {
  return (t) => pi(n, e, t)
}
function kb(n) {
  return typeof n == 'number'
    ? G$
    : typeof n == 'string'
    ? Rb(n)
      ? bx
      : Rr.test(n)
      ? FP
      : X$
    : Array.isArray(n)
    ? LO
    : typeof n == 'object'
    ? Rr.test(n)
      ? FP
      : W$
    : bx
}
function LO(n, e) {
  const t = [...n],
    i = t.length,
    r = n.map((s, o) => kb(s)(s, e[o]))
  return (s) => {
    for (let o = 0; o < i; o++) t[o] = r[o](s)
    return t
  }
}
function W$(n, e) {
  const t = { ...n, ...e },
    i = {}
  for (const r in t)
    n[r] !== void 0 && e[r] !== void 0 && (i[r] = kb(n[r])(n[r], e[r]))
  return (r) => {
    for (const s in i) t[s] = i[s](r)
    return t
  }
}
function $$(n, e) {
  var t
  const i = [],
    r = { color: 0, var: 0, number: 0 }
  for (let s = 0; s < e.values.length; s++) {
    const o = e.types[s],
      a = n.indexes[o][r[o]],
      c = (t = n.values[a]) !== null && t !== void 0 ? t : 0
    ;(i[s] = c), r[o]++
  }
  return i
}
const X$ = (n, e) => {
  const t = Lc.createTransformer(e),
    i = pg(n),
    r = pg(e)
  return i.indexes.var.length === r.indexes.var.length &&
    i.indexes.color.length === r.indexes.color.length &&
    i.indexes.number.length >= r.indexes.number.length
    ? (vM.has(n) && !r.values.length) || (vM.has(e) && !i.values.length)
      ? H$(n, e)
      : Kg(LO($$(i, r), r.values), t)
    : bx(n, e)
}
function NO(n, e, t) {
  return typeof n == 'number' && typeof e == 'number' && typeof t == 'number'
    ? pi(n, e, t)
    : kb(n)(n, e)
}
const q$ = 5
function DO(n, e, t) {
  const i = Math.max(e - q$, 0)
  return Mb(t - n(i), e - i)
}
const Mi = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  Hw = 0.001
function Y$({
  duration: n = Mi.duration,
  bounce: e = Mi.bounce,
  velocity: t = Mi.velocity,
  mass: i = Mi.mass,
}) {
  let r,
    s,
    o = 1 - e
  ;(o = Cl(Mi.minDamping, Mi.maxDamping, o)),
    (n = Cl(Mi.minDuration, Mi.maxDuration, Ml(n))),
    o < 1
      ? ((r = (u) => {
          const h = u * o,
            m = h * n,
            g = h - t,
            y = yM(u, o),
            _ = Math.exp(-m)
          return Hw - (g / y) * _
        }),
        (s = (u) => {
          const m = u * o * n,
            g = m * t + t,
            y = Math.pow(o, 2) * Math.pow(u, 2) * n,
            _ = Math.exp(-m),
            M = yM(Math.pow(u, 2), o)
          return ((-r(u) + Hw > 0 ? -1 : 1) * ((g - y) * _)) / M
        }))
      : ((r = (u) => {
          const h = Math.exp(-u * n),
            m = (u - t) * n + 1
          return -Hw + h * m
        }),
        (s = (u) => {
          const h = Math.exp(-u * n),
            m = (t - u) * (n * n)
          return h * m
        }))
  const a = 5 / n,
    c = K$(r, s, a)
  if (((n = Sl(n)), isNaN(c)))
    return { stiffness: Mi.stiffness, damping: Mi.damping, duration: n }
  {
    const u = Math.pow(c, 2) * i
    return { stiffness: u, damping: o * 2 * Math.sqrt(i * u), duration: n }
  }
}
const Z$ = 12
function K$(n, e, t) {
  let i = t
  for (let r = 1; r < Z$; r++) i = i - n(i) / e(i)
  return i
}
function yM(n, e) {
  return n * Math.sqrt(1 - e * e)
}
const Q$ = ['duration', 'bounce'],
  J$ = ['stiffness', 'damping', 'mass']
function UP(n, e) {
  return e.some((t) => n[t] !== void 0)
}
function eX(n) {
  let e = {
    velocity: Mi.velocity,
    stiffness: Mi.stiffness,
    damping: Mi.damping,
    mass: Mi.mass,
    isResolvedFromDuration: !1,
    ...n,
  }
  if (!UP(n, J$) && UP(n, Q$))
    if (n.visualDuration) {
      const t = n.visualDuration,
        i = (2 * Math.PI) / (t * 1.2),
        r = i * i,
        s = 2 * Cl(0.05, 1, 1 - (n.bounce || 0)) * Math.sqrt(r)
      e = { ...e, mass: Mi.mass, stiffness: r, damping: s }
    } else {
      const t = Y$(n)
      ;(e = { ...e, ...t, mass: Mi.mass }), (e.isResolvedFromDuration = !0)
    }
  return e
}
function OO(n = Mi.visualDuration, e = Mi.bounce) {
  const t =
    typeof n != 'object'
      ? { visualDuration: n, keyframes: [0, 1], bounce: e }
      : n
  let { restSpeed: i, restDelta: r } = t
  const s = t.keyframes[0],
    o = t.keyframes[t.keyframes.length - 1],
    a = { done: !1, value: s },
    {
      stiffness: c,
      damping: u,
      mass: h,
      duration: m,
      velocity: g,
      isResolvedFromDuration: y,
    } = eX({ ...t, velocity: -Ml(t.velocity || 0) }),
    _ = g || 0,
    M = u / (2 * Math.sqrt(c * h)),
    w = o - s,
    x = Ml(Math.sqrt(c / h)),
    T = Math.abs(w) < 5
  i || (i = T ? Mi.restSpeed.granular : Mi.restSpeed.default),
    r || (r = T ? Mi.restDelta.granular : Mi.restDelta.default)
  let A
  if (M < 1) {
    const D = yM(x, M)
    A = (O) => {
      const U = Math.exp(-M * x * O)
      return (
        o - U * (((_ + M * x * w) / D) * Math.sin(D * O) + w * Math.cos(D * O))
      )
    }
  } else if (M === 1) A = (D) => o - Math.exp(-x * D) * (w + (_ + x * w) * D)
  else {
    const D = x * Math.sqrt(M * M - 1)
    A = (O) => {
      const U = Math.exp(-M * x * O),
        F = Math.min(D * O, 300)
      return (
        o - (U * ((_ + M * x * w) * Math.sinh(F) + D * w * Math.cosh(F))) / D
      )
    }
  }
  const P = {
    calculatedDuration: (y && m) || null,
    next: (D) => {
      const O = A(D)
      if (y) a.done = D >= m
      else {
        let U = 0
        M < 1 && (U = D === 0 ? Sl(_) : DO(A, D, O))
        const F = Math.abs(U) <= i,
          N = Math.abs(o - O) <= r
        a.done = F && N
      }
      return (a.value = a.done ? o : O), a
    },
    toString: () => {
      const D = Math.min(IO(P), gM),
        O = iO((U) => P.next(D * U).value, D, 30)
      return D + 'ms ' + O
    },
  }
  return P
}
function BP({
  keyframes: n,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: i = 325,
  bounceDamping: r = 10,
  bounceStiffness: s = 500,
  modifyTarget: o,
  min: a,
  max: c,
  restDelta: u = 0.5,
  restSpeed: h,
}) {
  const m = n[0],
    g = { done: !1, value: m },
    y = (F) => (a !== void 0 && F < a) || (c !== void 0 && F > c),
    _ = (F) =>
      a === void 0
        ? c
        : c === void 0 || Math.abs(a - F) < Math.abs(c - F)
        ? a
        : c
  let M = t * e
  const w = m + M,
    x = o === void 0 ? w : o(w)
  x !== w && (M = x - m)
  const T = (F) => -M * Math.exp(-F / i),
    A = (F) => x + T(F),
    P = (F) => {
      const N = T(F),
        k = A(F)
      ;(g.done = Math.abs(N) <= u), (g.value = g.done ? x : k)
    }
  let D, O
  const U = (F) => {
    y(g.value) &&
      ((D = F),
      (O = OO({
        keyframes: [g.value, _(g.value)],
        velocity: DO(A, F, g.value),
        damping: r,
        stiffness: s,
        restDelta: u,
        restSpeed: h,
      })))
  }
  return (
    U(0),
    {
      calculatedDuration: null,
      next: (F) => {
        let N = !1
        return (
          !O && D === void 0 && ((N = !0), P(F), U(F)),
          D !== void 0 && F >= D ? O.next(F - D) : (!N && P(F), g)
        )
      },
    }
  )
}
const tX = Yg(0.42, 0, 1, 1),
  nX = Yg(0, 0, 0.58, 1),
  kO = Yg(0.42, 0, 0.58, 1),
  iX = (n) => Array.isArray(n) && typeof n[0] != 'number',
  zP = {
    linear: es,
    easeIn: tX,
    easeInOut: kO,
    easeOut: nX,
    circIn: Pb,
    circInOut: hO,
    circOut: fO,
    backIn: Cb,
    backInOut: uO,
    backOut: cO,
    anticipate: dO,
  },
  VP = (n) => {
    if (Ab(n)) {
      cM(n.length === 4)
      const [e, t, i, r] = n
      return Yg(e, t, i, r)
    } else if (typeof n == 'string') return cM(zP[n] !== void 0), zP[n]
    return n
  }
function rX(n, e, t) {
  const i = [],
    r = t || NO,
    s = n.length - 1
  for (let o = 0; o < s; o++) {
    let a = r(n[o], n[o + 1])
    if (e) {
      const c = Array.isArray(e) ? e[o] || es : e
      a = Kg(c, a)
    }
    i.push(a)
  }
  return i
}
function Fb(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) {
  const s = n.length
  if ((cM(s === e.length), s === 1)) return () => e[0]
  if (s === 2 && n[0] === n[1]) return () => e[1]
  n[0] > n[s - 1] && ((n = [...n].reverse()), (e = [...e].reverse()))
  const o = rX(e, i, r),
    a = o.length,
    c = (u) => {
      let h = 0
      if (a > 1) for (; h < n.length - 2 && !(u < n[h + 1]); h++);
      const m = xd(n[h], n[h + 1], u)
      return o[h](m)
    }
  return t ? (u) => c(Cl(n[0], n[s - 1], u)) : c
}
function sX(n, e) {
  const t = n[n.length - 1]
  for (let i = 1; i <= e; i++) {
    const r = xd(0, e, i)
    n.push(pi(t, 1, r))
  }
}
function FO(n) {
  const e = [0]
  return sX(e, n.length - 1), e
}
function oX(n, e) {
  return n.map((t) => t * e)
}
function aX(n, e) {
  return n.map(() => e || kO).splice(0, n.length - 1)
}
function Tx({
  duration: n = 300,
  keyframes: e,
  times: t,
  ease: i = 'easeInOut',
}) {
  const r = iX(i) ? i.map(VP) : VP(i),
    s = { done: !1, value: e[0] },
    o = oX(t && t.length === e.length ? t : FO(e), n),
    a = Fb(o, e, { ease: Array.isArray(r) ? r : aX(e, r) })
  return {
    calculatedDuration: n,
    next: (c) => ((s.value = a(c)), (s.done = c >= n), s),
  }
}
const lX = (n) => {
    const e = ({ timestamp: t }) => n(t)
    return {
      start: () => Dn.update(e, !0),
      stop: () => qo(e),
      now: () => (rr.isProcessing ? rr.timestamp : _a.now()),
    }
  },
  cX = { decay: BP, inertia: BP, tween: Tx, keyframes: Tx, spring: OO },
  uX = (n) => n / 100
let Ub = class extends RO {
  constructor(e) {
    super(e),
      (this.holdTime = null),
      (this.cancelTime = null),
      (this.currentTime = 0),
      (this.playbackSpeed = 1),
      (this.pendingPlayState = 'running'),
      (this.startTime = null),
      (this.state = 'idle'),
      (this.stop = () => {
        if (
          (this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle')
        )
          return
        this.teardown()
        const { onStop: c } = this.options
        c && c()
      })
    const { name: t, motionValue: i, element: r, keyframes: s } = this.options,
      o = (r == null ? void 0 : r.KeyframeResolver) || Ib,
      a = (c, u) => this.onKeyframesResolved(c, u)
    ;(this.resolver = new o(s, a, t, i, r)), this.resolver.scheduleResolve()
  }
  flatten() {
    super.flatten(),
      this._resolved &&
        Object.assign(
          this._resolved,
          this.initPlayback(this._resolved.keyframes),
        )
  }
  initPlayback(e) {
    const {
        type: t = 'keyframes',
        repeat: i = 0,
        repeatDelay: r = 0,
        repeatType: s,
        velocity: o = 0,
      } = this.options,
      a = Tb(t) ? t : cX[t] || Tx
    let c, u
    a !== Tx &&
      typeof e[0] != 'number' &&
      ((c = Kg(uX, NO(e[0], e[1]))), (e = [0, 100]))
    const h = a({ ...this.options, keyframes: e })
    s === 'mirror' &&
      (u = a({ ...this.options, keyframes: [...e].reverse(), velocity: -o })),
      h.calculatedDuration === null && (h.calculatedDuration = IO(h))
    const { calculatedDuration: m } = h,
      g = m + r,
      y = g * (i + 1) - r
    return {
      generator: h,
      mirroredGenerator: u,
      mapPercentToKeyframes: c,
      calculatedDuration: m,
      resolvedDuration: g,
      totalDuration: y,
    }
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options
    this.play(),
      this.pendingPlayState === 'paused' || !e
        ? this.pause()
        : (this.state = this.pendingPlayState)
  }
  tick(e, t = !1) {
    const { resolved: i } = this
    if (!i) {
      const { keyframes: F } = this.options
      return { done: !0, value: F[F.length - 1] }
    }
    const {
      finalKeyframe: r,
      generator: s,
      mirroredGenerator: o,
      mapPercentToKeyframes: a,
      keyframes: c,
      calculatedDuration: u,
      totalDuration: h,
      resolvedDuration: m,
    } = i
    if (this.startTime === null) return s.next(0)
    const {
      delay: g,
      repeat: y,
      repeatType: _,
      repeatDelay: M,
      onUpdate: w,
    } = this.options
    this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - h / this.speed, this.startTime)),
      t
        ? (this.currentTime = e)
        : this.holdTime !== null
        ? (this.currentTime = this.holdTime)
        : (this.currentTime = Math.round(e - this.startTime) * this.speed)
    const x = this.currentTime - g * (this.speed >= 0 ? 1 : -1),
      T = this.speed >= 0 ? x < 0 : x > h
    ;(this.currentTime = Math.max(x, 0)),
      this.state === 'finished' &&
        this.holdTime === null &&
        (this.currentTime = h)
    let A = this.currentTime,
      P = s
    if (y) {
      const F = Math.min(this.currentTime, h) / m
      let N = Math.floor(F),
        k = F % 1
      !k && F >= 1 && (k = 1),
        k === 1 && N--,
        (N = Math.min(N, y + 1)),
        !!(N % 2) &&
          (_ === 'reverse'
            ? ((k = 1 - k), M && (k -= M / m))
            : _ === 'mirror' && (P = o)),
        (A = Cl(0, 1, k) * m)
    }
    const D = T ? { done: !1, value: c[0] } : P.next(A)
    a && (D.value = a(D.value))
    let { done: O } = D
    !T &&
      u !== null &&
      (O = this.speed >= 0 ? this.currentTime >= h : this.currentTime <= 0)
    const U =
      this.holdTime === null &&
      (this.state === 'finished' || (this.state === 'running' && O))
    return (
      U && r !== void 0 && (D.value = I_(c, this.options, r)),
      w && w(D.value),
      U && this.finish(),
      D
    )
  }
  get duration() {
    const { resolved: e } = this
    return e ? Ml(e.calculatedDuration) : 0
  }
  get time() {
    return Ml(this.currentTime)
  }
  set time(e) {
    ;(e = Sl(e)),
      (this.currentTime = e),
      this.holdTime !== null || this.speed === 0
        ? (this.holdTime = e)
        : this.driver && (this.startTime = this.driver.now() - e / this.speed)
  }
  get speed() {
    return this.playbackSpeed
  }
  set speed(e) {
    const t = this.playbackSpeed !== e
    ;(this.playbackSpeed = e), t && (this.time = Ml(this.currentTime))
  }
  play() {
    if (
      (this.resolver.isScheduled || this.resolver.resume(), !this._resolved)
    ) {
      this.pendingPlayState = 'running'
      return
    }
    if (this.isStopped) return
    const { driver: e = lX, onPlay: t, startTime: i } = this.options
    this.driver || (this.driver = e((s) => this.tick(s))), t && t()
    const r = this.driver.now()
    this.holdTime !== null
      ? (this.startTime = r - this.holdTime)
      : this.startTime
      ? this.state === 'finished' && (this.startTime = r)
      : (this.startTime = i ?? this.calcStartTime()),
      this.state === 'finished' && this.updateFinishedPromise(),
      (this.cancelTime = this.startTime),
      (this.holdTime = null),
      (this.state = 'running'),
      this.driver.start()
  }
  pause() {
    var e
    if (!this._resolved) {
      this.pendingPlayState = 'paused'
      return
    }
    ;(this.state = 'paused'),
      (this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0)
  }
  complete() {
    this.state !== 'running' && this.play(),
      (this.pendingPlayState = this.state = 'finished'),
      (this.holdTime = null)
  }
  finish() {
    this.teardown(), (this.state = 'finished')
    const { onComplete: e } = this.options
    e && e()
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime),
      this.teardown(),
      this.updateFinishedPromise()
  }
  teardown() {
    ;(this.state = 'idle'),
      this.stopDriver(),
      this.resolveFinishedPromise(),
      this.updateFinishedPromise(),
      (this.startTime = this.cancelTime = null),
      this.resolver.cancel()
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0))
  }
  sample(e) {
    return (this.startTime = 0), this.tick(e, !0)
  }
}
const dX = new Set(['opacity', 'clipPath', 'filter', 'transform'])
function fX(
  n,
  e,
  t,
  {
    delay: i = 0,
    duration: r = 300,
    repeat: s = 0,
    repeatType: o = 'loop',
    ease: a = 'easeInOut',
    times: c,
  } = {},
) {
  const u = { [e]: t }
  c && (u.offset = c)
  const h = sO(a, r)
  return (
    Array.isArray(h) && (u.easing = h),
    n.animate(u, {
      delay: i,
      duration: r,
      easing: Array.isArray(h) ? 'linear' : h,
      fill: 'both',
      iterations: s + 1,
      direction: o === 'reverse' ? 'alternate' : 'normal',
    })
  )
}
const hX = bb(() => Object.hasOwnProperty.call(Element.prototype, 'animate')),
  Ax = 10,
  pX = 2e4
function mX(n) {
  return Tb(n.type) || n.type === 'spring' || !rO(n.ease)
}
function gX(n, e) {
  const t = new Ub({ ...e, keyframes: n, repeat: 0, delay: 0, isGenerator: !0 })
  let i = { done: !1, value: n[0] }
  const r = []
  let s = 0
  for (; !i.done && s < pX; ) (i = t.sample(s)), r.push(i.value), (s += Ax)
  return { times: void 0, keyframes: r, duration: s - Ax, ease: 'linear' }
}
const UO = { anticipate: dO, backInOut: uO, circInOut: hO }
function vX(n) {
  return n in UO
}
let jP = class extends RO {
  constructor(e) {
    super(e)
    const { name: t, motionValue: i, element: r, keyframes: s } = this.options
    ;(this.resolver = new PO(
      s,
      (o, a) => this.onKeyframesResolved(o, a),
      t,
      i,
      r,
    )),
      this.resolver.scheduleResolve()
  }
  initPlayback(e, t) {
    var i
    let {
      duration: r = 300,
      times: s,
      ease: o,
      type: a,
      motionValue: c,
      name: u,
      startTime: h,
    } = this.options
    if (!(!((i = c.owner) === null || i === void 0) && i.current)) return !1
    if (
      (typeof o == 'string' && Ex() && vX(o) && (o = UO[o]), mX(this.options))
    ) {
      const {
          onComplete: g,
          onUpdate: y,
          motionValue: _,
          element: M,
          ...w
        } = this.options,
        x = gX(e, w)
      ;(e = x.keyframes),
        e.length === 1 && (e[1] = e[0]),
        (r = x.duration),
        (s = x.times),
        (o = x.ease),
        (a = 'keyframes')
    }
    const m = fX(c.owner.current, u, e, {
      ...this.options,
      duration: r,
      times: s,
      ease: o,
    })
    return (
      (m.startTime = h ?? this.calcStartTime()),
      this.pendingTimeline
        ? (AP(m, this.pendingTimeline), (this.pendingTimeline = void 0))
        : (m.onfinish = () => {
            const { onComplete: g } = this.options
            c.set(I_(e, this.options, t)),
              g && g(),
              this.cancel(),
              this.resolveFinishedPromise()
          }),
      { animation: m, duration: r, times: s, type: a, ease: o, keyframes: e }
    )
  }
  get duration() {
    const { resolved: e } = this
    if (!e) return 0
    const { duration: t } = e
    return Ml(t)
  }
  get time() {
    const { resolved: e } = this
    if (!e) return 0
    const { animation: t } = e
    return Ml(t.currentTime || 0)
  }
  set time(e) {
    const { resolved: t } = this
    if (!t) return
    const { animation: i } = t
    i.currentTime = Sl(e)
  }
  get speed() {
    const { resolved: e } = this
    if (!e) return 1
    const { animation: t } = e
    return t.playbackRate
  }
  set speed(e) {
    const { resolved: t } = this
    if (!t) return
    const { animation: i } = t
    i.playbackRate = e
  }
  get state() {
    const { resolved: e } = this
    if (!e) return 'idle'
    const { animation: t } = e
    return t.playState
  }
  get startTime() {
    const { resolved: e } = this
    if (!e) return null
    const { animation: t } = e
    return t.startTime
  }
  attachTimeline(e) {
    if (!this._resolved) this.pendingTimeline = e
    else {
      const { resolved: t } = this
      if (!t) return es
      const { animation: i } = t
      AP(i, e)
    }
    return es
  }
  play() {
    if (this.isStopped) return
    const { resolved: e } = this
    if (!e) return
    const { animation: t } = e
    t.playState === 'finished' && this.updateFinishedPromise(), t.play()
  }
  pause() {
    const { resolved: e } = this
    if (!e) return
    const { animation: t } = e
    t.pause()
  }
  stop() {
    if ((this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle'))
      return
    this.resolveFinishedPromise(), this.updateFinishedPromise()
    const { resolved: e } = this
    if (!e) return
    const {
      animation: t,
      keyframes: i,
      duration: r,
      type: s,
      ease: o,
      times: a,
    } = e
    if (t.playState === 'idle' || t.playState === 'finished') return
    if (this.time) {
      const {
          motionValue: u,
          onUpdate: h,
          onComplete: m,
          element: g,
          ...y
        } = this.options,
        _ = new Ub({
          ...y,
          keyframes: i,
          duration: r,
          type: s,
          ease: o,
          times: a,
          isGenerator: !0,
        }),
        M = Sl(this.time)
      u.setWithVelocity(_.sample(M - Ax).value, _.sample(M).value, Ax)
    }
    const { onStop: c } = this.options
    c && c(), this.cancel()
  }
  complete() {
    const { resolved: e } = this
    e && e.animation.finish()
  }
  cancel() {
    const { resolved: e } = this
    e && e.animation.cancel()
  }
  static supports(e) {
    const {
      motionValue: t,
      name: i,
      repeatDelay: r,
      repeatType: s,
      damping: o,
      type: a,
    } = e
    return (
      hX() &&
      i &&
      dX.has(i) &&
      t &&
      t.owner &&
      t.owner.current instanceof HTMLElement &&
      !t.owner.getProps().onUpdate &&
      !r &&
      s !== 'mirror' &&
      o !== 0 &&
      a !== 'inertia'
    )
  }
}
const yX = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10 },
  xX = (n) => ({
    type: 'spring',
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  _X = { type: 'keyframes', duration: 0.8 },
  wX = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  SX = (n, { keyframes: e }) =>
    e.length > 2 ? _X : Md.has(n) ? (n.startsWith('scale') ? xX(e[1]) : yX) : wX
function MX({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: i,
  staggerDirection: r,
  repeat: s,
  repeatType: o,
  repeatDelay: a,
  from: c,
  elapsed: u,
  ...h
}) {
  return !!Object.keys(h).length
}
const Bb =
  (n, e, t, i = {}, r, s) =>
  (o) => {
    const a = xb(i, n) || {},
      c = a.delay || i.delay || 0
    let { elapsed: u = 0 } = i
    u = u - Sl(c)
    let h = {
      keyframes: Array.isArray(t) ? t : [null, t],
      ease: 'easeOut',
      velocity: e.getVelocity(),
      ...a,
      delay: -u,
      onUpdate: (g) => {
        e.set(g), a.onUpdate && a.onUpdate(g)
      },
      onComplete: () => {
        o(), a.onComplete && a.onComplete()
      },
      name: n,
      motionValue: e,
      element: s ? void 0 : r,
    }
    MX(a) || (h = { ...h, ...SX(n, h) }),
      h.duration && (h.duration = Sl(h.duration)),
      h.repeatDelay && (h.repeatDelay = Sl(h.repeatDelay)),
      h.from !== void 0 && (h.keyframes[0] = h.from)
    let m = !1
    if (
      ((h.type === !1 || (h.duration === 0 && !h.repeatDelay)) &&
        ((h.duration = 0), h.delay === 0 && (m = !0)),
      m && !s && e.get() !== void 0)
    ) {
      const g = I_(h.keyframes, a)
      if (g !== void 0)
        return (
          Dn.update(() => {
            h.onUpdate(g), h.onComplete()
          }),
          new K7([])
        )
    }
    return !s && jP.supports(h) ? new jP(h) : new Ub(h)
  }
function EX({ protectedKeys: n, needsAnimating: e }, t) {
  const i = n.hasOwnProperty(t) && e[t] !== !0
  return (e[t] = !1), i
}
function BO(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) {
  var s
  let { transition: o = n.getDefaultTransition(), transitionEnd: a, ...c } = e
  i && (o = i)
  const u = [],
    h = r && n.animationState && n.animationState.getState()[r]
  for (const m in c) {
    const g = n.getValue(
        m,
        (s = n.latestValues[m]) !== null && s !== void 0 ? s : null,
      ),
      y = c[m]
    if (y === void 0 || (h && EX(h, m))) continue
    const _ = { delay: t, ...xb(o || {}, m) }
    let M = !1
    if (window.MotionHandoffAnimation) {
      const x = tO(n)
      if (x) {
        const T = window.MotionHandoffAnimation(x, m, Dn)
        T !== null && ((_.startTime = T), (M = !0))
      }
    }
    uM(n, m),
      g.start(
        Bb(m, g, y, n.shouldReduceMotion && Md.has(m) ? { type: !1 } : _, n, M),
      )
    const w = g.animation
    w && u.push(w)
  }
  return (
    a &&
      Promise.all(u).then(() => {
        Dn.update(() => {
          a && X7(n, a)
        })
      }),
    u
  )
}
function xM(n, e, t = {}) {
  var i
  const r = R_(
    n,
    e,
    t.type === 'exit'
      ? (i = n.presenceContext) === null || i === void 0
        ? void 0
        : i.custom
      : void 0,
  )
  let { transition: s = n.getDefaultTransition() || {} } = r || {}
  t.transitionOverride && (s = t.transitionOverride)
  const o = r ? () => Promise.all(BO(n, r, t)) : () => Promise.resolve(),
    a =
      n.variantChildren && n.variantChildren.size
        ? (u = 0) => {
            const {
              delayChildren: h = 0,
              staggerChildren: m,
              staggerDirection: g,
            } = s
            return bX(n, e, h + u, m, g, t)
          }
        : () => Promise.resolve(),
    { when: c } = s
  if (c) {
    const [u, h] = c === 'beforeChildren' ? [o, a] : [a, o]
    return u().then(() => h())
  } else return Promise.all([o(), a(t.delay)])
}
function bX(n, e, t = 0, i = 0, r = 1, s) {
  const o = [],
    a = (n.variantChildren.size - 1) * i,
    c = r === 1 ? (u = 0) => u * i : (u = 0) => a - u * i
  return (
    Array.from(n.variantChildren)
      .sort(TX)
      .forEach((u, h) => {
        u.notify('AnimationStart', e),
          o.push(
            xM(u, e, { ...s, delay: t + c(h) }).then(() =>
              u.notify('AnimationComplete', e),
            ),
          )
      }),
    Promise.all(o)
  )
}
function TX(n, e) {
  return n.sortNodePosition(e)
}
function AX(n, e, t = {}) {
  n.notify('AnimationStart', e)
  let i
  if (Array.isArray(e)) {
    const r = e.map((s) => xM(n, s, t))
    i = Promise.all(r)
  } else if (typeof e == 'string') i = xM(n, e, t)
  else {
    const r = typeof e == 'function' ? R_(n, e, t.custom) : e
    i = Promise.all(BO(n, r, t))
  }
  return i.then(() => {
    n.notify('AnimationComplete', e)
  })
}
const CX = yb.length
function zO(n) {
  if (!n) return
  if (!n.isControllingVariants) {
    const t = n.parent ? zO(n.parent) || {} : {}
    return n.props.initial !== void 0 && (t.initial = n.props.initial), t
  }
  const e = {}
  for (let t = 0; t < CX; t++) {
    const i = yb[t],
      r = n.props[i]
    ;(fg(r) || r === !1) && (e[i] = r)
  }
  return e
}
const PX = [...vb].reverse(),
  RX = vb.length
function IX(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: i }) => AX(n, t, i)))
}
function LX(n) {
  let e = IX(n),
    t = HP(),
    i = !0
  const r = (c) => (u, h) => {
    var m
    const g = R_(
      n,
      h,
      c === 'exit'
        ? (m = n.presenceContext) === null || m === void 0
          ? void 0
          : m.custom
        : void 0,
    )
    if (g) {
      const { transition: y, transitionEnd: _, ...M } = g
      u = { ...u, ...M, ..._ }
    }
    return u
  }
  function s(c) {
    e = c(n)
  }
  function o(c) {
    const { props: u } = n,
      h = zO(n.parent) || {},
      m = [],
      g = new Set()
    let y = {},
      _ = 1 / 0
    for (let w = 0; w < RX; w++) {
      const x = PX[w],
        T = t[x],
        A = u[x] !== void 0 ? u[x] : h[x],
        P = fg(A),
        D = x === c ? T.isActive : null
      D === !1 && (_ = w)
      let O = A === h[x] && A !== u[x] && P
      if (
        (O && i && n.manuallyAnimateOnMount && (O = !1),
        (T.protectedKeys = { ...y }),
        (!T.isActive && D === null) ||
          (!A && !T.prevProp) ||
          P_(A) ||
          typeof A == 'boolean')
      )
        continue
      const U = NX(T.prevProp, A)
      let F = U || (x === c && T.isActive && !O && P) || (w > _ && P),
        N = !1
      const k = Array.isArray(A) ? A : [A]
      let z = k.reduce(r(x), {})
      D === !1 && (z = {})
      const { prevResolvedValues: $ = {} } = T,
        te = { ...$, ...z },
        j = (ne) => {
          ;(F = !0),
            g.has(ne) && ((N = !0), g.delete(ne)),
            (T.needsAnimating[ne] = !0)
          const V = n.getValue(ne)
          V && (V.liveStyle = !1)
        }
      for (const ne in te) {
        const V = z[ne],
          Y = $[ne]
        if (y.hasOwnProperty(ne)) continue
        let Q = !1
        lM(V) && lM(Y) ? (Q = !QD(V, Y)) : (Q = V !== Y),
          Q
            ? V != null
              ? j(ne)
              : g.add(ne)
            : V !== void 0 && g.has(ne)
            ? j(ne)
            : (T.protectedKeys[ne] = !0)
      }
      ;(T.prevProp = A),
        (T.prevResolvedValues = z),
        T.isActive && (y = { ...y, ...z }),
        i && n.blockInitialAnimation && (F = !1),
        F &&
          (!(O && U) || N) &&
          m.push(...k.map((ne) => ({ animation: ne, options: { type: x } })))
    }
    if (g.size) {
      const w = {}
      g.forEach((x) => {
        const T = n.getBaseTarget(x),
          A = n.getValue(x)
        A && (A.liveStyle = !0), (w[x] = T ?? null)
      }),
        m.push({ animation: w })
    }
    let M = !!m.length
    return (
      i &&
        (u.initial === !1 || u.initial === u.animate) &&
        !n.manuallyAnimateOnMount &&
        (M = !1),
      (i = !1),
      M ? e(m) : Promise.resolve()
    )
  }
  function a(c, u) {
    var h
    if (t[c].isActive === u) return Promise.resolve()
    ;(h = n.variantChildren) === null ||
      h === void 0 ||
      h.forEach((g) => {
        var y
        return (y = g.animationState) === null || y === void 0
          ? void 0
          : y.setActive(c, u)
      }),
      (t[c].isActive = u)
    const m = o(c)
    for (const g in t) t[g].protectedKeys = {}
    return m
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => t,
    reset: () => {
      ;(t = HP()), (i = !0)
    },
  }
}
function NX(n, e) {
  return typeof e == 'string' ? e !== n : Array.isArray(e) ? !QD(e, n) : !1
}
function zu(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  }
}
function HP() {
  return {
    animate: zu(!0),
    whileInView: zu(),
    whileHover: zu(),
    whileTap: zu(),
    whileDrag: zu(),
    whileFocus: zu(),
    exit: zu(),
  }
}
let zc = class {
    constructor(e) {
      ;(this.isMounted = !1), (this.node = e)
    }
    update() {}
  },
  DX = class extends zc {
    constructor(e) {
      super(e), e.animationState || (e.animationState = LX(e))
    }
    updateAnimationControlsSubscription() {
      const { animate: e } = this.node.getProps()
      P_(e) && (this.unmountControls = e.subscribe(this.node))
    }
    mount() {
      this.updateAnimationControlsSubscription()
    }
    update() {
      const { animate: e } = this.node.getProps(),
        { animate: t } = this.node.prevProps || {}
      e !== t && this.updateAnimationControlsSubscription()
    }
    unmount() {
      var e
      this.node.animationState.reset(),
        (e = this.unmountControls) === null || e === void 0 || e.call(this)
    }
  },
  OX = 0,
  kX = class extends zc {
    constructor() {
      super(...arguments), (this.id = OX++)
    }
    update() {
      if (!this.node.presenceContext) return
      const { isPresent: e, onExitComplete: t } = this.node.presenceContext,
        { isPresent: i } = this.node.prevPresenceContext || {}
      if (!this.node.animationState || e === i) return
      const r = this.node.animationState.setActive('exit', !e)
      t && !e && r.then(() => t(this.id))
    }
    mount() {
      const { register: e } = this.node.presenceContext || {}
      e && (this.unmount = e(this.id))
    }
    unmount() {}
  }
const FX = { animation: { Feature: DX }, exit: { Feature: kX } },
  Bo = { x: !1, y: !1 }
function VO() {
  return Bo.x || Bo.y
}
function UX(n) {
  return n === 'x' || n === 'y'
    ? Bo[n]
      ? null
      : ((Bo[n] = !0),
        () => {
          Bo[n] = !1
        })
    : Bo.x || Bo.y
    ? null
    : ((Bo.x = Bo.y = !0),
      () => {
        Bo.x = Bo.y = !1
      })
}
const zb = (n) =>
  n.pointerType === 'mouse'
    ? typeof n.button != 'number' || n.button <= 0
    : n.isPrimary !== !1
function mg(n, e, t, i = { passive: !0 }) {
  return n.addEventListener(e, t, i), () => n.removeEventListener(e, t)
}
function Qg(n) {
  return { point: { x: n.pageX, y: n.pageY } }
}
const BX = (n) => (e) => zb(e) && n(e, Qg(e))
function Im(n, e, t, i) {
  return mg(n, e, BX(t), i)
}
const GP = (n, e) => Math.abs(n - e)
function zX(n, e) {
  const t = GP(n.x, e.x),
    i = GP(n.y, e.y)
  return Math.sqrt(t ** 2 + i ** 2)
}
let jO = class {
  constructor(
    e,
    t,
    { transformPagePoint: i, contextWindow: r, dragSnapToOrigin: s = !1 } = {},
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return
        const m = Ww(this.lastMoveEventInfo, this.history),
          g = this.startEvent !== null,
          y = zX(m.offset, { x: 0, y: 0 }) >= 3
        if (!g && !y) return
        const { point: _ } = m,
          { timestamp: M } = rr
        this.history.push({ ..._, timestamp: M })
        const { onStart: w, onMove: x } = this.handlers
        g ||
          (w && w(this.lastMoveEvent, m),
          (this.startEvent = this.lastMoveEvent)),
          x && x(this.lastMoveEvent, m)
      }),
      (this.handlePointerMove = (m, g) => {
        ;(this.lastMoveEvent = m),
          (this.lastMoveEventInfo = Gw(g, this.transformPagePoint)),
          Dn.update(this.updatePoint, !0)
      }),
      (this.handlePointerUp = (m, g) => {
        this.end()
        const { onEnd: y, onSessionEnd: _, resumeAnimation: M } = this.handlers
        if (
          (this.dragSnapToOrigin && M && M(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return
        const w = Ww(
          m.type === 'pointercancel'
            ? this.lastMoveEventInfo
            : Gw(g, this.transformPagePoint),
          this.history,
        )
        this.startEvent && y && y(m, w), _ && _(m, w)
      }),
      !zb(e))
    )
      return
    ;(this.dragSnapToOrigin = s),
      (this.handlers = t),
      (this.transformPagePoint = i),
      (this.contextWindow = r || window)
    const o = Qg(e),
      a = Gw(o, this.transformPagePoint),
      { point: c } = a,
      { timestamp: u } = rr
    this.history = [{ ...c, timestamp: u }]
    const { onSessionStart: h } = t
    h && h(e, Ww(a, this.history)),
      (this.removeListeners = Kg(
        Im(this.contextWindow, 'pointermove', this.handlePointerMove),
        Im(this.contextWindow, 'pointerup', this.handlePointerUp),
        Im(this.contextWindow, 'pointercancel', this.handlePointerUp),
      ))
  }
  updateHandlers(e) {
    this.handlers = e
  }
  end() {
    this.removeListeners && this.removeListeners(), qo(this.updatePoint)
  }
}
function Gw(n, e) {
  return e ? { point: e(n.point) } : n
}
function WP(n, e) {
  return { x: n.x - e.x, y: n.y - e.y }
}
function Ww({ point: n }, e) {
  return {
    point: n,
    delta: WP(n, HO(e)),
    offset: WP(n, VX(e)),
    velocity: jX(e, 0.1),
  }
}
function VX(n) {
  return n[0]
}
function HO(n) {
  return n[n.length - 1]
}
function jX(n, e) {
  if (n.length < 2) return { x: 0, y: 0 }
  let t = n.length - 1,
    i = null
  const r = HO(n)
  for (; t >= 0 && ((i = n[t]), !(r.timestamp - i.timestamp > Sl(e))); ) t--
  if (!i) return { x: 0, y: 0 }
  const s = Ml(r.timestamp - i.timestamp)
  if (s === 0) return { x: 0, y: 0 }
  const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s }
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
}
function Jf(n) {
  return (
    n &&
    typeof n == 'object' &&
    Object.prototype.hasOwnProperty.call(n, 'current')
  )
}
const GO = 1e-4,
  HX = 1 - GO,
  GX = 1 + GO,
  WO = 0.01,
  WX = 0 - WO,
  $X = 0 + WO
function Bs(n) {
  return n.max - n.min
}
function XX(n, e, t) {
  return Math.abs(n - e) <= t
}
function $P(n, e, t, i = 0.5) {
  ;(n.origin = i),
    (n.originPoint = pi(e.min, e.max, n.origin)),
    (n.scale = Bs(t) / Bs(e)),
    (n.translate = pi(t.min, t.max, n.origin) - n.originPoint),
    ((n.scale >= HX && n.scale <= GX) || isNaN(n.scale)) && (n.scale = 1),
    ((n.translate >= WX && n.translate <= $X) || isNaN(n.translate)) &&
      (n.translate = 0)
}
function Lm(n, e, t, i) {
  $P(n.x, e.x, t.x, i ? i.originX : void 0),
    $P(n.y, e.y, t.y, i ? i.originY : void 0)
}
function XP(n, e, t) {
  ;(n.min = t.min + e.min), (n.max = n.min + Bs(e))
}
function qX(n, e, t) {
  XP(n.x, e.x, t.x), XP(n.y, e.y, t.y)
}
function qP(n, e, t) {
  ;(n.min = e.min - t.min), (n.max = n.min + Bs(e))
}
function Nm(n, e, t) {
  qP(n.x, e.x, t.x), qP(n.y, e.y, t.y)
}
function YX(n, { min: e, max: t }, i) {
  return (
    e !== void 0 && n < e
      ? (n = i ? pi(e, n, i.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = i ? pi(t, n, i.max) : Math.min(n, t)),
    n
  )
}
function YP(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  }
}
function ZX(n, { top: e, left: t, bottom: i, right: r }) {
  return { x: YP(n.x, t, r), y: YP(n.y, e, i) }
}
function ZP(n, e) {
  let t = e.min - n.min,
    i = e.max - n.max
  return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), { min: t, max: i }
}
function KX(n, e) {
  return { x: ZP(n.x, e.x), y: ZP(n.y, e.y) }
}
function QX(n, e) {
  let t = 0.5
  const i = Bs(n),
    r = Bs(e)
  return (
    r > i
      ? (t = xd(e.min, e.max - i, n.min))
      : i > r && (t = xd(n.min, n.max - r, e.min)),
    Cl(0, 1, t)
  )
}
function JX(n, e) {
  const t = {}
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  )
}
const _M = 0.35
function eq(n = _M) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = _M),
    { x: KP(n, 'left', 'right'), y: KP(n, 'top', 'bottom') }
  )
}
function KP(n, e, t) {
  return { min: QP(n, e), max: QP(n, t) }
}
function QP(n, e) {
  return typeof n == 'number' ? n : n[e] || 0
}
const JP = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  eh = () => ({ x: JP(), y: JP() }),
  eR = () => ({ min: 0, max: 0 }),
  Pi = () => ({ x: eR(), y: eR() })
function no(n) {
  return [n('x'), n('y')]
}
function $O({ top: n, left: e, right: t, bottom: i }) {
  return { x: { min: e, max: t }, y: { min: n, max: i } }
}
function tq({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min }
}
function nq(n, e) {
  if (!e) return n
  const t = e({ x: n.left, y: n.top }),
    i = e({ x: n.right, y: n.bottom })
  return { top: t.y, left: t.x, bottom: i.y, right: i.x }
}
function $w(n) {
  return n === void 0 || n === 1
}
function wM({ scale: n, scaleX: e, scaleY: t }) {
  return !$w(n) || !$w(e) || !$w(t)
}
function Wu(n) {
  return (
    wM(n) ||
    XO(n) ||
    n.z ||
    n.rotate ||
    n.rotateX ||
    n.rotateY ||
    n.skewX ||
    n.skewY
  )
}
function XO(n) {
  return tR(n.x) || tR(n.y)
}
function tR(n) {
  return n && n !== '0%'
}
function Cx(n, e, t) {
  const i = n - t,
    r = e * i
  return t + r
}
function nR(n, e, t, i, r) {
  return r !== void 0 && (n = Cx(n, r, i)), Cx(n, t, i) + e
}
function SM(n, e = 0, t = 1, i, r) {
  ;(n.min = nR(n.min, e, t, i, r)), (n.max = nR(n.max, e, t, i, r))
}
function qO(n, { x: e, y: t }) {
  SM(n.x, e.translate, e.scale, e.originPoint),
    SM(n.y, t.translate, t.scale, t.originPoint)
}
const iR = 0.999999999999,
  rR = 1.0000000000001
function iq(n, e, t, i = !1) {
  const r = t.length
  if (!r) return
  e.x = e.y = 1
  let s, o
  for (let a = 0; a < r; a++) {
    ;(s = t[a]), (o = s.projectionDelta)
    const { visualElement: c } = s.options
    ;(c && c.props.style && c.props.style.display === 'contents') ||
      (i &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        nh(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((e.x *= o.x.scale), (e.y *= o.y.scale), qO(n, o)),
      i && Wu(s.latestValues) && nh(n, s.latestValues))
  }
  e.x < rR && e.x > iR && (e.x = 1), e.y < rR && e.y > iR && (e.y = 1)
}
function th(n, e) {
  ;(n.min = n.min + e), (n.max = n.max + e)
}
function sR(n, e, t, i, r = 0.5) {
  const s = pi(n.min, n.max, r)
  SM(n, e, t, s, i)
}
function nh(n, e) {
  sR(n.x, e.x, e.scaleX, e.scale, e.originX),
    sR(n.y, e.y, e.scaleY, e.scale, e.originY)
}
function YO(n, e) {
  return $O(nq(n.getBoundingClientRect(), e))
}
function rq(n, e, t) {
  const i = YO(n, t),
    { scroll: r } = e
  return r && (th(i.x, r.offset.x), th(i.y, r.offset.y)), i
}
const ZO = ({ current: n }) => (n ? n.ownerDocument.defaultView : null),
  sq = new WeakMap()
let oq = class {
  constructor(e) {
    ;(this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Pi()),
      (this.visualElement = e)
  }
  start(e, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: i } = this.visualElement
    if (i && i.isPresent === !1) return
    const r = (h) => {
        const { dragSnapToOrigin: m } = this.getProps()
        m ? this.pauseAnimation() : this.stopAnimation(),
          t && this.snapToCursor(Qg(h).point)
      },
      s = (h, m) => {
        const { drag: g, dragPropagation: y, onDragStart: _ } = this.getProps()
        if (
          g &&
          !y &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = UX(g)),
          !this.openDragLock)
        )
          return
        ;(this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          no((w) => {
            let x = this.getAxisMotionValue(w).get() || 0
            if (wa.test(x)) {
              const { projection: T } = this.visualElement
              if (T && T.layout) {
                const A = T.layout.layoutBox[w]
                A && (x = Bs(A) * (parseFloat(x) / 100))
              }
            }
            this.originPoint[w] = x
          }),
          _ && Dn.postRender(() => _(h, m)),
          uM(this.visualElement, 'transform')
        const { animationState: M } = this.visualElement
        M && M.setActive('whileDrag', !0)
      },
      o = (h, m) => {
        const {
          dragPropagation: g,
          dragDirectionLock: y,
          onDirectionLock: _,
          onDrag: M,
        } = this.getProps()
        if (!g && !this.openDragLock) return
        const { offset: w } = m
        if (y && this.currentDirection === null) {
          ;(this.currentDirection = aq(w)),
            this.currentDirection !== null && _ && _(this.currentDirection)
          return
        }
        this.updateAxis('x', m.point, w),
          this.updateAxis('y', m.point, w),
          this.visualElement.render(),
          M && M(h, m)
      },
      a = (h, m) => this.stop(h, m),
      c = () =>
        no((h) => {
          var m
          return (
            this.getAnimationState(h) === 'paused' &&
            ((m = this.getAxisMotionValue(h).animation) === null || m === void 0
              ? void 0
              : m.play())
          )
        }),
      { dragSnapToOrigin: u } = this.getProps()
    this.panSession = new jO(
      e,
      {
        onSessionStart: r,
        onStart: s,
        onMove: o,
        onSessionEnd: a,
        resumeAnimation: c,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: u,
        contextWindow: ZO(this.visualElement),
      },
    )
  }
  stop(e, t) {
    const i = this.isDragging
    if ((this.cancel(), !i)) return
    const { velocity: r } = t
    this.startAnimation(r)
    const { onDragEnd: s } = this.getProps()
    s && Dn.postRender(() => s(e, t))
  }
  cancel() {
    this.isDragging = !1
    const { projection: e, animationState: t } = this.visualElement
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0)
    const { dragPropagation: i } = this.getProps()
    !i &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      t && t.setActive('whileDrag', !1)
  }
  updateAxis(e, t, i) {
    const { drag: r } = this.getProps()
    if (!i || !dy(e, r, this.currentDirection)) return
    const s = this.getAxisMotionValue(e)
    let o = this.originPoint[e] + i[e]
    this.constraints &&
      this.constraints[e] &&
      (o = YX(o, this.constraints[e], this.elastic[e])),
      s.set(o)
  }
  resolveConstraints() {
    var e
    const { dragConstraints: t, dragElastic: i } = this.getProps(),
      r =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (e = this.visualElement.projection) === null || e === void 0
          ? void 0
          : e.layout,
      s = this.constraints
    t && Jf(t)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : t && r
      ? (this.constraints = ZX(r.layoutBox, t))
      : (this.constraints = !1),
      (this.elastic = eq(i)),
      s !== this.constraints &&
        r &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        no((o) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(o) &&
            (this.constraints[o] = JX(r.layoutBox[o], this.constraints[o]))
        })
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps()
    if (!e || !Jf(e)) return !1
    const i = e.current,
      { projection: r } = this.visualElement
    if (!r || !r.layout) return !1
    const s = rq(i, r.root, this.visualElement.getTransformPagePoint())
    let o = KX(r.layout.layoutBox, s)
    if (t) {
      const a = t(tq(o))
      ;(this.hasMutatedConstraints = !!a), a && (o = $O(a))
    }
    return o
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a,
      } = this.getProps(),
      c = this.constraints || {},
      u = no((h) => {
        if (!dy(h, t, this.currentDirection)) return
        let m = c[h] || {}
        o && (m = { min: 0, max: 0 })
        const g = r ? 200 : 1e6,
          y = r ? 40 : 1e7,
          _ = {
            type: 'inertia',
            velocity: i ? e[h] : 0,
            bounceStiffness: g,
            bounceDamping: y,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...m,
          }
        return this.startAxisValueAnimation(h, _)
      })
    return Promise.all(u).then(a)
  }
  startAxisValueAnimation(e, t) {
    const i = this.getAxisMotionValue(e)
    return (
      uM(this.visualElement, e), i.start(Bb(e, i, 0, t, this.visualElement, !1))
    )
  }
  stopAnimation() {
    no((e) => this.getAxisMotionValue(e).stop())
  }
  pauseAnimation() {
    no((e) => {
      var t
      return (t = this.getAxisMotionValue(e).animation) === null || t === void 0
        ? void 0
        : t.pause()
    })
  }
  getAnimationState(e) {
    var t
    return (t = this.getAxisMotionValue(e).animation) === null || t === void 0
      ? void 0
      : t.state
  }
  getAxisMotionValue(e) {
    const t = `_drag${e.toUpperCase()}`,
      i = this.visualElement.getProps(),
      r = i[t]
    return (
      r ||
      this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    )
  }
  snapToCursor(e) {
    no((t) => {
      const { drag: i } = this.getProps()
      if (!dy(t, i, this.currentDirection)) return
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(t)
      if (r && r.layout) {
        const { min: o, max: a } = r.layout.layoutBox[t]
        s.set(e[t] - pi(o, a, 0.5))
      }
    })
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: i } = this.visualElement
    if (!Jf(t) || !i || !this.constraints) return
    this.stopAnimation()
    const r = { x: 0, y: 0 }
    no((o) => {
      const a = this.getAxisMotionValue(o)
      if (a && this.constraints !== !1) {
        const c = a.get()
        r[o] = QX({ min: c, max: c }, this.constraints[o])
      }
    })
    const { transformTemplate: s } = this.visualElement.getProps()
    ;(this.visualElement.current.style.transform = s ? s({}, '') : 'none'),
      i.root && i.root.updateScroll(),
      i.updateLayout(),
      this.resolveConstraints(),
      no((o) => {
        if (!dy(o, e, null)) return
        const a = this.getAxisMotionValue(o),
          { min: c, max: u } = this.constraints[o]
        a.set(pi(c, u, r[o]))
      })
  }
  addListeners() {
    if (!this.visualElement.current) return
    sq.set(this.visualElement, this)
    const e = this.visualElement.current,
      t = Im(e, 'pointerdown', (c) => {
        const { drag: u, dragListener: h = !0 } = this.getProps()
        u && h && this.start(c)
      }),
      i = () => {
        const { dragConstraints: c } = this.getProps()
        Jf(c) && c.current && (this.constraints = this.resolveRefConstraints())
      },
      { projection: r } = this.visualElement,
      s = r.addEventListener('measure', i)
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()),
      Dn.read(i)
    const o = mg(window, 'resize', () => this.scalePositionWithinConstraints()),
      a = r.addEventListener(
        'didUpdate',
        ({ delta: c, hasLayoutChanged: u }) => {
          this.isDragging &&
            u &&
            (no((h) => {
              const m = this.getAxisMotionValue(h)
              m &&
                ((this.originPoint[h] += c[h].translate),
                m.set(m.get() + c[h].translate))
            }),
            this.visualElement.render())
        },
      )
    return () => {
      o(), t(), s(), a && a()
    }
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: i = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: o = _M,
        dragMomentum: a = !0,
      } = e
    return {
      ...e,
      drag: t,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a,
    }
  }
}
function dy(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n)
}
function aq(n, e = 10) {
  let t = null
  return Math.abs(n.y) > e ? (t = 'y') : Math.abs(n.x) > e && (t = 'x'), t
}
let lq = class extends zc {
  constructor(e) {
    super(e),
      (this.removeGroupControls = es),
      (this.removeListeners = es),
      (this.controls = new oq(e))
  }
  mount() {
    const { dragControls: e } = this.node.getProps()
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || es)
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners()
  }
}
const oR = (n) => (e, t) => {
  n && Dn.postRender(() => n(e, t))
}
let cq = class extends zc {
  constructor() {
    super(...arguments), (this.removePointerDownListener = es)
  }
  onPointerDown(e) {
    this.session = new jO(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: ZO(this.node),
    })
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: i,
      onPanEnd: r,
    } = this.node.getProps()
    return {
      onSessionStart: oR(e),
      onStart: oR(t),
      onMove: i,
      onEnd: (s, o) => {
        delete this.session, r && Dn.postRender(() => r(s, o))
      },
    }
  }
  mount() {
    this.removePointerDownListener = Im(this.node.current, 'pointerdown', (e) =>
      this.onPointerDown(e),
    )
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end()
  }
}
const Vb = X.createContext(null)
function uq() {
  const n = X.useContext(Vb)
  if (n === null) return [!0, null]
  const { isPresent: e, onExitComplete: t, register: i } = n,
    r = X.useId()
  X.useEffect(() => i(r), [])
  const s = X.useCallback(() => t && t(r), [r, t])
  return !e && t ? [!1, s] : [!0]
}
const KO = X.createContext({}),
  QO = X.createContext({}),
  Ey = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }
function aR(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100
}
const em = {
    correct: (n, e) => {
      if (!e.target) return n
      if (typeof n == 'string')
        if (Yt.test(n)) n = parseFloat(n)
        else return n
      const t = aR(n, e.target.x),
        i = aR(n, e.target.y)
      return `${t}% ${i}%`
    },
  },
  dq = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const i = n,
        r = Lc.parse(n)
      if (r.length > 5) return i
      const s = Lc.createTransformer(n),
        o = typeof r[0] != 'number' ? 1 : 0,
        a = t.x.scale * e.x,
        c = t.y.scale * e.y
      ;(r[0 + o] /= a), (r[1 + o] /= c)
      const u = pi(a, c, 0.5)
      return (
        typeof r[2 + o] == 'number' && (r[2 + o] /= u),
        typeof r[3 + o] == 'number' && (r[3 + o] /= u),
        s(r)
      )
    },
  },
  Px = {}
function fq(n) {
  Object.assign(Px, n)
}
const { schedule: jb, cancel: One } = JD(queueMicrotask, !1)
let hq = class extends X.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
        layoutId: r,
      } = this.props,
      { projection: s } = e
    fq(pq),
      s &&
        (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener('animationComplete', () => {
          this.safeToRemove()
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Ey.hasEverUpdated = !0)
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: i,
        drag: r,
        isPresent: s,
      } = this.props,
      o = i.projection
    return (
      o &&
        ((o.isPresent = s),
        r || e.layoutDependency !== t || t === void 0
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              Dn.postRender(() => {
                const a = o.getStack()
                ;(!a || !a.members.length) && this.safeToRemove()
              }))),
      null
    )
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement
    e &&
      (e.root.didUpdate(),
      jb.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove()
      }))
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
      } = this.props,
      { projection: r } = e
    r &&
      (r.scheduleCheckAfterUnmount(),
      t && t.group && t.group.remove(r),
      i && i.deregister && i.deregister(r))
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props
    e && e()
  }
  render() {
    return null
  }
}
function JO(n) {
  const [e, t] = uq(),
    i = X.useContext(KO)
  return b.jsx(hq, {
    ...n,
    layoutGroup: i,
    switchLayoutGroup: X.useContext(QO),
    isPresent: e,
    safeToRemove: t,
  })
}
const pq = {
  borderRadius: {
    ...em,
    applyTo: [
      'borderTopLeftRadius',
      'borderTopRightRadius',
      'borderBottomLeftRadius',
      'borderBottomRightRadius',
    ],
  },
  borderTopLeftRadius: em,
  borderTopRightRadius: em,
  borderBottomLeftRadius: em,
  borderBottomRightRadius: em,
  boxShadow: dq,
}
function mq(n, e, t) {
  const i = Lr(n) ? n : ga(n)
  return i.start(Bb('', i, e, t)), i.animation
}
function gq(n) {
  return n instanceof SVGElement && n.tagName !== 'svg'
}
const vq = (n, e) => n.depth - e.depth
let yq = class {
  constructor() {
    ;(this.children = []), (this.isDirty = !1)
  }
  add(e) {
    _b(this.children, e), (this.isDirty = !0)
  }
  remove(e) {
    wb(this.children, e), (this.isDirty = !0)
  }
  forEach(e) {
    this.isDirty && this.children.sort(vq),
      (this.isDirty = !1),
      this.children.forEach(e)
  }
}
function xq(n, e) {
  const t = _a.now(),
    i = ({ timestamp: r }) => {
      const s = r - t
      s >= e && (qo(i), n(s - e))
    }
  return Dn.read(i, !0), () => qo(i)
}
function by(n) {
  const e = Lr(n) ? n.get() : n
  return U7(e) ? e.toValue() : e
}
const ek = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'],
  _q = ek.length,
  lR = (n) => (typeof n == 'string' ? parseFloat(n) : n),
  cR = (n) => typeof n == 'number' || Yt.test(n)
function wq(n, e, t, i, r, s) {
  r
    ? ((n.opacity = pi(0, t.opacity !== void 0 ? t.opacity : 1, Sq(i))),
      (n.opacityExit = pi(e.opacity !== void 0 ? e.opacity : 1, 0, Mq(i))))
    : s &&
      (n.opacity = pi(
        e.opacity !== void 0 ? e.opacity : 1,
        t.opacity !== void 0 ? t.opacity : 1,
        i,
      ))
  for (let o = 0; o < _q; o++) {
    const a = `border${ek[o]}Radius`
    let c = uR(e, a),
      u = uR(t, a)
    if (c === void 0 && u === void 0) continue
    c || (c = 0),
      u || (u = 0),
      c === 0 || u === 0 || cR(c) === cR(u)
        ? ((n[a] = Math.max(pi(lR(c), lR(u), i), 0)),
          (wa.test(u) || wa.test(c)) && (n[a] += '%'))
        : (n[a] = u)
  }
  ;(e.rotate || t.rotate) && (n.rotate = pi(e.rotate || 0, t.rotate || 0, i))
}
function uR(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius
}
const Sq = tk(0, 0.5, fO),
  Mq = tk(0.5, 0.95, es)
function tk(n, e, t) {
  return (i) => (i < n ? 0 : i > e ? 1 : t(xd(n, e, i)))
}
function dR(n, e) {
  ;(n.min = e.min), (n.max = e.max)
}
function eo(n, e) {
  dR(n.x, e.x), dR(n.y, e.y)
}
function fR(n, e) {
  ;(n.translate = e.translate),
    (n.scale = e.scale),
    (n.originPoint = e.originPoint),
    (n.origin = e.origin)
}
function hR(n, e, t, i, r) {
  return (
    (n -= e), (n = Cx(n, 1 / t, i)), r !== void 0 && (n = Cx(n, 1 / r, i)), n
  )
}
function Eq(n, e = 0, t = 1, i = 0.5, r, s = n, o = n) {
  if (
    (wa.test(e) &&
      ((e = parseFloat(e)), (e = pi(o.min, o.max, e / 100) - o.min)),
    typeof e != 'number')
  )
    return
  let a = pi(s.min, s.max, i)
  n === s && (a -= e),
    (n.min = hR(n.min, e, t, a, r)),
    (n.max = hR(n.max, e, t, a, r))
}
function pR(n, e, [t, i, r], s, o) {
  Eq(n, e[t], e[i], e[r], e.scale, s, o)
}
const bq = ['x', 'scaleX', 'originX'],
  Tq = ['y', 'scaleY', 'originY']
function mR(n, e, t, i) {
  pR(n.x, e, bq, t ? t.x : void 0, i ? i.x : void 0),
    pR(n.y, e, Tq, t ? t.y : void 0, i ? i.y : void 0)
}
function gR(n) {
  return n.translate === 0 && n.scale === 1
}
function nk(n) {
  return gR(n.x) && gR(n.y)
}
function vR(n, e) {
  return n.min === e.min && n.max === e.max
}
function Aq(n, e) {
  return vR(n.x, e.x) && vR(n.y, e.y)
}
function yR(n, e) {
  return (
    Math.round(n.min) === Math.round(e.min) &&
    Math.round(n.max) === Math.round(e.max)
  )
}
function ik(n, e) {
  return yR(n.x, e.x) && yR(n.y, e.y)
}
function xR(n) {
  return Bs(n.x) / Bs(n.y)
}
function _R(n, e) {
  return (
    n.translate === e.translate &&
    n.scale === e.scale &&
    n.originPoint === e.originPoint
  )
}
let Cq = class {
  constructor() {
    this.members = []
  }
  add(e) {
    _b(this.members, e), e.scheduleRender()
  }
  remove(e) {
    if (
      (wb(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1]
      t && this.promote(t)
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r)
    if (t === 0) return !1
    let i
    for (let r = t; r >= 0; r--) {
      const s = this.members[r]
      if (s.isPresent !== !1) {
        i = s
        break
      }
    }
    return i ? (this.promote(i), !0) : !1
  }
  promote(e, t) {
    const i = this.lead
    if (e !== i && ((this.prevLead = i), (this.lead = e), e.show(), i)) {
      i.instance && i.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = i),
        t && (e.resumeFrom.preserveOpacity = !0),
        i.snapshot &&
          ((e.snapshot = i.snapshot),
          (e.snapshot.latestValues = i.animationValues || i.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0)
      const { crossfade: r } = e.options
      r === !1 && i.hide()
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: i } = e
      t.onExitComplete && t.onExitComplete(),
        i && i.options.onExitComplete && i.options.onExitComplete()
    })
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1)
    })
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}
function Pq(n, e, t) {
  let i = ''
  const r = n.x.translate / e.x,
    s = n.y.translate / e.y,
    o = (t == null ? void 0 : t.z) || 0
  if (
    ((r || s || o) && (i = `translate3d(${r}px, ${s}px, ${o}px) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const {
      transformPerspective: u,
      rotate: h,
      rotateX: m,
      rotateY: g,
      skewX: y,
      skewY: _,
    } = t
    u && (i = `perspective(${u}px) ${i}`),
      h && (i += `rotate(${h}deg) `),
      m && (i += `rotateX(${m}deg) `),
      g && (i += `rotateY(${g}deg) `),
      y && (i += `skewX(${y}deg) `),
      _ && (i += `skewY(${_}deg) `)
  }
  const a = n.x.scale * e.x,
    c = n.y.scale * e.y
  return (a !== 1 || c !== 1) && (i += `scale(${a}, ${c})`), i || 'none'
}
const $u = {
    type: 'projectionFrame',
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0,
  },
  cm = typeof window < 'u' && window.MotionDebug !== void 0,
  Xw = ['', 'X', 'Y', 'Z'],
  Rq = { visibility: 'hidden' },
  wR = 1e3
let Iq = 0
function qw(n, e, t, i) {
  const { latestValues: r } = e
  r[n] && ((t[n] = r[n]), e.setStaticValue(n, 0), i && (i[n] = 0))
}
function rk(n) {
  if (((n.hasCheckedOptimisedAppear = !0), n.root === n)) return
  const { visualElement: e } = n.options
  if (!e) return
  const t = tO(e)
  if (window.MotionHasOptimisedAnimation(t, 'transform')) {
    const { layout: r, layoutId: s } = n.options
    window.MotionCancelOptimisedAnimation(t, 'transform', Dn, !(r || s))
  }
  const { parent: i } = n
  i && !i.hasCheckedOptimisedAppear && rk(i)
}
function sk({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: i,
  resetTransform: r,
}) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      ;(this.id = Iq++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots())
        }),
        (this.updateProjection = () => {
          ;(this.projectionUpdateScheduled = !1),
            cm &&
              ($u.totalNodes =
                $u.resolvedTargetDeltas =
                $u.recalculatedProjection =
                  0),
            this.nodes.forEach(Dq),
            this.nodes.forEach(Bq),
            this.nodes.forEach(zq),
            this.nodes.forEach(Oq),
            cm && window.MotionDebug.record($u)
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = o),
        (this.root = a ? a.root || a : this),
        (this.path = a ? [...a.path, a] : []),
        (this.parent = a),
        (this.depth = a ? a.depth + 1 : 0)
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0
      this.root === this && (this.nodes = new yq())
    }
    addEventListener(o, a) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new Sb()),
        this.eventHandlers.get(o).add(a)
      )
    }
    notifyListeners(o, ...a) {
      const c = this.eventHandlers.get(o)
      c && c.notify(...a)
    }
    hasListeners(o) {
      return this.eventHandlers.has(o)
    }
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance) return
      ;(this.isSVG = gq(o)), (this.instance = o)
      const { layoutId: c, layout: u, visualElement: h } = this.options
      if (
        (h && !h.current && h.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        a && (u || c) && (this.isLayoutDirty = !0),
        n)
      ) {
        let m
        const g = () => (this.root.updateBlockedByResize = !1)
        n(o, () => {
          ;(this.root.updateBlockedByResize = !0),
            m && m(),
            (m = xq(g, 250)),
            Ey.hasAnimatedSinceResize &&
              ((Ey.hasAnimatedSinceResize = !1), this.nodes.forEach(MR))
        })
      }
      c && this.root.registerSharedNode(c, this),
        this.options.animate !== !1 &&
          h &&
          (c || u) &&
          this.addEventListener(
            'didUpdate',
            ({
              delta: m,
              hasLayoutChanged: g,
              hasRelativeTargetChanged: y,
              layout: _,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                ;(this.target = void 0), (this.relativeTarget = void 0)
                return
              }
              const M =
                  this.options.transition || h.getDefaultTransition() || Wq,
                { onLayoutAnimationStart: w, onLayoutAnimationComplete: x } =
                  h.getProps(),
                T = !this.targetLayout || !ik(this.targetLayout, _) || y,
                A = !g && y
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                A ||
                (g && (T || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(m, A)
                const P = { ...xb(M, 'layout'), onPlay: w, onComplete: x }
                ;(h.shouldReduceMotion || this.options.layoutRoot) &&
                  ((P.delay = 0), (P.type = !1)),
                  this.startAnimation(P)
              } else
                g || MR(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete()
              this.targetLayout = _
            },
          )
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this)
      const o = this.getStack()
      o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        qo(this.updateProjection)
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      )
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(Vq),
        this.animationId++)
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options
      return o && o.getProps().transformTemplate
    }
    willUpdate(o = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete()
        return
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          rk(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return
      this.isLayoutDirty = !0
      for (let h = 0; h < this.path.length; h++) {
        const m = this.path[h]
        ;(m.shouldResetTransform = !0),
          m.updateScroll('snapshot'),
          m.options.layoutRoot && m.willUpdate(!1)
      }
      const { layoutId: a, layout: c } = this.options
      if (a === void 0 && !c) return
      const u = this.getTransformTemplate()
      ;(this.prevTransformTemplateValue = u
        ? u(this.latestValues, '')
        : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners('willUpdate')
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(SR)
        return
      }
      this.isUpdating || this.nodes.forEach(Fq),
        (this.isUpdating = !1),
        this.nodes.forEach(Uq),
        this.nodes.forEach(Lq),
        this.nodes.forEach(Nq),
        this.clearAllSnapshots()
      const a = _a.now()
      ;(rr.delta = Cl(0, 1e3 / 60, a - rr.timestamp)),
        (rr.timestamp = a),
        (rr.isProcessing = !0),
        Bw.update.process(rr),
        Bw.preRender.process(rr),
        Bw.render.process(rr),
        (rr.isProcessing = !1)
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), jb.read(this.scheduleUpdate))
    }
    clearAllSnapshots() {
      this.nodes.forEach(kq), this.sharedNodes.forEach(jq)
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        Dn.preRender(this.updateProjection, !1, !0))
    }
    scheduleCheckAfterUnmount() {
      Dn.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed()
      })
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure())
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++) this.path[c].updateScroll()
      const o = this.layout
      ;(this.layout = this.measure(!1)),
        (this.layoutCorrected = Pi()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners('measure', this.layout.layoutBox)
      const { visualElement: a } = this.options
      a &&
        a.notify(
          'LayoutMeasure',
          this.layout.layoutBox,
          o ? o.layoutBox : void 0,
        )
    }
    updateScroll(o = 'measure') {
      let a = !!(this.options.layoutScroll && this.instance)
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === o &&
          (a = !1),
        a)
      ) {
        const c = i(this.instance)
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: c,
          offset: t(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : c,
        }
      }
    }
    resetTransform() {
      if (!r) return
      const o =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        a = this.projectionDelta && !nk(this.projectionDelta),
        c = this.getTransformTemplate(),
        u = c ? c(this.latestValues, '') : void 0,
        h = u !== this.prevTransformTemplateValue
      o &&
        (a || Wu(this.latestValues) || h) &&
        (r(this.instance, u),
        (this.shouldResetTransform = !1),
        this.scheduleRender())
    }
    measure(o = !0) {
      const a = this.measurePageBox()
      let c = this.removeElementScroll(a)
      return (
        o && (c = this.removeTransform(c)),
        $q(c),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: c,
          latestValues: {},
          source: this.id,
        }
      )
    }
    measurePageBox() {
      var o
      const { visualElement: a } = this.options
      if (!a) return Pi()
      const c = a.measureViewportBox()
      if (
        !(
          ((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) ||
          this.path.some(Xq)
        )
      ) {
        const { scroll: h } = this.root
        h && (th(c.x, h.offset.x), th(c.y, h.offset.y))
      }
      return c
    }
    removeElementScroll(o) {
      var a
      const c = Pi()
      if (
        (eo(c, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
      )
        return c
      for (let u = 0; u < this.path.length; u++) {
        const h = this.path[u],
          { scroll: m, options: g } = h
        h !== this.root &&
          m &&
          g.layoutScroll &&
          (m.wasRoot && eo(c, o), th(c.x, m.offset.x), th(c.y, m.offset.y))
      }
      return c
    }
    applyTransform(o, a = !1) {
      const c = Pi()
      eo(c, o)
      for (let u = 0; u < this.path.length; u++) {
        const h = this.path[u]
        !a &&
          h.options.layoutScroll &&
          h.scroll &&
          h !== h.root &&
          nh(c, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }),
          Wu(h.latestValues) && nh(c, h.latestValues)
      }
      return Wu(this.latestValues) && nh(c, this.latestValues), c
    }
    removeTransform(o) {
      const a = Pi()
      eo(a, o)
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c]
        if (!u.instance || !Wu(u.latestValues)) continue
        wM(u.latestValues) && u.updateSnapshot()
        const h = Pi(),
          m = u.measurePageBox()
        eo(h, m),
          mR(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, h)
      }
      return Wu(this.latestValues) && mR(a, this.latestValues), a
    }
    setTargetDelta(o) {
      ;(this.targetDelta = o),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0)
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0,
      }
    }
    clearMeasurements() {
      ;(this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1)
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== rr.timestamp &&
        this.relativeParent.resolveTargetDelta(!0)
    }
    resolveTargetDelta(o = !1) {
      var a
      const c = this.getLead()
      this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = c.isSharedProjectionDirty)
      const u = !!this.resumingFrom || this !== c
      if (
        !(
          o ||
          (u && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((a = this.parent) === null || a === void 0) &&
            a.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return
      const { layout: m, layoutId: g } = this.options
      if (!(!this.layout || !(m || g))) {
        if (
          ((this.resolvedRelativeTargetAt = rr.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const y = this.getClosestProjectingParent()
          y && y.layout && this.animationProgress !== 1
            ? ((this.relativeParent = y),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Pi()),
              (this.relativeTargetOrigin = Pi()),
              Nm(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                y.layout.layoutBox,
              ),
              eo(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = Pi()), (this.targetWithTransforms = Pi())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                qX(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target,
                ))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : eo(this.target, this.layout.layoutBox),
                qO(this.target, this.targetDelta))
              : eo(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1
            const y = this.getClosestProjectingParent()
            y &&
            !!y.resumingFrom == !!this.resumingFrom &&
            !y.options.layoutScroll &&
            y.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = y),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = Pi()),
                (this.relativeTargetOrigin = Pi()),
                Nm(this.relativeTargetOrigin, this.target, y.target),
                eo(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0)
          }
          cm && $u.resolvedTargetDeltas++
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          wM(this.parent.latestValues) ||
          XO(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent()
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      )
    }
    calcProjection() {
      var o
      const a = this.getLead(),
        c = !!this.resumingFrom || this !== a
      let u = !0
      if (
        ((this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) &&
            o.isProjectionDirty)) &&
          (u = !1),
        c &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (u = !1),
        this.resolvedRelativeTargetAt === rr.timestamp && (u = !1),
        u)
      )
        return
      const { layout: h, layoutId: m } = this.options
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(h || m))
      )
        return
      eo(this.layoutCorrected, this.layout.layoutBox)
      const g = this.treeScale.x,
        y = this.treeScale.y
      iq(this.layoutCorrected, this.treeScale, this.path, c),
        a.layout &&
          !a.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((a.target = a.layout.layoutBox), (a.targetWithTransforms = Pi()))
      const { target: _ } = a
      if (!_) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender())
        return
      }
      !this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (fR(this.prevProjectionDelta.x, this.projectionDelta.x),
          fR(this.prevProjectionDelta.y, this.projectionDelta.y)),
        Lm(this.projectionDelta, this.layoutCorrected, _, this.latestValues),
        (this.treeScale.x !== g ||
          this.treeScale.y !== y ||
          !_R(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !_R(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners('projectionUpdate', _)),
        cm && $u.recalculatedProjection++
    }
    hide() {
      this.isVisible = !1
    }
    show() {
      this.isVisible = !0
    }
    scheduleRender(o = !0) {
      var a
      if (
        ((a = this.options.visualElement) === null ||
          a === void 0 ||
          a.scheduleRender(),
        o)
      ) {
        const c = this.getStack()
        c && c.scheduleRender()
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0)
    }
    createProjectionDeltas() {
      ;(this.prevProjectionDelta = eh()),
        (this.projectionDelta = eh()),
        (this.projectionDeltaWithTransform = eh())
    }
    setAnimationOrigin(o, a = !1) {
      const c = this.snapshot,
        u = c ? c.latestValues : {},
        h = { ...this.latestValues },
        m = eh()
      ;(!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a)
      const g = Pi(),
        y = c ? c.source : void 0,
        _ = this.layout ? this.layout.source : void 0,
        M = y !== _,
        w = this.getStack(),
        x = !w || w.members.length <= 1,
        T = !!(M && !x && this.options.crossfade === !0 && !this.path.some(Gq))
      this.animationProgress = 0
      let A
      ;(this.mixTargetDelta = (P) => {
        const D = P / 1e3
        ER(m.x, o.x, D),
          ER(m.y, o.y, D),
          this.setTargetDelta(m),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Nm(g, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            Hq(this.relativeTarget, this.relativeTargetOrigin, g, D),
            A && Aq(this.relativeTarget, A) && (this.isProjectionDirty = !1),
            A || (A = Pi()),
            eo(A, this.relativeTarget)),
          M &&
            ((this.animationValues = h), wq(h, u, this.latestValues, D, T, x)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = D)
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
    }
    startAnimation(o) {
      this.notifyListeners('animationStart'),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (qo(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = Dn.update(() => {
          ;(Ey.hasAnimatedSinceResize = !0),
            (this.currentAnimation = mq(0, wR, {
              ...o,
              onUpdate: (a) => {
                this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a)
              },
              onComplete: () => {
                o.onComplete && o.onComplete(), this.completeAnimation()
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0)
        }))
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0))
      const o = this.getStack()
      o && o.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners('animationComplete')
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(wR),
        this.currentAnimation.stop()),
        this.completeAnimation()
    }
    applyTransformsToTarget() {
      const o = this.getLead()
      let { targetWithTransforms: a, target: c, layout: u, latestValues: h } = o
      if (!(!a || !c || !u)) {
        if (
          this !== o &&
          this.layout &&
          u &&
          ok(this.options.animationType, this.layout.layoutBox, u.layoutBox)
        ) {
          c = this.target || Pi()
          const m = Bs(this.layout.layoutBox.x)
          ;(c.x.min = o.target.x.min), (c.x.max = c.x.min + m)
          const g = Bs(this.layout.layoutBox.y)
          ;(c.y.min = o.target.y.min), (c.y.max = c.y.min + g)
        }
        eo(a, c),
          nh(a, h),
          Lm(this.projectionDeltaWithTransform, this.layoutCorrected, a, h)
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new Cq()),
        this.sharedNodes.get(o).add(a)
      const u = a.options.initialPromotionConfig
      a.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity:
          u && u.shouldPreserveFollowOpacity
            ? u.shouldPreserveFollowOpacity(a)
            : void 0,
      })
    }
    isLead() {
      const o = this.getStack()
      return o ? o.lead === this : !0
    }
    getLead() {
      var o
      const { layoutId: a } = this.options
      return a
        ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) ||
            this
        : this
    }
    getPrevLead() {
      var o
      const { layoutId: a } = this.options
      return a
        ? (o = this.getStack()) === null || o === void 0
          ? void 0
          : o.prevLead
        : void 0
    }
    getStack() {
      const { layoutId: o } = this.options
      if (o) return this.root.sharedNodes.get(o)
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: c } = {}) {
      const u = this.getStack()
      u && u.promote(this, c),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a })
    }
    relegate() {
      const o = this.getStack()
      return o ? o.relegate(this) : !1
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options
      if (!o) return
      let a = !1
      const { latestValues: c } = o
      if (
        ((c.z ||
          c.rotate ||
          c.rotateX ||
          c.rotateY ||
          c.rotateZ ||
          c.skewX ||
          c.skewY) &&
          (a = !0),
        !a)
      )
        return
      const u = {}
      c.z && qw('z', o, u, this.animationValues)
      for (let h = 0; h < Xw.length; h++)
        qw(`rotate${Xw[h]}`, o, u, this.animationValues),
          qw(`skew${Xw[h]}`, o, u, this.animationValues)
      o.render()
      for (const h in u)
        o.setStaticValue(h, u[h]),
          this.animationValues && (this.animationValues[h] = u[h])
      o.scheduleRender()
    }
    getProjectionStyles(o) {
      var a, c
      if (!this.instance || this.isSVG) return
      if (!this.isVisible) return Rq
      const u = { visibility: '' },
        h = this.getTransformTemplate()
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (u.opacity = ''),
          (u.pointerEvents = by(o == null ? void 0 : o.pointerEvents) || ''),
          (u.transform = h ? h(this.latestValues, '') : 'none'),
          u
        )
      const m = this.getLead()
      if (!this.projectionDelta || !this.layout || !m.target) {
        const M = {}
        return (
          this.options.layoutId &&
            ((M.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (M.pointerEvents = by(o == null ? void 0 : o.pointerEvents) || '')),
          this.hasProjected &&
            !Wu(this.latestValues) &&
            ((M.transform = h ? h({}, '') : 'none'), (this.hasProjected = !1)),
          M
        )
      }
      const g = m.animationValues || m.latestValues
      this.applyTransformsToTarget(),
        (u.transform = Pq(
          this.projectionDeltaWithTransform,
          this.treeScale,
          g,
        )),
        h && (u.transform = h(g, u.transform))
      const { x: y, y: _ } = this.projectionDelta
      ;(u.transformOrigin = `${y.origin * 100}% ${_.origin * 100}% 0`),
        m.animationValues
          ? (u.opacity =
              m === this
                ? (c =
                    (a = g.opacity) !== null && a !== void 0
                      ? a
                      : this.latestValues.opacity) !== null && c !== void 0
                  ? c
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : g.opacityExit)
          : (u.opacity =
              m === this
                ? g.opacity !== void 0
                  ? g.opacity
                  : ''
                : g.opacityExit !== void 0
                ? g.opacityExit
                : 0)
      for (const M in Px) {
        if (g[M] === void 0) continue
        const { correct: w, applyTo: x } = Px[M],
          T = u.transform === 'none' ? g[M] : w(g[M], m)
        if (x) {
          const A = x.length
          for (let P = 0; P < A; P++) u[x[P]] = T
        } else u[M] = T
      }
      return (
        this.options.layoutId &&
          (u.pointerEvents =
            m === this
              ? by(o == null ? void 0 : o.pointerEvents) || ''
              : 'none'),
        u
      )
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0
    }
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a
        return (a = o.currentAnimation) === null || a === void 0
          ? void 0
          : a.stop()
      }),
        this.root.nodes.forEach(SR),
        this.root.sharedNodes.clear()
    }
  }
}
function Lq(n) {
  n.updateLayout()
}
function Nq(n) {
  var e
  const t =
    ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    n.snapshot
  if (n.isLead() && n.layout && t && n.hasListeners('didUpdate')) {
    const { layoutBox: i, measuredBox: r } = n.layout,
      { animationType: s } = n.options,
      o = t.source !== n.layout.source
    s === 'size'
      ? no((m) => {
          const g = o ? t.measuredBox[m] : t.layoutBox[m],
            y = Bs(g)
          ;(g.min = i[m].min), (g.max = g.min + y)
        })
      : ok(s, t.layoutBox, i) &&
        no((m) => {
          const g = o ? t.measuredBox[m] : t.layoutBox[m],
            y = Bs(i[m])
          ;(g.max = g.min + y),
            n.relativeTarget &&
              !n.currentAnimation &&
              ((n.isProjectionDirty = !0),
              (n.relativeTarget[m].max = n.relativeTarget[m].min + y))
        })
    const a = eh()
    Lm(a, i, t.layoutBox)
    const c = eh()
    o ? Lm(c, n.applyTransform(r, !0), t.measuredBox) : Lm(c, i, t.layoutBox)
    const u = !nk(a)
    let h = !1
    if (!n.resumeFrom) {
      const m = n.getClosestProjectingParent()
      if (m && !m.resumeFrom) {
        const { snapshot: g, layout: y } = m
        if (g && y) {
          const _ = Pi()
          Nm(_, t.layoutBox, g.layoutBox)
          const M = Pi()
          Nm(M, i, y.layoutBox),
            ik(_, M) || (h = !0),
            m.options.layoutRoot &&
              ((n.relativeTarget = M),
              (n.relativeTargetOrigin = _),
              (n.relativeParent = m))
        }
      }
    }
    n.notifyListeners('didUpdate', {
      layout: i,
      snapshot: t,
      delta: c,
      layoutDelta: a,
      hasLayoutChanged: u,
      hasRelativeTargetChanged: h,
    })
  } else if (n.isLead()) {
    const { onExitComplete: i } = n.options
    i && i()
  }
  n.options.transition = void 0
}
function Dq(n) {
  cm && $u.totalNodes++,
    n.parent &&
      (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
      n.isSharedProjectionDirty ||
        (n.isSharedProjectionDirty = !!(
          n.isProjectionDirty ||
          n.parent.isProjectionDirty ||
          n.parent.isSharedProjectionDirty
        )),
      n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty))
}
function Oq(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1
}
function kq(n) {
  n.clearSnapshot()
}
function SR(n) {
  n.clearMeasurements()
}
function Fq(n) {
  n.isLayoutDirty = !1
}
function Uq(n) {
  const { visualElement: e } = n.options
  e && e.getProps().onBeforeLayoutMeasure && e.notify('BeforeLayoutMeasure'),
    n.resetTransform()
}
function MR(n) {
  n.finishAnimation(),
    (n.targetDelta = n.relativeTarget = n.target = void 0),
    (n.isProjectionDirty = !0)
}
function Bq(n) {
  n.resolveTargetDelta()
}
function zq(n) {
  n.calcProjection()
}
function Vq(n) {
  n.resetSkewAndRotation()
}
function jq(n) {
  n.removeLeadSnapshot()
}
function ER(n, e, t) {
  ;(n.translate = pi(e.translate, 0, t)),
    (n.scale = pi(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint)
}
function bR(n, e, t, i) {
  ;(n.min = pi(e.min, t.min, i)), (n.max = pi(e.max, t.max, i))
}
function Hq(n, e, t, i) {
  bR(n.x, e.x, t.x, i), bR(n.y, e.y, t.y, i)
}
function Gq(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0
}
const Wq = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  TR = (n) =>
    typeof navigator < 'u' &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(n),
  AR = TR('applewebkit/') && !TR('chrome/') ? Math.round : es
function CR(n) {
  ;(n.min = AR(n.min)), (n.max = AR(n.max))
}
function $q(n) {
  CR(n.x), CR(n.y)
}
function ok(n, e, t) {
  return n === 'position' || (n === 'preserve-aspect' && !XX(xR(e), xR(t), 0.2))
}
function Xq(n) {
  var e
  return (
    n !== n.root &&
    ((e = n.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
  )
}
const qq = sk({
    attachResizeListener: (n, e) => mg(n, 'resize', e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  Yw = { current: void 0 },
  ak = sk({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!Yw.current) {
        const n = new qq({})
        n.mount(window), n.setOptions({ layoutScroll: !0 }), (Yw.current = n)
      }
      return Yw.current
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : 'none'
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === 'fixed',
  }),
  Yq = {
    pan: { Feature: cq },
    drag: { Feature: lq, ProjectionNode: ak, MeasureLayout: JO },
  }
function Hb(n, e, t) {
  var i
  if (n instanceof Element) return [n]
  if (typeof n == 'string') {
    let r = document
    const s = (i = void 0) !== null && i !== void 0 ? i : r.querySelectorAll(n)
    return s ? Array.from(s) : []
  }
  return Array.from(n)
}
function lk(n, e) {
  const t = Hb(n),
    i = new AbortController(),
    r = { passive: !0, ...e, signal: i.signal }
  return [t, r, () => i.abort()]
}
function PR(n) {
  return (e) => {
    e.pointerType === 'touch' || VO() || n(e)
  }
}
function Zq(n, e, t = {}) {
  const [i, r, s] = lk(n, t),
    o = PR((a) => {
      const { target: c } = a,
        u = e(a)
      if (!u || !c) return
      const h = PR((m) => {
        u(m), c.removeEventListener('pointerleave', h)
      })
      c.addEventListener('pointerleave', h, r)
    })
  return (
    i.forEach((a) => {
      a.addEventListener('pointerenter', o, r)
    }),
    s
  )
}
function RR(n, e, t) {
  const { props: i } = n
  n.animationState &&
    i.whileHover &&
    n.animationState.setActive('whileHover', t === 'Start')
  const r = 'onHover' + t,
    s = i[r]
  s && Dn.postRender(() => s(e, Qg(e)))
}
let Kq = class extends zc {
    mount() {
      const { current: e } = this.node
      e &&
        (this.unmount = Zq(
          e,
          (t) => (RR(this.node, t, 'Start'), (i) => RR(this.node, i, 'End')),
        ))
    }
    unmount() {}
  },
  Qq = class extends zc {
    constructor() {
      super(...arguments), (this.isActive = !1)
    }
    onFocus() {
      let e = !1
      try {
        e = this.node.current.matches(':focus-visible')
      } catch {
        e = !0
      }
      !e ||
        !this.node.animationState ||
        (this.node.animationState.setActive('whileFocus', !0),
        (this.isActive = !0))
    }
    onBlur() {
      !this.isActive ||
        !this.node.animationState ||
        (this.node.animationState.setActive('whileFocus', !1),
        (this.isActive = !1))
    }
    mount() {
      this.unmount = Kg(
        mg(this.node.current, 'focus', () => this.onFocus()),
        mg(this.node.current, 'blur', () => this.onBlur()),
      )
    }
    unmount() {}
  }
const um = new WeakSet()
function IR(n) {
  return (e) => {
    e.key === 'Enter' && n(e)
  }
}
function Zw(n, e) {
  n.dispatchEvent(
    new PointerEvent('pointer' + e, { isPrimary: !0, bubbles: !0 }),
  )
}
const Jq = (n, e) => {
    const t = n.currentTarget
    if (!t) return
    const i = IR(() => {
      if (um.has(t)) return
      Zw(t, 'down')
      const r = IR(() => {
          Zw(t, 'up')
        }),
        s = () => Zw(t, 'cancel')
      t.addEventListener('keyup', r, e), t.addEventListener('blur', s, e)
    })
    t.addEventListener('keydown', i, e),
      t.addEventListener('blur', () => t.removeEventListener('keydown', i), e)
  },
  eY = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'])
function tY(n) {
  return eY.has(n.tagName) || n.tabIndex !== -1
}
const ck = (n, e) => (e ? (n === e ? !0 : ck(n, e.parentElement)) : !1)
function LR(n) {
  return zb(n) && !VO()
}
function nY(n, e, t = {}) {
  const [i, r, s] = lk(n, t),
    o = (a) => {
      const c = a.currentTarget
      if (!LR(a) || um.has(c)) return
      um.add(c)
      const u = e(a),
        h = (y, _) => {
          window.removeEventListener('pointerup', m),
            window.removeEventListener('pointercancel', g),
            !(!LR(y) || !um.has(c)) && (um.delete(c), u && u(y, { success: _ }))
        },
        m = (y) => {
          h(y, t.useGlobalTarget || ck(c, y.target))
        },
        g = (y) => {
          h(y, !1)
        }
      window.addEventListener('pointerup', m, r),
        window.addEventListener('pointercancel', g, r)
    }
  return (
    i.forEach((a) => {
      tY(a) || (a.tabIndex = 0),
        (t.useGlobalTarget ? window : a).addEventListener('pointerdown', o, r),
        a.addEventListener('focus', (u) => Jq(u, r), r)
    }),
    s
  )
}
function NR(n, e, t) {
  const { props: i } = n
  n.animationState &&
    i.whileTap &&
    n.animationState.setActive('whileTap', t === 'Start')
  const r = 'onTap' + (t === 'End' ? '' : t),
    s = i[r]
  s && Dn.postRender(() => s(e, Qg(e)))
}
let iY = class extends zc {
  mount() {
    const { current: e } = this.node
    e &&
      (this.unmount = nY(
        e,
        (t) => (
          NR(this.node, t, 'Start'),
          (i, { success: r }) => NR(this.node, i, r ? 'End' : 'Cancel')
        ),
        { useGlobalTarget: this.node.props.globalTapTarget },
      ))
  }
  unmount() {}
}
const MM = new WeakMap(),
  Kw = new WeakMap(),
  rY = (n) => {
    const e = MM.get(n.target)
    e && e(n)
  },
  sY = (n) => {
    n.forEach(rY)
  }
function oY({ root: n, ...e }) {
  const t = n || document
  Kw.has(t) || Kw.set(t, {})
  const i = Kw.get(t),
    r = JSON.stringify(e)
  return i[r] || (i[r] = new IntersectionObserver(sY, { root: n, ...e })), i[r]
}
function aY(n, e, t) {
  const i = oY(e)
  return (
    MM.set(n, t),
    i.observe(n),
    () => {
      MM.delete(n), i.unobserve(n)
    }
  )
}
const lY = { some: 0, all: 1 }
let cY = class extends zc {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1)
  }
  startObserver() {
    this.unmount()
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: i, amount: r = 'some', once: s } = e,
      o = {
        root: t ? t.current : void 0,
        rootMargin: i,
        threshold: typeof r == 'number' ? r : lY[r],
      },
      a = (c) => {
        const { isIntersecting: u } = c
        if (
          this.isInView === u ||
          ((this.isInView = u), s && !u && this.hasEnteredView)
        )
          return
        u && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive('whileInView', u)
        const { onViewportEnter: h, onViewportLeave: m } = this.node.getProps(),
          g = u ? h : m
        g && g(c)
      }
    return aY(this.node.current, o, a)
  }
  mount() {
    this.startObserver()
  }
  update() {
    if (typeof IntersectionObserver > 'u') return
    const { props: e, prevProps: t } = this.node
    ;['amount', 'margin', 'root'].some(uY(e, t)) && this.startObserver()
  }
  unmount() {}
}
function uY({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t]
}
const dY = {
    inView: { Feature: cY },
    tap: { Feature: iY },
    focus: { Feature: Qq },
    hover: { Feature: Kq },
  },
  fY = { layout: { ProjectionNode: ak, MeasureLayout: JO } },
  Gb = X.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: 'never',
  }),
  L_ = X.createContext({}),
  Wb = typeof window < 'u',
  $b = Wb ? X.useLayoutEffect : X.useEffect,
  uk = X.createContext({ strict: !1 })
function hY(n, e, t, i, r) {
  var s, o
  const { visualElement: a } = X.useContext(L_),
    c = X.useContext(uk),
    u = X.useContext(Vb),
    h = X.useContext(Gb).reducedMotion,
    m = X.useRef(null)
  ;(i = i || c.renderer),
    !m.current &&
      i &&
      (m.current = i(n, {
        visualState: e,
        parent: a,
        props: t,
        presenceContext: u,
        blockInitialAnimation: u ? u.initial === !1 : !1,
        reducedMotionConfig: h,
      }))
  const g = m.current,
    y = X.useContext(QO)
  g &&
    !g.projection &&
    r &&
    (g.type === 'html' || g.type === 'svg') &&
    pY(m.current, t, r, y)
  const _ = X.useRef(!1)
  X.useInsertionEffect(() => {
    g && _.current && g.update(t, u)
  })
  const M = t[eO],
    w = X.useRef(
      !!M &&
        !(
          !((s = window.MotionHandoffIsComplete) === null || s === void 0) &&
          s.call(window, M)
        ) &&
        ((o = window.MotionHasOptimisedAnimation) === null || o === void 0
          ? void 0
          : o.call(window, M)),
    )
  return (
    $b(() => {
      g &&
        ((_.current = !0),
        (window.MotionIsMounted = !0),
        g.updateFeatures(),
        jb.render(g.render),
        w.current && g.animationState && g.animationState.animateChanges())
    }),
    X.useEffect(() => {
      g &&
        (!w.current && g.animationState && g.animationState.animateChanges(),
        w.current &&
          (queueMicrotask(() => {
            var x
            ;(x = window.MotionHandoffMarkAsComplete) === null ||
              x === void 0 ||
              x.call(window, M)
          }),
          (w.current = !1)))
    }),
    g
  )
}
function pY(n, e, t, i) {
  const {
    layoutId: r,
    layout: s,
    drag: o,
    dragConstraints: a,
    layoutScroll: c,
    layoutRoot: u,
  } = e
  ;(n.projection = new t(
    n.latestValues,
    e['data-framer-portal-id'] ? void 0 : dk(n.parent),
  )),
    n.projection.setOptions({
      layoutId: r,
      layout: s,
      alwaysMeasureLayout: !!o || (a && Jf(a)),
      visualElement: n,
      animationType: typeof s == 'string' ? s : 'both',
      initialPromotionConfig: i,
      layoutScroll: c,
      layoutRoot: u,
    })
}
function dk(n) {
  if (n) return n.options.allowProjection !== !1 ? n.projection : dk(n.parent)
}
function mY(n, e, t) {
  return X.useCallback(
    (i) => {
      i && n.mount && n.mount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == 'function' ? t(i) : Jf(t) && (t.current = i))
    },
    [e],
  )
}
function N_(n) {
  return P_(n.animate) || yb.some((e) => fg(n[e]))
}
function fk(n) {
  return !!(N_(n) || n.variants)
}
function gY(n, e) {
  if (N_(n)) {
    const { initial: t, animate: i } = n
    return {
      initial: t === !1 || fg(t) ? t : void 0,
      animate: fg(i) ? i : void 0,
    }
  }
  return n.inherit !== !1 ? e : {}
}
function vY(n) {
  const { initial: e, animate: t } = gY(n, X.useContext(L_))
  return X.useMemo(() => ({ initial: e, animate: t }), [DR(e), DR(t)])
}
function DR(n) {
  return Array.isArray(n) ? n.join(' ') : n
}
const OR = {
    animation: [
      'animate',
      'variants',
      'whileHover',
      'whileTap',
      'exit',
      'whileInView',
      'whileFocus',
      'whileDrag',
    ],
    exit: ['exit'],
    drag: ['drag', 'dragControls'],
    focus: ['whileFocus'],
    hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
    tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
    pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
    inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
    layout: ['layout', 'layoutId'],
  },
  Eh = {}
for (const n in OR) Eh[n] = { isEnabled: (e) => OR[n].some((t) => !!e[t]) }
function yY(n) {
  for (const e in n) Eh[e] = { ...Eh[e], ...n[e] }
}
const xY = Symbol.for('motionComponentSymbol')
function _Y({
  preloadedFeatures: n,
  createVisualElement: e,
  useRender: t,
  useVisualState: i,
  Component: r,
}) {
  n && yY(n)
  function s(a, c) {
    let u
    const h = { ...X.useContext(Gb), ...a, layoutId: wY(a) },
      { isStatic: m } = h,
      g = vY(a),
      y = i(a, m)
    if (!m && Wb) {
      SY()
      const _ = MY(h)
      ;(u = _.MeasureLayout),
        (g.visualElement = hY(r, y, h, e, _.ProjectionNode))
    }
    return b.jsxs(L_.Provider, {
      value: g,
      children: [
        u && g.visualElement
          ? b.jsx(u, { visualElement: g.visualElement, ...h })
          : null,
        t(r, a, mY(y, g.visualElement, c), y, m, g.visualElement),
      ],
    })
  }
  const o = X.forwardRef(s)
  return (o[xY] = r), o
}
function wY({ layoutId: n }) {
  const e = X.useContext(KO).id
  return e && n !== void 0 ? e + '-' + n : n
}
function SY(n, e) {
  X.useContext(uk).strict
}
function MY(n) {
  const { drag: e, layout: t } = Eh
  if (!e && !t) return {}
  const i = { ...e, ...t }
  return {
    MeasureLayout:
      (e != null && e.isEnabled(n)) || (t != null && t.isEnabled(n))
        ? i.MeasureLayout
        : void 0,
    ProjectionNode: i.ProjectionNode,
  }
}
const EY = [
  'animate',
  'circle',
  'defs',
  'desc',
  'ellipse',
  'g',
  'image',
  'line',
  'filter',
  'marker',
  'mask',
  'metadata',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'rect',
  'stop',
  'switch',
  'symbol',
  'svg',
  'text',
  'tspan',
  'use',
  'view',
]
function Xb(n) {
  return typeof n != 'string' || n.includes('-')
    ? !1
    : !!(EY.indexOf(n) > -1 || /[A-Z]/u.test(n))
}
function hk(n, { style: e, vars: t }, i, r) {
  Object.assign(n.style, e, r && r.getProjectionStyles(i))
  for (const s in t) n.style.setProperty(s, t[s])
}
const pk = new Set([
  'baseFrequency',
  'diffuseConstant',
  'kernelMatrix',
  'kernelUnitLength',
  'keySplines',
  'keyTimes',
  'limitingConeAngle',
  'markerHeight',
  'markerWidth',
  'numOctaves',
  'targetX',
  'targetY',
  'surfaceScale',
  'specularConstant',
  'specularExponent',
  'stdDeviation',
  'tableValues',
  'viewBox',
  'gradientTransform',
  'pathLength',
  'startOffset',
  'textLength',
  'lengthAdjust',
])
function mk(n, e, t, i) {
  hk(n, e, void 0, i)
  for (const r in e.attrs) n.setAttribute(pk.has(r) ? r : Eb(r), e.attrs[r])
}
function gk(n, { layout: e, layoutId: t }) {
  return (
    Md.has(n) ||
    n.startsWith('origin') ||
    ((e || t !== void 0) && (!!Px[n] || n === 'opacity'))
  )
}
function qb(n, e, t) {
  var i
  const { style: r } = n,
    s = {}
  for (const o in r)
    (Lr(r[o]) ||
      (e.style && Lr(e.style[o])) ||
      gk(o, n) ||
      ((i = t == null ? void 0 : t.getValue(o)) === null || i === void 0
        ? void 0
        : i.liveStyle) !== void 0) &&
      (s[o] = r[o])
  return s
}
function vk(n, e, t) {
  const i = qb(n, e, t)
  for (const r in n)
    if (Lr(n[r]) || Lr(e[r])) {
      const s =
        qg.indexOf(r) !== -1
          ? 'attr' + r.charAt(0).toUpperCase() + r.substring(1)
          : r
      i[s] = n[r]
    }
  return i
}
function D_(n) {
  const e = X.useRef(null)
  return e.current === null && (e.current = n()), e.current
}
function bY(
  { scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t },
  i,
  r,
  s,
) {
  const o = { latestValues: TY(i, r, s, n), renderState: e() }
  return t && (o.mount = (a) => t(i, a, o)), o
}
const yk = (n) => (e, t) => {
  const i = X.useContext(L_),
    r = X.useContext(Vb),
    s = () => bY(n, e, i, r)
  return t ? s() : D_(s)
}
function TY(n, e, t, i) {
  const r = {},
    s = i(n, {})
  for (const g in s) r[g] = by(s[g])
  let { initial: o, animate: a } = n
  const c = N_(n),
    u = fk(n)
  e &&
    u &&
    !c &&
    n.inherit !== !1 &&
    (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate))
  let h = t ? t.initial === !1 : !1
  h = h || o === !1
  const m = h ? a : o
  if (m && typeof m != 'boolean' && !P_(m)) {
    const g = Array.isArray(m) ? m : [m]
    for (let y = 0; y < g.length; y++) {
      const _ = gb(n, g[y])
      if (_) {
        const { transitionEnd: M, transition: w, ...x } = _
        for (const T in x) {
          let A = x[T]
          if (Array.isArray(A)) {
            const P = h ? A.length - 1 : 0
            A = A[P]
          }
          A !== null && (r[T] = A)
        }
        for (const T in M) r[T] = M[T]
      }
    }
  }
  return r
}
const Yb = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }),
  xk = () => ({ ...Yb(), attrs: {} }),
  _k = (n, e) => (e && typeof n == 'number' ? e.transform(n) : n),
  AY = {
    x: 'translateX',
    y: 'translateY',
    z: 'translateZ',
    transformPerspective: 'perspective',
  },
  CY = qg.length
function PY(n, e, t) {
  let i = '',
    r = !0
  for (let s = 0; s < CY; s++) {
    const o = qg[s],
      a = n[o]
    if (a === void 0) continue
    let c = !0
    if (
      (typeof a == 'number'
        ? (c = a === (o.startsWith('scale') ? 1 : 0))
        : (c = parseFloat(a) === 0),
      !c || t)
    ) {
      const u = _k(a, Db[o])
      if (!c) {
        r = !1
        const h = AY[o] || o
        i += `${h}(${u}) `
      }
      t && (e[o] = u)
    }
  }
  return (i = i.trim()), t ? (i = t(e, r ? '' : i)) : r && (i = 'none'), i
}
function Zb(n, e, t) {
  const { style: i, vars: r, transformOrigin: s } = n
  let o = !1,
    a = !1
  for (const c in e) {
    const u = e[c]
    if (Md.has(c)) {
      o = !0
      continue
    } else if (vO(c)) {
      r[c] = u
      continue
    } else {
      const h = _k(u, Db[c])
      c.startsWith('origin') ? ((a = !0), (s[c] = h)) : (i[c] = h)
    }
  }
  if (
    (e.transform ||
      (o || t
        ? (i.transform = PY(e, n.transform, t))
        : i.transform && (i.transform = 'none')),
    a)
  ) {
    const { originX: c = '50%', originY: u = '50%', originZ: h = 0 } = s
    i.transformOrigin = `${c} ${u} ${h}`
  }
}
function kR(n, e, t) {
  return typeof n == 'string' ? n : Yt.transform(e + t * n)
}
function RY(n, e, t) {
  const i = kR(e, n.x, n.width),
    r = kR(t, n.y, n.height)
  return `${i} ${r}`
}
const IY = { offset: 'stroke-dashoffset', array: 'stroke-dasharray' },
  LY = { offset: 'strokeDashoffset', array: 'strokeDasharray' }
function NY(n, e, t = 1, i = 0, r = !0) {
  n.pathLength = 1
  const s = r ? IY : LY
  n[s.offset] = Yt.transform(-i)
  const o = Yt.transform(e),
    a = Yt.transform(t)
  n[s.array] = `${o} ${a}`
}
function Kb(
  n,
  {
    attrX: e,
    attrY: t,
    attrScale: i,
    originX: r,
    originY: s,
    pathLength: o,
    pathSpacing: a = 1,
    pathOffset: c = 0,
    ...u
  },
  h,
  m,
) {
  if ((Zb(n, u, m), h)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox)
    return
  }
  ;(n.attrs = n.style), (n.style = {})
  const { attrs: g, style: y, dimensions: _ } = n
  g.transform && (_ && (y.transform = g.transform), delete g.transform),
    _ &&
      (r !== void 0 || s !== void 0 || y.transform) &&
      (y.transformOrigin = RY(
        _,
        r !== void 0 ? r : 0.5,
        s !== void 0 ? s : 0.5,
      )),
    e !== void 0 && (g.x = e),
    t !== void 0 && (g.y = t),
    i !== void 0 && (g.scale = i),
    o !== void 0 && NY(g, o, a, c, !1)
}
const Qb = (n) => typeof n == 'string' && n.toLowerCase() === 'svg',
  DY = {
    useVisualState: yk({
      scrapeMotionValuesFromProps: vk,
      createRenderState: xk,
      onMount: (n, e, { renderState: t, latestValues: i }) => {
        Dn.read(() => {
          try {
            t.dimensions =
              typeof e.getBBox == 'function'
                ? e.getBBox()
                : e.getBoundingClientRect()
          } catch {
            t.dimensions = { x: 0, y: 0, width: 0, height: 0 }
          }
        }),
          Dn.render(() => {
            Kb(t, i, Qb(e.tagName), n.transformTemplate), mk(e, t)
          })
      },
    }),
  },
  OY = {
    useVisualState: yk({
      scrapeMotionValuesFromProps: qb,
      createRenderState: Yb,
    }),
  }
function wk(n, e, t) {
  for (const i in e) !Lr(e[i]) && !gk(i, t) && (n[i] = e[i])
}
function kY({ transformTemplate: n }, e) {
  return X.useMemo(() => {
    const t = Yb()
    return Zb(t, e, n), Object.assign({}, t.vars, t.style)
  }, [e])
}
function FY(n, e) {
  const t = n.style || {},
    i = {}
  return wk(i, t, n), Object.assign(i, kY(n, e)), i
}
function UY(n, e) {
  const t = {},
    i = FY(n, e)
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((t.draggable = !1),
      (i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = 'none'),
      (i.touchAction =
        n.drag === !0 ? 'none' : `pan-${n.drag === 'x' ? 'y' : 'x'}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (t.tabIndex = 0),
    (t.style = i),
    t
  )
}
const BY = new Set([
  'animate',
  'exit',
  'variants',
  'initial',
  'style',
  'values',
  'variants',
  'transition',
  'transformTemplate',
  'custom',
  'inherit',
  'onBeforeLayoutMeasure',
  'onAnimationStart',
  'onAnimationComplete',
  'onUpdate',
  'onDragStart',
  'onDrag',
  'onDragEnd',
  'onMeasureDragConstraints',
  'onDirectionLock',
  'onDragTransitionEnd',
  '_dragX',
  '_dragY',
  'onHoverStart',
  'onHoverEnd',
  'onViewportEnter',
  'onViewportLeave',
  'globalTapTarget',
  'ignoreStrict',
  'viewport',
])
function Rx(n) {
  return (
    n.startsWith('while') ||
    (n.startsWith('drag') && n !== 'draggable') ||
    n.startsWith('layout') ||
    n.startsWith('onTap') ||
    n.startsWith('onPan') ||
    n.startsWith('onLayout') ||
    BY.has(n)
  )
}
let Sk = (n) => !Rx(n)
function zY(n) {
  n && (Sk = (e) => (e.startsWith('on') ? !Rx(e) : n(e)))
}
try {
  zY(require('@emotion/is-prop-valid').default)
} catch {}
function VY(n, e, t) {
  const i = {}
  for (const r in n)
    (r === 'values' && typeof n.values == 'object') ||
      ((Sk(r) ||
        (t === !0 && Rx(r)) ||
        (!e && !Rx(r)) ||
        (n.draggable && r.startsWith('onDrag'))) &&
        (i[r] = n[r]))
  return i
}
function jY(n, e, t, i) {
  const r = X.useMemo(() => {
    const s = xk()
    return (
      Kb(s, e, Qb(i), n.transformTemplate),
      { ...s.attrs, style: { ...s.style } }
    )
  }, [e])
  if (n.style) {
    const s = {}
    wk(s, n.style, n), (r.style = { ...s, ...r.style })
  }
  return r
}
function HY(n = !1) {
  return (t, i, r, { latestValues: s }, o) => {
    const c = (Xb(t) ? jY : UY)(i, s, o, t),
      u = VY(i, typeof t == 'string', n),
      h = t !== X.Fragment ? { ...u, ...c, ref: r } : {},
      { children: m } = i,
      g = X.useMemo(() => (Lr(m) ? m.get() : m), [m])
    return X.createElement(t, { ...h, children: g })
  }
}
function GY(n, e) {
  return function (i, { forwardMotionProps: r } = { forwardMotionProps: !1 }) {
    const o = {
      ...(Xb(i) ? DY : OY),
      preloadedFeatures: n,
      useRender: HY(r),
      createVisualElement: e,
      Component: i,
    }
    return _Y(o)
  }
}
const EM = { current: null },
  Mk = { current: !1 }
function WY() {
  if (((Mk.current = !0), !!Wb))
    if (window.matchMedia) {
      const n = window.matchMedia('(prefers-reduced-motion)'),
        e = () => (EM.current = n.matches)
      n.addListener(e), e()
    } else EM.current = !1
}
function $Y(n, e, t) {
  for (const i in e) {
    const r = e[i],
      s = t[i]
    if (Lr(r)) n.addValue(i, r)
    else if (Lr(s)) n.addValue(i, ga(r, { owner: n }))
    else if (s !== r)
      if (n.hasValue(i)) {
        const o = n.getValue(i)
        o.liveStyle === !0 ? o.jump(r) : o.hasAnimated || o.set(r)
      } else {
        const o = n.getStaticValue(i)
        n.addValue(i, ga(o !== void 0 ? o : r, { owner: n }))
      }
  }
  for (const i in t) e[i] === void 0 && n.removeValue(i)
  return e
}
const FR = new WeakMap(),
  XY = [..._O, Rr, Lc],
  qY = (n) => XY.find(xO(n)),
  UR = [
    'AnimationStart',
    'AnimationComplete',
    'Update',
    'BeforeLayoutMeasure',
    'LayoutMeasure',
    'LayoutAnimationStart',
    'LayoutAnimationComplete',
  ]
let YY = class {
    scrapeMotionValuesFromProps(e, t, i) {
      return {}
    }
    constructor(
      {
        parent: e,
        props: t,
        presenceContext: i,
        reducedMotionConfig: r,
        blockInitialAnimation: s,
        visualState: o,
      },
      a = {},
    ) {
      ;(this.current = null),
        (this.children = new Set()),
        (this.isVariantNode = !1),
        (this.isControllingVariants = !1),
        (this.shouldReduceMotion = null),
        (this.values = new Map()),
        (this.KeyframeResolver = Ib),
        (this.features = {}),
        (this.valueSubscriptions = new Map()),
        (this.prevMotionValues = {}),
        (this.events = {}),
        (this.propEventSubscriptions = {}),
        (this.notifyUpdate = () => this.notify('Update', this.latestValues)),
        (this.render = () => {
          this.current &&
            (this.triggerBuild(),
            this.renderInstance(
              this.current,
              this.renderState,
              this.props.style,
              this.projection,
            ))
        }),
        (this.renderScheduledAt = 0),
        (this.scheduleRender = () => {
          const g = _a.now()
          this.renderScheduledAt < g &&
            ((this.renderScheduledAt = g), Dn.render(this.render, !1, !0))
        })
      const { latestValues: c, renderState: u } = o
      ;(this.latestValues = c),
        (this.baseTarget = { ...c }),
        (this.initialValues = t.initial ? { ...c } : {}),
        (this.renderState = u),
        (this.parent = e),
        (this.props = t),
        (this.presenceContext = i),
        (this.depth = e ? e.depth + 1 : 0),
        (this.reducedMotionConfig = r),
        (this.options = a),
        (this.blockInitialAnimation = !!s),
        (this.isControllingVariants = N_(t)),
        (this.isVariantNode = fk(t)),
        this.isVariantNode && (this.variantChildren = new Set()),
        (this.manuallyAnimateOnMount = !!(e && e.current))
      const { willChange: h, ...m } = this.scrapeMotionValuesFromProps(
        t,
        {},
        this,
      )
      for (const g in m) {
        const y = m[g]
        c[g] !== void 0 && Lr(y) && y.set(c[g], !1)
      }
    }
    mount(e) {
      ;(this.current = e),
        FR.set(e, this),
        this.projection &&
          !this.projection.instance &&
          this.projection.mount(e),
        this.parent &&
          this.isVariantNode &&
          !this.isControllingVariants &&
          (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach((t, i) => this.bindToMotionValue(i, t)),
        Mk.current || WY(),
        (this.shouldReduceMotion =
          this.reducedMotionConfig === 'never'
            ? !1
            : this.reducedMotionConfig === 'always'
            ? !0
            : EM.current),
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
      FR.delete(this.current),
        this.projection && this.projection.unmount(),
        qo(this.notifyUpdate),
        qo(this.render),
        this.valueSubscriptions.forEach((e) => e()),
        this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this)
      for (const e in this.events) this.events[e].clear()
      for (const e in this.features) {
        const t = this.features[e]
        t && (t.unmount(), (t.isMounted = !1))
      }
      this.current = null
    }
    bindToMotionValue(e, t) {
      this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)()
      const i = Md.has(e),
        r = t.on('change', (a) => {
          ;(this.latestValues[e] = a),
            this.props.onUpdate && Dn.preRender(this.notifyUpdate),
            i && this.projection && (this.projection.isTransformDirty = !0)
        }),
        s = t.on('renderRequest', this.scheduleRender)
      let o
      window.MotionCheckAppearSync &&
        (o = window.MotionCheckAppearSync(this, e, t)),
        this.valueSubscriptions.set(e, () => {
          r(), s(), o && o(), t.owner && t.stop()
        })
    }
    sortNodePosition(e) {
      return !this.current ||
        !this.sortInstanceNodePosition ||
        this.type !== e.type
        ? 0
        : this.sortInstanceNodePosition(this.current, e.current)
    }
    updateFeatures() {
      let e = 'animation'
      for (e in Eh) {
        const t = Eh[e]
        if (!t) continue
        const { isEnabled: i, Feature: r } = t
        if (
          (!this.features[e] &&
            r &&
            i(this.props) &&
            (this.features[e] = new r(this)),
          this.features[e])
        ) {
          const s = this.features[e]
          s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0))
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
      return this.current
        ? this.measureInstanceViewportBox(this.current, this.props)
        : Pi()
    }
    getStaticValue(e) {
      return this.latestValues[e]
    }
    setStaticValue(e, t) {
      this.latestValues[e] = t
    }
    update(e, t) {
      ;(e.transformTemplate || this.props.transformTemplate) &&
        this.scheduleRender(),
        (this.prevProps = this.props),
        (this.props = e),
        (this.prevPresenceContext = this.presenceContext),
        (this.presenceContext = t)
      for (let i = 0; i < UR.length; i++) {
        const r = UR[i]
        this.propEventSubscriptions[r] &&
          (this.propEventSubscriptions[r](),
          delete this.propEventSubscriptions[r])
        const s = 'on' + r,
          o = e[s]
        o && (this.propEventSubscriptions[r] = this.on(r, o))
      }
      ;(this.prevMotionValues = $Y(
        this,
        this.scrapeMotionValuesFromProps(e, this.prevProps, this),
        this.prevMotionValues,
      )),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
      return this.props
    }
    getVariant(e) {
      return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
      return this.props.transition
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint
    }
    getClosestVariantNode() {
      return this.isVariantNode
        ? this
        : this.parent
        ? this.parent.getClosestVariantNode()
        : void 0
    }
    addVariantChild(e) {
      const t = this.getClosestVariantNode()
      if (t)
        return (
          t.variantChildren && t.variantChildren.add(e),
          () => t.variantChildren.delete(e)
        )
    }
    addValue(e, t) {
      const i = this.values.get(e)
      t !== i &&
        (i && this.removeValue(e),
        this.bindToMotionValue(e, t),
        this.values.set(e, t),
        (this.latestValues[e] = t.get()))
    }
    removeValue(e) {
      this.values.delete(e)
      const t = this.valueSubscriptions.get(e)
      t && (t(), this.valueSubscriptions.delete(e)),
        delete this.latestValues[e],
        this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
      return this.values.has(e)
    }
    getValue(e, t) {
      if (this.props.values && this.props.values[e]) return this.props.values[e]
      let i = this.values.get(e)
      return (
        i === void 0 &&
          t !== void 0 &&
          ((i = ga(t === null ? void 0 : t, { owner: this })),
          this.addValue(e, i)),
        i
      )
    }
    readValue(e, t) {
      var i
      let r =
        this.latestValues[e] !== void 0 || !this.current
          ? this.latestValues[e]
          : (i = this.getBaseTargetFromProps(this.props, e)) !== null &&
            i !== void 0
          ? i
          : this.readValueFromInstance(this.current, e, this.options)
      return (
        r != null &&
          (typeof r == 'string' && (mO(r) || pO(r))
            ? (r = parseFloat(r))
            : !qY(r) && Lc.test(t) && (r = CO(e, t)),
          this.setBaseTarget(e, Lr(r) ? r.get() : r)),
        Lr(r) ? r.get() : r
      )
    }
    setBaseTarget(e, t) {
      this.baseTarget[e] = t
    }
    getBaseTarget(e) {
      var t
      const { initial: i } = this.props
      let r
      if (typeof i == 'string' || typeof i == 'object') {
        const o = gb(
          this.props,
          i,
          (t = this.presenceContext) === null || t === void 0
            ? void 0
            : t.custom,
        )
        o && (r = o[e])
      }
      if (i && r !== void 0) return r
      const s = this.getBaseTargetFromProps(this.props, e)
      return s !== void 0 && !Lr(s)
        ? s
        : this.initialValues[e] !== void 0 && r === void 0
        ? void 0
        : this.baseTarget[e]
    }
    on(e, t) {
      return (
        this.events[e] || (this.events[e] = new Sb()), this.events[e].add(t)
      )
    }
    notify(e, ...t) {
      this.events[e] && this.events[e].notify(...t)
    }
  },
  Ek = class extends YY {
    constructor() {
      super(...arguments), (this.KeyframeResolver = PO)
    }
    sortInstanceNodePosition(e, t) {
      return e.compareDocumentPosition(t) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, t) {
      return e.style ? e.style[t] : void 0
    }
    removeValueFromRenderState(e, { vars: t, style: i }) {
      delete t[e], delete i[e]
    }
    handleChildMotionValue() {
      this.childSubscription &&
        (this.childSubscription(), delete this.childSubscription)
      const { children: e } = this.props
      Lr(e) &&
        (this.childSubscription = e.on('change', (t) => {
          this.current && (this.current.textContent = `${t}`)
        }))
    }
  }
function ZY(n) {
  return window.getComputedStyle(n)
}
let KY = class extends Ek {
    constructor() {
      super(...arguments), (this.type = 'html'), (this.renderInstance = hk)
    }
    readValueFromInstance(e, t) {
      if (Md.has(t)) {
        const i = Ob(t)
        return (i && i.default) || 0
      } else {
        const i = ZY(e),
          r = (vO(t) ? i.getPropertyValue(t) : i[t]) || 0
        return typeof r == 'string' ? r.trim() : r
      }
    }
    measureInstanceViewportBox(e, { transformPagePoint: t }) {
      return YO(e, t)
    }
    build(e, t, i) {
      Zb(e, t, i.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, t, i) {
      return qb(e, t, i)
    }
  },
  QY = class extends Ek {
    constructor() {
      super(...arguments),
        (this.type = 'svg'),
        (this.isSVGTag = !1),
        (this.measureInstanceViewportBox = Pi)
    }
    getBaseTargetFromProps(e, t) {
      return e[t]
    }
    readValueFromInstance(e, t) {
      if (Md.has(t)) {
        const i = Ob(t)
        return (i && i.default) || 0
      }
      return (t = pk.has(t) ? t : Eb(t)), e.getAttribute(t)
    }
    scrapeMotionValuesFromProps(e, t, i) {
      return vk(e, t, i)
    }
    build(e, t, i) {
      Kb(e, t, this.isSVGTag, i.transformTemplate)
    }
    renderInstance(e, t, i, r) {
      mk(e, t, i, r)
    }
    mount(e) {
      ;(this.isSVGTag = Qb(e.tagName)), super.mount(e)
    }
  }
const JY = (n, e) =>
    Xb(n) ? new QY(e) : new KY(e, { allowProjection: n !== X.Fragment }),
  Jb = GY({ ...FX, ...dY, ...Yq, ...fY }, JY)
function eZ(n) {
  const e = D_(() => ga(n)),
    { isStatic: t } = X.useContext(Gb)
  if (t) {
    const [, i] = X.useState(n)
    X.useEffect(() => e.on('change', i), [])
  }
  return e
}
function bk(n, e) {
  const t = eZ(e()),
    i = () => t.set(e())
  return (
    i(),
    $b(() => {
      const r = () => Dn.preRender(i, !1, !0),
        s = n.map((o) => o.on('change', r))
      return () => {
        s.forEach((o) => o()), qo(i)
      }
    }),
    t
  )
}
const tZ = (n) => n && typeof n == 'object' && n.mix,
  nZ = (n) => (tZ(n) ? n.mix : void 0)
function iZ(...n) {
  const e = !Array.isArray(n[0]),
    t = e ? 0 : -1,
    i = n[0 + t],
    r = n[1 + t],
    s = n[2 + t],
    o = n[3 + t],
    a = Fb(r, s, { mixer: nZ(s[0]), ...o })
  return e ? a(i) : a
}
function rZ(n) {
  ;(Pm.current = []), n()
  const e = bk(Pm.current, n)
  return (Pm.current = void 0), e
}
function ih(n, e, t, i) {
  if (typeof n == 'function') return rZ(n)
  const r = typeof e == 'function' ? e : iZ(e, t, i)
  return Array.isArray(n) ? BR(n, r) : BR([n], ([s]) => r(s))
}
function BR(n, e) {
  const t = D_(() => [])
  return bk(n, () => {
    t.length = 0
    const i = n.length
    for (let r = 0; r < i; r++) t[r] = n[r].get()
    return e(t)
  })
}
function Tk(n, e) {
  let t
  const i = () => {
    const { currentTime: r } = e,
      o = (r === null ? 0 : r.value) / 100
    t !== o && n(o), (t = o)
  }
  return Dn.update(i, !0), () => qo(i)
}
const Ty = new WeakMap()
let xc
function sZ(n, e) {
  if (e) {
    const { inlineSize: t, blockSize: i } = e[0]
    return { width: t, height: i }
  } else
    return n instanceof SVGElement && 'getBBox' in n
      ? n.getBBox()
      : { width: n.offsetWidth, height: n.offsetHeight }
}
function oZ({ target: n, contentRect: e, borderBoxSize: t }) {
  var i
  ;(i = Ty.get(n)) === null ||
    i === void 0 ||
    i.forEach((r) => {
      r({
        target: n,
        contentSize: e,
        get size() {
          return sZ(n, t)
        },
      })
    })
}
function aZ(n) {
  n.forEach(oZ)
}
function lZ() {
  typeof ResizeObserver > 'u' || (xc = new ResizeObserver(aZ))
}
function cZ(n, e) {
  xc || lZ()
  const t = Hb(n)
  return (
    t.forEach((i) => {
      let r = Ty.get(i)
      r || ((r = new Set()), Ty.set(i, r)),
        r.add(e),
        xc == null || xc.observe(i)
    }),
    () => {
      t.forEach((i) => {
        const r = Ty.get(i)
        r == null || r.delete(e),
          (r != null && r.size) || xc == null || xc.unobserve(i)
      })
    }
  )
}
const Ay = new Set()
let Dm
function uZ() {
  ;(Dm = () => {
    const n = { width: window.innerWidth, height: window.innerHeight },
      e = { target: window, size: n, contentSize: n }
    Ay.forEach((t) => t(e))
  }),
    window.addEventListener('resize', Dm)
}
function dZ(n) {
  return (
    Ay.add(n),
    Dm || uZ(),
    () => {
      Ay.delete(n), !Ay.size && Dm && (Dm = void 0)
    }
  )
}
function fZ(n, e) {
  return typeof n == 'function' ? dZ(n) : cZ(n, e)
}
const hZ = 50,
  zR = () => ({
    current: 0,
    offset: [],
    progress: 0,
    scrollLength: 0,
    targetOffset: 0,
    targetLength: 0,
    containerLength: 0,
    velocity: 0,
  }),
  pZ = () => ({ time: 0, x: zR(), y: zR() }),
  mZ = {
    x: { length: 'Width', position: 'Left' },
    y: { length: 'Height', position: 'Top' },
  }
function VR(n, e, t, i) {
  const r = t[e],
    { length: s, position: o } = mZ[e],
    a = r.current,
    c = t.time
  ;(r.current = n[`scroll${o}`]),
    (r.scrollLength = n[`scroll${s}`] - n[`client${s}`]),
    (r.offset.length = 0),
    (r.offset[0] = 0),
    (r.offset[1] = r.scrollLength),
    (r.progress = xd(0, r.scrollLength, r.current))
  const u = i - c
  r.velocity = u > hZ ? 0 : Mb(r.current - a, u)
}
function gZ(n, e, t) {
  VR(n, 'x', e, t), VR(n, 'y', e, t), (e.time = t)
}
function vZ(n, e) {
  const t = { x: 0, y: 0 }
  let i = n
  for (; i && i !== e; )
    if (i instanceof HTMLElement)
      (t.x += i.offsetLeft), (t.y += i.offsetTop), (i = i.offsetParent)
    else if (i.tagName === 'svg') {
      const r = i.getBoundingClientRect()
      i = i.parentElement
      const s = i.getBoundingClientRect()
      ;(t.x += r.left - s.left), (t.y += r.top - s.top)
    } else if (i instanceof SVGGraphicsElement) {
      const { x: r, y: s } = i.getBBox()
      ;(t.x += r), (t.y += s)
      let o = null,
        a = i.parentNode
      for (; !o; ) a.tagName === 'svg' && (o = a), (a = i.parentNode)
      i = o
    } else break
  return t
}
const yZ = {
    Enter: [
      [0, 1],
      [1, 1],
    ],
    Exit: [
      [0, 0],
      [1, 0],
    ],
    Any: [
      [1, 0],
      [0, 1],
    ],
    All: [
      [0, 0],
      [1, 1],
    ],
  },
  bM = { start: 0, center: 0.5, end: 1 }
function jR(n, e, t = 0) {
  let i = 0
  if ((n in bM && (n = bM[n]), typeof n == 'string')) {
    const r = parseFloat(n)
    n.endsWith('px')
      ? (i = r)
      : n.endsWith('%')
      ? (n = r / 100)
      : n.endsWith('vw')
      ? (i = (r / 100) * document.documentElement.clientWidth)
      : n.endsWith('vh')
      ? (i = (r / 100) * document.documentElement.clientHeight)
      : (n = r)
  }
  return typeof n == 'number' && (i = e * n), t + i
}
const xZ = [0, 0]
function _Z(n, e, t, i) {
  let r = Array.isArray(n) ? n : xZ,
    s = 0,
    o = 0
  return (
    typeof n == 'number'
      ? (r = [n, n])
      : typeof n == 'string' &&
        ((n = n.trim()),
        n.includes(' ') ? (r = n.split(' ')) : (r = [n, bM[n] ? n : '0'])),
    (s = jR(r[0], t, i)),
    (o = jR(r[1], e)),
    s - o
  )
}
const wZ = { x: 0, y: 0 }
function SZ(n) {
  return 'getBBox' in n && n.tagName !== 'svg'
    ? n.getBBox()
    : { width: n.clientWidth, height: n.clientHeight }
}
function MZ(n, e, t) {
  const { offset: i = yZ.All } = t,
    { target: r = n, axis: s = 'y' } = t,
    o = s === 'y' ? 'height' : 'width',
    a = r !== n ? vZ(r, n) : wZ,
    c = r === n ? { width: n.scrollWidth, height: n.scrollHeight } : SZ(r),
    u = { width: n.clientWidth, height: n.clientHeight }
  e[s].offset.length = 0
  let h = !e[s].interpolate
  const m = i.length
  for (let g = 0; g < m; g++) {
    const y = _Z(i[g], u[o], c[o], a[s])
    !h && y !== e[s].interpolatorOffsets[g] && (h = !0), (e[s].offset[g] = y)
  }
  h &&
    ((e[s].interpolate = Fb(e[s].offset, FO(i))),
    (e[s].interpolatorOffsets = [...e[s].offset])),
    (e[s].progress = e[s].interpolate(e[s].current))
}
function EZ(n, e = n, t) {
  if (((t.x.targetOffset = 0), (t.y.targetOffset = 0), e !== n)) {
    let i = e
    for (; i && i !== n; )
      (t.x.targetOffset += i.offsetLeft),
        (t.y.targetOffset += i.offsetTop),
        (i = i.offsetParent)
  }
  ;(t.x.targetLength = e === n ? e.scrollWidth : e.clientWidth),
    (t.y.targetLength = e === n ? e.scrollHeight : e.clientHeight),
    (t.x.containerLength = n.clientWidth),
    (t.y.containerLength = n.clientHeight)
}
function bZ(n, e, t, i = {}) {
  return {
    measure: () => EZ(n, i.target, t),
    update: (r) => {
      gZ(n, t, r), (i.offset || i.target) && MZ(n, t, i)
    },
    notify: () => e(t),
  }
}
const tm = new WeakMap(),
  HR = new WeakMap(),
  Qw = new WeakMap(),
  GR = (n) => (n === document.documentElement ? window : n)
function eT(n, { container: e = document.documentElement, ...t } = {}) {
  let i = Qw.get(e)
  i || ((i = new Set()), Qw.set(e, i))
  const r = pZ(),
    s = bZ(e, n, r, t)
  if ((i.add(s), !tm.has(e))) {
    const a = () => {
        for (const g of i) g.measure()
      },
      c = () => {
        for (const g of i) g.update(rr.timestamp)
      },
      u = () => {
        for (const g of i) g.notify()
      },
      h = () => {
        Dn.read(a, !1, !0), Dn.read(c, !1, !0), Dn.update(u, !1, !0)
      }
    tm.set(e, h)
    const m = GR(e)
    window.addEventListener('resize', h, { passive: !0 }),
      e !== document.documentElement && HR.set(e, fZ(e, h)),
      m.addEventListener('scroll', h, { passive: !0 })
  }
  const o = tm.get(e)
  return (
    Dn.read(o, !1, !0),
    () => {
      var a
      qo(o)
      const c = Qw.get(e)
      if (!c || (c.delete(s), c.size)) return
      const u = tm.get(e)
      tm.delete(e),
        u &&
          (GR(e).removeEventListener('scroll', u),
          (a = HR.get(e)) === null || a === void 0 || a(),
          window.removeEventListener('resize', u))
    }
  )
}
function TZ({ source: n, container: e, axis: t = 'y' }) {
  n && (e = n)
  const i = { value: 0 },
    r = eT(
      (s) => {
        i.value = s[t].progress * 100
      },
      { container: e, axis: t },
    )
  return { currentTime: i, cancel: r }
}
const Jw = new Map()
function Ak({
  source: n,
  container: e = document.documentElement,
  axis: t = 'y',
} = {}) {
  n && (e = n), Jw.has(e) || Jw.set(e, {})
  const i = Jw.get(e)
  return (
    i[t] ||
      (i[t] = nO()
        ? new ScrollTimeline({ source: e, axis: t })
        : TZ({ source: e, axis: t })),
    i[t]
  )
}
function AZ(n) {
  return n.length === 2
}
function Ck(n) {
  return n && (n.target || n.offset)
}
function CZ(n, e) {
  return AZ(n) || Ck(e)
    ? eT((t) => {
        n(t[e.axis].progress, t)
      }, e)
    : Tk(n, Ak(e))
}
function PZ(n, e) {
  if ((n.flatten(), Ck(e)))
    return (
      n.pause(),
      eT((t) => {
        n.time = n.duration * t[e.axis].progress
      }, e)
    )
  {
    const t = Ak(e)
    return n.attachTimeline
      ? n.attachTimeline(
          t,
          (i) => (
            i.pause(),
            Tk((r) => {
              i.time = i.duration * r
            }, t)
          ),
        )
      : es
  }
}
function RZ(n, { axis: e = 'y', ...t } = {}) {
  const i = { axis: e, ...t }
  return typeof n == 'function' ? CZ(n, i) : PZ(n, i)
}
function WR(n, e) {
  F7(!!(!e || e.current))
}
const IZ = () => ({
  scrollX: ga(0),
  scrollY: ga(0),
  scrollXProgress: ga(0),
  scrollYProgress: ga(0),
})
function tT({ container: n, target: e, layoutEffect: t = !0, ...i } = {}) {
  const r = D_(IZ)
  return (
    (t ? $b : X.useEffect)(
      () => (
        WR('target', e),
        WR('container', n),
        RZ(
          (o, { x: a, y: c }) => {
            r.scrollX.set(a.current),
              r.scrollXProgress.set(a.progress),
              r.scrollY.set(c.current),
              r.scrollYProgress.set(c.progress)
          },
          {
            ...i,
            container: (n == null ? void 0 : n.current) || void 0,
            target: (e == null ? void 0 : e.current) || void 0,
          },
        )
      ),
      [n, e, JSON.stringify(i.offset)],
    ),
    r
  )
}
const LZ = { some: 0, all: 1 }
function NZ(n, e, { root: t, margin: i, amount: r = 'some' } = {}) {
  const s = Hb(n),
    o = new WeakMap(),
    a = (u) => {
      u.forEach((h) => {
        const m = o.get(h.target)
        if (h.isIntersecting !== !!m)
          if (h.isIntersecting) {
            const g = e(h)
            typeof g == 'function' ? o.set(h.target, g) : c.unobserve(h.target)
          } else m && (m(h), o.delete(h.target))
      })
    },
    c = new IntersectionObserver(a, {
      root: t,
      rootMargin: i,
      threshold: typeof r == 'number' ? r : LZ[r],
    })
  return s.forEach((u) => c.observe(u)), () => c.disconnect()
}
function DZ(n, { root: e, margin: t, amount: i, once: r = !1 } = {}) {
  const [s, o] = X.useState(!1)
  return (
    X.useEffect(() => {
      if (!n.current || (r && s)) return
      const a = () => (o(!0), r ? void 0 : () => o(!1)),
        c = { root: (e && e.current) || void 0, margin: t, amount: i }
      return NZ(n.current, a, c)
    }, [e, n, t, r, i]),
    s
  )
}
const fy = ({
  ProjectSrc: n,
  imgSrc: e,
  title: t,
  description: i,
  tags: r,
  disabled: s = !1,
  imagePos: o = '',
  borderDirection: a = [],
}) => {
  const c = {
      top: 'lg:border-t-[1px]',
      right: 'lg:border-r-[1px]',
      bottom: 'lg:border-b-[1px]',
      left: 'lg:border-l-[1px]',
      none: '',
    },
    u = Array.isArray(a) ? a.map((h) => c[h] || '').join(' ') : c[a] || ''
  return b.jsx('div', {
    className: `w-full lg:mx-4 ${u} lg:border-[#dddddd] 
      ${s ? 'cursor-default hidden lg:block' : ''}`,
    children: b.jsxs(Fs, {
      to: s ? '#' : n,
      className: 'w-full group',
      style: { pointerEvents: s ? 'none' : 'auto' },
      children: [
        b.jsxs('div', {
          className:
            'w-full h-96 overflow-hidden 3xl:min-h-[1080px] relative rounded-lg',
          children: [
            b.jsx('img', {
              src: e,
              alt: t,
              className: `w-full h-full object-cover ${o} group-hover:scale-105 group-hover:brightness-[80%] easeAnimateStyle`,
            }),
            b.jsx('div', {
              className: `absolute top-[50%] left-[50%] transform -translate-x-1/2 -translate-y-1/2 bg-white text-black text-lg px-6 py-1 
          rounded-full opacity-0 group-hover:opacity-100 transition-opacity duration-300`,
              children: 'See Details',
            }),
          ],
        }),
        b.jsxs('div', {
          className: 'text-center space-y-1',
          children: [
            b.jsx('h3', {
              className: 'mt-4 text-lg font-semibold text-gray-800 text-center',
              children: t,
            }),
            b.jsxs('p', { children: [' ', i, ' '] }),
          ],
        }),
        b.jsx('div', {
          className: 'mt-2 flex flex-wrap gap-2 justify-center capitalize mb-8',
          children: r.map((h, m) =>
            b.jsxs(
              'span',
              {
                className: `text-sm text-gray-600 bg-gray-100 px-2 py-1 rounded-full ${
                  s ? '' : 'hover:bg-gray-200'
                }`,
                children: ['/ ', h],
              },
              m,
            ),
          ),
        }),
      ],
    }),
  })
}
function nT({ theme: n = 'home', goBackHome: e = 'false' }) {
  return b.jsxs('footer', {
    'data-theme': n,
    className: 'pb-20 text-center text-textColor space-y-6 lg:space-y-2',
    children: [
      b.jsxs('div', {
        className:
          'flex space-y-6 flex-col lg:flex-row justify-center items-center lg:space-y-0 lg:space-x-6 mb-2 py-1',
        children: [
          e === 'true' &&
            b.jsx(Fs, {
              to: '/',
              className: 'text-primary hover:animate-bounce easeAnimateStyle',
              children: 'Go back home',
            }),
          b.jsx('a', {
            href: 'https://www.linkedin.com/in/jingdi-shang-bb7997326/',
            target: '_blank',
            rel: 'noopener noreferrer',
            className: 'text-primary hover:animate-bounce easeAnimateStyle',
            children: 'LinkedIn',
          }),
          b.jsx('a', {
            href: 'mailto:emberuiux@gmail.com',
            className:
              'text-primary hover:animate-bounce easeAnimateStyle py-1',
            children: 'emberuiux@gmail.com',
          }),
        ],
      }),
      b.jsxs('div', {
        className:
          'flex flex-row justify-center items-center space-x-2 max-w-[80%] mx-auto',
        children: [
          b.jsxs('p', {
            className: 'text-sm ',
            children: [
              '© Created by Kevin Shang in React.js powered by a bit too much coffee',
              ' ',
            ],
          }),
          b.jsx('img', {
            src: '/coffee.png',
            alt: 'coffee',
            className: 'w-6 h-6',
          }),
        ],
      }),
    ],
  })
}
const dm = Jb('div'),
  Ix = Jb('img'),
  $R = Jb('path'),
  OZ = ['2022', '2023', '2024', '2025']
function kZ() {
  const n = X.useRef(null),
    e = DZ(n, { once: !0, amount: 0.9 })
  return b.jsx('div', {
    className: '',
    children: b.jsxs('div', {
      className: 'w-full h-auto relative pt-10 pb-40 lg:py-28',
      id: 'timeline',
      style: {
        backgroundImage:
          'linear-gradient(to bottom, rgba(210, 210, 210, 1), rgba(210, 210, 210, 0))',
      },
      children: [
        b.jsxs('div', {
          className: 'w-full hidden xl:block xl:ml-[7%]',
          children: [
            b.jsx('svg', {
              ref: n,
              width: '100%',
              height: '465',
              viewBox: '0 0 1440 500',
              fill: 'none',
              xmlns: 'http://www.w3.org/2000/svg',
              preserveAspectRatio: 'none',
              children: b.jsx($R, {
                d: 'M0 10.4998C63.6667 -13.8335 186.441 -5.39313 267.5 187C350.5 384 561 537.5 804 428C1047 318.5 946.5 24.0997 1488.5 210.5',
                stroke: '#f6f6C6',
                strokeWidth: '1',
                initial: {
                  pathLength: 0,
                  d: 'M0 10.4998C63.6667 -13.8335 186.441 -5.39313 267.5 187C350.5 384 561 537.5 804 428C1047 318.5 946.5 24.0997 1488.5 210.5',
                },
                animate: e
                  ? {
                      pathLength: 1,
                      d: [
                        'M0 10.4998C63.6667 -13.8335 186.441 -5.39313 267.5 187C350.5 384 561 537.5 804 428C1047 318.5 946.5 24.0997 1488.5 210.5',
                        'M0 20.4998C63.6667 -3.8335 186.441 -15.39313 267.5 197C350.5 394 561 527.5 804 438C1047 328.5 946.5 14.0997 1488.5 220.5',
                        'M0 10.4998C63.6667 -13.8335 186.441 -5.39313 267.5 187C350.5 384 561 537.5 804 428C1047 318.5 946.5 24.0997 1488.5 210.5',
                      ],
                    }
                  : { pathLength: 0 },
                transition: {
                  pathLength: { duration: 2, ease: 'easeInOut' },
                  d: { repeat: 1 / 0, duration: 3, ease: 'easeInOut' },
                },
              }),
            }),
            b.jsxs('span', {
              className: 'font-bold absolute top-[21%] left-[8%] ',
              children: [' ', '2022', ' '],
            }),
            b.jsxs('span', {
              className: 'font-bold absolute top-[74%] left-[37%]',
              children: [' ', '2023', ' '],
            }),
            b.jsxs('span', {
              className: 'font-bold absolute top-[62%] left-[72%]',
              children: [' ', '2024', ' '],
            }),
            b.jsxs('span', {
              className: 'font-bold absolute top-[41%] right-[5%]',
              children: [' ', '2025', ' '],
            }),
            b.jsx('p', {
              className: 'timeline-text top-[35%] left-[13%]',
              children: 'Loan Status App',
            }),
            b.jsxs('span', {
              className: 'timeline-text top-[26%] left-[24%]',
              children: [
                'ReadyAI ',
                b.jsx('br', {}),
                b.jsxs('span', {
                  className: 'flex space-x-1',
                  children: [
                    b.jsx('svg', {
                      xmlns: 'http://www.w3.org/2000/svg',
                      viewBox: '0 0 20 20',
                      fill: 'currentColor',
                      className: 'size-5',
                      children: b.jsx('path', {
                        fillRule: 'evenodd',
                        d: 'M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-5.5-2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM10 12a5.99 5.99 0 0 0-4.793 2.39A6.483 6.483 0 0 0 10 16.5a6.483 6.483 0 0 0 4.793-2.11A5.99 5.99 0 0 0 10 12Z',
                        clipRule: 'evenodd',
                      }),
                    }),
                    b.jsx('p', { children: 'UX Design Intern' }),
                  ],
                }),
              ],
            }),
            b.jsxs('p', {
              className: 'timeline-text top-[59%] left-[20%]',
              children: [
                'AZ Laboratories ',
                b.jsx('br', {}),
                ' Dashboard Redesign',
              ],
            }),
            b.jsx('p', {
              className: 'timeline-text top-[55%] left-[32%]',
              children: 'Scooter Screen Redesign',
            }),
            b.jsxs('span', {
              className: 'timeline-text top-[65%] left-[42%]',
              children: [
                'Eth Tech ',
                b.jsx('br', {}),
                ' ',
                b.jsxs('span', {
                  className: 'flex space-x-1',
                  children: [
                    b.jsx('svg', {
                      xmlns: 'http://www.w3.org/2000/svg',
                      viewBox: '0 0 20 20',
                      fill: 'currentColor',
                      className: 'size-5',
                      children: b.jsx('path', {
                        fillRule: 'evenodd',
                        d: 'M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-5.5-2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM10 12a5.99 5.99 0 0 0-4.793 2.39A6.483 6.483 0 0 0 10 16.5a6.483 6.483 0 0 0 4.793-2.11A5.99 5.99 0 0 0 10 12Z',
                        clipRule: 'evenodd',
                      }),
                    }),
                    b.jsx('p', { children: 'Product Designer' }),
                  ],
                }),
              ],
            }),
            b.jsx('p', {
              className: 'timeline-text top-[68%] left-[55%]',
              children: 'YUPI: Urgent Care Design',
            }),
            b.jsxs('span', {
              className: 'timeline-text top-[34%] right-[20%]',
              children: [
                'Varsity Tutor ',
                b.jsx('br', {}),
                b.jsxs('span', {
                  className: 'flex space-x-1',
                  children: [
                    b.jsx('svg', {
                      xmlns: 'http://www.w3.org/2000/svg',
                      viewBox: '0 0 20 20',
                      fill: 'currentColor',
                      className: 'size-5',
                      children: b.jsx('path', {
                        fillRule: 'evenodd',
                        d: 'M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-5.5-2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM10 12a5.99 5.99 0 0 0-4.793 2.39A6.483 6.483 0 0 0 10 16.5a6.483 6.483 0 0 0 4.793-2.11A5.99 5.99 0 0 0 10 12Z',
                        clipRule: 'evenodd',
                      }),
                    }),
                    b.jsx('p', { children: 'Design Lead' }),
                  ],
                }),
              ],
            }),
            b.jsxs('p', {
              className: 'timeline-text top-[40%] right-[10%]',
              children: ['GoValley', b.jsx('br', {}), 'UX Design Intern'],
            }),
            b.jsxs('span', {
              className: 'timeline-text top-[12%] left-[8%] flex space-x-1',
              children: [
                b.jsx('svg', {
                  xmlns: 'http://www.w3.org/2000/svg',
                  viewBox: '0 0 20 20',
                  fill: 'currentColor',
                  className: 'size-5',
                  children: b.jsx('path', {
                    fillRule: 'evenodd',
                    d: 'M9.664 1.319a.75.75 0 0 1 .672 0 41.059 41.059 0 0 1 8.198 5.424.75.75 0 0 1-.254 1.285 31.372 31.372 0 0 0-7.86 3.83.75.75 0 0 1-.84 0 31.508 31.508 0 0 0-2.08-1.287V9.394c0-.244.116-.463.302-.592a35.504 35.504 0 0 1 3.305-2.033.75.75 0 0 0-.714-1.319 37 37 0 0 0-3.446 2.12A2.216 2.216 0 0 0 6 9.393v.38a31.293 31.293 0 0 0-4.28-1.746.75.75 0 0 1-.254-1.285 41.059 41.059 0 0 1 8.198-5.424ZM6 11.459a29.848 29.848 0 0 0-2.455-1.158 41.029 41.029 0 0 0-.39 3.114.75.75 0 0 0 .419.74c.528.256 1.046.53 1.554.82-.21.324-.455.63-.739.914a.75.75 0 1 0 1.06 1.06c.37-.369.69-.77.96-1.193a26.61 26.61 0 0 1 3.095 2.348.75.75 0 0 0 .992 0 26.547 26.547 0 0 1 5.93-3.95.75.75 0 0 0 .42-.739 41.053 41.053 0 0 0-.39-3.114 29.925 29.925 0 0 0-5.199 2.801 2.25 2.25 0 0 1-2.514 0c-.41-.275-.826-.541-1.25-.797a6.985 6.985 0 0 1-1.084 3.45 26.503 26.503 0 0 0-1.281-.78A5.487 5.487 0 0 0 6 12v-.54Z',
                    clipRule: 'evenodd',
                  }),
                }),
                b.jsx('p', {
                  className: '',
                  children: 'BA in CS @ UMN',
                }),
              ],
            }),
            b.jsxs('span', {
              className: 'timeline-text top-[31%] right-[2%] flex space-x-1',
              children: [
                b.jsx('svg', {
                  xmlns: 'http://www.w3.org/2000/svg',
                  viewBox: '0 0 20 20',
                  fill: 'currentColor',
                  className: 'size-5',
                  children: b.jsx('path', {
                    fillRule: 'evenodd',
                    d: 'M9.664 1.319a.75.75 0 0 1 .672 0 41.059 41.059 0 0 1 8.198 5.424.75.75 0 0 1-.254 1.285 31.372 31.372 0 0 0-7.86 3.83.75.75 0 0 1-.84 0 31.508 31.508 0 0 0-2.08-1.287V9.394c0-.244.116-.463.302-.592a35.504 35.504 0 0 1 3.305-2.033.75.75 0 0 0-.714-1.319 37 37 0 0 0-3.446 2.12A2.216 2.216 0 0 0 6 9.393v.38a31.293 31.293 0 0 0-4.28-1.746.75.75 0 0 1-.254-1.285 41.059 41.059 0 0 1 8.198-5.424ZM6 11.459a29.848 29.848 0 0 0-2.455-1.158 41.029 41.029 0 0 0-.39 3.114.75.75 0 0 0 .419.74c.528.256 1.046.53 1.554.82-.21.324-.455.63-.739.914a.75.75 0 1 0 1.06 1.06c.37-.369.69-.77.96-1.193a26.61 26.61 0 0 1 3.095 2.348.75.75 0 0 0 .992 0 26.547 26.547 0 0 1 5.93-3.95.75.75 0 0 0 .42-.739 41.053 41.053 0 0 0-.39-3.114 29.925 29.925 0 0 0-5.199 2.801 2.25 2.25 0 0 1-2.514 0c-.41-.275-.826-.541-1.25-.797a6.985 6.985 0 0 1-1.084 3.45 26.503 26.503 0 0 0-1.281-.78A5.487 5.487 0 0 0 6 12v-.54Z',
                    clipRule: 'evenodd',
                  }),
                }),
                b.jsx('p', { className: '', children: 'MS in HCI @ CMU' }),
              ],
            }),
          ],
        }),
        b.jsxs('div', {
          className: 'block xl:hidden relative w-full sm:w-[60%] mx-auto',
          children: [
            b.jsx('svg', {
              width: '100',
              height: '600',
              viewBox: '0 0 100 600',
              fill: 'none',
              xmlns: 'http://www.w3.org/2000/svg',
              className: 'absolute left-1/2 -translate-x-1/2 z-0',
              children: b.jsx($R, {
                d: `M50 0 
              Q 30 75, 50 150 
              T 50 300 
              T 50 450 
              T 50 600`,
                stroke: '#f6f6C6',
                strokeWidth: '1',
                fill: 'none',
                initial: { pathLength: 0 },
                whileInView: { pathLength: 1 },
                viewport: { once: !0, amount: 0.5 },
                transition: { duration: 2, ease: 'easeInOut' },
              }),
            }),
            b.jsx('div', {
              className: 'space-y-36',
              children: OZ.map((t, i) =>
                b.jsx(
                  'div',
                  {
                    className: 'flex flex-col items-center',
                    children: b.jsx('div', {
                      className: 'font-bold text-gray-700 py-2 px-4 z-20',
                      children: t,
                    }),
                  },
                  i,
                ),
              ),
            }),
            b.jsx('p', {
              className: 'timeline-text top-[10%] left-[9%] text-right pr-4',
              children: '',
            }),
            b.jsxs('span', {
              className: 'timeline-text top-[10%] right-[16%] text-left pl-4',
              children: [
                'ReadyAI ',
                b.jsx('br', {}),
                b.jsxs('span', {
                  className: 'flex space-x-1',
                  children: [
                    b.jsx('svg', {
                      xmlns: 'http://www.w3.org/2000/svg',
                      viewBox: '0 0 20 20',
                      fill: 'currentColor',
                      className: 'size-5',
                      children: b.jsx('path', {
                        fillRule: 'evenodd',
                        d: 'M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-5.5-2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM10 12a5.99 5.99 0 0 0-4.793 2.39A6.483 6.483 0 0 0 10 16.5a6.483 6.483 0 0 0 4.793-2.11A5.99 5.99 0 0 0 10 12Z',
                        clipRule: 'evenodd',
                      }),
                    }),
                    b.jsx('p', { children: 'UX Design Intern' }),
                  ],
                }),
              ],
            }),
            b.jsx('p', {
              className: 'timeline-text top-[20%] right-[13%] text-left pl-4',
              children: 'Healthcare mobile app',
            }),
            b.jsxs('span', {
              className: 'timeline-text top-[40%] left-[16%] text-right pr-4',
              children: [
                'Eth Tech ',
                b.jsx('br', {}),
                b.jsxs('span', {
                  className: 'flex space-x-1',
                  children: [
                    b.jsx('svg', {
                      xmlns: 'http://www.w3.org/2000/svg',
                      viewBox: '0 0 20 20',
                      fill: 'currentColor',
                      className: 'size-5',
                      children: b.jsx('path', {
                        fillRule: 'evenodd',
                        d: 'M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-5.5-2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM10 12a5.99 5.99 0 0 0-4.793 2.39A6.483 6.483 0 0 0 10 16.5a6.483 6.483 0 0 0 4.793-2.11A5.99 5.99 0 0 0 10 12Z',
                        clipRule: 'evenodd',
                      }),
                    }),
                    b.jsx('p', { children: 'Product Designer' }),
                  ],
                }),
              ],
            }),
            b.jsxs('p', {
              className: 'timeline-text top-[45%] right-[15%] text-left pl-4',
              children: ['News Website ', b.jsx('br', {}), ' Editor Dashboard'],
            }),
            b.jsxs('span', {
              className: 'timeline-text top-[70%] left-[10%] text-right pr-4',
              children: [
                'Varsity Tutor ',
                b.jsx('br', {}),
                b.jsxs('span', {
                  className: 'flex space-x-1',
                  children: [
                    b.jsx('svg', {
                      xmlns: 'http://www.w3.org/2000/svg',
                      viewBox: '0 0 20 20',
                      fill: 'currentColor',
                      className: 'size-5',
                      children: b.jsx('path', {
                        fillRule: 'evenodd',
                        d: 'M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-5.5-2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM10 12a5.99 5.99 0 0 0-4.793 2.39A6.483 6.483 0 0 0 10 16.5a6.483 6.483 0 0 0 4.793-2.11A5.99 5.99 0 0 0 10 12Z',
                        clipRule: 'evenodd',
                      }),
                    }),
                    b.jsx('p', { children: 'Capstone Project Design Lead' }),
                  ],
                }),
              ],
            }),
            b.jsxs('span', {
              className:
                'timeline-text top-[85%] right-[10%] text-left pl-4 flex space-x-1',
              children: [
                b.jsx('svg', {
                  xmlns: 'http://www.w3.org/2000/svg',
                  viewBox: '0 0 20 20',
                  fill: 'currentColor',
                  className: 'size-5',
                  children: b.jsx('path', {
                    fillRule: 'evenodd',
                    d: 'M9.664 1.319a.75.75 0 0 1 .672 0 41.059 41.059 0 0 1 8.198 5.424.75.75 0 0 1-.254 1.285 31.372 31.372 0 0 0-7.86 3.83.75.75 0 0 1-.84 0 31.508 31.508 0 0 0-2.08-1.287V9.394c0-.244.116-.463.302-.592a35.504 35.504 0 0 1 3.305-2.033.75.75 0 0 0-.714-1.319 37 37 0 0 0-3.446 2.12A2.216 2.216 0 0 0 6 9.393v.38a31.293 31.293 0 0 0-4.28-1.746.75.75 0 0 1-.254-1.285 41.059 41.059 0 0 1 8.198-5.424ZM6 11.459a29.848 29.848 0 0 0-2.455-1.158 41.029 41.029 0 0 0-.39 3.114.75.75 0 0 0 .419.74c.528.256 1.046.53 1.554.82-.21.324-.455.63-.739.914a.75.75 0 1 0 1.06 1.06c.37-.369.69-.77.96-1.193a26.61 26.61 0 0 1 3.095 2.348.75.75 0 0 0 .992 0 26.547 26.547 0 0 1 5.93-3.95.75.75 0 0 0 .42-.739 41.053 41.053 0 0 0-.39-3.114 29.925 29.925 0 0 0-5.199 2.801 2.25 2.25 0 0 1-2.514 0c-.41-.275-.826-.541-1.25-.797a6.985 6.985 0 0 1-1.084 3.45 26.503 26.503 0 0 0-1.281-.78A5.487 5.487 0 0 0 6 12v-.54Z',
                    clipRule: 'evenodd',
                  }),
                }),
                b.jsx('p', { children: 'MS in HCI @ CMU' }),
              ],
            }),
            b.jsxs('p', {
              className:
                'timeline-text bottom-[-10%] left-[20%] text-right pr-4',
              children: [
                'AI Agent Chatbot ',
                b.jsx('br', {}),
                ' US Navy research',
              ],
            }),
          ],
        }),
      ],
    }),
  })
}
function FZ(n) {
  if (typeof Proxy > 'u') return n
  const e = new Map(),
    t = (...i) => n(...i)
  return new Proxy(t, {
    get: (i, r) =>
      r === 'create' ? n : (e.has(r) || e.set(r, n(r)), e.get(r)),
  })
}
function O_(n) {
  return n !== null && typeof n == 'object' && typeof n.start == 'function'
}
const TM = (n) => Array.isArray(n)
function Pk(n, e) {
  if (!Array.isArray(e)) return !1
  const t = e.length
  if (t !== n.length) return !1
  for (let i = 0; i < t; i++) if (e[i] !== n[i]) return !1
  return !0
}
function gg(n) {
  return typeof n == 'string' || Array.isArray(n)
}
function XR(n) {
  const e = [{}, {}]
  return (
    n == null ||
      n.values.forEach((t, i) => {
        ;(e[0][i] = t.get()), (e[1][i] = t.getVelocity())
      }),
    e
  )
}
function iT(n, e, t, i) {
  if (typeof e == 'function') {
    const [r, s] = XR(i)
    e = e(t !== void 0 ? t : n.custom, r, s)
  }
  if (
    (typeof e == 'string' && (e = n.variants && n.variants[e]),
    typeof e == 'function')
  ) {
    const [r, s] = XR(i)
    e = e(t !== void 0 ? t : n.custom, r, s)
  }
  return e
}
function k_(n, e, t) {
  const i = n.getProps()
  return iT(i, e, t !== void 0 ? t : i.custom, n)
}
const rT = [
    'animate',
    'whileInView',
    'whileFocus',
    'whileHover',
    'whileTap',
    'whileDrag',
    'exit',
  ],
  sT = ['initial', ...rT],
  ks = (n) => n
let AM = ks
function oT(n) {
  let e
  return () => (e === void 0 && (e = n()), e)
}
const bh = (n, e, t) => {
    const i = e - n
    return i === 0 ? 1 : (t - n) / i
  },
  El = (n) => n * 1e3,
  bl = (n) => n / 1e3,
  UZ = oT(() => window.ScrollTimeline !== void 0)
class BZ {
  constructor(e) {
    ;(this.stop = () => this.runAll('stop')),
      (this.animations = e.filter(Boolean))
  }
  get finished() {
    return Promise.all(
      this.animations.map((e) => ('finished' in e ? e.finished : e)),
    )
  }
  getAll(e) {
    return this.animations[0][e]
  }
  setAll(e, t) {
    for (let i = 0; i < this.animations.length; i++) this.animations[i][e] = t
  }
  attachTimeline(e, t) {
    const i = this.animations.map((r) =>
      UZ() && r.attachTimeline ? r.attachTimeline(e) : t(r),
    )
    return () => {
      i.forEach((r, s) => {
        r && r(), this.animations[s].stop()
      })
    }
  }
  get time() {
    return this.getAll('time')
  }
  set time(e) {
    this.setAll('time', e)
  }
  get speed() {
    return this.getAll('speed')
  }
  set speed(e) {
    this.setAll('speed', e)
  }
  get startTime() {
    return this.getAll('startTime')
  }
  get duration() {
    let e = 0
    for (let t = 0; t < this.animations.length; t++)
      e = Math.max(e, this.animations[t].duration)
    return e
  }
  runAll(e) {
    this.animations.forEach((t) => t[e]())
  }
  flatten() {
    this.runAll('flatten')
  }
  play() {
    this.runAll('play')
  }
  pause() {
    this.runAll('pause')
  }
  cancel() {
    this.runAll('cancel')
  }
  complete() {
    this.runAll('complete')
  }
}
class zZ extends BZ {
  then(e, t) {
    return Promise.all(this.animations).then(e).catch(t)
  }
}
function aT(n, e) {
  return n ? n[e] || n.default || n : void 0
}
const CM = 2e4
function Rk(n) {
  let e = 0
  const t = 50
  let i = n.next(e)
  for (; !i.done && e < CM; ) (e += t), (i = n.next(e))
  return e >= CM ? 1 / 0 : e
}
function lT(n) {
  return typeof n == 'function'
}
function qR(n, e) {
  ;(n.timeline = e), (n.onfinish = null)
}
const cT = (n) => Array.isArray(n) && typeof n[0] == 'number',
  VZ = { linearEasing: void 0 }
function jZ(n, e) {
  const t = oT(n)
  return () => {
    var i
    return (i = VZ[e]) !== null && i !== void 0 ? i : t()
  }
}
const Lx = jZ(() => {
    try {
      document
        .createElement('div')
        .animate({ opacity: 0 }, { easing: 'linear(0, 1)' })
    } catch {
      return !1
    }
    return !0
  }, 'linearEasing'),
  Ik = (n, e, t = 10) => {
    let i = ''
    const r = Math.max(Math.round(e / t), 2)
    for (let s = 0; s < r; s++) i += n(bh(0, r - 1, s)) + ', '
    return `linear(${i.substring(0, i.length - 2)})`
  }
function Lk(n) {
  return !!(
    (typeof n == 'function' && Lx()) ||
    !n ||
    (typeof n == 'string' && (n in PM || Lx())) ||
    cT(n) ||
    (Array.isArray(n) && n.every(Lk))
  )
}
const fm = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
  PM = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'ease-in',
    easeOut: 'ease-out',
    easeInOut: 'ease-in-out',
    circIn: fm([0, 0.65, 0.55, 1]),
    circOut: fm([0.55, 0, 1, 0.45]),
    backIn: fm([0.31, 0.01, 0.66, -0.59]),
    backOut: fm([0.33, 1.53, 0.69, 0.99]),
  }
function Nk(n, e) {
  if (n)
    return typeof n == 'function' && Lx()
      ? Ik(n, e)
      : cT(n)
      ? fm(n)
      : Array.isArray(n)
      ? n.map((t) => Nk(t, e) || PM.easeOut)
      : PM[n]
}
const zo = { x: !1, y: !1 }
function Dk() {
  return zo.x || zo.y
}
function Ok(n, e, t) {
  var i
  if (n instanceof Element) return [n]
  if (typeof n == 'string') {
    let r = document
    const s = (i = void 0) !== null && i !== void 0 ? i : r.querySelectorAll(n)
    return s ? Array.from(s) : []
  }
  return Array.from(n)
}
function kk(n, e) {
  const t = Ok(n),
    i = new AbortController(),
    r = { passive: !0, ...e, signal: i.signal }
  return [t, r, () => i.abort()]
}
function YR(n) {
  return (e) => {
    e.pointerType === 'touch' || Dk() || n(e)
  }
}
function HZ(n, e, t = {}) {
  const [i, r, s] = kk(n, t),
    o = YR((a) => {
      const { target: c } = a,
        u = e(a)
      if (!u || !c) return
      const h = YR((m) => {
        u(m), c.removeEventListener('pointerleave', h)
      })
      c.addEventListener('pointerleave', h, r)
    })
  return (
    i.forEach((a) => {
      a.addEventListener('pointerenter', o, r)
    }),
    s
  )
}
const uT = (n) =>
    n.pointerType === 'mouse'
      ? typeof n.button != 'number' || n.button <= 0
      : n.isPrimary !== !1,
  hm = new WeakSet()
function ZR(n) {
  return (e) => {
    e.key === 'Enter' && n(e)
  }
}
function eS(n, e) {
  n.dispatchEvent(
    new PointerEvent('pointer' + e, { isPrimary: !0, bubbles: !0 }),
  )
}
const GZ = (n, e) => {
    const t = n.currentTarget
    if (!t) return
    const i = ZR(() => {
      if (hm.has(t)) return
      eS(t, 'down')
      const r = ZR(() => {
          eS(t, 'up')
        }),
        s = () => eS(t, 'cancel')
      t.addEventListener('keyup', r, e), t.addEventListener('blur', s, e)
    })
    t.addEventListener('keydown', i, e),
      t.addEventListener('blur', () => t.removeEventListener('keydown', i), e)
  },
  WZ = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'])
function $Z(n) {
  return WZ.has(n.tagName) || n.tabIndex !== -1
}
const Fk = (n, e) => (e ? (n === e ? !0 : Fk(n, e.parentElement)) : !1)
function KR(n) {
  return uT(n) && !Dk()
}
function XZ(n, e, t = {}) {
  const [i, r, s] = kk(n, t),
    o = (a) => {
      const c = a.currentTarget
      if (!KR(a) || hm.has(c)) return
      hm.add(c)
      const u = e(a),
        h = (y, _) => {
          window.removeEventListener('pointerup', m),
            window.removeEventListener('pointercancel', g),
            !(!KR(y) || !hm.has(c)) && (hm.delete(c), u && u(y, { success: _ }))
        },
        m = (y) => {
          h(y, t.useGlobalTarget || Fk(c, y.target))
        },
        g = (y) => {
          h(y, !1)
        }
      window.addEventListener('pointerup', m, r),
        window.addEventListener('pointercancel', g, r)
    }
  return (
    i.forEach((a) => {
      $Z(a) || (a.tabIndex = 0),
        (t.useGlobalTarget ? window : a).addEventListener('pointerdown', o, r),
        a.addEventListener('focus', (u) => GZ(u, r), r)
    }),
    s
  )
}
function qZ(n) {
  return n === 'x' || n === 'y'
    ? zo[n]
      ? null
      : ((zo[n] = !0),
        () => {
          zo[n] = !1
        })
    : zo.x || zo.y
    ? null
    : ((zo.x = zo.y = !0),
      () => {
        zo.x = zo.y = !1
      })
}
const Jg = [
    'transformPerspective',
    'x',
    'y',
    'z',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY',
  ],
  Ed = new Set(Jg),
  YZ = (n) => !!(n && typeof n == 'object' && n.mix && n.toValue),
  ZZ = (n) => (TM(n) ? n[n.length - 1] || 0 : n),
  KZ = { skipAnimations: !1, useManualTiming: !1 }
function QZ(n) {
  let e = new Set(),
    t = new Set(),
    i = !1,
    r = !1
  const s = new WeakSet()
  let o = { delta: 0, timestamp: 0, isProcessing: !1 }
  function a(u) {
    s.has(u) && (c.schedule(u), n()), u(o)
  }
  const c = {
    schedule: (u, h = !1, m = !1) => {
      const y = m && i ? e : t
      return h && s.add(u), y.has(u) || y.add(u), u
    },
    cancel: (u) => {
      t.delete(u), s.delete(u)
    },
    process: (u) => {
      if (((o = u), i)) {
        r = !0
        return
      }
      ;(i = !0),
        ([e, t] = [t, e]),
        e.forEach(a),
        e.clear(),
        (i = !1),
        r && ((r = !1), c.process(u))
    },
  }
  return c
}
const hy = [
    'read',
    'resolveKeyframes',
    'update',
    'preRender',
    'render',
    'postRender',
  ],
  JZ = 40
function Uk(n, e) {
  let t = !1,
    i = !0
  const r = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = () => (t = !0),
    o = hy.reduce((x, T) => ((x[T] = QZ(s)), x), {}),
    {
      read: a,
      resolveKeyframes: c,
      update: u,
      preRender: h,
      render: m,
      postRender: g,
    } = o,
    y = () => {
      const x = performance.now()
      ;(t = !1),
        (r.delta = i ? 1e3 / 60 : Math.max(Math.min(x - r.timestamp, JZ), 1)),
        (r.timestamp = x),
        (r.isProcessing = !0),
        a.process(r),
        c.process(r),
        u.process(r),
        h.process(r),
        m.process(r),
        g.process(r),
        (r.isProcessing = !1),
        t && e && ((i = !1), n(y))
    },
    _ = () => {
      ;(t = !0), (i = !0), r.isProcessing || n(y)
    }
  return {
    schedule: hy.reduce((x, T) => {
      const A = o[T]
      return (x[T] = (P, D = !1, O = !1) => (t || _(), A.schedule(P, D, O))), x
    }, {}),
    cancel: (x) => {
      for (let T = 0; T < hy.length; T++) o[hy[T]].cancel(x)
    },
    state: r,
    steps: o,
  }
}
const {
  schedule: ri,
  cancel: Nc,
  state: vr,
  steps: tS,
} = Uk(typeof requestAnimationFrame < 'u' ? requestAnimationFrame : ks, !0)
let Cy
function eK() {
  Cy = void 0
}
const Sa = {
  now: () => (
    Cy === void 0 &&
      Sa.set(
        vr.isProcessing || KZ.useManualTiming
          ? vr.timestamp
          : performance.now(),
      ),
    Cy
  ),
  set: (n) => {
    ;(Cy = n), queueMicrotask(eK)
  },
}
function dT(n, e) {
  n.indexOf(e) === -1 && n.push(e)
}
function fT(n, e) {
  const t = n.indexOf(e)
  t > -1 && n.splice(t, 1)
}
class hT {
  constructor() {
    this.subscriptions = []
  }
  add(e) {
    return dT(this.subscriptions, e), () => fT(this.subscriptions, e)
  }
  notify(e, t, i) {
    const r = this.subscriptions.length
    if (r)
      if (r === 1) this.subscriptions[0](e, t, i)
      else
        for (let s = 0; s < r; s++) {
          const o = this.subscriptions[s]
          o && o(e, t, i)
        }
  }
  getSize() {
    return this.subscriptions.length
  }
  clear() {
    this.subscriptions.length = 0
  }
}
function Bk(n, e) {
  return e ? n * (1e3 / e) : 0
}
const QR = 30,
  tK = (n) => !isNaN(parseFloat(n))
class nK {
  constructor(e, t = {}) {
    ;(this.version = '11.16.0'),
      (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (i, r = !0) => {
        const s = Sa.now()
        this.updatedAt !== s && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(i),
          this.current !== this.prev &&
            this.events.change &&
            this.events.change.notify(this.current),
          r &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current)
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = t.owner)
  }
  setCurrent(e) {
    ;(this.current = e),
      (this.updatedAt = Sa.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = tK(this.current))
  }
  setPrevFrameValue(e = this.current) {
    ;(this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt)
  }
  onChange(e) {
    return this.on('change', e)
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new hT())
    const i = this.events[e].add(t)
    return e === 'change'
      ? () => {
          i(),
            ri.read(() => {
              this.events.change.getSize() || this.stop()
            })
        }
      : i
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear()
  }
  attach(e, t) {
    ;(this.passiveEffect = e), (this.stopPassiveEffect = t)
  }
  set(e, t = !0) {
    !t || !this.passiveEffect
      ? this.updateAndNotify(e, t)
      : this.passiveEffect(e, this.updateAndNotify)
  }
  setWithVelocity(e, t, i) {
    this.set(t),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - i)
  }
  jump(e, t = !0) {
    this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      t && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
  get() {
    return this.current
  }
  getPrevious() {
    return this.prev
  }
  getVelocity() {
    const e = Sa.now()
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > QR
    )
      return 0
    const t = Math.min(this.updatedAt - this.prevUpdatedAt, QR)
    return Bk(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        ;(this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify()
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation()
      })
    )
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation()
  }
  isAnimating() {
    return !!this.animation
  }
  clearAnimation() {
    delete this.animation
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
}
function vg(n, e) {
  return new nK(n, e)
}
function iK(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, vg(t))
}
function rK(n, e) {
  const t = k_(n, e)
  let { transitionEnd: i = {}, transition: r = {}, ...s } = t || {}
  s = { ...s, ...i }
  for (const o in s) {
    const a = ZZ(s[o])
    iK(n, o, a)
  }
}
const Nr = (n) => !!(n && n.getVelocity)
function sK(n) {
  return !!(Nr(n) && n.add)
}
function RM(n, e) {
  const t = n.getValue('willChange')
  if (sK(t)) return t.add(e)
}
const pT = (n) => n.replace(/([a-z])([A-Z])/gu, '$1-$2').toLowerCase(),
  oK = 'framerAppearId',
  zk = 'data-' + pT(oK)
function Vk(n) {
  return n.props[zk]
}
const jk = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  aK = 1e-7,
  lK = 12
function cK(n, e, t, i, r) {
  let s,
    o,
    a = 0
  do (o = e + (t - e) / 2), (s = jk(o, i, r) - n), s > 0 ? (t = o) : (e = o)
  while (Math.abs(s) > aK && ++a < lK)
  return o
}
function ev(n, e, t, i) {
  if (n === e && t === i) return ks
  const r = (s) => cK(s, 0, 1, n, t)
  return (s) => (s === 0 || s === 1 ? s : jk(r(s), e, i))
}
const Hk = (n) => (e) => e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
  Gk = (n) => (e) => 1 - n(1 - e),
  Wk = ev(0.33, 1.53, 0.69, 0.99),
  mT = Gk(Wk),
  $k = Hk(mT),
  Xk = (n) =>
    (n *= 2) < 1 ? 0.5 * mT(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  gT = (n) => 1 - Math.sin(Math.acos(n)),
  qk = Gk(gT),
  Yk = Hk(gT),
  Zk = (n) => /^0[^.\s]+$/u.test(n)
function uK(n) {
  return typeof n == 'number'
    ? n === 0
    : n !== null
    ? n === 'none' || n === '0' || Zk(n)
    : !0
}
const Kk = (n) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n),
  Qk = (n) => (e) => typeof e == 'string' && e.startsWith(n),
  Jk = Qk('--'),
  dK = Qk('var(--'),
  vT = (n) => (dK(n) ? fK.test(n.split('/*')[0].trim()) : !1),
  fK =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  hK = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
function pK(n) {
  const e = hK.exec(n)
  if (!e) return [,]
  const [, t, i, r] = e
  return [`--${t ?? i}`, r]
}
function eF(n, e, t = 1) {
  const [i, r] = pK(n)
  if (!i) return
  const s = window.getComputedStyle(e).getPropertyValue(i)
  if (s) {
    const o = s.trim()
    return Kk(o) ? parseFloat(o) : o
  }
  return vT(r) ? eF(r, e, t + 1) : r
}
const Pl = (n, e, t) => (t > e ? e : t < n ? n : t),
  kh = {
    test: (n) => typeof n == 'number',
    parse: parseFloat,
    transform: (n) => n,
  },
  yg = { ...kh, transform: (n) => Pl(0, 1, n) },
  py = { ...kh, default: 1 },
  tv = (n) => ({
    test: (e) =>
      typeof e == 'string' && e.endsWith(n) && e.split(' ').length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  _c = tv('deg'),
  Ma = tv('%'),
  Zt = tv('px'),
  mK = tv('vh'),
  gK = tv('vw'),
  JR = {
    ...Ma,
    parse: (n) => Ma.parse(n) / 100,
    transform: (n) => Ma.transform(n * 100),
  },
  vK = new Set([
    'width',
    'height',
    'top',
    'left',
    'right',
    'bottom',
    'x',
    'y',
    'translateX',
    'translateY',
  ]),
  e3 = (n) => n === kh || n === Zt,
  t3 = (n, e) => parseFloat(n.split(', ')[e]),
  n3 =
    (n, e) =>
    (t, { transform: i }) => {
      if (i === 'none' || !i) return 0
      const r = i.match(/^matrix3d\((.+)\)$/u)
      if (r) return t3(r[1], e)
      {
        const s = i.match(/^matrix\((.+)\)$/u)
        return s ? t3(s[1], n) : 0
      }
    },
  yK = new Set(['x', 'y', 'z']),
  xK = Jg.filter((n) => !yK.has(n))
function _K(n) {
  const e = []
  return (
    xK.forEach((t) => {
      const i = n.getValue(t)
      i !== void 0 &&
        (e.push([t, i.get()]), i.set(t.startsWith('scale') ? 1 : 0))
    }),
    e
  )
}
const Th = {
  width: ({ x: n }, { paddingLeft: e = '0', paddingRight: t = '0' }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  height: ({ y: n }, { paddingTop: e = '0', paddingBottom: t = '0' }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  top: (n, { top: e }) => parseFloat(e),
  left: (n, { left: e }) => parseFloat(e),
  bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
  right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
  x: n3(4, 13),
  y: n3(5, 14),
}
Th.translateX = Th.x
Th.translateY = Th.y
const tF = (n) => (e) => e.test(n),
  wK = { test: (n) => n === 'auto', parse: (n) => n },
  nF = [kh, Zt, Ma, _c, gK, mK, wK],
  i3 = (n) => nF.find(tF(n)),
  fd = new Set()
let IM = !1,
  LM = !1
function iF() {
  if (LM) {
    const n = Array.from(fd).filter((i) => i.needsMeasurement),
      e = new Set(n.map((i) => i.element)),
      t = new Map()
    e.forEach((i) => {
      const r = _K(i)
      r.length && (t.set(i, r), i.render())
    }),
      n.forEach((i) => i.measureInitialState()),
      e.forEach((i) => {
        i.render()
        const r = t.get(i)
        r &&
          r.forEach(([s, o]) => {
            var a
            ;(a = i.getValue(s)) === null || a === void 0 || a.set(o)
          })
      }),
      n.forEach((i) => i.measureEndState()),
      n.forEach((i) => {
        i.suspendedScrollY !== void 0 && window.scrollTo(0, i.suspendedScrollY)
      })
  }
  ;(LM = !1), (IM = !1), fd.forEach((n) => n.complete()), fd.clear()
}
function rF() {
  fd.forEach((n) => {
    n.readKeyframes(), n.needsMeasurement && (LM = !0)
  })
}
function SK() {
  rF(), iF()
}
class yT {
  constructor(e, t, i, r, s, o = !1) {
    ;(this.isComplete = !1),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.isScheduled = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = t),
      (this.name = i),
      (this.motionValue = r),
      (this.element = s),
      (this.isAsync = o)
  }
  scheduleResolve() {
    ;(this.isScheduled = !0),
      this.isAsync
        ? (fd.add(this),
          IM || ((IM = !0), ri.read(rF), ri.resolveKeyframes(iF)))
        : (this.readKeyframes(), this.complete())
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: t, element: i, motionValue: r } = this
    for (let s = 0; s < e.length; s++)
      if (e[s] === null)
        if (s === 0) {
          const o = r == null ? void 0 : r.get(),
            a = e[e.length - 1]
          if (o !== void 0) e[0] = o
          else if (i && t) {
            const c = i.readValue(t, a)
            c != null && (e[0] = c)
          }
          e[0] === void 0 && (e[0] = a), r && o === void 0 && r.set(e[0])
        } else e[s] = e[s - 1]
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    ;(this.isComplete = !0),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
      fd.delete(this)
  }
  cancel() {
    this.isComplete || ((this.isScheduled = !1), fd.delete(this))
  }
  resume() {
    this.isComplete || this.scheduleResolve()
  }
}
const Om = (n) => Math.round(n * 1e5) / 1e5,
  xT = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu
function MK(n) {
  return n == null
}
const EK =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  _T = (n, e) => (t) =>
    !!(
      (typeof t == 'string' && EK.test(t) && t.startsWith(n)) ||
      (e && !MK(t) && Object.prototype.hasOwnProperty.call(t, e))
    ),
  sF = (n, e, t) => (i) => {
    if (typeof i != 'string') return i
    const [r, s, o, a] = i.match(xT)
    return {
      [n]: parseFloat(r),
      [e]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    }
  },
  bK = (n) => Pl(0, 255, n),
  nS = { ...kh, transform: (n) => Math.round(bK(n)) },
  sd = {
    test: _T('rgb', 'red'),
    parse: sF('red', 'green', 'blue'),
    transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) =>
      'rgba(' +
      nS.transform(n) +
      ', ' +
      nS.transform(e) +
      ', ' +
      nS.transform(t) +
      ', ' +
      Om(yg.transform(i)) +
      ')',
  }
function TK(n) {
  let e = '',
    t = '',
    i = '',
    r = ''
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (i = n.substring(5, 7)),
        (r = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (i = n.substring(3, 4)),
        (r = n.substring(4, 5)),
        (e += e),
        (t += t),
        (i += i),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  )
}
const NM = { test: _T('#'), parse: TK, transform: sd.transform },
  rh = {
    test: _T('hsl', 'hue'),
    parse: sF('hue', 'saturation', 'lightness'),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) =>
      'hsla(' +
      Math.round(n) +
      ', ' +
      Ma.transform(Om(e)) +
      ', ' +
      Ma.transform(Om(t)) +
      ', ' +
      Om(yg.transform(i)) +
      ')',
  },
  Ir = {
    test: (n) => sd.test(n) || NM.test(n) || rh.test(n),
    parse: (n) =>
      sd.test(n) ? sd.parse(n) : rh.test(n) ? rh.parse(n) : NM.parse(n),
    transform: (n) =>
      typeof n == 'string'
        ? n
        : n.hasOwnProperty('red')
        ? sd.transform(n)
        : rh.transform(n),
  },
  AK =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu
function CK(n) {
  var e, t
  return (
    isNaN(n) &&
    typeof n == 'string' &&
    (((e = n.match(xT)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((t = n.match(AK)) === null || t === void 0 ? void 0 : t.length) || 0) >
      0
  )
}
const oF = 'number',
  aF = 'color',
  PK = 'var',
  RK = 'var(',
  r3 = '${}',
  IK =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu
function xg(n) {
  const e = n.toString(),
    t = [],
    i = { color: [], number: [], var: [] },
    r = []
  let s = 0
  const a = e
    .replace(
      IK,
      (c) => (
        Ir.test(c)
          ? (i.color.push(s), r.push(aF), t.push(Ir.parse(c)))
          : c.startsWith(RK)
          ? (i.var.push(s), r.push(PK), t.push(c))
          : (i.number.push(s), r.push(oF), t.push(parseFloat(c))),
        ++s,
        r3
      ),
    )
    .split(r3)
  return { values: t, split: a, indexes: i, types: r }
}
function lF(n) {
  return xg(n).values
}
function cF(n) {
  const { split: e, types: t } = xg(n),
    i = e.length
  return (r) => {
    let s = ''
    for (let o = 0; o < i; o++)
      if (((s += e[o]), r[o] !== void 0)) {
        const a = t[o]
        a === oF
          ? (s += Om(r[o]))
          : a === aF
          ? (s += Ir.transform(r[o]))
          : (s += r[o])
      }
    return s
  }
}
const LK = (n) => (typeof n == 'number' ? 0 : n)
function NK(n) {
  const e = lF(n)
  return cF(n)(e.map(LK))
}
const Dc = {
    test: CK,
    parse: lF,
    createTransformer: cF,
    getAnimatableNone: NK,
  },
  DK = new Set(['brightness', 'contrast', 'saturate', 'opacity'])
function OK(n) {
  const [e, t] = n.slice(0, -1).split('(')
  if (e === 'drop-shadow') return n
  const [i] = t.match(xT) || []
  if (!i) return n
  const r = t.replace(i, '')
  let s = DK.has(e) ? 1 : 0
  return i !== t && (s *= 100), e + '(' + s + r + ')'
}
const kK = /\b([a-z-]*)\(.*?\)/gu,
  DM = {
    ...Dc,
    getAnimatableNone: (n) => {
      const e = n.match(kK)
      return e ? e.map(OK).join(' ') : n
    },
  },
  FK = {
    borderWidth: Zt,
    borderTopWidth: Zt,
    borderRightWidth: Zt,
    borderBottomWidth: Zt,
    borderLeftWidth: Zt,
    borderRadius: Zt,
    radius: Zt,
    borderTopLeftRadius: Zt,
    borderTopRightRadius: Zt,
    borderBottomRightRadius: Zt,
    borderBottomLeftRadius: Zt,
    width: Zt,
    maxWidth: Zt,
    height: Zt,
    maxHeight: Zt,
    top: Zt,
    right: Zt,
    bottom: Zt,
    left: Zt,
    padding: Zt,
    paddingTop: Zt,
    paddingRight: Zt,
    paddingBottom: Zt,
    paddingLeft: Zt,
    margin: Zt,
    marginTop: Zt,
    marginRight: Zt,
    marginBottom: Zt,
    marginLeft: Zt,
    backgroundPositionX: Zt,
    backgroundPositionY: Zt,
  },
  UK = {
    rotate: _c,
    rotateX: _c,
    rotateY: _c,
    rotateZ: _c,
    scale: py,
    scaleX: py,
    scaleY: py,
    scaleZ: py,
    skew: _c,
    skewX: _c,
    skewY: _c,
    distance: Zt,
    translateX: Zt,
    translateY: Zt,
    translateZ: Zt,
    x: Zt,
    y: Zt,
    z: Zt,
    perspective: Zt,
    transformPerspective: Zt,
    opacity: yg,
    originX: JR,
    originY: JR,
    originZ: Zt,
  },
  s3 = { ...kh, transform: Math.round },
  wT = {
    ...FK,
    ...UK,
    zIndex: s3,
    size: Zt,
    fillOpacity: yg,
    strokeOpacity: yg,
    numOctaves: s3,
  },
  BK = {
    ...wT,
    color: Ir,
    backgroundColor: Ir,
    outlineColor: Ir,
    fill: Ir,
    stroke: Ir,
    borderColor: Ir,
    borderTopColor: Ir,
    borderRightColor: Ir,
    borderBottomColor: Ir,
    borderLeftColor: Ir,
    filter: DM,
    WebkitFilter: DM,
  },
  ST = (n) => BK[n]
function uF(n, e) {
  let t = ST(n)
  return (
    t !== DM && (t = Dc), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  )
}
const zK = new Set(['auto', 'none', '0'])
function VK(n, e, t) {
  let i = 0,
    r
  for (; i < n.length && !r; ) {
    const s = n[i]
    typeof s == 'string' && !zK.has(s) && xg(s).values.length && (r = n[i]), i++
  }
  if (r && t) for (const s of e) n[s] = uF(t, r)
}
class dF extends yT {
  constructor(e, t, i, r, s) {
    super(e, t, i, r, s, !0)
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: t, name: i } = this
    if (!t || !t.current) return
    super.readKeyframes()
    for (let c = 0; c < e.length; c++) {
      let u = e[c]
      if (typeof u == 'string' && ((u = u.trim()), vT(u))) {
        const h = eF(u, t.current)
        h !== void 0 && (e[c] = h),
          c === e.length - 1 && (this.finalKeyframe = u)
      }
    }
    if ((this.resolveNoneKeyframes(), !vK.has(i) || e.length !== 2)) return
    const [r, s] = e,
      o = i3(r),
      a = i3(s)
    if (o !== a)
      if (e3(o) && e3(a))
        for (let c = 0; c < e.length; c++) {
          const u = e[c]
          typeof u == 'string' && (e[c] = parseFloat(u))
        }
      else this.needsMeasurement = !0
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: t } = this,
      i = []
    for (let r = 0; r < e.length; r++) uK(e[r]) && i.push(r)
    i.length && VK(e, i, t)
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: t, name: i } = this
    if (!e || !e.current) return
    i === 'height' && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = Th[i](
        e.measureViewportBox(),
        window.getComputedStyle(e.current),
      )),
      (t[0] = this.measuredOrigin)
    const r = t[t.length - 1]
    r !== void 0 && e.getValue(i, r).jump(r, !1)
  }
  measureEndState() {
    var e
    const { element: t, name: i, unresolvedKeyframes: r } = this
    if (!t || !t.current) return
    const s = t.getValue(i)
    s && s.jump(this.measuredOrigin, !1)
    const o = r.length - 1,
      a = r[o]
    ;(r[o] = Th[i](t.measureViewportBox(), window.getComputedStyle(t.current))),
      a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a),
      !((e = this.removedTransforms) === null || e === void 0) &&
        e.length &&
        this.removedTransforms.forEach(([c, u]) => {
          t.getValue(c).set(u)
        }),
      this.resolveNoneKeyframes()
  }
}
const o3 = (n, e) =>
  e === 'zIndex'
    ? !1
    : !!(
        typeof n == 'number' ||
        Array.isArray(n) ||
        (typeof n == 'string' &&
          (Dc.test(n) || n === '0') &&
          !n.startsWith('url('))
      )
function jK(n) {
  const e = n[0]
  if (n.length === 1) return !0
  for (let t = 0; t < n.length; t++) if (n[t] !== e) return !0
}
function HK(n, e, t, i) {
  const r = n[0]
  if (r === null) return !1
  if (e === 'display' || e === 'visibility') return !0
  const s = n[n.length - 1],
    o = o3(r, e),
    a = o3(s, e)
  return !o || !a ? !1 : jK(n) || ((t === 'spring' || lT(t)) && i)
}
const GK = (n) => n !== null
function F_(n, { repeat: e, repeatType: t = 'loop' }, i) {
  const r = n.filter(GK),
    s = e && t !== 'loop' && e % 2 === 1 ? 0 : r.length - 1
  return !s || i === void 0 ? r[s] : i
}
const WK = 40
class fF {
  constructor({
    autoplay: e = !0,
    delay: t = 0,
    type: i = 'keyframes',
    repeat: r = 0,
    repeatDelay: s = 0,
    repeatType: o = 'loop',
    ...a
  }) {
    ;(this.isStopped = !1),
      (this.hasAttemptedResolve = !1),
      (this.createdAt = Sa.now()),
      (this.options = {
        autoplay: e,
        delay: t,
        type: i,
        repeat: r,
        repeatDelay: s,
        repeatType: o,
        ...a,
      }),
      this.updateFinishedPromise()
  }
  calcStartTime() {
    return this.resolvedAt
      ? this.resolvedAt - this.createdAt > WK
        ? this.resolvedAt
        : this.createdAt
      : this.createdAt
  }
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && SK(), this._resolved
  }
  onKeyframesResolved(e, t) {
    ;(this.resolvedAt = Sa.now()), (this.hasAttemptedResolve = !0)
    const {
      name: i,
      type: r,
      velocity: s,
      delay: o,
      onComplete: a,
      onUpdate: c,
      isGenerator: u,
    } = this.options
    if (!u && !HK(e, i, r, s))
      if (o) this.options.duration = 0
      else {
        c == null || c(F_(e, this.options, t)),
          a == null || a(),
          this.resolveFinishedPromise()
        return
      }
    const h = this.initPlayback(e, t)
    h !== !1 &&
      ((this._resolved = { keyframes: e, finalKeyframe: t, ...h }),
      this.onPostResolved())
  }
  onPostResolved() {}
  then(e, t) {
    return this.currentFinishedPromise.then(e, t)
  }
  flatten() {
    ;(this.options.type = 'keyframes'), (this.options.ease = 'linear')
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e
    })
  }
}
const mi = (n, e, t) => n + (e - n) * t
function iS(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  )
}
function $K({ hue: n, saturation: e, lightness: t, alpha: i }) {
  ;(n /= 360), (e /= 100), (t /= 100)
  let r = 0,
    s = 0,
    o = 0
  if (!e) r = s = o = t
  else {
    const a = t < 0.5 ? t * (1 + e) : t + e - t * e,
      c = 2 * t - a
    ;(r = iS(c, a, n + 1 / 3)), (s = iS(c, a, n)), (o = iS(c, a, n - 1 / 3))
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: i,
  }
}
function Nx(n, e) {
  return (t) => (t > 0 ? e : n)
}
const rS = (n, e, t) => {
    const i = n * n,
      r = t * (e * e - i) + i
    return r < 0 ? 0 : Math.sqrt(r)
  },
  XK = [NM, sd, rh],
  qK = (n) => XK.find((e) => e.test(n))
function a3(n) {
  const e = qK(n)
  if (!e) return !1
  let t = e.parse(n)
  return e === rh && (t = $K(t)), t
}
const l3 = (n, e) => {
    const t = a3(n),
      i = a3(e)
    if (!t || !i) return Nx(n, e)
    const r = { ...t }
    return (s) => (
      (r.red = rS(t.red, i.red, s)),
      (r.green = rS(t.green, i.green, s)),
      (r.blue = rS(t.blue, i.blue, s)),
      (r.alpha = mi(t.alpha, i.alpha, s)),
      sd.transform(r)
    )
  },
  YK = (n, e) => (t) => e(n(t)),
  nv = (...n) => n.reduce(YK),
  OM = new Set(['none', 'hidden'])
function ZK(n, e) {
  return OM.has(n) ? (t) => (t <= 0 ? n : e) : (t) => (t >= 1 ? e : n)
}
function KK(n, e) {
  return (t) => mi(n, e, t)
}
function MT(n) {
  return typeof n == 'number'
    ? KK
    : typeof n == 'string'
    ? vT(n)
      ? Nx
      : Ir.test(n)
      ? l3
      : eQ
    : Array.isArray(n)
    ? hF
    : typeof n == 'object'
    ? Ir.test(n)
      ? l3
      : QK
    : Nx
}
function hF(n, e) {
  const t = [...n],
    i = t.length,
    r = n.map((s, o) => MT(s)(s, e[o]))
  return (s) => {
    for (let o = 0; o < i; o++) t[o] = r[o](s)
    return t
  }
}
function QK(n, e) {
  const t = { ...n, ...e },
    i = {}
  for (const r in t)
    n[r] !== void 0 && e[r] !== void 0 && (i[r] = MT(n[r])(n[r], e[r]))
  return (r) => {
    for (const s in i) t[s] = i[s](r)
    return t
  }
}
function JK(n, e) {
  var t
  const i = [],
    r = { color: 0, var: 0, number: 0 }
  for (let s = 0; s < e.values.length; s++) {
    const o = e.types[s],
      a = n.indexes[o][r[o]],
      c = (t = n.values[a]) !== null && t !== void 0 ? t : 0
    ;(i[s] = c), r[o]++
  }
  return i
}
const eQ = (n, e) => {
  const t = Dc.createTransformer(e),
    i = xg(n),
    r = xg(e)
  return i.indexes.var.length === r.indexes.var.length &&
    i.indexes.color.length === r.indexes.color.length &&
    i.indexes.number.length >= r.indexes.number.length
    ? (OM.has(n) && !r.values.length) || (OM.has(e) && !i.values.length)
      ? ZK(n, e)
      : nv(hF(JK(i, r), r.values), t)
    : Nx(n, e)
}
function pF(n, e, t) {
  return typeof n == 'number' && typeof e == 'number' && typeof t == 'number'
    ? mi(n, e, t)
    : MT(n)(n, e)
}
const tQ = 5
function mF(n, e, t) {
  const i = Math.max(e - tQ, 0)
  return Bk(t - n(i), e - i)
}
const Ei = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  sS = 0.001
function nQ({
  duration: n = Ei.duration,
  bounce: e = Ei.bounce,
  velocity: t = Ei.velocity,
  mass: i = Ei.mass,
}) {
  let r,
    s,
    o = 1 - e
  ;(o = Pl(Ei.minDamping, Ei.maxDamping, o)),
    (n = Pl(Ei.minDuration, Ei.maxDuration, bl(n))),
    o < 1
      ? ((r = (u) => {
          const h = u * o,
            m = h * n,
            g = h - t,
            y = kM(u, o),
            _ = Math.exp(-m)
          return sS - (g / y) * _
        }),
        (s = (u) => {
          const m = u * o * n,
            g = m * t + t,
            y = Math.pow(o, 2) * Math.pow(u, 2) * n,
            _ = Math.exp(-m),
            M = kM(Math.pow(u, 2), o)
          return ((-r(u) + sS > 0 ? -1 : 1) * ((g - y) * _)) / M
        }))
      : ((r = (u) => {
          const h = Math.exp(-u * n),
            m = (u - t) * n + 1
          return -sS + h * m
        }),
        (s = (u) => {
          const h = Math.exp(-u * n),
            m = (t - u) * (n * n)
          return h * m
        }))
  const a = 5 / n,
    c = rQ(r, s, a)
  if (((n = El(n)), isNaN(c)))
    return { stiffness: Ei.stiffness, damping: Ei.damping, duration: n }
  {
    const u = Math.pow(c, 2) * i
    return { stiffness: u, damping: o * 2 * Math.sqrt(i * u), duration: n }
  }
}
const iQ = 12
function rQ(n, e, t) {
  let i = t
  for (let r = 1; r < iQ; r++) i = i - n(i) / e(i)
  return i
}
function kM(n, e) {
  return n * Math.sqrt(1 - e * e)
}
const sQ = ['duration', 'bounce'],
  oQ = ['stiffness', 'damping', 'mass']
function c3(n, e) {
  return e.some((t) => n[t] !== void 0)
}
function aQ(n) {
  let e = {
    velocity: Ei.velocity,
    stiffness: Ei.stiffness,
    damping: Ei.damping,
    mass: Ei.mass,
    isResolvedFromDuration: !1,
    ...n,
  }
  if (!c3(n, oQ) && c3(n, sQ))
    if (n.visualDuration) {
      const t = n.visualDuration,
        i = (2 * Math.PI) / (t * 1.2),
        r = i * i,
        s = 2 * Pl(0.05, 1, 1 - (n.bounce || 0)) * Math.sqrt(r)
      e = { ...e, mass: Ei.mass, stiffness: r, damping: s }
    } else {
      const t = nQ(n)
      ;(e = { ...e, ...t, mass: Ei.mass }), (e.isResolvedFromDuration = !0)
    }
  return e
}
function gF(n = Ei.visualDuration, e = Ei.bounce) {
  const t =
    typeof n != 'object'
      ? { visualDuration: n, keyframes: [0, 1], bounce: e }
      : n
  let { restSpeed: i, restDelta: r } = t
  const s = t.keyframes[0],
    o = t.keyframes[t.keyframes.length - 1],
    a = { done: !1, value: s },
    {
      stiffness: c,
      damping: u,
      mass: h,
      duration: m,
      velocity: g,
      isResolvedFromDuration: y,
    } = aQ({ ...t, velocity: -bl(t.velocity || 0) }),
    _ = g || 0,
    M = u / (2 * Math.sqrt(c * h)),
    w = o - s,
    x = bl(Math.sqrt(c / h)),
    T = Math.abs(w) < 5
  i || (i = T ? Ei.restSpeed.granular : Ei.restSpeed.default),
    r || (r = T ? Ei.restDelta.granular : Ei.restDelta.default)
  let A
  if (M < 1) {
    const D = kM(x, M)
    A = (O) => {
      const U = Math.exp(-M * x * O)
      return (
        o - U * (((_ + M * x * w) / D) * Math.sin(D * O) + w * Math.cos(D * O))
      )
    }
  } else if (M === 1) A = (D) => o - Math.exp(-x * D) * (w + (_ + x * w) * D)
  else {
    const D = x * Math.sqrt(M * M - 1)
    A = (O) => {
      const U = Math.exp(-M * x * O),
        F = Math.min(D * O, 300)
      return (
        o - (U * ((_ + M * x * w) * Math.sinh(F) + D * w * Math.cosh(F))) / D
      )
    }
  }
  const P = {
    calculatedDuration: (y && m) || null,
    next: (D) => {
      const O = A(D)
      if (y) a.done = D >= m
      else {
        let U = 0
        M < 1 && (U = D === 0 ? El(_) : mF(A, D, O))
        const F = Math.abs(U) <= i,
          N = Math.abs(o - O) <= r
        a.done = F && N
      }
      return (a.value = a.done ? o : O), a
    },
    toString: () => {
      const D = Math.min(Rk(P), CM),
        O = Ik((U) => P.next(D * U).value, D, 30)
      return D + 'ms ' + O
    },
  }
  return P
}
function u3({
  keyframes: n,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: i = 325,
  bounceDamping: r = 10,
  bounceStiffness: s = 500,
  modifyTarget: o,
  min: a,
  max: c,
  restDelta: u = 0.5,
  restSpeed: h,
}) {
  const m = n[0],
    g = { done: !1, value: m },
    y = (F) => (a !== void 0 && F < a) || (c !== void 0 && F > c),
    _ = (F) =>
      a === void 0
        ? c
        : c === void 0 || Math.abs(a - F) < Math.abs(c - F)
        ? a
        : c
  let M = t * e
  const w = m + M,
    x = o === void 0 ? w : o(w)
  x !== w && (M = x - m)
  const T = (F) => -M * Math.exp(-F / i),
    A = (F) => x + T(F),
    P = (F) => {
      const N = T(F),
        k = A(F)
      ;(g.done = Math.abs(N) <= u), (g.value = g.done ? x : k)
    }
  let D, O
  const U = (F) => {
    y(g.value) &&
      ((D = F),
      (O = gF({
        keyframes: [g.value, _(g.value)],
        velocity: mF(A, F, g.value),
        damping: r,
        stiffness: s,
        restDelta: u,
        restSpeed: h,
      })))
  }
  return (
    U(0),
    {
      calculatedDuration: null,
      next: (F) => {
        let N = !1
        return (
          !O && D === void 0 && ((N = !0), P(F), U(F)),
          D !== void 0 && F >= D ? O.next(F - D) : (!N && P(F), g)
        )
      },
    }
  )
}
const lQ = ev(0.42, 0, 1, 1),
  cQ = ev(0, 0, 0.58, 1),
  vF = ev(0.42, 0, 0.58, 1),
  uQ = (n) => Array.isArray(n) && typeof n[0] != 'number',
  d3 = {
    linear: ks,
    easeIn: lQ,
    easeInOut: vF,
    easeOut: cQ,
    circIn: gT,
    circInOut: Yk,
    circOut: qk,
    backIn: mT,
    backInOut: $k,
    backOut: Wk,
    anticipate: Xk,
  },
  f3 = (n) => {
    if (cT(n)) {
      AM(n.length === 4)
      const [e, t, i, r] = n
      return ev(e, t, i, r)
    } else if (typeof n == 'string') return AM(d3[n] !== void 0), d3[n]
    return n
  }
function dQ(n, e, t) {
  const i = [],
    r = t || pF,
    s = n.length - 1
  for (let o = 0; o < s; o++) {
    let a = r(n[o], n[o + 1])
    if (e) {
      const c = Array.isArray(e) ? e[o] || ks : e
      a = nv(c, a)
    }
    i.push(a)
  }
  return i
}
function fQ(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) {
  const s = n.length
  if ((AM(s === e.length), s === 1)) return () => e[0]
  if (s === 2 && n[0] === n[1]) return () => e[1]
  n[0] > n[s - 1] && ((n = [...n].reverse()), (e = [...e].reverse()))
  const o = dQ(e, i, r),
    a = o.length,
    c = (u) => {
      let h = 0
      if (a > 1) for (; h < n.length - 2 && !(u < n[h + 1]); h++);
      const m = bh(n[h], n[h + 1], u)
      return o[h](m)
    }
  return t ? (u) => c(Pl(n[0], n[s - 1], u)) : c
}
function hQ(n, e) {
  const t = n[n.length - 1]
  for (let i = 1; i <= e; i++) {
    const r = bh(0, e, i)
    n.push(mi(t, 1, r))
  }
}
function pQ(n) {
  const e = [0]
  return hQ(e, n.length - 1), e
}
function mQ(n, e) {
  return n.map((t) => t * e)
}
function gQ(n, e) {
  return n.map(() => e || vF).splice(0, n.length - 1)
}
function Dx({
  duration: n = 300,
  keyframes: e,
  times: t,
  ease: i = 'easeInOut',
}) {
  const r = uQ(i) ? i.map(f3) : f3(i),
    s = { done: !1, value: e[0] },
    o = mQ(t && t.length === e.length ? t : pQ(e), n),
    a = fQ(o, e, { ease: Array.isArray(r) ? r : gQ(e, r) })
  return {
    calculatedDuration: n,
    next: (c) => ((s.value = a(c)), (s.done = c >= n), s),
  }
}
const vQ = (n) => {
    const e = ({ timestamp: t }) => n(t)
    return {
      start: () => ri.update(e, !0),
      stop: () => Nc(e),
      now: () => (vr.isProcessing ? vr.timestamp : Sa.now()),
    }
  },
  yQ = { decay: u3, inertia: u3, tween: Dx, keyframes: Dx, spring: gF },
  xQ = (n) => n / 100
class ET extends fF {
  constructor(e) {
    super(e),
      (this.holdTime = null),
      (this.cancelTime = null),
      (this.currentTime = 0),
      (this.playbackSpeed = 1),
      (this.pendingPlayState = 'running'),
      (this.startTime = null),
      (this.state = 'idle'),
      (this.stop = () => {
        if (
          (this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle')
        )
          return
        this.teardown()
        const { onStop: c } = this.options
        c && c()
      })
    const { name: t, motionValue: i, element: r, keyframes: s } = this.options,
      o = (r == null ? void 0 : r.KeyframeResolver) || yT,
      a = (c, u) => this.onKeyframesResolved(c, u)
    ;(this.resolver = new o(s, a, t, i, r)), this.resolver.scheduleResolve()
  }
  flatten() {
    super.flatten(),
      this._resolved &&
        Object.assign(
          this._resolved,
          this.initPlayback(this._resolved.keyframes),
        )
  }
  initPlayback(e) {
    const {
        type: t = 'keyframes',
        repeat: i = 0,
        repeatDelay: r = 0,
        repeatType: s,
        velocity: o = 0,
      } = this.options,
      a = lT(t) ? t : yQ[t] || Dx
    let c, u
    a !== Dx &&
      typeof e[0] != 'number' &&
      ((c = nv(xQ, pF(e[0], e[1]))), (e = [0, 100]))
    const h = a({ ...this.options, keyframes: e })
    s === 'mirror' &&
      (u = a({ ...this.options, keyframes: [...e].reverse(), velocity: -o })),
      h.calculatedDuration === null && (h.calculatedDuration = Rk(h))
    const { calculatedDuration: m } = h,
      g = m + r,
      y = g * (i + 1) - r
    return {
      generator: h,
      mirroredGenerator: u,
      mapPercentToKeyframes: c,
      calculatedDuration: m,
      resolvedDuration: g,
      totalDuration: y,
    }
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options
    this.play(),
      this.pendingPlayState === 'paused' || !e
        ? this.pause()
        : (this.state = this.pendingPlayState)
  }
  tick(e, t = !1) {
    const { resolved: i } = this
    if (!i) {
      const { keyframes: F } = this.options
      return { done: !0, value: F[F.length - 1] }
    }
    const {
      finalKeyframe: r,
      generator: s,
      mirroredGenerator: o,
      mapPercentToKeyframes: a,
      keyframes: c,
      calculatedDuration: u,
      totalDuration: h,
      resolvedDuration: m,
    } = i
    if (this.startTime === null) return s.next(0)
    const {
      delay: g,
      repeat: y,
      repeatType: _,
      repeatDelay: M,
      onUpdate: w,
    } = this.options
    this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - h / this.speed, this.startTime)),
      t
        ? (this.currentTime = e)
        : this.holdTime !== null
        ? (this.currentTime = this.holdTime)
        : (this.currentTime = Math.round(e - this.startTime) * this.speed)
    const x = this.currentTime - g * (this.speed >= 0 ? 1 : -1),
      T = this.speed >= 0 ? x < 0 : x > h
    ;(this.currentTime = Math.max(x, 0)),
      this.state === 'finished' &&
        this.holdTime === null &&
        (this.currentTime = h)
    let A = this.currentTime,
      P = s
    if (y) {
      const F = Math.min(this.currentTime, h) / m
      let N = Math.floor(F),
        k = F % 1
      !k && F >= 1 && (k = 1),
        k === 1 && N--,
        (N = Math.min(N, y + 1)),
        !!(N % 2) &&
          (_ === 'reverse'
            ? ((k = 1 - k), M && (k -= M / m))
            : _ === 'mirror' && (P = o)),
        (A = Pl(0, 1, k) * m)
    }
    const D = T ? { done: !1, value: c[0] } : P.next(A)
    a && (D.value = a(D.value))
    let { done: O } = D
    !T &&
      u !== null &&
      (O = this.speed >= 0 ? this.currentTime >= h : this.currentTime <= 0)
    const U =
      this.holdTime === null &&
      (this.state === 'finished' || (this.state === 'running' && O))
    return (
      U && r !== void 0 && (D.value = F_(c, this.options, r)),
      w && w(D.value),
      U && this.finish(),
      D
    )
  }
  get duration() {
    const { resolved: e } = this
    return e ? bl(e.calculatedDuration) : 0
  }
  get time() {
    return bl(this.currentTime)
  }
  set time(e) {
    ;(e = El(e)),
      (this.currentTime = e),
      this.holdTime !== null || this.speed === 0
        ? (this.holdTime = e)
        : this.driver && (this.startTime = this.driver.now() - e / this.speed)
  }
  get speed() {
    return this.playbackSpeed
  }
  set speed(e) {
    const t = this.playbackSpeed !== e
    ;(this.playbackSpeed = e), t && (this.time = bl(this.currentTime))
  }
  play() {
    if (
      (this.resolver.isScheduled || this.resolver.resume(), !this._resolved)
    ) {
      this.pendingPlayState = 'running'
      return
    }
    if (this.isStopped) return
    const { driver: e = vQ, onPlay: t, startTime: i } = this.options
    this.driver || (this.driver = e((s) => this.tick(s))), t && t()
    const r = this.driver.now()
    this.holdTime !== null
      ? (this.startTime = r - this.holdTime)
      : this.startTime
      ? this.state === 'finished' && (this.startTime = r)
      : (this.startTime = i ?? this.calcStartTime()),
      this.state === 'finished' && this.updateFinishedPromise(),
      (this.cancelTime = this.startTime),
      (this.holdTime = null),
      (this.state = 'running'),
      this.driver.start()
  }
  pause() {
    var e
    if (!this._resolved) {
      this.pendingPlayState = 'paused'
      return
    }
    ;(this.state = 'paused'),
      (this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0)
  }
  complete() {
    this.state !== 'running' && this.play(),
      (this.pendingPlayState = this.state = 'finished'),
      (this.holdTime = null)
  }
  finish() {
    this.teardown(), (this.state = 'finished')
    const { onComplete: e } = this.options
    e && e()
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime),
      this.teardown(),
      this.updateFinishedPromise()
  }
  teardown() {
    ;(this.state = 'idle'),
      this.stopDriver(),
      this.resolveFinishedPromise(),
      this.updateFinishedPromise(),
      (this.startTime = this.cancelTime = null),
      this.resolver.cancel()
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0))
  }
  sample(e) {
    return (this.startTime = 0), this.tick(e, !0)
  }
}
const _Q = new Set(['opacity', 'clipPath', 'filter', 'transform'])
function wQ(
  n,
  e,
  t,
  {
    delay: i = 0,
    duration: r = 300,
    repeat: s = 0,
    repeatType: o = 'loop',
    ease: a = 'easeInOut',
    times: c,
  } = {},
) {
  const u = { [e]: t }
  c && (u.offset = c)
  const h = Nk(a, r)
  return (
    Array.isArray(h) && (u.easing = h),
    n.animate(u, {
      delay: i,
      duration: r,
      easing: Array.isArray(h) ? 'linear' : h,
      fill: 'both',
      iterations: s + 1,
      direction: o === 'reverse' ? 'alternate' : 'normal',
    })
  )
}
const SQ = oT(() => Object.hasOwnProperty.call(Element.prototype, 'animate')),
  Ox = 10,
  MQ = 2e4
function EQ(n) {
  return lT(n.type) || n.type === 'spring' || !Lk(n.ease)
}
function bQ(n, e) {
  const t = new ET({ ...e, keyframes: n, repeat: 0, delay: 0, isGenerator: !0 })
  let i = { done: !1, value: n[0] }
  const r = []
  let s = 0
  for (; !i.done && s < MQ; ) (i = t.sample(s)), r.push(i.value), (s += Ox)
  return { times: void 0, keyframes: r, duration: s - Ox, ease: 'linear' }
}
const yF = { anticipate: Xk, backInOut: $k, circInOut: Yk }
function TQ(n) {
  return n in yF
}
class h3 extends fF {
  constructor(e) {
    super(e)
    const { name: t, motionValue: i, element: r, keyframes: s } = this.options
    ;(this.resolver = new dF(
      s,
      (o, a) => this.onKeyframesResolved(o, a),
      t,
      i,
      r,
    )),
      this.resolver.scheduleResolve()
  }
  initPlayback(e, t) {
    var i
    let {
      duration: r = 300,
      times: s,
      ease: o,
      type: a,
      motionValue: c,
      name: u,
      startTime: h,
    } = this.options
    if (!(!((i = c.owner) === null || i === void 0) && i.current)) return !1
    if (
      (typeof o == 'string' && Lx() && TQ(o) && (o = yF[o]), EQ(this.options))
    ) {
      const {
          onComplete: g,
          onUpdate: y,
          motionValue: _,
          element: M,
          ...w
        } = this.options,
        x = bQ(e, w)
      ;(e = x.keyframes),
        e.length === 1 && (e[1] = e[0]),
        (r = x.duration),
        (s = x.times),
        (o = x.ease),
        (a = 'keyframes')
    }
    const m = wQ(c.owner.current, u, e, {
      ...this.options,
      duration: r,
      times: s,
      ease: o,
    })
    return (
      (m.startTime = h ?? this.calcStartTime()),
      this.pendingTimeline
        ? (qR(m, this.pendingTimeline), (this.pendingTimeline = void 0))
        : (m.onfinish = () => {
            const { onComplete: g } = this.options
            c.set(F_(e, this.options, t)),
              g && g(),
              this.cancel(),
              this.resolveFinishedPromise()
          }),
      { animation: m, duration: r, times: s, type: a, ease: o, keyframes: e }
    )
  }
  get duration() {
    const { resolved: e } = this
    if (!e) return 0
    const { duration: t } = e
    return bl(t)
  }
  get time() {
    const { resolved: e } = this
    if (!e) return 0
    const { animation: t } = e
    return bl(t.currentTime || 0)
  }
  set time(e) {
    const { resolved: t } = this
    if (!t) return
    const { animation: i } = t
    i.currentTime = El(e)
  }
  get speed() {
    const { resolved: e } = this
    if (!e) return 1
    const { animation: t } = e
    return t.playbackRate
  }
  set speed(e) {
    const { resolved: t } = this
    if (!t) return
    const { animation: i } = t
    i.playbackRate = e
  }
  get state() {
    const { resolved: e } = this
    if (!e) return 'idle'
    const { animation: t } = e
    return t.playState
  }
  get startTime() {
    const { resolved: e } = this
    if (!e) return null
    const { animation: t } = e
    return t.startTime
  }
  attachTimeline(e) {
    if (!this._resolved) this.pendingTimeline = e
    else {
      const { resolved: t } = this
      if (!t) return ks
      const { animation: i } = t
      qR(i, e)
    }
    return ks
  }
  play() {
    if (this.isStopped) return
    const { resolved: e } = this
    if (!e) return
    const { animation: t } = e
    t.playState === 'finished' && this.updateFinishedPromise(), t.play()
  }
  pause() {
    const { resolved: e } = this
    if (!e) return
    const { animation: t } = e
    t.pause()
  }
  stop() {
    if ((this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle'))
      return
    this.resolveFinishedPromise(), this.updateFinishedPromise()
    const { resolved: e } = this
    if (!e) return
    const {
      animation: t,
      keyframes: i,
      duration: r,
      type: s,
      ease: o,
      times: a,
    } = e
    if (t.playState === 'idle' || t.playState === 'finished') return
    if (this.time) {
      const {
          motionValue: u,
          onUpdate: h,
          onComplete: m,
          element: g,
          ...y
        } = this.options,
        _ = new ET({
          ...y,
          keyframes: i,
          duration: r,
          type: s,
          ease: o,
          times: a,
          isGenerator: !0,
        }),
        M = El(this.time)
      u.setWithVelocity(_.sample(M - Ox).value, _.sample(M).value, Ox)
    }
    const { onStop: c } = this.options
    c && c(), this.cancel()
  }
  complete() {
    const { resolved: e } = this
    e && e.animation.finish()
  }
  cancel() {
    const { resolved: e } = this
    e && e.animation.cancel()
  }
  static supports(e) {
    const {
      motionValue: t,
      name: i,
      repeatDelay: r,
      repeatType: s,
      damping: o,
      type: a,
    } = e
    return (
      SQ() &&
      i &&
      _Q.has(i) &&
      t &&
      t.owner &&
      t.owner.current instanceof HTMLElement &&
      !t.owner.getProps().onUpdate &&
      !r &&
      s !== 'mirror' &&
      o !== 0 &&
      a !== 'inertia'
    )
  }
}
const AQ = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10 },
  CQ = (n) => ({
    type: 'spring',
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  PQ = { type: 'keyframes', duration: 0.8 },
  RQ = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  IQ = (n, { keyframes: e }) =>
    e.length > 2 ? PQ : Ed.has(n) ? (n.startsWith('scale') ? CQ(e[1]) : AQ) : RQ
function LQ({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: i,
  staggerDirection: r,
  repeat: s,
  repeatType: o,
  repeatDelay: a,
  from: c,
  elapsed: u,
  ...h
}) {
  return !!Object.keys(h).length
}
const bT =
  (n, e, t, i = {}, r, s) =>
  (o) => {
    const a = aT(i, n) || {},
      c = a.delay || i.delay || 0
    let { elapsed: u = 0 } = i
    u = u - El(c)
    let h = {
      keyframes: Array.isArray(t) ? t : [null, t],
      ease: 'easeOut',
      velocity: e.getVelocity(),
      ...a,
      delay: -u,
      onUpdate: (g) => {
        e.set(g), a.onUpdate && a.onUpdate(g)
      },
      onComplete: () => {
        o(), a.onComplete && a.onComplete()
      },
      name: n,
      motionValue: e,
      element: s ? void 0 : r,
    }
    LQ(a) || (h = { ...h, ...IQ(n, h) }),
      h.duration && (h.duration = El(h.duration)),
      h.repeatDelay && (h.repeatDelay = El(h.repeatDelay)),
      h.from !== void 0 && (h.keyframes[0] = h.from)
    let m = !1
    if (
      ((h.type === !1 || (h.duration === 0 && !h.repeatDelay)) &&
        ((h.duration = 0), h.delay === 0 && (m = !0)),
      m && !s && e.get() !== void 0)
    ) {
      const g = F_(h.keyframes, a)
      if (g !== void 0)
        return (
          ri.update(() => {
            h.onUpdate(g), h.onComplete()
          }),
          new zZ([])
        )
    }
    return !s && h3.supports(h) ? new h3(h) : new ET(h)
  }
function NQ({ protectedKeys: n, needsAnimating: e }, t) {
  const i = n.hasOwnProperty(t) && e[t] !== !0
  return (e[t] = !1), i
}
function xF(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) {
  var s
  let { transition: o = n.getDefaultTransition(), transitionEnd: a, ...c } = e
  i && (o = i)
  const u = [],
    h = r && n.animationState && n.animationState.getState()[r]
  for (const m in c) {
    const g = n.getValue(
        m,
        (s = n.latestValues[m]) !== null && s !== void 0 ? s : null,
      ),
      y = c[m]
    if (y === void 0 || (h && NQ(h, m))) continue
    const _ = { delay: t, ...aT(o || {}, m) }
    let M = !1
    if (window.MotionHandoffAnimation) {
      const x = Vk(n)
      if (x) {
        const T = window.MotionHandoffAnimation(x, m, ri)
        T !== null && ((_.startTime = T), (M = !0))
      }
    }
    RM(n, m),
      g.start(
        bT(m, g, y, n.shouldReduceMotion && Ed.has(m) ? { type: !1 } : _, n, M),
      )
    const w = g.animation
    w && u.push(w)
  }
  return (
    a &&
      Promise.all(u).then(() => {
        ri.update(() => {
          a && rK(n, a)
        })
      }),
    u
  )
}
function FM(n, e, t = {}) {
  var i
  const r = k_(
    n,
    e,
    t.type === 'exit'
      ? (i = n.presenceContext) === null || i === void 0
        ? void 0
        : i.custom
      : void 0,
  )
  let { transition: s = n.getDefaultTransition() || {} } = r || {}
  t.transitionOverride && (s = t.transitionOverride)
  const o = r ? () => Promise.all(xF(n, r, t)) : () => Promise.resolve(),
    a =
      n.variantChildren && n.variantChildren.size
        ? (u = 0) => {
            const {
              delayChildren: h = 0,
              staggerChildren: m,
              staggerDirection: g,
            } = s
            return DQ(n, e, h + u, m, g, t)
          }
        : () => Promise.resolve(),
    { when: c } = s
  if (c) {
    const [u, h] = c === 'beforeChildren' ? [o, a] : [a, o]
    return u().then(() => h())
  } else return Promise.all([o(), a(t.delay)])
}
function DQ(n, e, t = 0, i = 0, r = 1, s) {
  const o = [],
    a = (n.variantChildren.size - 1) * i,
    c = r === 1 ? (u = 0) => u * i : (u = 0) => a - u * i
  return (
    Array.from(n.variantChildren)
      .sort(OQ)
      .forEach((u, h) => {
        u.notify('AnimationStart', e),
          o.push(
            FM(u, e, { ...s, delay: t + c(h) }).then(() =>
              u.notify('AnimationComplete', e),
            ),
          )
      }),
    Promise.all(o)
  )
}
function OQ(n, e) {
  return n.sortNodePosition(e)
}
function kQ(n, e, t = {}) {
  n.notify('AnimationStart', e)
  let i
  if (Array.isArray(e)) {
    const r = e.map((s) => FM(n, s, t))
    i = Promise.all(r)
  } else if (typeof e == 'string') i = FM(n, e, t)
  else {
    const r = typeof e == 'function' ? k_(n, e, t.custom) : e
    i = Promise.all(xF(n, r, t))
  }
  return i.then(() => {
    n.notify('AnimationComplete', e)
  })
}
const FQ = sT.length
function _F(n) {
  if (!n) return
  if (!n.isControllingVariants) {
    const t = n.parent ? _F(n.parent) || {} : {}
    return n.props.initial !== void 0 && (t.initial = n.props.initial), t
  }
  const e = {}
  for (let t = 0; t < FQ; t++) {
    const i = sT[t],
      r = n.props[i]
    ;(gg(r) || r === !1) && (e[i] = r)
  }
  return e
}
const UQ = [...rT].reverse(),
  BQ = rT.length
function zQ(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: i }) => kQ(n, t, i)))
}
function VQ(n) {
  let e = zQ(n),
    t = p3(),
    i = !0
  const r = (c) => (u, h) => {
    var m
    const g = k_(
      n,
      h,
      c === 'exit'
        ? (m = n.presenceContext) === null || m === void 0
          ? void 0
          : m.custom
        : void 0,
    )
    if (g) {
      const { transition: y, transitionEnd: _, ...M } = g
      u = { ...u, ...M, ..._ }
    }
    return u
  }
  function s(c) {
    e = c(n)
  }
  function o(c) {
    const { props: u } = n,
      h = _F(n.parent) || {},
      m = [],
      g = new Set()
    let y = {},
      _ = 1 / 0
    for (let w = 0; w < BQ; w++) {
      const x = UQ[w],
        T = t[x],
        A = u[x] !== void 0 ? u[x] : h[x],
        P = gg(A),
        D = x === c ? T.isActive : null
      D === !1 && (_ = w)
      let O = A === h[x] && A !== u[x] && P
      if (
        (O && i && n.manuallyAnimateOnMount && (O = !1),
        (T.protectedKeys = { ...y }),
        (!T.isActive && D === null) ||
          (!A && !T.prevProp) ||
          O_(A) ||
          typeof A == 'boolean')
      )
        continue
      const U = jQ(T.prevProp, A)
      let F = U || (x === c && T.isActive && !O && P) || (w > _ && P),
        N = !1
      const k = Array.isArray(A) ? A : [A]
      let z = k.reduce(r(x), {})
      D === !1 && (z = {})
      const { prevResolvedValues: $ = {} } = T,
        te = { ...$, ...z },
        j = (ne) => {
          ;(F = !0),
            g.has(ne) && ((N = !0), g.delete(ne)),
            (T.needsAnimating[ne] = !0)
          const V = n.getValue(ne)
          V && (V.liveStyle = !1)
        }
      for (const ne in te) {
        const V = z[ne],
          Y = $[ne]
        if (y.hasOwnProperty(ne)) continue
        let Q = !1
        TM(V) && TM(Y) ? (Q = !Pk(V, Y)) : (Q = V !== Y),
          Q
            ? V != null
              ? j(ne)
              : g.add(ne)
            : V !== void 0 && g.has(ne)
            ? j(ne)
            : (T.protectedKeys[ne] = !0)
      }
      ;(T.prevProp = A),
        (T.prevResolvedValues = z),
        T.isActive && (y = { ...y, ...z }),
        i && n.blockInitialAnimation && (F = !1),
        F &&
          (!(O && U) || N) &&
          m.push(...k.map((ne) => ({ animation: ne, options: { type: x } })))
    }
    if (g.size) {
      const w = {}
      g.forEach((x) => {
        const T = n.getBaseTarget(x),
          A = n.getValue(x)
        A && (A.liveStyle = !0), (w[x] = T ?? null)
      }),
        m.push({ animation: w })
    }
    let M = !!m.length
    return (
      i &&
        (u.initial === !1 || u.initial === u.animate) &&
        !n.manuallyAnimateOnMount &&
        (M = !1),
      (i = !1),
      M ? e(m) : Promise.resolve()
    )
  }
  function a(c, u) {
    var h
    if (t[c].isActive === u) return Promise.resolve()
    ;(h = n.variantChildren) === null ||
      h === void 0 ||
      h.forEach((g) => {
        var y
        return (y = g.animationState) === null || y === void 0
          ? void 0
          : y.setActive(c, u)
      }),
      (t[c].isActive = u)
    const m = o(c)
    for (const g in t) t[g].protectedKeys = {}
    return m
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => t,
    reset: () => {
      ;(t = p3()), (i = !0)
    },
  }
}
function jQ(n, e) {
  return typeof e == 'string' ? e !== n : Array.isArray(e) ? !Pk(e, n) : !1
}
function Vu(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  }
}
function p3() {
  return {
    animate: Vu(!0),
    whileInView: Vu(),
    whileHover: Vu(),
    whileTap: Vu(),
    whileDrag: Vu(),
    whileFocus: Vu(),
    exit: Vu(),
  }
}
class Vc {
  constructor(e) {
    ;(this.isMounted = !1), (this.node = e)
  }
  update() {}
}
class HQ extends Vc {
  constructor(e) {
    super(e), e.animationState || (e.animationState = VQ(e))
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps()
    O_(e) && (this.unmountControls = e.subscribe(this.node))
  }
  mount() {
    this.updateAnimationControlsSubscription()
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {}
    e !== t && this.updateAnimationControlsSubscription()
  }
  unmount() {
    var e
    this.node.animationState.reset(),
      (e = this.unmountControls) === null || e === void 0 || e.call(this)
  }
}
let GQ = 0
class WQ extends Vc {
  constructor() {
    super(...arguments), (this.id = GQ++)
  }
  update() {
    if (!this.node.presenceContext) return
    const { isPresent: e, onExitComplete: t } = this.node.presenceContext,
      { isPresent: i } = this.node.prevPresenceContext || {}
    if (!this.node.animationState || e === i) return
    const r = this.node.animationState.setActive('exit', !e)
    t && !e && r.then(() => t(this.id))
  }
  mount() {
    const { register: e } = this.node.presenceContext || {}
    e && (this.unmount = e(this.id))
  }
  unmount() {}
}
const $Q = { animation: { Feature: HQ }, exit: { Feature: WQ } }
function _g(n, e, t, i = { passive: !0 }) {
  return n.addEventListener(e, t, i), () => n.removeEventListener(e, t)
}
function iv(n) {
  return { point: { x: n.pageX, y: n.pageY } }
}
const XQ = (n) => (e) => uT(e) && n(e, iv(e))
function km(n, e, t, i) {
  return _g(n, e, XQ(t), i)
}
const m3 = (n, e) => Math.abs(n - e)
function qQ(n, e) {
  const t = m3(n.x, e.x),
    i = m3(n.y, e.y)
  return Math.sqrt(t ** 2 + i ** 2)
}
class wF {
  constructor(
    e,
    t,
    { transformPagePoint: i, contextWindow: r, dragSnapToOrigin: s = !1 } = {},
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return
        const m = aS(this.lastMoveEventInfo, this.history),
          g = this.startEvent !== null,
          y = qQ(m.offset, { x: 0, y: 0 }) >= 3
        if (!g && !y) return
        const { point: _ } = m,
          { timestamp: M } = vr
        this.history.push({ ..._, timestamp: M })
        const { onStart: w, onMove: x } = this.handlers
        g ||
          (w && w(this.lastMoveEvent, m),
          (this.startEvent = this.lastMoveEvent)),
          x && x(this.lastMoveEvent, m)
      }),
      (this.handlePointerMove = (m, g) => {
        ;(this.lastMoveEvent = m),
          (this.lastMoveEventInfo = oS(g, this.transformPagePoint)),
          ri.update(this.updatePoint, !0)
      }),
      (this.handlePointerUp = (m, g) => {
        this.end()
        const { onEnd: y, onSessionEnd: _, resumeAnimation: M } = this.handlers
        if (
          (this.dragSnapToOrigin && M && M(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return
        const w = aS(
          m.type === 'pointercancel'
            ? this.lastMoveEventInfo
            : oS(g, this.transformPagePoint),
          this.history,
        )
        this.startEvent && y && y(m, w), _ && _(m, w)
      }),
      !uT(e))
    )
      return
    ;(this.dragSnapToOrigin = s),
      (this.handlers = t),
      (this.transformPagePoint = i),
      (this.contextWindow = r || window)
    const o = iv(e),
      a = oS(o, this.transformPagePoint),
      { point: c } = a,
      { timestamp: u } = vr
    this.history = [{ ...c, timestamp: u }]
    const { onSessionStart: h } = t
    h && h(e, aS(a, this.history)),
      (this.removeListeners = nv(
        km(this.contextWindow, 'pointermove', this.handlePointerMove),
        km(this.contextWindow, 'pointerup', this.handlePointerUp),
        km(this.contextWindow, 'pointercancel', this.handlePointerUp),
      ))
  }
  updateHandlers(e) {
    this.handlers = e
  }
  end() {
    this.removeListeners && this.removeListeners(), Nc(this.updatePoint)
  }
}
function oS(n, e) {
  return e ? { point: e(n.point) } : n
}
function g3(n, e) {
  return { x: n.x - e.x, y: n.y - e.y }
}
function aS({ point: n }, e) {
  return {
    point: n,
    delta: g3(n, SF(e)),
    offset: g3(n, YQ(e)),
    velocity: ZQ(e, 0.1),
  }
}
function YQ(n) {
  return n[0]
}
function SF(n) {
  return n[n.length - 1]
}
function ZQ(n, e) {
  if (n.length < 2) return { x: 0, y: 0 }
  let t = n.length - 1,
    i = null
  const r = SF(n)
  for (; t >= 0 && ((i = n[t]), !(r.timestamp - i.timestamp > El(e))); ) t--
  if (!i) return { x: 0, y: 0 }
  const s = bl(r.timestamp - i.timestamp)
  if (s === 0) return { x: 0, y: 0 }
  const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s }
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
}
function sh(n) {
  return (
    n &&
    typeof n == 'object' &&
    Object.prototype.hasOwnProperty.call(n, 'current')
  )
}
const MF = 1e-4,
  KQ = 1 - MF,
  QQ = 1 + MF,
  EF = 0.01,
  JQ = 0 - EF,
  eJ = 0 + EF
function zs(n) {
  return n.max - n.min
}
function tJ(n, e, t) {
  return Math.abs(n - e) <= t
}
function v3(n, e, t, i = 0.5) {
  ;(n.origin = i),
    (n.originPoint = mi(e.min, e.max, n.origin)),
    (n.scale = zs(t) / zs(e)),
    (n.translate = mi(t.min, t.max, n.origin) - n.originPoint),
    ((n.scale >= KQ && n.scale <= QQ) || isNaN(n.scale)) && (n.scale = 1),
    ((n.translate >= JQ && n.translate <= eJ) || isNaN(n.translate)) &&
      (n.translate = 0)
}
function Fm(n, e, t, i) {
  v3(n.x, e.x, t.x, i ? i.originX : void 0),
    v3(n.y, e.y, t.y, i ? i.originY : void 0)
}
function y3(n, e, t) {
  ;(n.min = t.min + e.min), (n.max = n.min + zs(e))
}
function nJ(n, e, t) {
  y3(n.x, e.x, t.x), y3(n.y, e.y, t.y)
}
function x3(n, e, t) {
  ;(n.min = e.min - t.min), (n.max = n.min + zs(e))
}
function Um(n, e, t) {
  x3(n.x, e.x, t.x), x3(n.y, e.y, t.y)
}
function iJ(n, { min: e, max: t }, i) {
  return (
    e !== void 0 && n < e
      ? (n = i ? mi(e, n, i.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = i ? mi(t, n, i.max) : Math.min(n, t)),
    n
  )
}
function _3(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  }
}
function rJ(n, { top: e, left: t, bottom: i, right: r }) {
  return { x: _3(n.x, t, r), y: _3(n.y, e, i) }
}
function w3(n, e) {
  let t = e.min - n.min,
    i = e.max - n.max
  return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), { min: t, max: i }
}
function sJ(n, e) {
  return { x: w3(n.x, e.x), y: w3(n.y, e.y) }
}
function oJ(n, e) {
  let t = 0.5
  const i = zs(n),
    r = zs(e)
  return (
    r > i
      ? (t = bh(e.min, e.max - i, n.min))
      : i > r && (t = bh(n.min, n.max - r, e.min)),
    Pl(0, 1, t)
  )
}
function aJ(n, e) {
  const t = {}
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  )
}
const UM = 0.35
function lJ(n = UM) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = UM),
    { x: S3(n, 'left', 'right'), y: S3(n, 'top', 'bottom') }
  )
}
function S3(n, e, t) {
  return { min: M3(n, e), max: M3(n, t) }
}
function M3(n, e) {
  return typeof n == 'number' ? n : n[e] || 0
}
const E3 = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  oh = () => ({ x: E3(), y: E3() }),
  b3 = () => ({ min: 0, max: 0 }),
  Ri = () => ({ x: b3(), y: b3() })
function io(n) {
  return [n('x'), n('y')]
}
function bF({ top: n, left: e, right: t, bottom: i }) {
  return { x: { min: e, max: t }, y: { min: n, max: i } }
}
function cJ({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min }
}
function uJ(n, e) {
  if (!e) return n
  const t = e({ x: n.left, y: n.top }),
    i = e({ x: n.right, y: n.bottom })
  return { top: t.y, left: t.x, bottom: i.y, right: i.x }
}
function lS(n) {
  return n === void 0 || n === 1
}
function BM({ scale: n, scaleX: e, scaleY: t }) {
  return !lS(n) || !lS(e) || !lS(t)
}
function Xu(n) {
  return (
    BM(n) ||
    TF(n) ||
    n.z ||
    n.rotate ||
    n.rotateX ||
    n.rotateY ||
    n.skewX ||
    n.skewY
  )
}
function TF(n) {
  return T3(n.x) || T3(n.y)
}
function T3(n) {
  return n && n !== '0%'
}
function kx(n, e, t) {
  const i = n - t,
    r = e * i
  return t + r
}
function A3(n, e, t, i, r) {
  return r !== void 0 && (n = kx(n, r, i)), kx(n, t, i) + e
}
function zM(n, e = 0, t = 1, i, r) {
  ;(n.min = A3(n.min, e, t, i, r)), (n.max = A3(n.max, e, t, i, r))
}
function AF(n, { x: e, y: t }) {
  zM(n.x, e.translate, e.scale, e.originPoint),
    zM(n.y, t.translate, t.scale, t.originPoint)
}
const C3 = 0.999999999999,
  P3 = 1.0000000000001
function dJ(n, e, t, i = !1) {
  const r = t.length
  if (!r) return
  e.x = e.y = 1
  let s, o
  for (let a = 0; a < r; a++) {
    ;(s = t[a]), (o = s.projectionDelta)
    const { visualElement: c } = s.options
    ;(c && c.props.style && c.props.style.display === 'contents') ||
      (i &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        lh(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((e.x *= o.x.scale), (e.y *= o.y.scale), AF(n, o)),
      i && Xu(s.latestValues) && lh(n, s.latestValues))
  }
  e.x < P3 && e.x > C3 && (e.x = 1), e.y < P3 && e.y > C3 && (e.y = 1)
}
function ah(n, e) {
  ;(n.min = n.min + e), (n.max = n.max + e)
}
function R3(n, e, t, i, r = 0.5) {
  const s = mi(n.min, n.max, r)
  zM(n, e, t, s, i)
}
function lh(n, e) {
  R3(n.x, e.x, e.scaleX, e.scale, e.originX),
    R3(n.y, e.y, e.scaleY, e.scale, e.originY)
}
function CF(n, e) {
  return bF(uJ(n.getBoundingClientRect(), e))
}
function fJ(n, e, t) {
  const i = CF(n, t),
    { scroll: r } = e
  return r && (ah(i.x, r.offset.x), ah(i.y, r.offset.y)), i
}
const PF = ({ current: n }) => (n ? n.ownerDocument.defaultView : null),
  hJ = new WeakMap()
class pJ {
  constructor(e) {
    ;(this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Ri()),
      (this.visualElement = e)
  }
  start(e, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: i } = this.visualElement
    if (i && i.isPresent === !1) return
    const r = (h) => {
        const { dragSnapToOrigin: m } = this.getProps()
        m ? this.pauseAnimation() : this.stopAnimation(),
          t && this.snapToCursor(iv(h).point)
      },
      s = (h, m) => {
        const { drag: g, dragPropagation: y, onDragStart: _ } = this.getProps()
        if (
          g &&
          !y &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = qZ(g)),
          !this.openDragLock)
        )
          return
        ;(this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          io((w) => {
            let x = this.getAxisMotionValue(w).get() || 0
            if (Ma.test(x)) {
              const { projection: T } = this.visualElement
              if (T && T.layout) {
                const A = T.layout.layoutBox[w]
                A && (x = zs(A) * (parseFloat(x) / 100))
              }
            }
            this.originPoint[w] = x
          }),
          _ && ri.postRender(() => _(h, m)),
          RM(this.visualElement, 'transform')
        const { animationState: M } = this.visualElement
        M && M.setActive('whileDrag', !0)
      },
      o = (h, m) => {
        const {
          dragPropagation: g,
          dragDirectionLock: y,
          onDirectionLock: _,
          onDrag: M,
        } = this.getProps()
        if (!g && !this.openDragLock) return
        const { offset: w } = m
        if (y && this.currentDirection === null) {
          ;(this.currentDirection = mJ(w)),
            this.currentDirection !== null && _ && _(this.currentDirection)
          return
        }
        this.updateAxis('x', m.point, w),
          this.updateAxis('y', m.point, w),
          this.visualElement.render(),
          M && M(h, m)
      },
      a = (h, m) => this.stop(h, m),
      c = () =>
        io((h) => {
          var m
          return (
            this.getAnimationState(h) === 'paused' &&
            ((m = this.getAxisMotionValue(h).animation) === null || m === void 0
              ? void 0
              : m.play())
          )
        }),
      { dragSnapToOrigin: u } = this.getProps()
    this.panSession = new wF(
      e,
      {
        onSessionStart: r,
        onStart: s,
        onMove: o,
        onSessionEnd: a,
        resumeAnimation: c,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: u,
        contextWindow: PF(this.visualElement),
      },
    )
  }
  stop(e, t) {
    const i = this.isDragging
    if ((this.cancel(), !i)) return
    const { velocity: r } = t
    this.startAnimation(r)
    const { onDragEnd: s } = this.getProps()
    s && ri.postRender(() => s(e, t))
  }
  cancel() {
    this.isDragging = !1
    const { projection: e, animationState: t } = this.visualElement
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0)
    const { dragPropagation: i } = this.getProps()
    !i &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      t && t.setActive('whileDrag', !1)
  }
  updateAxis(e, t, i) {
    const { drag: r } = this.getProps()
    if (!i || !my(e, r, this.currentDirection)) return
    const s = this.getAxisMotionValue(e)
    let o = this.originPoint[e] + i[e]
    this.constraints &&
      this.constraints[e] &&
      (o = iJ(o, this.constraints[e], this.elastic[e])),
      s.set(o)
  }
  resolveConstraints() {
    var e
    const { dragConstraints: t, dragElastic: i } = this.getProps(),
      r =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (e = this.visualElement.projection) === null || e === void 0
          ? void 0
          : e.layout,
      s = this.constraints
    t && sh(t)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : t && r
      ? (this.constraints = rJ(r.layoutBox, t))
      : (this.constraints = !1),
      (this.elastic = lJ(i)),
      s !== this.constraints &&
        r &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        io((o) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(o) &&
            (this.constraints[o] = aJ(r.layoutBox[o], this.constraints[o]))
        })
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps()
    if (!e || !sh(e)) return !1
    const i = e.current,
      { projection: r } = this.visualElement
    if (!r || !r.layout) return !1
    const s = fJ(i, r.root, this.visualElement.getTransformPagePoint())
    let o = sJ(r.layout.layoutBox, s)
    if (t) {
      const a = t(cJ(o))
      ;(this.hasMutatedConstraints = !!a), a && (o = bF(a))
    }
    return o
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a,
      } = this.getProps(),
      c = this.constraints || {},
      u = io((h) => {
        if (!my(h, t, this.currentDirection)) return
        let m = c[h] || {}
        o && (m = { min: 0, max: 0 })
        const g = r ? 200 : 1e6,
          y = r ? 40 : 1e7,
          _ = {
            type: 'inertia',
            velocity: i ? e[h] : 0,
            bounceStiffness: g,
            bounceDamping: y,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...m,
          }
        return this.startAxisValueAnimation(h, _)
      })
    return Promise.all(u).then(a)
  }
  startAxisValueAnimation(e, t) {
    const i = this.getAxisMotionValue(e)
    return (
      RM(this.visualElement, e), i.start(bT(e, i, 0, t, this.visualElement, !1))
    )
  }
  stopAnimation() {
    io((e) => this.getAxisMotionValue(e).stop())
  }
  pauseAnimation() {
    io((e) => {
      var t
      return (t = this.getAxisMotionValue(e).animation) === null || t === void 0
        ? void 0
        : t.pause()
    })
  }
  getAnimationState(e) {
    var t
    return (t = this.getAxisMotionValue(e).animation) === null || t === void 0
      ? void 0
      : t.state
  }
  getAxisMotionValue(e) {
    const t = `_drag${e.toUpperCase()}`,
      i = this.visualElement.getProps(),
      r = i[t]
    return (
      r ||
      this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    )
  }
  snapToCursor(e) {
    io((t) => {
      const { drag: i } = this.getProps()
      if (!my(t, i, this.currentDirection)) return
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(t)
      if (r && r.layout) {
        const { min: o, max: a } = r.layout.layoutBox[t]
        s.set(e[t] - mi(o, a, 0.5))
      }
    })
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: i } = this.visualElement
    if (!sh(t) || !i || !this.constraints) return
    this.stopAnimation()
    const r = { x: 0, y: 0 }
    io((o) => {
      const a = this.getAxisMotionValue(o)
      if (a && this.constraints !== !1) {
        const c = a.get()
        r[o] = oJ({ min: c, max: c }, this.constraints[o])
      }
    })
    const { transformTemplate: s } = this.visualElement.getProps()
    ;(this.visualElement.current.style.transform = s ? s({}, '') : 'none'),
      i.root && i.root.updateScroll(),
      i.updateLayout(),
      this.resolveConstraints(),
      io((o) => {
        if (!my(o, e, null)) return
        const a = this.getAxisMotionValue(o),
          { min: c, max: u } = this.constraints[o]
        a.set(mi(c, u, r[o]))
      })
  }
  addListeners() {
    if (!this.visualElement.current) return
    hJ.set(this.visualElement, this)
    const e = this.visualElement.current,
      t = km(e, 'pointerdown', (c) => {
        const { drag: u, dragListener: h = !0 } = this.getProps()
        u && h && this.start(c)
      }),
      i = () => {
        const { dragConstraints: c } = this.getProps()
        sh(c) && c.current && (this.constraints = this.resolveRefConstraints())
      },
      { projection: r } = this.visualElement,
      s = r.addEventListener('measure', i)
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()),
      ri.read(i)
    const o = _g(window, 'resize', () => this.scalePositionWithinConstraints()),
      a = r.addEventListener(
        'didUpdate',
        ({ delta: c, hasLayoutChanged: u }) => {
          this.isDragging &&
            u &&
            (io((h) => {
              const m = this.getAxisMotionValue(h)
              m &&
                ((this.originPoint[h] += c[h].translate),
                m.set(m.get() + c[h].translate))
            }),
            this.visualElement.render())
        },
      )
    return () => {
      o(), t(), s(), a && a()
    }
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: i = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: o = UM,
        dragMomentum: a = !0,
      } = e
    return {
      ...e,
      drag: t,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a,
    }
  }
}
function my(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n)
}
function mJ(n, e = 10) {
  let t = null
  return Math.abs(n.y) > e ? (t = 'y') : Math.abs(n.x) > e && (t = 'x'), t
}
class gJ extends Vc {
  constructor(e) {
    super(e),
      (this.removeGroupControls = ks),
      (this.removeListeners = ks),
      (this.controls = new pJ(e))
  }
  mount() {
    const { dragControls: e } = this.node.getProps()
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || ks)
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners()
  }
}
const I3 = (n) => (e, t) => {
  n && ri.postRender(() => n(e, t))
}
class vJ extends Vc {
  constructor() {
    super(...arguments), (this.removePointerDownListener = ks)
  }
  onPointerDown(e) {
    this.session = new wF(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: PF(this.node),
    })
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: i,
      onPanEnd: r,
    } = this.node.getProps()
    return {
      onSessionStart: I3(e),
      onStart: I3(t),
      onMove: i,
      onEnd: (s, o) => {
        delete this.session, r && ri.postRender(() => r(s, o))
      },
    }
  }
  mount() {
    this.removePointerDownListener = km(this.node.current, 'pointerdown', (e) =>
      this.onPointerDown(e),
    )
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end()
  }
}
const TT = X.createContext(null)
function yJ() {
  const n = X.useContext(TT)
  if (n === null) return [!0, null]
  const { isPresent: e, onExitComplete: t, register: i } = n,
    r = X.useId()
  X.useEffect(() => i(r), [])
  const s = X.useCallback(() => t && t(r), [r, t])
  return !e && t ? [!1, s] : [!0]
}
const RF = X.createContext({}),
  IF = X.createContext({}),
  Py = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }
function L3(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100
}
const nm = {
    correct: (n, e) => {
      if (!e.target) return n
      if (typeof n == 'string')
        if (Zt.test(n)) n = parseFloat(n)
        else return n
      const t = L3(n, e.target.x),
        i = L3(n, e.target.y)
      return `${t}% ${i}%`
    },
  },
  xJ = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const i = n,
        r = Dc.parse(n)
      if (r.length > 5) return i
      const s = Dc.createTransformer(n),
        o = typeof r[0] != 'number' ? 1 : 0,
        a = t.x.scale * e.x,
        c = t.y.scale * e.y
      ;(r[0 + o] /= a), (r[1 + o] /= c)
      const u = mi(a, c, 0.5)
      return (
        typeof r[2 + o] == 'number' && (r[2 + o] /= u),
        typeof r[3 + o] == 'number' && (r[3 + o] /= u),
        s(r)
      )
    },
  },
  Fx = {}
function _J(n) {
  Object.assign(Fx, n)
}
const { schedule: AT, cancel: qne } = Uk(queueMicrotask, !1)
class wJ extends X.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
        layoutId: r,
      } = this.props,
      { projection: s } = e
    _J(SJ),
      s &&
        (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener('animationComplete', () => {
          this.safeToRemove()
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Py.hasEverUpdated = !0)
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: i,
        drag: r,
        isPresent: s,
      } = this.props,
      o = i.projection
    return (
      o &&
        ((o.isPresent = s),
        r || e.layoutDependency !== t || t === void 0
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              ri.postRender(() => {
                const a = o.getStack()
                ;(!a || !a.members.length) && this.safeToRemove()
              }))),
      null
    )
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement
    e &&
      (e.root.didUpdate(),
      AT.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove()
      }))
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
      } = this.props,
      { projection: r } = e
    r &&
      (r.scheduleCheckAfterUnmount(),
      t && t.group && t.group.remove(r),
      i && i.deregister && i.deregister(r))
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props
    e && e()
  }
  render() {
    return null
  }
}
function LF(n) {
  const [e, t] = yJ(),
    i = X.useContext(RF)
  return b.jsx(wJ, {
    ...n,
    layoutGroup: i,
    switchLayoutGroup: X.useContext(IF),
    isPresent: e,
    safeToRemove: t,
  })
}
const SJ = {
  borderRadius: {
    ...nm,
    applyTo: [
      'borderTopLeftRadius',
      'borderTopRightRadius',
      'borderBottomLeftRadius',
      'borderBottomRightRadius',
    ],
  },
  borderTopLeftRadius: nm,
  borderTopRightRadius: nm,
  borderBottomLeftRadius: nm,
  borderBottomRightRadius: nm,
  boxShadow: xJ,
}
function MJ(n, e, t) {
  const i = Nr(n) ? n : vg(n)
  return i.start(bT('', i, e, t)), i.animation
}
function EJ(n) {
  return n instanceof SVGElement && n.tagName !== 'svg'
}
const bJ = (n, e) => n.depth - e.depth
class TJ {
  constructor() {
    ;(this.children = []), (this.isDirty = !1)
  }
  add(e) {
    dT(this.children, e), (this.isDirty = !0)
  }
  remove(e) {
    fT(this.children, e), (this.isDirty = !0)
  }
  forEach(e) {
    this.isDirty && this.children.sort(bJ),
      (this.isDirty = !1),
      this.children.forEach(e)
  }
}
function AJ(n, e) {
  const t = Sa.now(),
    i = ({ timestamp: r }) => {
      const s = r - t
      s >= e && (Nc(i), n(s - e))
    }
  return ri.read(i, !0), () => Nc(i)
}
function Ry(n) {
  const e = Nr(n) ? n.get() : n
  return YZ(e) ? e.toValue() : e
}
const NF = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'],
  CJ = NF.length,
  N3 = (n) => (typeof n == 'string' ? parseFloat(n) : n),
  D3 = (n) => typeof n == 'number' || Zt.test(n)
function PJ(n, e, t, i, r, s) {
  r
    ? ((n.opacity = mi(0, t.opacity !== void 0 ? t.opacity : 1, RJ(i))),
      (n.opacityExit = mi(e.opacity !== void 0 ? e.opacity : 1, 0, IJ(i))))
    : s &&
      (n.opacity = mi(
        e.opacity !== void 0 ? e.opacity : 1,
        t.opacity !== void 0 ? t.opacity : 1,
        i,
      ))
  for (let o = 0; o < CJ; o++) {
    const a = `border${NF[o]}Radius`
    let c = O3(e, a),
      u = O3(t, a)
    if (c === void 0 && u === void 0) continue
    c || (c = 0),
      u || (u = 0),
      c === 0 || u === 0 || D3(c) === D3(u)
        ? ((n[a] = Math.max(mi(N3(c), N3(u), i), 0)),
          (Ma.test(u) || Ma.test(c)) && (n[a] += '%'))
        : (n[a] = u)
  }
  ;(e.rotate || t.rotate) && (n.rotate = mi(e.rotate || 0, t.rotate || 0, i))
}
function O3(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius
}
const RJ = DF(0, 0.5, qk),
  IJ = DF(0.5, 0.95, ks)
function DF(n, e, t) {
  return (i) => (i < n ? 0 : i > e ? 1 : t(bh(n, e, i)))
}
function k3(n, e) {
  ;(n.min = e.min), (n.max = e.max)
}
function to(n, e) {
  k3(n.x, e.x), k3(n.y, e.y)
}
function F3(n, e) {
  ;(n.translate = e.translate),
    (n.scale = e.scale),
    (n.originPoint = e.originPoint),
    (n.origin = e.origin)
}
function U3(n, e, t, i, r) {
  return (
    (n -= e), (n = kx(n, 1 / t, i)), r !== void 0 && (n = kx(n, 1 / r, i)), n
  )
}
function LJ(n, e = 0, t = 1, i = 0.5, r, s = n, o = n) {
  if (
    (Ma.test(e) &&
      ((e = parseFloat(e)), (e = mi(o.min, o.max, e / 100) - o.min)),
    typeof e != 'number')
  )
    return
  let a = mi(s.min, s.max, i)
  n === s && (a -= e),
    (n.min = U3(n.min, e, t, a, r)),
    (n.max = U3(n.max, e, t, a, r))
}
function B3(n, e, [t, i, r], s, o) {
  LJ(n, e[t], e[i], e[r], e.scale, s, o)
}
const NJ = ['x', 'scaleX', 'originX'],
  DJ = ['y', 'scaleY', 'originY']
function z3(n, e, t, i) {
  B3(n.x, e, NJ, t ? t.x : void 0, i ? i.x : void 0),
    B3(n.y, e, DJ, t ? t.y : void 0, i ? i.y : void 0)
}
function V3(n) {
  return n.translate === 0 && n.scale === 1
}
function OF(n) {
  return V3(n.x) && V3(n.y)
}
function j3(n, e) {
  return n.min === e.min && n.max === e.max
}
function OJ(n, e) {
  return j3(n.x, e.x) && j3(n.y, e.y)
}
function H3(n, e) {
  return (
    Math.round(n.min) === Math.round(e.min) &&
    Math.round(n.max) === Math.round(e.max)
  )
}
function kF(n, e) {
  return H3(n.x, e.x) && H3(n.y, e.y)
}
function G3(n) {
  return zs(n.x) / zs(n.y)
}
function W3(n, e) {
  return (
    n.translate === e.translate &&
    n.scale === e.scale &&
    n.originPoint === e.originPoint
  )
}
class kJ {
  constructor() {
    this.members = []
  }
  add(e) {
    dT(this.members, e), e.scheduleRender()
  }
  remove(e) {
    if (
      (fT(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1]
      t && this.promote(t)
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r)
    if (t === 0) return !1
    let i
    for (let r = t; r >= 0; r--) {
      const s = this.members[r]
      if (s.isPresent !== !1) {
        i = s
        break
      }
    }
    return i ? (this.promote(i), !0) : !1
  }
  promote(e, t) {
    const i = this.lead
    if (e !== i && ((this.prevLead = i), (this.lead = e), e.show(), i)) {
      i.instance && i.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = i),
        t && (e.resumeFrom.preserveOpacity = !0),
        i.snapshot &&
          ((e.snapshot = i.snapshot),
          (e.snapshot.latestValues = i.animationValues || i.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0)
      const { crossfade: r } = e.options
      r === !1 && i.hide()
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: i } = e
      t.onExitComplete && t.onExitComplete(),
        i && i.options.onExitComplete && i.options.onExitComplete()
    })
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1)
    })
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}
function FJ(n, e, t) {
  let i = ''
  const r = n.x.translate / e.x,
    s = n.y.translate / e.y,
    o = (t == null ? void 0 : t.z) || 0
  if (
    ((r || s || o) && (i = `translate3d(${r}px, ${s}px, ${o}px) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const {
      transformPerspective: u,
      rotate: h,
      rotateX: m,
      rotateY: g,
      skewX: y,
      skewY: _,
    } = t
    u && (i = `perspective(${u}px) ${i}`),
      h && (i += `rotate(${h}deg) `),
      m && (i += `rotateX(${m}deg) `),
      g && (i += `rotateY(${g}deg) `),
      y && (i += `skewX(${y}deg) `),
      _ && (i += `skewY(${_}deg) `)
  }
  const a = n.x.scale * e.x,
    c = n.y.scale * e.y
  return (a !== 1 || c !== 1) && (i += `scale(${a}, ${c})`), i || 'none'
}
const qu = {
    type: 'projectionFrame',
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0,
  },
  pm = typeof window < 'u' && window.MotionDebug !== void 0,
  cS = ['', 'X', 'Y', 'Z'],
  UJ = { visibility: 'hidden' },
  $3 = 1e3
let BJ = 0
function uS(n, e, t, i) {
  const { latestValues: r } = e
  r[n] && ((t[n] = r[n]), e.setStaticValue(n, 0), i && (i[n] = 0))
}
function FF(n) {
  if (((n.hasCheckedOptimisedAppear = !0), n.root === n)) return
  const { visualElement: e } = n.options
  if (!e) return
  const t = Vk(e)
  if (window.MotionHasOptimisedAnimation(t, 'transform')) {
    const { layout: r, layoutId: s } = n.options
    window.MotionCancelOptimisedAnimation(t, 'transform', ri, !(r || s))
  }
  const { parent: i } = n
  i && !i.hasCheckedOptimisedAppear && FF(i)
}
function UF({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: i,
  resetTransform: r,
}) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      ;(this.id = BJ++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots())
        }),
        (this.updateProjection = () => {
          ;(this.projectionUpdateScheduled = !1),
            pm &&
              (qu.totalNodes =
                qu.resolvedTargetDeltas =
                qu.recalculatedProjection =
                  0),
            this.nodes.forEach(jJ),
            this.nodes.forEach(XJ),
            this.nodes.forEach(qJ),
            this.nodes.forEach(HJ),
            pm && window.MotionDebug.record(qu)
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = o),
        (this.root = a ? a.root || a : this),
        (this.path = a ? [...a.path, a] : []),
        (this.parent = a),
        (this.depth = a ? a.depth + 1 : 0)
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0
      this.root === this && (this.nodes = new TJ())
    }
    addEventListener(o, a) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new hT()),
        this.eventHandlers.get(o).add(a)
      )
    }
    notifyListeners(o, ...a) {
      const c = this.eventHandlers.get(o)
      c && c.notify(...a)
    }
    hasListeners(o) {
      return this.eventHandlers.has(o)
    }
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance) return
      ;(this.isSVG = EJ(o)), (this.instance = o)
      const { layoutId: c, layout: u, visualElement: h } = this.options
      if (
        (h && !h.current && h.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        a && (u || c) && (this.isLayoutDirty = !0),
        n)
      ) {
        let m
        const g = () => (this.root.updateBlockedByResize = !1)
        n(o, () => {
          ;(this.root.updateBlockedByResize = !0),
            m && m(),
            (m = AJ(g, 250)),
            Py.hasAnimatedSinceResize &&
              ((Py.hasAnimatedSinceResize = !1), this.nodes.forEach(q3))
        })
      }
      c && this.root.registerSharedNode(c, this),
        this.options.animate !== !1 &&
          h &&
          (c || u) &&
          this.addEventListener(
            'didUpdate',
            ({
              delta: m,
              hasLayoutChanged: g,
              hasRelativeTargetChanged: y,
              layout: _,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                ;(this.target = void 0), (this.relativeTarget = void 0)
                return
              }
              const M =
                  this.options.transition || h.getDefaultTransition() || JJ,
                { onLayoutAnimationStart: w, onLayoutAnimationComplete: x } =
                  h.getProps(),
                T = !this.targetLayout || !kF(this.targetLayout, _) || y,
                A = !g && y
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                A ||
                (g && (T || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(m, A)
                const P = { ...aT(M, 'layout'), onPlay: w, onComplete: x }
                ;(h.shouldReduceMotion || this.options.layoutRoot) &&
                  ((P.delay = 0), (P.type = !1)),
                  this.startAnimation(P)
              } else
                g || q3(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete()
              this.targetLayout = _
            },
          )
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this)
      const o = this.getStack()
      o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Nc(this.updateProjection)
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      )
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(YJ),
        this.animationId++)
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options
      return o && o.getProps().transformTemplate
    }
    willUpdate(o = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete()
        return
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          FF(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return
      this.isLayoutDirty = !0
      for (let h = 0; h < this.path.length; h++) {
        const m = this.path[h]
        ;(m.shouldResetTransform = !0),
          m.updateScroll('snapshot'),
          m.options.layoutRoot && m.willUpdate(!1)
      }
      const { layoutId: a, layout: c } = this.options
      if (a === void 0 && !c) return
      const u = this.getTransformTemplate()
      ;(this.prevTransformTemplateValue = u
        ? u(this.latestValues, '')
        : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners('willUpdate')
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(X3)
        return
      }
      this.isUpdating || this.nodes.forEach(WJ),
        (this.isUpdating = !1),
        this.nodes.forEach($J),
        this.nodes.forEach(zJ),
        this.nodes.forEach(VJ),
        this.clearAllSnapshots()
      const a = Sa.now()
      ;(vr.delta = Pl(0, 1e3 / 60, a - vr.timestamp)),
        (vr.timestamp = a),
        (vr.isProcessing = !0),
        tS.update.process(vr),
        tS.preRender.process(vr),
        tS.render.process(vr),
        (vr.isProcessing = !1)
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), AT.read(this.scheduleUpdate))
    }
    clearAllSnapshots() {
      this.nodes.forEach(GJ), this.sharedNodes.forEach(ZJ)
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        ri.preRender(this.updateProjection, !1, !0))
    }
    scheduleCheckAfterUnmount() {
      ri.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed()
      })
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure())
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++) this.path[c].updateScroll()
      const o = this.layout
      ;(this.layout = this.measure(!1)),
        (this.layoutCorrected = Ri()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners('measure', this.layout.layoutBox)
      const { visualElement: a } = this.options
      a &&
        a.notify(
          'LayoutMeasure',
          this.layout.layoutBox,
          o ? o.layoutBox : void 0,
        )
    }
    updateScroll(o = 'measure') {
      let a = !!(this.options.layoutScroll && this.instance)
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === o &&
          (a = !1),
        a)
      ) {
        const c = i(this.instance)
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: c,
          offset: t(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : c,
        }
      }
    }
    resetTransform() {
      if (!r) return
      const o =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        a = this.projectionDelta && !OF(this.projectionDelta),
        c = this.getTransformTemplate(),
        u = c ? c(this.latestValues, '') : void 0,
        h = u !== this.prevTransformTemplateValue
      o &&
        (a || Xu(this.latestValues) || h) &&
        (r(this.instance, u),
        (this.shouldResetTransform = !1),
        this.scheduleRender())
    }
    measure(o = !0) {
      const a = this.measurePageBox()
      let c = this.removeElementScroll(a)
      return (
        o && (c = this.removeTransform(c)),
        eee(c),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: c,
          latestValues: {},
          source: this.id,
        }
      )
    }
    measurePageBox() {
      var o
      const { visualElement: a } = this.options
      if (!a) return Ri()
      const c = a.measureViewportBox()
      if (
        !(
          ((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) ||
          this.path.some(tee)
        )
      ) {
        const { scroll: h } = this.root
        h && (ah(c.x, h.offset.x), ah(c.y, h.offset.y))
      }
      return c
    }
    removeElementScroll(o) {
      var a
      const c = Ri()
      if (
        (to(c, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
      )
        return c
      for (let u = 0; u < this.path.length; u++) {
        const h = this.path[u],
          { scroll: m, options: g } = h
        h !== this.root &&
          m &&
          g.layoutScroll &&
          (m.wasRoot && to(c, o), ah(c.x, m.offset.x), ah(c.y, m.offset.y))
      }
      return c
    }
    applyTransform(o, a = !1) {
      const c = Ri()
      to(c, o)
      for (let u = 0; u < this.path.length; u++) {
        const h = this.path[u]
        !a &&
          h.options.layoutScroll &&
          h.scroll &&
          h !== h.root &&
          lh(c, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }),
          Xu(h.latestValues) && lh(c, h.latestValues)
      }
      return Xu(this.latestValues) && lh(c, this.latestValues), c
    }
    removeTransform(o) {
      const a = Ri()
      to(a, o)
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c]
        if (!u.instance || !Xu(u.latestValues)) continue
        BM(u.latestValues) && u.updateSnapshot()
        const h = Ri(),
          m = u.measurePageBox()
        to(h, m),
          z3(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, h)
      }
      return Xu(this.latestValues) && z3(a, this.latestValues), a
    }
    setTargetDelta(o) {
      ;(this.targetDelta = o),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0)
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0,
      }
    }
    clearMeasurements() {
      ;(this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1)
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== vr.timestamp &&
        this.relativeParent.resolveTargetDelta(!0)
    }
    resolveTargetDelta(o = !1) {
      var a
      const c = this.getLead()
      this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = c.isSharedProjectionDirty)
      const u = !!this.resumingFrom || this !== c
      if (
        !(
          o ||
          (u && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((a = this.parent) === null || a === void 0) &&
            a.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return
      const { layout: m, layoutId: g } = this.options
      if (!(!this.layout || !(m || g))) {
        if (
          ((this.resolvedRelativeTargetAt = vr.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const y = this.getClosestProjectingParent()
          y && y.layout && this.animationProgress !== 1
            ? ((this.relativeParent = y),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Ri()),
              (this.relativeTargetOrigin = Ri()),
              Um(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                y.layout.layoutBox,
              ),
              to(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = Ri()), (this.targetWithTransforms = Ri())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                nJ(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target,
                ))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : to(this.target, this.layout.layoutBox),
                AF(this.target, this.targetDelta))
              : to(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1
            const y = this.getClosestProjectingParent()
            y &&
            !!y.resumingFrom == !!this.resumingFrom &&
            !y.options.layoutScroll &&
            y.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = y),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = Ri()),
                (this.relativeTargetOrigin = Ri()),
                Um(this.relativeTargetOrigin, this.target, y.target),
                to(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0)
          }
          pm && qu.resolvedTargetDeltas++
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          BM(this.parent.latestValues) ||
          TF(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent()
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      )
    }
    calcProjection() {
      var o
      const a = this.getLead(),
        c = !!this.resumingFrom || this !== a
      let u = !0
      if (
        ((this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) &&
            o.isProjectionDirty)) &&
          (u = !1),
        c &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (u = !1),
        this.resolvedRelativeTargetAt === vr.timestamp && (u = !1),
        u)
      )
        return
      const { layout: h, layoutId: m } = this.options
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(h || m))
      )
        return
      to(this.layoutCorrected, this.layout.layoutBox)
      const g = this.treeScale.x,
        y = this.treeScale.y
      dJ(this.layoutCorrected, this.treeScale, this.path, c),
        a.layout &&
          !a.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((a.target = a.layout.layoutBox), (a.targetWithTransforms = Ri()))
      const { target: _ } = a
      if (!_) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender())
        return
      }
      !this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (F3(this.prevProjectionDelta.x, this.projectionDelta.x),
          F3(this.prevProjectionDelta.y, this.projectionDelta.y)),
        Fm(this.projectionDelta, this.layoutCorrected, _, this.latestValues),
        (this.treeScale.x !== g ||
          this.treeScale.y !== y ||
          !W3(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !W3(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners('projectionUpdate', _)),
        pm && qu.recalculatedProjection++
    }
    hide() {
      this.isVisible = !1
    }
    show() {
      this.isVisible = !0
    }
    scheduleRender(o = !0) {
      var a
      if (
        ((a = this.options.visualElement) === null ||
          a === void 0 ||
          a.scheduleRender(),
        o)
      ) {
        const c = this.getStack()
        c && c.scheduleRender()
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0)
    }
    createProjectionDeltas() {
      ;(this.prevProjectionDelta = oh()),
        (this.projectionDelta = oh()),
        (this.projectionDeltaWithTransform = oh())
    }
    setAnimationOrigin(o, a = !1) {
      const c = this.snapshot,
        u = c ? c.latestValues : {},
        h = { ...this.latestValues },
        m = oh()
      ;(!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a)
      const g = Ri(),
        y = c ? c.source : void 0,
        _ = this.layout ? this.layout.source : void 0,
        M = y !== _,
        w = this.getStack(),
        x = !w || w.members.length <= 1,
        T = !!(M && !x && this.options.crossfade === !0 && !this.path.some(QJ))
      this.animationProgress = 0
      let A
      ;(this.mixTargetDelta = (P) => {
        const D = P / 1e3
        Y3(m.x, o.x, D),
          Y3(m.y, o.y, D),
          this.setTargetDelta(m),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Um(g, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            KJ(this.relativeTarget, this.relativeTargetOrigin, g, D),
            A && OJ(this.relativeTarget, A) && (this.isProjectionDirty = !1),
            A || (A = Ri()),
            to(A, this.relativeTarget)),
          M &&
            ((this.animationValues = h), PJ(h, u, this.latestValues, D, T, x)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = D)
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
    }
    startAnimation(o) {
      this.notifyListeners('animationStart'),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (Nc(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = ri.update(() => {
          ;(Py.hasAnimatedSinceResize = !0),
            (this.currentAnimation = MJ(0, $3, {
              ...o,
              onUpdate: (a) => {
                this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a)
              },
              onComplete: () => {
                o.onComplete && o.onComplete(), this.completeAnimation()
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0)
        }))
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0))
      const o = this.getStack()
      o && o.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners('animationComplete')
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta($3),
        this.currentAnimation.stop()),
        this.completeAnimation()
    }
    applyTransformsToTarget() {
      const o = this.getLead()
      let { targetWithTransforms: a, target: c, layout: u, latestValues: h } = o
      if (!(!a || !c || !u)) {
        if (
          this !== o &&
          this.layout &&
          u &&
          BF(this.options.animationType, this.layout.layoutBox, u.layoutBox)
        ) {
          c = this.target || Ri()
          const m = zs(this.layout.layoutBox.x)
          ;(c.x.min = o.target.x.min), (c.x.max = c.x.min + m)
          const g = zs(this.layout.layoutBox.y)
          ;(c.y.min = o.target.y.min), (c.y.max = c.y.min + g)
        }
        to(a, c),
          lh(a, h),
          Fm(this.projectionDeltaWithTransform, this.layoutCorrected, a, h)
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new kJ()),
        this.sharedNodes.get(o).add(a)
      const u = a.options.initialPromotionConfig
      a.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity:
          u && u.shouldPreserveFollowOpacity
            ? u.shouldPreserveFollowOpacity(a)
            : void 0,
      })
    }
    isLead() {
      const o = this.getStack()
      return o ? o.lead === this : !0
    }
    getLead() {
      var o
      const { layoutId: a } = this.options
      return a
        ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) ||
            this
        : this
    }
    getPrevLead() {
      var o
      const { layoutId: a } = this.options
      return a
        ? (o = this.getStack()) === null || o === void 0
          ? void 0
          : o.prevLead
        : void 0
    }
    getStack() {
      const { layoutId: o } = this.options
      if (o) return this.root.sharedNodes.get(o)
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: c } = {}) {
      const u = this.getStack()
      u && u.promote(this, c),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a })
    }
    relegate() {
      const o = this.getStack()
      return o ? o.relegate(this) : !1
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options
      if (!o) return
      let a = !1
      const { latestValues: c } = o
      if (
        ((c.z ||
          c.rotate ||
          c.rotateX ||
          c.rotateY ||
          c.rotateZ ||
          c.skewX ||
          c.skewY) &&
          (a = !0),
        !a)
      )
        return
      const u = {}
      c.z && uS('z', o, u, this.animationValues)
      for (let h = 0; h < cS.length; h++)
        uS(`rotate${cS[h]}`, o, u, this.animationValues),
          uS(`skew${cS[h]}`, o, u, this.animationValues)
      o.render()
      for (const h in u)
        o.setStaticValue(h, u[h]),
          this.animationValues && (this.animationValues[h] = u[h])
      o.scheduleRender()
    }
    getProjectionStyles(o) {
      var a, c
      if (!this.instance || this.isSVG) return
      if (!this.isVisible) return UJ
      const u = { visibility: '' },
        h = this.getTransformTemplate()
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (u.opacity = ''),
          (u.pointerEvents = Ry(o == null ? void 0 : o.pointerEvents) || ''),
          (u.transform = h ? h(this.latestValues, '') : 'none'),
          u
        )
      const m = this.getLead()
      if (!this.projectionDelta || !this.layout || !m.target) {
        const M = {}
        return (
          this.options.layoutId &&
            ((M.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (M.pointerEvents = Ry(o == null ? void 0 : o.pointerEvents) || '')),
          this.hasProjected &&
            !Xu(this.latestValues) &&
            ((M.transform = h ? h({}, '') : 'none'), (this.hasProjected = !1)),
          M
        )
      }
      const g = m.animationValues || m.latestValues
      this.applyTransformsToTarget(),
        (u.transform = FJ(
          this.projectionDeltaWithTransform,
          this.treeScale,
          g,
        )),
        h && (u.transform = h(g, u.transform))
      const { x: y, y: _ } = this.projectionDelta
      ;(u.transformOrigin = `${y.origin * 100}% ${_.origin * 100}% 0`),
        m.animationValues
          ? (u.opacity =
              m === this
                ? (c =
                    (a = g.opacity) !== null && a !== void 0
                      ? a
                      : this.latestValues.opacity) !== null && c !== void 0
                  ? c
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : g.opacityExit)
          : (u.opacity =
              m === this
                ? g.opacity !== void 0
                  ? g.opacity
                  : ''
                : g.opacityExit !== void 0
                ? g.opacityExit
                : 0)
      for (const M in Fx) {
        if (g[M] === void 0) continue
        const { correct: w, applyTo: x } = Fx[M],
          T = u.transform === 'none' ? g[M] : w(g[M], m)
        if (x) {
          const A = x.length
          for (let P = 0; P < A; P++) u[x[P]] = T
        } else u[M] = T
      }
      return (
        this.options.layoutId &&
          (u.pointerEvents =
            m === this
              ? Ry(o == null ? void 0 : o.pointerEvents) || ''
              : 'none'),
        u
      )
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0
    }
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a
        return (a = o.currentAnimation) === null || a === void 0
          ? void 0
          : a.stop()
      }),
        this.root.nodes.forEach(X3),
        this.root.sharedNodes.clear()
    }
  }
}
function zJ(n) {
  n.updateLayout()
}
function VJ(n) {
  var e
  const t =
    ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    n.snapshot
  if (n.isLead() && n.layout && t && n.hasListeners('didUpdate')) {
    const { layoutBox: i, measuredBox: r } = n.layout,
      { animationType: s } = n.options,
      o = t.source !== n.layout.source
    s === 'size'
      ? io((m) => {
          const g = o ? t.measuredBox[m] : t.layoutBox[m],
            y = zs(g)
          ;(g.min = i[m].min), (g.max = g.min + y)
        })
      : BF(s, t.layoutBox, i) &&
        io((m) => {
          const g = o ? t.measuredBox[m] : t.layoutBox[m],
            y = zs(i[m])
          ;(g.max = g.min + y),
            n.relativeTarget &&
              !n.currentAnimation &&
              ((n.isProjectionDirty = !0),
              (n.relativeTarget[m].max = n.relativeTarget[m].min + y))
        })
    const a = oh()
    Fm(a, i, t.layoutBox)
    const c = oh()
    o ? Fm(c, n.applyTransform(r, !0), t.measuredBox) : Fm(c, i, t.layoutBox)
    const u = !OF(a)
    let h = !1
    if (!n.resumeFrom) {
      const m = n.getClosestProjectingParent()
      if (m && !m.resumeFrom) {
        const { snapshot: g, layout: y } = m
        if (g && y) {
          const _ = Ri()
          Um(_, t.layoutBox, g.layoutBox)
          const M = Ri()
          Um(M, i, y.layoutBox),
            kF(_, M) || (h = !0),
            m.options.layoutRoot &&
              ((n.relativeTarget = M),
              (n.relativeTargetOrigin = _),
              (n.relativeParent = m))
        }
      }
    }
    n.notifyListeners('didUpdate', {
      layout: i,
      snapshot: t,
      delta: c,
      layoutDelta: a,
      hasLayoutChanged: u,
      hasRelativeTargetChanged: h,
    })
  } else if (n.isLead()) {
    const { onExitComplete: i } = n.options
    i && i()
  }
  n.options.transition = void 0
}
function jJ(n) {
  pm && qu.totalNodes++,
    n.parent &&
      (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
      n.isSharedProjectionDirty ||
        (n.isSharedProjectionDirty = !!(
          n.isProjectionDirty ||
          n.parent.isProjectionDirty ||
          n.parent.isSharedProjectionDirty
        )),
      n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty))
}
function HJ(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1
}
function GJ(n) {
  n.clearSnapshot()
}
function X3(n) {
  n.clearMeasurements()
}
function WJ(n) {
  n.isLayoutDirty = !1
}
function $J(n) {
  const { visualElement: e } = n.options
  e && e.getProps().onBeforeLayoutMeasure && e.notify('BeforeLayoutMeasure'),
    n.resetTransform()
}
function q3(n) {
  n.finishAnimation(),
    (n.targetDelta = n.relativeTarget = n.target = void 0),
    (n.isProjectionDirty = !0)
}
function XJ(n) {
  n.resolveTargetDelta()
}
function qJ(n) {
  n.calcProjection()
}
function YJ(n) {
  n.resetSkewAndRotation()
}
function ZJ(n) {
  n.removeLeadSnapshot()
}
function Y3(n, e, t) {
  ;(n.translate = mi(e.translate, 0, t)),
    (n.scale = mi(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint)
}
function Z3(n, e, t, i) {
  ;(n.min = mi(e.min, t.min, i)), (n.max = mi(e.max, t.max, i))
}
function KJ(n, e, t, i) {
  Z3(n.x, e.x, t.x, i), Z3(n.y, e.y, t.y, i)
}
function QJ(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0
}
const JJ = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  K3 = (n) =>
    typeof navigator < 'u' &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(n),
  Q3 = K3('applewebkit/') && !K3('chrome/') ? Math.round : ks
function J3(n) {
  ;(n.min = Q3(n.min)), (n.max = Q3(n.max))
}
function eee(n) {
  J3(n.x), J3(n.y)
}
function BF(n, e, t) {
  return n === 'position' || (n === 'preserve-aspect' && !tJ(G3(e), G3(t), 0.2))
}
function tee(n) {
  var e
  return (
    n !== n.root &&
    ((e = n.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
  )
}
const nee = UF({
    attachResizeListener: (n, e) => _g(n, 'resize', e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  dS = { current: void 0 },
  zF = UF({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!dS.current) {
        const n = new nee({})
        n.mount(window), n.setOptions({ layoutScroll: !0 }), (dS.current = n)
      }
      return dS.current
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : 'none'
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === 'fixed',
  }),
  iee = {
    pan: { Feature: vJ },
    drag: { Feature: gJ, ProjectionNode: zF, MeasureLayout: LF },
  }
function eI(n, e, t) {
  const { props: i } = n
  n.animationState &&
    i.whileHover &&
    n.animationState.setActive('whileHover', t === 'Start')
  const r = 'onHover' + t,
    s = i[r]
  s && ri.postRender(() => s(e, iv(e)))
}
class ree extends Vc {
  mount() {
    const { current: e } = this.node
    e &&
      (this.unmount = HZ(
        e,
        (t) => (eI(this.node, t, 'Start'), (i) => eI(this.node, i, 'End')),
      ))
  }
  unmount() {}
}
class see extends Vc {
  constructor() {
    super(...arguments), (this.isActive = !1)
  }
  onFocus() {
    let e = !1
    try {
      e = this.node.current.matches(':focus-visible')
    } catch {
      e = !0
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !0),
      (this.isActive = !0))
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !1),
      (this.isActive = !1))
  }
  mount() {
    this.unmount = nv(
      _g(this.node.current, 'focus', () => this.onFocus()),
      _g(this.node.current, 'blur', () => this.onBlur()),
    )
  }
  unmount() {}
}
function tI(n, e, t) {
  const { props: i } = n
  n.animationState &&
    i.whileTap &&
    n.animationState.setActive('whileTap', t === 'Start')
  const r = 'onTap' + (t === 'End' ? '' : t),
    s = i[r]
  s && ri.postRender(() => s(e, iv(e)))
}
class oee extends Vc {
  mount() {
    const { current: e } = this.node
    e &&
      (this.unmount = XZ(
        e,
        (t) => (
          tI(this.node, t, 'Start'),
          (i, { success: r }) => tI(this.node, i, r ? 'End' : 'Cancel')
        ),
        { useGlobalTarget: this.node.props.globalTapTarget },
      ))
  }
  unmount() {}
}
const VM = new WeakMap(),
  fS = new WeakMap(),
  aee = (n) => {
    const e = VM.get(n.target)
    e && e(n)
  },
  lee = (n) => {
    n.forEach(aee)
  }
function cee({ root: n, ...e }) {
  const t = n || document
  fS.has(t) || fS.set(t, {})
  const i = fS.get(t),
    r = JSON.stringify(e)
  return i[r] || (i[r] = new IntersectionObserver(lee, { root: n, ...e })), i[r]
}
function uee(n, e, t) {
  const i = cee(e)
  return (
    VM.set(n, t),
    i.observe(n),
    () => {
      VM.delete(n), i.unobserve(n)
    }
  )
}
const dee = { some: 0, all: 1 }
class fee extends Vc {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1)
  }
  startObserver() {
    this.unmount()
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: i, amount: r = 'some', once: s } = e,
      o = {
        root: t ? t.current : void 0,
        rootMargin: i,
        threshold: typeof r == 'number' ? r : dee[r],
      },
      a = (c) => {
        const { isIntersecting: u } = c
        if (
          this.isInView === u ||
          ((this.isInView = u), s && !u && this.hasEnteredView)
        )
          return
        u && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive('whileInView', u)
        const { onViewportEnter: h, onViewportLeave: m } = this.node.getProps(),
          g = u ? h : m
        g && g(c)
      }
    return uee(this.node.current, o, a)
  }
  mount() {
    this.startObserver()
  }
  update() {
    if (typeof IntersectionObserver > 'u') return
    const { props: e, prevProps: t } = this.node
    ;['amount', 'margin', 'root'].some(hee(e, t)) && this.startObserver()
  }
  unmount() {}
}
function hee({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t]
}
const pee = {
    inView: { Feature: fee },
    tap: { Feature: oee },
    focus: { Feature: see },
    hover: { Feature: ree },
  },
  mee = { layout: { ProjectionNode: zF, MeasureLayout: LF } },
  VF = X.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: 'never',
  }),
  U_ = X.createContext({}),
  CT = typeof window < 'u',
  gee = CT ? X.useLayoutEffect : X.useEffect,
  jF = X.createContext({ strict: !1 })
function vee(n, e, t, i, r) {
  var s, o
  const { visualElement: a } = X.useContext(U_),
    c = X.useContext(jF),
    u = X.useContext(TT),
    h = X.useContext(VF).reducedMotion,
    m = X.useRef(null)
  ;(i = i || c.renderer),
    !m.current &&
      i &&
      (m.current = i(n, {
        visualState: e,
        parent: a,
        props: t,
        presenceContext: u,
        blockInitialAnimation: u ? u.initial === !1 : !1,
        reducedMotionConfig: h,
      }))
  const g = m.current,
    y = X.useContext(IF)
  g &&
    !g.projection &&
    r &&
    (g.type === 'html' || g.type === 'svg') &&
    yee(m.current, t, r, y)
  const _ = X.useRef(!1)
  X.useInsertionEffect(() => {
    g && _.current && g.update(t, u)
  })
  const M = t[zk],
    w = X.useRef(
      !!M &&
        !(
          !((s = window.MotionHandoffIsComplete) === null || s === void 0) &&
          s.call(window, M)
        ) &&
        ((o = window.MotionHasOptimisedAnimation) === null || o === void 0
          ? void 0
          : o.call(window, M)),
    )
  return (
    gee(() => {
      g &&
        ((_.current = !0),
        (window.MotionIsMounted = !0),
        g.updateFeatures(),
        AT.render(g.render),
        w.current && g.animationState && g.animationState.animateChanges())
    }),
    X.useEffect(() => {
      g &&
        (!w.current && g.animationState && g.animationState.animateChanges(),
        w.current &&
          (queueMicrotask(() => {
            var x
            ;(x = window.MotionHandoffMarkAsComplete) === null ||
              x === void 0 ||
              x.call(window, M)
          }),
          (w.current = !1)))
    }),
    g
  )
}
function yee(n, e, t, i) {
  const {
    layoutId: r,
    layout: s,
    drag: o,
    dragConstraints: a,
    layoutScroll: c,
    layoutRoot: u,
  } = e
  ;(n.projection = new t(
    n.latestValues,
    e['data-framer-portal-id'] ? void 0 : HF(n.parent),
  )),
    n.projection.setOptions({
      layoutId: r,
      layout: s,
      alwaysMeasureLayout: !!o || (a && sh(a)),
      visualElement: n,
      animationType: typeof s == 'string' ? s : 'both',
      initialPromotionConfig: i,
      layoutScroll: c,
      layoutRoot: u,
    })
}
function HF(n) {
  if (n) return n.options.allowProjection !== !1 ? n.projection : HF(n.parent)
}
function xee(n, e, t) {
  return X.useCallback(
    (i) => {
      i && n.mount && n.mount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == 'function' ? t(i) : sh(t) && (t.current = i))
    },
    [e],
  )
}
function B_(n) {
  return O_(n.animate) || sT.some((e) => gg(n[e]))
}
function GF(n) {
  return !!(B_(n) || n.variants)
}
function _ee(n, e) {
  if (B_(n)) {
    const { initial: t, animate: i } = n
    return {
      initial: t === !1 || gg(t) ? t : void 0,
      animate: gg(i) ? i : void 0,
    }
  }
  return n.inherit !== !1 ? e : {}
}
function wee(n) {
  const { initial: e, animate: t } = _ee(n, X.useContext(U_))
  return X.useMemo(() => ({ initial: e, animate: t }), [nI(e), nI(t)])
}
function nI(n) {
  return Array.isArray(n) ? n.join(' ') : n
}
const iI = {
    animation: [
      'animate',
      'variants',
      'whileHover',
      'whileTap',
      'exit',
      'whileInView',
      'whileFocus',
      'whileDrag',
    ],
    exit: ['exit'],
    drag: ['drag', 'dragControls'],
    focus: ['whileFocus'],
    hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
    tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
    pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
    inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
    layout: ['layout', 'layoutId'],
  },
  Ah = {}
for (const n in iI) Ah[n] = { isEnabled: (e) => iI[n].some((t) => !!e[t]) }
function See(n) {
  for (const e in n) Ah[e] = { ...Ah[e], ...n[e] }
}
const Mee = Symbol.for('motionComponentSymbol')
function Eee({
  preloadedFeatures: n,
  createVisualElement: e,
  useRender: t,
  useVisualState: i,
  Component: r,
}) {
  n && See(n)
  function s(a, c) {
    let u
    const h = { ...X.useContext(VF), ...a, layoutId: bee(a) },
      { isStatic: m } = h,
      g = wee(a),
      y = i(a, m)
    if (!m && CT) {
      Tee()
      const _ = Aee(h)
      ;(u = _.MeasureLayout),
        (g.visualElement = vee(r, y, h, e, _.ProjectionNode))
    }
    return b.jsxs(U_.Provider, {
      value: g,
      children: [
        u && g.visualElement
          ? b.jsx(u, { visualElement: g.visualElement, ...h })
          : null,
        t(r, a, xee(y, g.visualElement, c), y, m, g.visualElement),
      ],
    })
  }
  const o = X.forwardRef(s)
  return (o[Mee] = r), o
}
function bee({ layoutId: n }) {
  const e = X.useContext(RF).id
  return e && n !== void 0 ? e + '-' + n : n
}
function Tee(n, e) {
  X.useContext(jF).strict
}
function Aee(n) {
  const { drag: e, layout: t } = Ah
  if (!e && !t) return {}
  const i = { ...e, ...t }
  return {
    MeasureLayout:
      (e != null && e.isEnabled(n)) || (t != null && t.isEnabled(n))
        ? i.MeasureLayout
        : void 0,
    ProjectionNode: i.ProjectionNode,
  }
}
const Cee = [
  'animate',
  'circle',
  'defs',
  'desc',
  'ellipse',
  'g',
  'image',
  'line',
  'filter',
  'marker',
  'mask',
  'metadata',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'rect',
  'stop',
  'switch',
  'symbol',
  'svg',
  'text',
  'tspan',
  'use',
  'view',
]
function PT(n) {
  return typeof n != 'string' || n.includes('-')
    ? !1
    : !!(Cee.indexOf(n) > -1 || /[A-Z]/u.test(n))
}
function WF(n, { style: e, vars: t }, i, r) {
  Object.assign(n.style, e, r && r.getProjectionStyles(i))
  for (const s in t) n.style.setProperty(s, t[s])
}
const $F = new Set([
  'baseFrequency',
  'diffuseConstant',
  'kernelMatrix',
  'kernelUnitLength',
  'keySplines',
  'keyTimes',
  'limitingConeAngle',
  'markerHeight',
  'markerWidth',
  'numOctaves',
  'targetX',
  'targetY',
  'surfaceScale',
  'specularConstant',
  'specularExponent',
  'stdDeviation',
  'tableValues',
  'viewBox',
  'gradientTransform',
  'pathLength',
  'startOffset',
  'textLength',
  'lengthAdjust',
])
function XF(n, e, t, i) {
  WF(n, e, void 0, i)
  for (const r in e.attrs) n.setAttribute($F.has(r) ? r : pT(r), e.attrs[r])
}
function qF(n, { layout: e, layoutId: t }) {
  return (
    Ed.has(n) ||
    n.startsWith('origin') ||
    ((e || t !== void 0) && (!!Fx[n] || n === 'opacity'))
  )
}
function RT(n, e, t) {
  var i
  const { style: r } = n,
    s = {}
  for (const o in r)
    (Nr(r[o]) ||
      (e.style && Nr(e.style[o])) ||
      qF(o, n) ||
      ((i = t == null ? void 0 : t.getValue(o)) === null || i === void 0
        ? void 0
        : i.liveStyle) !== void 0) &&
      (s[o] = r[o])
  return s
}
function YF(n, e, t) {
  const i = RT(n, e, t)
  for (const r in n)
    if (Nr(n[r]) || Nr(e[r])) {
      const s =
        Jg.indexOf(r) !== -1
          ? 'attr' + r.charAt(0).toUpperCase() + r.substring(1)
          : r
      i[s] = n[r]
    }
  return i
}
function Pee(n) {
  const e = X.useRef(null)
  return e.current === null && (e.current = n()), e.current
}
function Ree(
  { scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t },
  i,
  r,
  s,
) {
  const o = { latestValues: Iee(i, r, s, n), renderState: e() }
  return t && (o.mount = (a) => t(i, a, o)), o
}
const ZF = (n) => (e, t) => {
  const i = X.useContext(U_),
    r = X.useContext(TT),
    s = () => Ree(n, e, i, r)
  return t ? s() : Pee(s)
}
function Iee(n, e, t, i) {
  const r = {},
    s = i(n, {})
  for (const g in s) r[g] = Ry(s[g])
  let { initial: o, animate: a } = n
  const c = B_(n),
    u = GF(n)
  e &&
    u &&
    !c &&
    n.inherit !== !1 &&
    (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate))
  let h = t ? t.initial === !1 : !1
  h = h || o === !1
  const m = h ? a : o
  if (m && typeof m != 'boolean' && !O_(m)) {
    const g = Array.isArray(m) ? m : [m]
    for (let y = 0; y < g.length; y++) {
      const _ = iT(n, g[y])
      if (_) {
        const { transitionEnd: M, transition: w, ...x } = _
        for (const T in x) {
          let A = x[T]
          if (Array.isArray(A)) {
            const P = h ? A.length - 1 : 0
            A = A[P]
          }
          A !== null && (r[T] = A)
        }
        for (const T in M) r[T] = M[T]
      }
    }
  }
  return r
}
const IT = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }),
  KF = () => ({ ...IT(), attrs: {} }),
  QF = (n, e) => (e && typeof n == 'number' ? e.transform(n) : n),
  Lee = {
    x: 'translateX',
    y: 'translateY',
    z: 'translateZ',
    transformPerspective: 'perspective',
  },
  Nee = Jg.length
function Dee(n, e, t) {
  let i = '',
    r = !0
  for (let s = 0; s < Nee; s++) {
    const o = Jg[s],
      a = n[o]
    if (a === void 0) continue
    let c = !0
    if (
      (typeof a == 'number'
        ? (c = a === (o.startsWith('scale') ? 1 : 0))
        : (c = parseFloat(a) === 0),
      !c || t)
    ) {
      const u = QF(a, wT[o])
      if (!c) {
        r = !1
        const h = Lee[o] || o
        i += `${h}(${u}) `
      }
      t && (e[o] = u)
    }
  }
  return (i = i.trim()), t ? (i = t(e, r ? '' : i)) : r && (i = 'none'), i
}
function LT(n, e, t) {
  const { style: i, vars: r, transformOrigin: s } = n
  let o = !1,
    a = !1
  for (const c in e) {
    const u = e[c]
    if (Ed.has(c)) {
      o = !0
      continue
    } else if (Jk(c)) {
      r[c] = u
      continue
    } else {
      const h = QF(u, wT[c])
      c.startsWith('origin') ? ((a = !0), (s[c] = h)) : (i[c] = h)
    }
  }
  if (
    (e.transform ||
      (o || t
        ? (i.transform = Dee(e, n.transform, t))
        : i.transform && (i.transform = 'none')),
    a)
  ) {
    const { originX: c = '50%', originY: u = '50%', originZ: h = 0 } = s
    i.transformOrigin = `${c} ${u} ${h}`
  }
}
function rI(n, e, t) {
  return typeof n == 'string' ? n : Zt.transform(e + t * n)
}
function Oee(n, e, t) {
  const i = rI(e, n.x, n.width),
    r = rI(t, n.y, n.height)
  return `${i} ${r}`
}
const kee = { offset: 'stroke-dashoffset', array: 'stroke-dasharray' },
  Fee = { offset: 'strokeDashoffset', array: 'strokeDasharray' }
function Uee(n, e, t = 1, i = 0, r = !0) {
  n.pathLength = 1
  const s = r ? kee : Fee
  n[s.offset] = Zt.transform(-i)
  const o = Zt.transform(e),
    a = Zt.transform(t)
  n[s.array] = `${o} ${a}`
}
function NT(
  n,
  {
    attrX: e,
    attrY: t,
    attrScale: i,
    originX: r,
    originY: s,
    pathLength: o,
    pathSpacing: a = 1,
    pathOffset: c = 0,
    ...u
  },
  h,
  m,
) {
  if ((LT(n, u, m), h)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox)
    return
  }
  ;(n.attrs = n.style), (n.style = {})
  const { attrs: g, style: y, dimensions: _ } = n
  g.transform && (_ && (y.transform = g.transform), delete g.transform),
    _ &&
      (r !== void 0 || s !== void 0 || y.transform) &&
      (y.transformOrigin = Oee(
        _,
        r !== void 0 ? r : 0.5,
        s !== void 0 ? s : 0.5,
      )),
    e !== void 0 && (g.x = e),
    t !== void 0 && (g.y = t),
    i !== void 0 && (g.scale = i),
    o !== void 0 && Uee(g, o, a, c, !1)
}
const DT = (n) => typeof n == 'string' && n.toLowerCase() === 'svg',
  Bee = {
    useVisualState: ZF({
      scrapeMotionValuesFromProps: YF,
      createRenderState: KF,
      onMount: (n, e, { renderState: t, latestValues: i }) => {
        ri.read(() => {
          try {
            t.dimensions =
              typeof e.getBBox == 'function'
                ? e.getBBox()
                : e.getBoundingClientRect()
          } catch {
            t.dimensions = { x: 0, y: 0, width: 0, height: 0 }
          }
        }),
          ri.render(() => {
            NT(t, i, DT(e.tagName), n.transformTemplate), XF(e, t)
          })
      },
    }),
  },
  zee = {
    useVisualState: ZF({
      scrapeMotionValuesFromProps: RT,
      createRenderState: IT,
    }),
  }
function JF(n, e, t) {
  for (const i in e) !Nr(e[i]) && !qF(i, t) && (n[i] = e[i])
}
function Vee({ transformTemplate: n }, e) {
  return X.useMemo(() => {
    const t = IT()
    return LT(t, e, n), Object.assign({}, t.vars, t.style)
  }, [e])
}
function jee(n, e) {
  const t = n.style || {},
    i = {}
  return JF(i, t, n), Object.assign(i, Vee(n, e)), i
}
function Hee(n, e) {
  const t = {},
    i = jee(n, e)
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((t.draggable = !1),
      (i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = 'none'),
      (i.touchAction =
        n.drag === !0 ? 'none' : `pan-${n.drag === 'x' ? 'y' : 'x'}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (t.tabIndex = 0),
    (t.style = i),
    t
  )
}
const Gee = new Set([
  'animate',
  'exit',
  'variants',
  'initial',
  'style',
  'values',
  'variants',
  'transition',
  'transformTemplate',
  'custom',
  'inherit',
  'onBeforeLayoutMeasure',
  'onAnimationStart',
  'onAnimationComplete',
  'onUpdate',
  'onDragStart',
  'onDrag',
  'onDragEnd',
  'onMeasureDragConstraints',
  'onDirectionLock',
  'onDragTransitionEnd',
  '_dragX',
  '_dragY',
  'onHoverStart',
  'onHoverEnd',
  'onViewportEnter',
  'onViewportLeave',
  'globalTapTarget',
  'ignoreStrict',
  'viewport',
])
function Ux(n) {
  return (
    n.startsWith('while') ||
    (n.startsWith('drag') && n !== 'draggable') ||
    n.startsWith('layout') ||
    n.startsWith('onTap') ||
    n.startsWith('onPan') ||
    n.startsWith('onLayout') ||
    Gee.has(n)
  )
}
let eU = (n) => !Ux(n)
function Wee(n) {
  n && (eU = (e) => (e.startsWith('on') ? !Ux(e) : n(e)))
}
try {
  Wee(require('@emotion/is-prop-valid').default)
} catch {}
function $ee(n, e, t) {
  const i = {}
  for (const r in n)
    (r === 'values' && typeof n.values == 'object') ||
      ((eU(r) ||
        (t === !0 && Ux(r)) ||
        (!e && !Ux(r)) ||
        (n.draggable && r.startsWith('onDrag'))) &&
        (i[r] = n[r]))
  return i
}
function Xee(n, e, t, i) {
  const r = X.useMemo(() => {
    const s = KF()
    return (
      NT(s, e, DT(i), n.transformTemplate),
      { ...s.attrs, style: { ...s.style } }
    )
  }, [e])
  if (n.style) {
    const s = {}
    JF(s, n.style, n), (r.style = { ...s, ...r.style })
  }
  return r
}
function qee(n = !1) {
  return (t, i, r, { latestValues: s }, o) => {
    const c = (PT(t) ? Xee : Hee)(i, s, o, t),
      u = $ee(i, typeof t == 'string', n),
      h = t !== X.Fragment ? { ...u, ...c, ref: r } : {},
      { children: m } = i,
      g = X.useMemo(() => (Nr(m) ? m.get() : m), [m])
    return X.createElement(t, { ...h, children: g })
  }
}
function Yee(n, e) {
  return function (i, { forwardMotionProps: r } = { forwardMotionProps: !1 }) {
    const o = {
      ...(PT(i) ? Bee : zee),
      preloadedFeatures: n,
      useRender: qee(r),
      createVisualElement: e,
      Component: i,
    }
    return Eee(o)
  }
}
const jM = { current: null },
  tU = { current: !1 }
function Zee() {
  if (((tU.current = !0), !!CT))
    if (window.matchMedia) {
      const n = window.matchMedia('(prefers-reduced-motion)'),
        e = () => (jM.current = n.matches)
      n.addListener(e), e()
    } else jM.current = !1
}
function Kee(n, e, t) {
  for (const i in e) {
    const r = e[i],
      s = t[i]
    if (Nr(r)) n.addValue(i, r)
    else if (Nr(s)) n.addValue(i, vg(r, { owner: n }))
    else if (s !== r)
      if (n.hasValue(i)) {
        const o = n.getValue(i)
        o.liveStyle === !0 ? o.jump(r) : o.hasAnimated || o.set(r)
      } else {
        const o = n.getStaticValue(i)
        n.addValue(i, vg(o !== void 0 ? o : r, { owner: n }))
      }
  }
  for (const i in t) e[i] === void 0 && n.removeValue(i)
  return e
}
const sI = new WeakMap(),
  Qee = [...nF, Ir, Dc],
  Jee = (n) => Qee.find(tF(n)),
  oI = [
    'AnimationStart',
    'AnimationComplete',
    'Update',
    'BeforeLayoutMeasure',
    'LayoutMeasure',
    'LayoutAnimationStart',
    'LayoutAnimationComplete',
  ]
class ete {
  scrapeMotionValuesFromProps(e, t, i) {
    return {}
  }
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: i,
      reducedMotionConfig: r,
      blockInitialAnimation: s,
      visualState: o,
    },
    a = {},
  ) {
    ;(this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = yT),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify('Update', this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection,
          ))
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const g = Sa.now()
        this.renderScheduledAt < g &&
          ((this.renderScheduledAt = g), ri.render(this.render, !1, !0))
      })
    const { latestValues: c, renderState: u } = o
    ;(this.latestValues = c),
      (this.baseTarget = { ...c }),
      (this.initialValues = t.initial ? { ...c } : {}),
      (this.renderState = u),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = i),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.options = a),
      (this.blockInitialAnimation = !!s),
      (this.isControllingVariants = B_(t)),
      (this.isVariantNode = GF(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current))
    const { willChange: h, ...m } = this.scrapeMotionValuesFromProps(
      t,
      {},
      this,
    )
    for (const g in m) {
      const y = m[g]
      c[g] !== void 0 && Nr(y) && y.set(c[g], !1)
    }
  }
  mount(e) {
    ;(this.current = e),
      sI.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, i) => this.bindToMotionValue(i, t)),
      tU.current || Zee(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === 'never'
          ? !1
          : this.reducedMotionConfig === 'always'
          ? !0
          : jM.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext)
  }
  unmount() {
    sI.delete(this.current),
      this.projection && this.projection.unmount(),
      Nc(this.notifyUpdate),
      Nc(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this)
    for (const e in this.events) this.events[e].clear()
    for (const e in this.features) {
      const t = this.features[e]
      t && (t.unmount(), (t.isMounted = !1))
    }
    this.current = null
  }
  bindToMotionValue(e, t) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)()
    const i = Ed.has(e),
      r = t.on('change', (a) => {
        ;(this.latestValues[e] = a),
          this.props.onUpdate && ri.preRender(this.notifyUpdate),
          i && this.projection && (this.projection.isTransformDirty = !0)
      }),
      s = t.on('renderRequest', this.scheduleRender)
    let o
    window.MotionCheckAppearSync &&
      (o = window.MotionCheckAppearSync(this, e, t)),
      this.valueSubscriptions.set(e, () => {
        r(), s(), o && o(), t.owner && t.stop()
      })
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current)
  }
  updateFeatures() {
    let e = 'animation'
    for (e in Ah) {
      const t = Ah[e]
      if (!t) continue
      const { isEnabled: i, Feature: r } = t
      if (
        (!this.features[e] &&
          r &&
          i(this.props) &&
          (this.features[e] = new r(this)),
        this.features[e])
      ) {
        const s = this.features[e]
        s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0))
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props)
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : Ri()
  }
  getStaticValue(e) {
    return this.latestValues[e]
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t
  }
  update(e, t) {
    ;(e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t)
    for (let i = 0; i < oI.length; i++) {
      const r = oI[i]
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r])
      const s = 'on' + r,
        o = e[s]
      o && (this.propEventSubscriptions[r] = this.on(r, o))
    }
    ;(this.prevMotionValues = Kee(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps, this),
      this.prevMotionValues,
    )),
      this.handleChildMotionValue && this.handleChildMotionValue()
  }
  getProps() {
    return this.props
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0
  }
  getDefaultTransition() {
    return this.props.transition
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode()
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      )
  }
  addValue(e, t) {
    const i = this.values.get(e)
    t !== i &&
      (i && this.removeValue(e),
      this.bindToMotionValue(e, t),
      this.values.set(e, t),
      (this.latestValues[e] = t.get()))
  }
  removeValue(e) {
    this.values.delete(e)
    const t = this.valueSubscriptions.get(e)
    t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState)
  }
  hasValue(e) {
    return this.values.has(e)
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e]
    let i = this.values.get(e)
    return (
      i === void 0 &&
        t !== void 0 &&
        ((i = vg(t === null ? void 0 : t, { owner: this })),
        this.addValue(e, i)),
      i
    )
  }
  readValue(e, t) {
    var i
    let r =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : (i = this.getBaseTargetFromProps(this.props, e)) !== null &&
          i !== void 0
        ? i
        : this.readValueFromInstance(this.current, e, this.options)
    return (
      r != null &&
        (typeof r == 'string' && (Kk(r) || Zk(r))
          ? (r = parseFloat(r))
          : !Jee(r) && Dc.test(t) && (r = uF(e, t)),
        this.setBaseTarget(e, Nr(r) ? r.get() : r)),
      Nr(r) ? r.get() : r
    )
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t
  }
  getBaseTarget(e) {
    var t
    const { initial: i } = this.props
    let r
    if (typeof i == 'string' || typeof i == 'object') {
      const o = iT(
        this.props,
        i,
        (t = this.presenceContext) === null || t === void 0 ? void 0 : t.custom,
      )
      o && (r = o[e])
    }
    if (i && r !== void 0) return r
    const s = this.getBaseTargetFromProps(this.props, e)
    return s !== void 0 && !Nr(s)
      ? s
      : this.initialValues[e] !== void 0 && r === void 0
      ? void 0
      : this.baseTarget[e]
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new hT()), this.events[e].add(t)
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t)
  }
}
class nU extends ete {
  constructor() {
    super(...arguments), (this.KeyframeResolver = dF)
  }
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0
  }
  removeValueFromRenderState(e, { vars: t, style: i }) {
    delete t[e], delete i[e]
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription)
    const { children: e } = this.props
    Nr(e) &&
      (this.childSubscription = e.on('change', (t) => {
        this.current && (this.current.textContent = `${t}`)
      }))
  }
}
function tte(n) {
  return window.getComputedStyle(n)
}
class nte extends nU {
  constructor() {
    super(...arguments), (this.type = 'html'), (this.renderInstance = WF)
  }
  readValueFromInstance(e, t) {
    if (Ed.has(t)) {
      const i = ST(t)
      return (i && i.default) || 0
    } else {
      const i = tte(e),
        r = (Jk(t) ? i.getPropertyValue(t) : i[t]) || 0
      return typeof r == 'string' ? r.trim() : r
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return CF(e, t)
  }
  build(e, t, i) {
    LT(e, t, i.transformTemplate)
  }
  scrapeMotionValuesFromProps(e, t, i) {
    return RT(e, t, i)
  }
}
class ite extends nU {
  constructor() {
    super(...arguments),
      (this.type = 'svg'),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = Ri)
  }
  getBaseTargetFromProps(e, t) {
    return e[t]
  }
  readValueFromInstance(e, t) {
    if (Ed.has(t)) {
      const i = ST(t)
      return (i && i.default) || 0
    }
    return (t = $F.has(t) ? t : pT(t)), e.getAttribute(t)
  }
  scrapeMotionValuesFromProps(e, t, i) {
    return YF(e, t, i)
  }
  build(e, t, i) {
    NT(e, t, this.isSVGTag, i.transformTemplate)
  }
  renderInstance(e, t, i, r) {
    XF(e, t, i, r)
  }
  mount(e) {
    ;(this.isSVGTag = DT(e.tagName)), super.mount(e)
  }
}
const rte = (n, e) =>
    PT(n) ? new ite(e) : new nte(e, { allowProjection: n !== X.Fragment }),
  ste = Yee({ ...$Q, ...pee, ...iee, ...mee }, rte),
  OT = FZ(ste),
  ote = { some: 0, all: 1 }
function ate(n, e, { root: t, margin: i, amount: r = 'some' } = {}) {
  const s = Ok(n),
    o = new WeakMap(),
    a = (u) => {
      u.forEach((h) => {
        const m = o.get(h.target)
        if (h.isIntersecting !== !!m)
          if (h.isIntersecting) {
            const g = e(h)
            typeof g == 'function' ? o.set(h.target, g) : c.unobserve(h.target)
          } else m && (m(h), o.delete(h.target))
      })
    },
    c = new IntersectionObserver(a, {
      root: t,
      rootMargin: i,
      threshold: typeof r == 'number' ? r : ote[r],
    })
  return s.forEach((u) => c.observe(u)), () => c.disconnect()
}
function lte(n, { root: e, margin: t, amount: i, once: r = !1 } = {}) {
  const [s, o] = X.useState(!1)
  return (
    X.useEffect(() => {
      if (!n.current || (r && s)) return
      const a = () => (o(!0), r ? void 0 : () => o(!1)),
        c = { root: (e && e.current) || void 0, margin: t, amount: i }
      return ate(n.current, a, c)
    }, [e, n, t, r, i]),
    s
  )
}
const cte = [
    { label: 'timeline', id: 'timeline', offset: -100 },
    { label: 'projects', id: 'projects', offset: -50 },
    { label: 'other', id: 'other', offset: -100 },
  ],
  ute = [
    { label: 'Enso SaaS Platform', id: '/enso' },
    { label: 'Google Internship', id: '/google' },
    { label: 'ReStyle Mobile App', id: '/restyle' },
  ],
  hS = [
    {
      title: 'AZ Laboratories Dashboard Redesign',
      src: 'https://jf-temp-1301446188.cos.ap-guangzhou.myqcloud.com/R09TUw==/eyJpZCI6ImNhMTA3NzQyLTljY2MtNDZjOC1hZWU2LTUxMjE0M2YzNWQwMiIsIm5hbWUiOiJwMS5wbmciLCJkaXIiOiIifQ==',
      bgColor: '#FDE8B1',
      tags: [{ name: 'Adobe Creative Suite' }],
      tagline:
        'Work with AZ Lab',
      name: 'peaem website',
      url: '/peaem',
      icon: !0,
    },
    {
      title: '1Cademy Collaborative Platform',
      src: '/homepage/other/1cademy.jpg',
      url: '/1cademy',
      bgColor: '#212121',
      tags: [],
      tagline:
        'Design Lead | Collaborative platform for students and professors',
      textColor: '#ff8a33',
      summary:
        '1Cademy is a research group sponsored by Google Cloud, Honor Education, and the University of Michigan. Our mission is to develop a collaborative learning platform for students, professors, and researchers.',
    },
    {
      title: 'We Beat - Healthcare Mobile App',
      src: '/homepage/other/wb.jpg',
      bgColor: '#EAF6F6',
      tags: [],
      tagline: 'Resiliency training app for C.S. Mott Hospital at UMich',
      textColor: '#EAF6F6',
      name: 'we beat app',
      url: '/wb',
      icon: !0,
    },
    {
      title: 'Individual Responsive Website Project',
      src: '/homepage/other/individual.jpg',
      bgColor: '#4A5E69',
      tags: [
        { name: 'Accessibility' },
        { name: 'HTML, CSS, JS' },
        { name: 'Responsive Design' },
      ],
      tagline: 'Design + development from start to finish',
      name: 'individual website project',
      url: '/individual',
      icon: !0,
    },
    {
      title: 'MotorCity Casino Navigation App',
      src: '/homepage/other/casino.jpg',
      bgColor: '#AFC1CB',
      tags: [
        { name: 'Figma Prototype' },
        { name: 'Project Management' },
        { name: 'React' },
      ],
      tagline:
        'Collaboration with hardware and software students to build a navigation app demo',
      name: 'motorcity app',
      url: '/casino',
      icon: !0,
    },
  ],
  dte = () => {
    const [n, e] = X.useState(hS[0].src),
      [t, i] = X.useState(hS[0].url),
      [r, s] = X.useState(0),
      [o, a] = X.useState(!1),
      c = (u, h) => {
        e(u.src), i(u.url), s(h)
      }
    return (
      X.useEffect(() => {
        const u = () => {
          a(window.innerWidth < 768)
        }
        return (
          u(),
          window.addEventListener('resize', u),
          () => {
            window.removeEventListener('resize', u)
          }
        )
      }, []),
      b.jsxs('div', {
        className:
          'md:space-x-10 xl:space-x-[3%] justify-center flex pb-20 lg:pb-10 relative',
        children: [
          b.jsx('div', {
            className:
              'md:w-[45%] xl:w-[45%] xl:h-[85vh] rounded-lg overflow-hidden z-10',
            children: b.jsx(OT.img, {
              src: n,
              alt: 'Selected Image',
              className: 'hidden md:block h-full w-full object-cover',
              transition: { duration: 0.3 },
              initial: { opacity: 0 },
              animate: { opacity: 1 },
            }),
          }),
          b.jsxs('div', {
            className:
              'w-[80%] md:w-[40%] xl:w-[32%] flex flex-col justify-center',
            children: [
              b.jsxs('h3', {
                className:
                  'pb-8 text-center text-xl font-semibold md:text-left xl:text-2xl xl:font-normal pl-4 italic text-gray-500',
                children: [' ', "Some other projects I've done", ' '],
              }),
              hS.map((u, h) =>
                b.jsx(
                  'div',
                  {
                    onClick: () => c(u, h),
                    className: `md:cursor-pointer py-6 px-4 border-b-[1px] border-borderColor transition-colors duration-500 ease-in-out 
              ${!o && r === h ? 'text-primary font-bold bg-[#F8F8F8]' : ''} 
              md:hover:bg-[#F3F3F3]`,
                    children: b.jsxs('div', {
                      className: 'flex flex-row ',
                      children: [
                        b.jsx('span', {
                          className: `text-xl md:text-2xl font-title w-[1.5rem] pr-8
                  ${r === h ? 'text-primary' : ''}`,
                          children:
                            !o && r === h
                              ? b.jsx('svg', {
                                  xmlns: 'http://www.w3.org/2000/svg',
                                  viewBox: '0 0 24 24',
                                  fill: 'currentColor',
                                  className: 'size-6 transform scale-x-[-1]',
                                  children: b.jsx('path', {
                                    fillRule: 'evenodd',
                                    d: 'M4.5 5.653c0-1.427 1.529-2.33 2.779-1.643l11.54 6.347c1.295.712 1.295 2.573 0 3.286L7.28 19.99c-1.25.687-2.779-.217-2.779-1.643V5.653Z',
                                    clipRule: 'evenodd',
                                  }),
                                })
                              : h + 1 + '.',
                        }),
                        b.jsxs('span', {
                          className: 'space-y-1 ml-0',
                          children: [
                            b.jsx('h4', { className: '', children: u.title }),
                            b.jsx('p', {
                              className: 'text-sm font-light',
                              children: u.tagline,
                            }),
                          ],
                        }),
                      ],
                    }),
                  },
                  h,
                ),
              ),
            ],
          }),
        ],
      })
    )
  },
  fte = [
    { src: '/homepage/design/1', alt: 'Magazine design 1' },
    { src: '/homepage/design/3', alt: 'Magazine design 3' },
    { src: '/homepage/design/4', alt: 'Magazine design 4' },
  ]
function hte({ src: n, closeModal: e }) {
  return b.jsxs(
    OT.div,
    {
      className:
        'w-screen h-screen fixed z-50 top-0 left-0 right-0 bottom-0 flex items-center justify-center bg-black bg-opacity-75 m-0',
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      children: [
        b.jsx('span', { className: 'absolute w-full h-full', onClick: e }),
        b.jsxs('div', {
          className: 'relative max-w-[60%]',
          children: [
            b.jsx('img', {
              src: n,
              alt: 'Selected Image',
              className: 'max-h-[80vh] object-contain',
            }),
            b.jsx('button', {
              className: `absolute bg-light/40 rounded-full w-12 h-12 top-4 right-4 flex items-center justify-center
                text-black/60 outline-none bg-white/40 hover:bg-white/80 hover:text-black easeAnimateStyle`,
              onClick: e,
              children: b.jsx('svg', {
                xmlns: 'http://www.w3.org/2000/svg',
                fill: 'none',
                viewBox: '0 0 24 24',
                strokeWidth: 2,
                stroke: 'currentColor',
                className: 'w-8 h-8',
                children: b.jsx('path', {
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  d: 'M6 18L18 6M6 6l12 12',
                }),
              }),
            }),
          ],
        }),
      ],
    },
    'modal',
  )
}
const pte = ({ images: n }) => {
  const [e, t] = X.useState(null),
    [i, r] = X.useState(!1)
  X.useEffect(() => {
    const a = window.matchMedia('(min-width: 768px)'),
      c = () => r(a.matches)
    return (
      c(),
      a.addEventListener('change', c),
      () => {
        a.removeEventListener('change', c)
      }
    )
  }, [])
  const s = (a) => {
      i && t(a)
    },
    o = () => {
      t(null)
    }
  return b.jsxs('div', {
    className: 'w-full relative hidden lg:block',
    children: [
      b.jsxs('div', {
        className: 'w-[80%] flex flex-col lg:flex-row mx-auto ',
        children: [
          b.jsxs('div', {
            className:
              'flex flex-col justify-center items-start pb-8 w-full lg:w-[15vw] z-10 space-y-4 mr-24',
            children: [
              b.jsx('div', {
                className: 'flex flex-row lg:flex-col items-start lg:space-y-2',
                children: b.jsx('h3', {
                  className: 'xl:text-[1.5rem] 2xl:text-[1.8rem] pb-8',
                  children: 'Graphic Design',
                }),
              }),
              b.jsxs('div', {
                className:
                  'lg:w-[15vw] flex items-center justify-between flex-row z-10',
                children: [
                  b.jsx('img', {
                    src: '/homepage/design/illustrator.png',
                    alt: 'illustrator logo',
                    className: 'w-[30%]',
                  }),
                  b.jsx('img', {
                    src: '/homepage/design/indesign.png',
                    alt: 'indesign logo',
                    className: 'w-[30%]',
                  }),
                  b.jsx('img', {
                    src: '/homepage/design/photoshop.png',
                    alt: 'photoshop logo',
                    className: 'w-[30%]',
                  }),
                ],
              }),
            ],
          }),
          b.jsx('div', {
            className:
              'flex flex-col lg:flex-row space-y-4 lg:space-y-0 lg:space-x-8 justify-end',
            children: n.map((a, c) =>
              b.jsx(
                'div',
                {
                  className: `cursor-pointer relative w-[80%] lg:w-[30%] border border-[#bdbdbd]
          md:hover:brightness-75 easeAnimateStyle z-10 rounded-lg overflow-hidden`,
                  onClick: () => s(a),
                  children: b.jsx('img', {
                    src: a.src + '_sm.jpg',
                    alt: `Image ${c + 1}`,
                    className: 'w-full h-full object-cover',
                  }),
                },
                c,
              ),
            ),
          }),
        ],
      }),
      b.jsx('img', {
        src: '/homepage/design/waves.svg',
        className:
          'hidden lg:inline-block w-full absolute top-[-60%] left-0 z-0',
      }),
      e && b.jsx(hte, { src: e.src + '_lg.jpg', closeModal: o }),
    ],
  })
}
function mte() {
  return b.jsxs('div', {
    className:
      'whitespace-normal lg:whitespace-pre-line w-[100vw] bg-white overflow-x-hidden',
    'data-theme': 'home',
    children: [
      b.jsx(KD, { sidebarItems: cte }),
      b.jsxs('div', {
        id: 'home',
        className: '',
        children: [
          b.jsx(C7, {}),
          b.jsxs('p', {
            className: `w-[90%] max-w-[240px] lg:w-auto lg:max-w-[1400px] mt-2 text-lg absolute z-10 text-[#616160] font-light 
      top-[50vh] left-[50%] transform -translate-x-1/2 -translate-y-1/2 text-center font-title xl:text-[1.1rem] 2xl:text-[1.2rem] 2xl:leading-relaxed`,
            children: [
              "Hi, I'm Kevin. Bridging ",
              b.jsx('strong', { children: 'computer science and design' }),
              ',',
              ' ',
              `
`,
              'I design experiences, navigating business dynamics, ',
              `
`,
              ' where human emotions illuminate technology.',
            ],
          }),
        ],
      }),
      b.jsx(kZ, {}),
      b.jsx('div', {
        className:
          'flex justify-center items-center pb-40 px-4 lg:px-20 xl:px-20 2xl:px-40 xl:ml-[5%]',
        id: 'projects',
        children: b.jsxs('div', {
          className: 'w-full flex flex-col space-y-8',
          children: [
            b.jsxs('div', {
              className:
                'w-full flex flex-col lg:flex-row space-y-8 lg:space-y-0',
              children: [
                b.jsx(fy, {
                  ProjectSrc: '/enso',
                  imgSrc: '/homepage/enso.jpg',
                  title:
                    'Web3-encrypted app for secure enterprise collaboration',
                  description: 'Sole designer from concept to launch',
                  tags: ['Design System', 'Functionality-First Design'],
                  borderDirection: ['bottom'],
                }),
                b.jsx('div', {
                  className:
                    'w-[1.5px] h-[29rem] bg-[#dddddd] mx-8 hidden lg:block',
                }),
                b.jsx(fy, {
                  ProjectSrc: '/google',
                  imgSrc: '/homepage/google.jpg',
                  title:
                    '[Google Internship] Consumer-facing development platform',
                  description:
                    'Pivoted direction, driving immediate and long-term technical solutions.',
                  tags: [
                    'Cross-Functional Collaboration',
                    'Developer Experience',
                  ],
                  imagePos: 'object-right-top',
                  borderDirection: ['bottom'],
                }),
              ],
            }),
            b.jsxs('div', {
              className:
                'flex flex-col lg:flex-row space-y-8 lg:space-y-0 lg:pt-5',
              children: [
                b.jsx(fy, {
                  ProjectSrc: '/restyle',
                  imgSrc: '/homepage/restyle.jpg',
                  title: '[Restyle] Redesigning the way we recycle fashion',
                  tags: [
                    'Design system',
                    'Information Hierachy',
                    'Usability Testing',
                  ],
                }),
                b.jsx('div', {
                  className:
                    'w-[1.5px] h-[29rem] bg-[#dddddd] mx-8 hidden lg:block',
                }),
                b.jsx(fy, {
                  ProjectSrc: '',
                  imgSrc: '/homepage/lock.jpg',
                  title:
                    '[2025 Capstone] Surefront B2B Product Management Platform',
                  tags: [],
                  disabled: !0,
                }),
              ],
            }),
          ],
        }),
      }),
      b.jsx('section', {
        id: 'design',
        className: 'w-full pb-20 lg:pb-40 lg:pt-10 xl:ml-[3%]',
        children: b.jsx(pte, { images: fte }),
      }),
      b.jsx('section', {
        id: 'other',
        className: 'w-full lg:pb-20 z-[1] xl:pb-10 xl:ml-[3%]',
        children: b.jsx(dte, {}),
      }),
      b.jsx('div', { className: 'w-full xl:ml-[4%]', children: b.jsx(nT, {}) }),
    ],
  })
}
const so = ({ pt: n, pb: e }) => {
    const t = n ? `xl:pt-${n}` : '',
      i = e ? `xl:pb-${e}` : '',
      r = `w-full border-t border-borderColor ${t} ${i}`.trim()
    return b.jsx('div', { className: r })
  },
  gte = () =>
    b.jsxs('div', {
      className: 'overflow-hidden',
      'data-theme': 'home',
      children: [
        b.jsx(KD, { sidebarItems: ute, defaultVisible: !0 }),
        b.jsxs('div', {
          className: 'xl:pl-[5%]',
          children: [
            b.jsxs('div', {
              className:
                'mx-[7.5%] lg:mx-0 space-y-4 lg:space-y-6 pt-32 lg:pt-48 pb-10 lg:pb-0 flex flex-col lg:items-center',
              children: [
                b.jsx('h1', {
                  className:
                    'text-left lg:text-center font-semibold lg:font-normal',
                  children:
                    "Here's my journey so far. Let's talk about what's next!",
                }),
                b.jsx('p', {
                  className: 'lg:w-[70%] xl:w-[50%] lg:text-center font-light',
                  children:
                    'UX Designer with CS background and experience in B2B and consumer platforms, SaaS web app, AI- driven tools, and developer solutions. I align cross-functional teams through rapid prototyping and leverage research-driven insights to create scalable design systems for complex platforms.',
                }),
                b.jsx('div', {
                  className: 'w-[10%] border-t border-borderColor lg:mx-auto',
                }),
                b.jsxs('div', {
                  className:
                    'flex flex-col space-y-4 md:space-y-0 md:items-center lg:justify-center md:flex-row md:space-x-3 text-gray-500',
                  children: [
                    b.jsxs('a', {
                      href: '/resume_ember_2025.pdf',
                      target: '_blank',
                      className:
                        'hover:text-black hover:bg-opacity-100 easeAnimateStyle bg-borderColor bg-opacity-40 px-4 py-1 rounded-full',
                      children: [' ', 'Download my resume', ' '],
                    }),
                    b.jsx('a', {
                      href: 'https://www.linkedin.com/in/ember-shan',
                      target: '_blank',
                      rel: 'noopener noreferrer',
                      className:
                        'hover:text-black easeAnimateStyle bg-borderColor bg-opacity-40 px-4 py-1 rounded-full',
                      children: 'LinkedIn',
                    }),
                    b.jsx('a', {
                      href: 'mailto:emberuiux@gmail.com',
                      className:
                        'hover:text-black easeAnimateStyle bg-borderColor bg-opacity-40 px-4 py-1 rounded-full',
                      children: 'emberuiux@gmail.com',
                    }),
                  ],
                }),
              ],
            }),
            b.jsx('div', {
              className:
                'hidden lg:flex relative h-[80vh] lg:h-[30vh] w-full lg:items-center lg:justify-center lg:flex-row flex-col lg:space-y-0 space-y-8',
              children: b.jsxs('div', {
                className:
                  'relative w-[80%] lg:h-[1px] h-full bg-[#8C8C8C] flex lg:flex-row flex-col items-center mx-auto',
                children: [
                  b.jsxs('div', {
                    className:
                      'absolute lg:left-0 lg:top-[-2.25rem] top-0 flex flex-col items-center',
                    children: [
                      b.jsx('span', {
                        className:
                          'text-gray-600 lg:mb-3 ml-[3rem] lg:ml-0 absolute top-[-7px] lg:static lg:top-0',
                        children: '2019',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[5px] h-[5px] bg-gray-700 rounded-full transform lg:-translate-y-[2px]',
                      }),
                      b.jsxs('span', {
                        className: `lg:mb-4 text-gray-700 absolute right-1/2 mr-3 text-right w-[45vw] text-sm 
            lg:w-[300px] lg:top-[3rem] lg:left-0 lg:text-base lg:mr-0 lg:right-auto lg:text-left lg:space-y-1`,
                        children: [
                          b.jsx('p', { children: ' 2019-2021 ' }),
                          b.jsx('p', {
                            className: 'font-bold',
                            children: ' College of William & Mary ',
                          }),
                          b.jsx('p', {
                            children: ' Working toward CS and Art ',
                          }),
                        ],
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className:
                      'absolute lg:left-[14%] lg:top-[-2.25rem] top-[13%] flex flex-col items-center',
                    children: [
                      b.jsx('span', {
                        className:
                          'text-gray-600 lg:mb-3 ml-[3rem] lg:ml-0 absolute top-[-7px] lg:static lg:top-0',
                        children: '2020',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[5px] h-[5px] bg-gray-700 rounded-full transform lg:-translate-y-[2px]',
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className:
                      'absolute lg:left-[29%] lg:top-[-2.25rem] top-[26%] flex flex-col items-center',
                    children: [
                      b.jsx('span', {
                        className:
                          'text-gray-600 lg:mb-3 ml-[3rem] lg:ml-0 absolute top-[-7px] lg:static lg:top-0',
                        children: '2021',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[5px] h-[5px] bg-gray-700 rounded-full transform lg:-translate-y-[2px]',
                      }),
                      b.jsxs('span', {
                        className: `lg:mb-4 text-gray-700 absolute right-1/2 mr-3 text-right w-[45vw] text-sm 
            lg:w-[300px] lg:top-[3rem] lg:left-0 lg:text-base lg:mr-0 lg:right-auto lg:text-left lg:space-y-1`,
                        children: [
                          b.jsx('p', { children: ' 2021-​04/2023 ' }),
                          b.jsxs('p', {
                            className: 'font-bold',
                            children: [
                              ' ',
                              'University of Michigan - Ann Arbor',
                              ' ',
                            ],
                          }),
                          b.jsx('p', {
                            children: ' B.S. in Information Science ',
                          }),
                        ],
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className:
                      'absolute lg:left-[43%] lg:top-[-2.25rem] top-[39%] flex flex-col items-center',
                    children: [
                      b.jsx('span', {
                        className:
                          'text-gray-600 lg:mb-3 ml-[3rem] lg:ml-0 absolute top-[-7px] lg:static lg:top-0',
                        children: '2022',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[5px] h-[5px] bg-gray-700 rounded-full transform lg:-translate-y-[2px]',
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className:
                      'absolute lg:left-[57%] lg:top-[-2.25rem] top-[52%] flex flex-col items-center',
                    children: [
                      b.jsx('span', {
                        className:
                          'text-gray-600 lg:mb-3 ml-[3rem] lg:ml-0 absolute top-[-7px] lg:static lg:top-0',
                        children: '2023',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[5px] h-[5px] bg-gray-700 rounded-full transform lg:-translate-y-[2px]',
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className:
                      'absolute lg:left-[71%] lg:top-[-2.25rem] top-[65%] flex flex-col items-center',
                    children: [
                      b.jsx('span', {
                        className:
                          'text-gray-600 lg:mb-3 ml-[3rem] lg:ml-0 absolute top-[-7px] lg:static lg:top-0',
                        children: '2024',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[5px] h-[5px] bg-gray-700 rounded-full transform lg:-translate-y-[2px]',
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className:
                      'absolute lg:left-[85%] lg:top-[-2.25rem] top-[78%] flex flex-col items-center',
                    children: [
                      b.jsx('span', {
                        className:
                          'text-gray-600 lg:mb-3 ml-[3rem] lg:ml-0 absolute top-[-7px] lg:static lg:top-0',
                        children: '2025',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[5px] h-[5px] bg-gray-700 rounded-full transform lg:-translate-y-[2px]',
                      }),
                      b.jsxs('span', {
                        className: `lg:mb-4 text-gray-700 absolute right-1/2 mr-3 text-right w-[45vw] text-sm 
            lg:w-[300px] lg:top-[3rem] lg:left-0 lg:text-base lg:mr-0 lg:right-auto lg:text-left lg:space-y-1`,
                        children: [
                          b.jsx('p', {
                            children: ' 08/2024-expected 08/2025 ',
                          }),
                          b.jsx('p', {
                            className: 'font-bold',
                            children: ' Carnegie Mellon University ',
                          }),
                          b.jsxs('p', {
                            className: 'max-w-[80%]',
                            children: [
                              ' ',
                              'M.S. in Human-Computer Interaction, School of Computer Science',
                              ' ',
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            }),
            b.jsxs('div', {
              className: 'lg:hidden space-y-8 mx-[7.5%]',
              children: [
                b.jsxs('div', {
                  className: 'border-b border-borderColor w-full rounded-md',
                  children: [
                    b.jsx('p', { children: ' 2019​-2021 ' }),
                    b.jsx('p', {
                      className: 'font-semibold',
                      children: ' College of William & Mary ',
                    }),
                    b.jsx('p', { children: ' Working toward CS and Art ' }),
                  ],
                }),
                b.jsxs('div', {
                  className: 'border-b border-borderColor w-full rounded-md',
                  children: [
                    b.jsx('p', { children: ' 2021​-04/2023 ' }),
                    b.jsxs('p', {
                      className: 'font-semibold',
                      children: [
                        ' ',
                        'University of Michigan - Ann Arbor',
                        ' ',
                      ],
                    }),
                    b.jsx('p', { children: ' B.S. in Information Science ' }),
                  ],
                }),
                b.jsxs('div', {
                  className: 'rounded-md w-full',
                  children: [
                    b.jsx('p', { children: ' 08/2024-expected 08/2025 ' }),
                    b.jsx('p', {
                      className: 'font-semibold',
                      children: ' Carnegie Mellon University ',
                    }),
                    b.jsxs('p', {
                      children: [
                        ' ',
                        'M.S. in Human-Computer Interaction, School of Computer Science',
                        ' ',
                      ],
                    }),
                  ],
                }),
              ],
            }),
            b.jsxs('div', {
              className:
                'content-container pb-0 pt-0 lg:py-0 xl:pt-0 xl:pb-0 mx-[7.5%] lg:mx-auto',
              id: 'work-experience',
              children: [
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] xl:w-full space-y-6 pt-20 lg:pt-40 flex flex-col',
                  children: [
                    b.jsx('h2', {
                      className: 'text-left xl:text-center uppercase',
                      children: 'WORK EXPERIENCE',
                    }),
                    b.jsx(so, {}),
                  ],
                }),
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] space-y-4 xl:space-y-0 xl:space-x-8 flex flex-col xl:flex-row mx-auto',
                  children: [
                    b.jsxs('span', {
                      className: 'xl:w-[30%] space-y-1',
                      children: [
                        b.jsx('h3', {
                          className: 'text-[#8C8C8C]',
                          children: ' Google ',
                        }),
                        b.jsx('h3', { children: ' UX Design Intern ' }),
                        b.jsxs('p', {
                          className: 'text-[#8C8C8C] text-sm',
                          children: [' ', '05-​08/2024, Sunnyvale, CA', ' '],
                        }),
                      ],
                    }),
                    b.jsxs('span', {
                      className: 'xl:w-[70%] space-y-4 text-[#202020]',
                      children: [
                        b.jsx('p', {
                          children:
                            'Defined the UX vision for a new Firebase developer tool, proactively uncovering user pain points to improve onboarding and discoverability. Drove two proposals to leadership approval within three months.',
                        }),
                        b.jsx('p', {
                          children:
                            'Designed high-fidelity prototypes and led presentations to UX and PM leads, aligning cross-functional teams and integrating feedback into final designs. Closely collaborated with engineers to ensure feasibility.',
                        }),
                        b.jsx('p', {
                          children:
                            'Developed a scalable, cohesive design system aligned with new style guidelines, collaborating with multiple product teams to create a unified user experience.',
                        }),
                      ],
                    }),
                  ],
                }),
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] space-y-4 xl:space-y-0 xl:space-x-8 flex flex-col xl:flex-row mx-auto',
                  children: [
                    b.jsxs('span', {
                      className: 'xl:w-[30%] space-y-1',
                      children: [
                        b.jsx('h3', {
                          className: 'text-[#8C8C8C]',
                          children: ' PeaEm ',
                        }),
                        b.jsx('h3', { children: ' Sr. Product Designer ' }),
                        b.jsxs('p', {
                          className: 'text-[#8C8C8C] text-sm',
                          children: [' ', '05/2023-​05/2024, Remote', ' '],
                        }),
                      ],
                    }),
                    b.jsxs('span', {
                      className: 'xl:w-[70%] space-y-4 text-[#202020]',
                      children: [
                        b.jsx('p', {
                          children:
                            'Sole UX designer driving the launch of a previously stalled 2-year encrypted B2B SaaS web app for secure online communication and document collaboration.',
                        }),
                        b.jsx('p', {
                          children:
                            'Navigated ambiguity to define the MVP, translating competitive insights, interview findings, and business needs into actionable design decisions. Collaborated with engineers to ensure seamless parallel design and development in Figma Dev Mode.',
                        }),
                        b.jsx('p', {
                          children:
                            'Created investor-ready high-fidelity prototypes that helped secure funding. Conducted usability testing to refine user flows, simplify language, and improve accessibility.',
                        }),
                      ],
                    }),
                  ],
                }),
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] space-y-4 xl:space-y-0 xl:space-x-8 flex flex-col xl:flex-row mx-auto',
                  children: [
                    b.jsxs('span', {
                      className: 'xl:w-[30%] space-y-1',
                      children: [
                        b.jsx('h3', {
                          className: 'text-[#8C8C8C]',
                          children: ' 1Cademy at UMich ',
                        }),
                        b.jsx('h3', { children: ' Design Lead ' }),
                        b.jsxs('p', {
                          className: 'text-[#8C8C8C] text-sm',
                          children: [' ', '04/2022-​01/2023, Part-time', ' '],
                        }),
                      ],
                    }),
                    b.jsxs('span', {
                      className: 'xl:w-[70%] space-y-4 text-[#202020]',
                      children: [
                        b.jsx('p', {
                          children:
                            'Led an international team of 8 engineers across multiple countries, managing collaboration through GitHub in an agile workflow for a learning platform used by 1,400+ students across 184 U.S. universities.',
                        }),
                        b.jsx('p', {
                          children:
                            "Conducted 2-hour design workshops and established 1Cademy's first design system with style guides.",
                        }),
                      ],
                    }),
                  ],
                }),
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] space-y-4 xl:space-y-0 xl:space-x-8 flex flex-col xl:flex-row xl:items-center mx-auto',
                  children: [
                    b.jsxs('span', {
                      className: 'xl:w-[30%] space-y-1',
                      children: [
                        b.jsx('h3', {
                          className: 'text-[#8C8C8C]',
                          children: ' Energy Solutions ',
                        }),
                        b.jsx('h3', { children: ' Wed Design Intern ' }),
                        b.jsxs('p', {
                          className: 'text-[#8C8C8C] text-sm',
                          children: [' ', '07/2022-​01/2023, Remote', ' '],
                        }),
                      ],
                    }),
                    b.jsx('span', {
                      className: 'xl:w-[70%] space-y-4 text-[#202020]',
                      children: b.jsx('p', {
                        children:
                          'Revamped the company website by addressing WCAG accessibility and navigation issues, leading to a 15% reduction in bounce rate.',
                      }),
                    }),
                  ],
                }),
              ],
            }),
            b.jsxs('div', {
              className:
                'content-container pt-0 lg:pt-0 xl:pt-0 xl:pb-32 mx-[7.5%] lg:mx-auto',
              id: 'academic-projects',
              children: [
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] xl:w-full space-y-6 pt-20 lg:pt-32 flex flex-col',
                  children: [
                    b.jsx('h2', {
                      className: 'text-left xl:text-center uppercase',
                      children: 'Academic Projects',
                    }),
                    b.jsx(so, {}),
                  ],
                }),
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] space-y-4 xl:space-y-0 xl:space-x-8 flex flex-col xl:flex-row mx-auto xl:items-center',
                  children: [
                    b.jsxs('span', {
                      className: 'xl:w-[30%] space-y-1',
                      children: [
                        b.jsx('h3', {
                          className: 'text-[#8C8C8C]',
                          children: ' Surefront (School Capstone)',
                        }),
                        b.jsx('h3', { children: ' UX Designer ' }),
                        b.jsxs('p', {
                          className: 'text-[#8C8C8C] text-sm',
                          children: [
                            ' ',
                            '01/2025-​Present, Pittsburgh, PA',
                            ' ',
                          ],
                        }),
                      ],
                    }),
                    b.jsx('span', {
                      className: 'xl:w-[70%] space-y-4 text-[#202020]',
                      children: b.jsx('p', {
                        children:
                          'Prioritized business goals through scoping canvas. Conducted 10 on-site interviews with suppliers and retailers to inform UX changes, adapting the B2B PLM platform for new apparel verticals.',
                      }),
                    }),
                  ],
                }),
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] space-y-4 xl:space-y-0 xl:space-x-8 flex flex-col xl:flex-row mx-auto xl:items-center',
                  children: [
                    b.jsxs('span', {
                      className: 'xl:w-[30%] space-y-1',
                      children: [
                        b.jsx('h3', {
                          className: 'text-[#8C8C8C]',
                          children: ' US Navy AI Agent ',
                        }),
                        b.jsx('h3', { children: ' UX Designer ' }),
                        b.jsxs('p', {
                          className: 'text-[#8C8C8C] text-sm',
                          children: [' ', '08-​12/2024, Pittsburgh, PA', ' '],
                        }),
                      ],
                    }),
                    b.jsx('span', {
                      className: 'xl:w-[70%] space-y-4 text-[#202020]',
                      children: b.jsx('p', {
                        children:
                          'Designed and optimized human-AI workflows for decision-making between naval teams and an AI chatbot. Improved situational awareness by integrating real-time aerial sensor notifications, enabling context-aware responses.',
                      }),
                    }),
                  ],
                }),
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] space-y-4 xl:space-y-0 xl:space-x-8 flex flex-col xl:flex-row xl:items-center mx-auto',
                  children: [
                    b.jsxs('span', {
                      className: 'xl:w-[30%] space-y-1',
                      children: [
                        b.jsx('h3', {
                          className: 'text-[#8C8C8C]',
                          children: ' C.S. Mott Hospital ',
                        }),
                        b.jsx('h3', { children: ' UX Researcher + Designer ' }),
                        b.jsxs('p', {
                          className: 'text-[#8C8C8C] text-sm',
                          children: [
                            ' ',
                            '09/2022-​04/2023, Ann Arbor, MI',
                            ' ',
                          ],
                        }),
                      ],
                    }),
                    b.jsxs('span', {
                      className: 'xl:w-[70%] space-y-4 text-[#202020]',
                      children: [
                        b.jsx('p', {
                          children:
                            'Led the design of a mental health app for children with chronic heart disease, resulting in a 90% satisfaction rate among 4 focus groups.',
                        }),
                        b.jsx('p', {
                          children:
                            'Conducted interviews with physicians and children, affinity diagrams, competitive analysis, and heuristic evaluation in a group of 4 researchers to incorporate research findings and UX requirements.',
                        }),
                      ],
                    }),
                  ],
                }),
                b.jsxs('div', {
                  className:
                    'w-full lg:w-[80%] space-y-4 xl:space-y-0 xl:space-x-8 flex flex-col xl:flex-row xl:items-center mx-auto',
                  children: [
                    b.jsxs('span', {
                      className: 'xl:w-[30%] space-y-1',
                      children: [
                        b.jsx('h3', {
                          className: 'text-[#8C8C8C]',
                          children: ' MotorCity Hotel ',
                        }),
                        b.jsx('h3', { children: ' Frontend Developer ' }),
                        b.jsxs('p', {
                          className: 'text-[#8C8C8C] text-sm',
                          children: [' ', '01/2022-​12/2022, Detroit, MI', ' '],
                        }),
                      ],
                    }),
                    b.jsx('span', {
                      className: 'xl:w-[70%] space-y-4 text-[#202020]',
                      children: b.jsx('p', {
                        children:
                          'Developed a navigation app using the React.js framework, integrating location data from APIs for dynamic functionality. Enhanced hierarchy and usability through color schemes and micro-interactions.',
                      }),
                    }),
                  ],
                }),
              ],
            }),
            b.jsx(nT, { theme: 'home', goBackHome: 'true' }),
          ],
        }),
      ],
    }),
  iU = ({
    isVisible: n,
    setIsVisible: e,
    sidebarItems: t,
    theme: i,
    isFixed: r,
    mixBlend: s,
    isBottom: o,
  }) => (
    X.useEffect(() => {
      const a = () => {
        const c = window.scrollY,
          u = window.innerHeight
        c >= (u * 3) / 4 ? e(!0) : e(!1)
      }
      return (
        window.addEventListener('scroll', a),
        () => {
          window.removeEventListener('scroll', a)
        }
      )
    }, []),
    b.jsxs('div', {
      className: `z-20 hidden h-full text-sidebarText
        ${s ? `${s}` : 'mix-blend-normal'}
        xl:bg-dark xl:justify-between xl:h-screen xl:w-[7%] xl:py-8 xl:flex-col xl:items-center 
        easeAnimateStyle  
        hidden xl:fixed top-0 left-0 xl:flex xl:border-r xl:border-borderColor
        ${r || n ? 'opacity-100' : 'xl:opacity-0'} 
      `,
      'data-theme': i,
      children: [
        b.jsx(Ic, { theme: i }),
        b.jsx('ul', {
          className: `space-y-6 h-full flex flex-col justify-center text-sm 
         easeAnimateStyle`,
          children: t.map((a) => {
            const c = a.id.startsWith('/')
            return b.jsx(
              'li',
              {
                className:
                  'py-1 px-1 cursor-pointer list-none text-center hover:text-primary',
                children: c
                  ? b.jsxs('span', {
                      className: 'flex flex-row items-center',
                      children: [
                        b.jsx(Fs, {
                          to: a.id,
                          children: b.jsxs('p', {
                            className: 'text-sm',
                            children: [' ', a.label, ' '],
                          }),
                        }),
                        a.icon
                          ? b.jsx('svg', {
                              xmlns: 'http://www.w3.org/2000/svg',
                              viewBox: '0 0 20 20',
                              fill: 'currentColor',
                              className: 'w-5 h-5 mr-1',
                              children: b.jsx('path', {
                                fillRule: 'evenodd',
                                d: 'M5.22 14.78a.75.75 0 001.06 0l7.22-7.22v5.69a.75.75 0 001.5 0v-7.5a.75.75 0 00-.75-.75h-7.5a.75.75 0 000 1.5h5.69l-7.22 7.22a.75.75 0 000 1.06z',
                                clipRule: 'evenodd',
                              }),
                            })
                          : b.jsx(b.Fragment, {}),
                      ],
                    })
                  : b.jsx('span', {
                      children: b.jsxs(YD.Link, {
                        to: a.id,
                        smooth: !0,
                        duration: 100,
                        offset: a.offset || 0,
                        spy: !0,
                        activeClass: 'text-primary underline',
                        children: [
                          a.icon &&
                            b.jsx('span', {
                              className: 'icon',
                              children: 'Icon',
                            }),
                          ' ',
                          b.jsxs('p', {
                            className: 'text-sm',
                            children: [' ', a.label, ' '],
                          }),
                        ],
                      }),
                    }),
              },
              a.id,
            )
          }),
        }),
        b.jsxs('div', {
          className: `space-y-6 flex flex-col items-center 
        ${o ? 'mb-[45vh]' : ''} easeAnimateStyle`,
          children: [
            b.jsx(Fs, {
              to: '/resume',
              children: b.jsxs('span', {
                className: 'flex flex-row hover:underline items-center',
                children: [
                  b.jsx('p', {
                    className: 'text-sm text-center',
                    children: ' Resume ',
                  }),
                  b.jsx('svg', {
                    xmlns: 'http://www.w3.org/2000/svg',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    strokeWidth: 1.5,
                    stroke: 'currentColor',
                    className: 'size-3 ml-1',
                    children: b.jsx('path', {
                      strokeLinecap: 'round',
                      strokeLinejoin: 'round',
                      d: 'm4.5 19.5 15-15m0 0H8.25m11.25 0v11.25',
                    }),
                  }),
                ],
              }),
            }),
            b.jsx(ZD, {}),
          ],
        }),
      ],
    })
  )
var pS, aI
function vte() {
  if (aI) return pS
  ;(aI = 1),
    (pS = function (r, s, o) {
      var a = document.head || document.getElementsByTagName('head')[0],
        c = document.createElement('script')
      typeof s == 'function' && ((o = s), (s = {})),
        (s = s || {}),
        (o = o || function () {}),
        (c.type = s.type || 'text/javascript'),
        (c.charset = s.charset || 'utf8'),
        (c.async = 'async' in s ? !!s.async : !0),
        (c.src = r),
        s.attrs && n(c, s.attrs),
        s.text && (c.text = '' + s.text)
      var u = 'onload' in c ? e : t
      u(c, o), c.onload || e(c, o), a.appendChild(c)
    })
  function n(i, r) {
    for (var s in r) i.setAttribute(s, r[s])
  }
  function e(i, r) {
    ;(i.onload = function () {
      ;(this.onerror = this.onload = null), r(null, i)
    }),
      (i.onerror = function () {
        ;(this.onerror = this.onload = null),
          r(new Error('Failed to load ' + this.src), i)
      })
  }
  function t(i, r) {
    i.onreadystatechange = function () {
      ;(this.readyState != 'complete' && this.readyState != 'loaded') ||
        ((this.onreadystatechange = null), r(null, i))
    }
  }
  return pS
}
var mS, lI
function rU() {
  if (lI) return mS
  lI = 1
  var n = function (T) {
    return e(T) && !t(T)
  }
  function e(x) {
    return !!x && typeof x == 'object'
  }
  function t(x) {
    var T = Object.prototype.toString.call(x)
    return T === '[object RegExp]' || T === '[object Date]' || s(x)
  }
  var i = typeof Symbol == 'function' && Symbol.for,
    r = i ? Symbol.for('react.element') : 60103
  function s(x) {
    return x.$$typeof === r
  }
  function o(x) {
    return Array.isArray(x) ? [] : {}
  }
  function a(x, T) {
    return T.clone !== !1 && T.isMergeableObject(x) ? M(o(x), x, T) : x
  }
  function c(x, T, A) {
    return x.concat(T).map(function (P) {
      return a(P, A)
    })
  }
  function u(x, T) {
    if (!T.customMerge) return M
    var A = T.customMerge(x)
    return typeof A == 'function' ? A : M
  }
  function h(x) {
    return Object.getOwnPropertySymbols
      ? Object.getOwnPropertySymbols(x).filter(function (T) {
          return Object.propertyIsEnumerable.call(x, T)
        })
      : []
  }
  function m(x) {
    return Object.keys(x).concat(h(x))
  }
  function g(x, T) {
    try {
      return T in x
    } catch {
      return !1
    }
  }
  function y(x, T) {
    return (
      g(x, T) &&
      !(
        Object.hasOwnProperty.call(x, T) &&
        Object.propertyIsEnumerable.call(x, T)
      )
    )
  }
  function _(x, T, A) {
    var P = {}
    return (
      A.isMergeableObject(x) &&
        m(x).forEach(function (D) {
          P[D] = a(x[D], A)
        }),
      m(T).forEach(function (D) {
        y(x, D) ||
          (g(x, D) && A.isMergeableObject(T[D])
            ? (P[D] = u(D, A)(x[D], T[D], A))
            : (P[D] = a(T[D], A)))
      }),
      P
    )
  }
  function M(x, T, A) {
    ;(A = A || {}),
      (A.arrayMerge = A.arrayMerge || c),
      (A.isMergeableObject = A.isMergeableObject || n),
      (A.cloneUnlessOtherwiseSpecified = a)
    var P = Array.isArray(T),
      D = Array.isArray(x),
      O = P === D
    return O ? (P ? A.arrayMerge(x, T, A) : _(x, T, A)) : a(T, A)
  }
  M.all = function (T, A) {
    if (!Array.isArray(T)) throw new Error('first argument should be an array')
    return T.reduce(function (P, D) {
      return M(P, D, A)
    }, {})
  }
  var w = M
  return (mS = w), mS
}
var gS, cI
function z_() {
  if (cI) return gS
  cI = 1
  var n = Object.create,
    e = Object.defineProperty,
    t = Object.getOwnPropertyDescriptor,
    i = Object.getOwnPropertyNames,
    r = Object.getPrototypeOf,
    s = Object.prototype.hasOwnProperty,
    o = (Y, Q) => {
      for (var q in Q) e(Y, q, { get: Q[q], enumerable: !0 })
    },
    a = (Y, Q, q, oe) => {
      if ((Q && typeof Q == 'object') || typeof Q == 'function')
        for (let _e of i(Q))
          !s.call(Y, _e) &&
            _e !== q &&
            e(Y, _e, {
              get: () => Q[_e],
              enumerable: !(oe = t(Q, _e)) || oe.enumerable,
            })
      return Y
    },
    c = (Y, Q, q) => (
      (q = Y != null ? n(r(Y)) : {}),
      a(
        !Y || !Y.__esModule ? e(q, 'default', { value: Y, enumerable: !0 }) : q,
        Y,
      )
    ),
    u = (Y) => a(e({}, '__esModule', { value: !0 }), Y),
    h = {}
  o(h, {
    callPlayer: () => j,
    getConfig: () => $,
    getSDK: () => z,
    isBlobUrl: () => J,
    isMediaStream: () => K,
    lazy: () => _,
    omit: () => te,
    parseEndTime: () => O,
    parseStartTime: () => D,
    queryString: () => F,
    randomString: () => U,
    supportsWebKitPresentationMode: () => ne,
  }),
    (gS = u(h))
  var m = c(Vs()),
    g = c(vte()),
    y = c(rU())
  const _ = (Y) =>
      m.default.lazy(async () => {
        const Q = await Y()
        return typeof Q.default == 'function' ? Q : Q.default
      }),
    M = /[?&#](?:start|t)=([0-9hms]+)/,
    w = /[?&#]end=([0-9hms]+)/,
    x = /(\d+)(h|m|s)/g,
    T = /^\d+$/
  function A(Y, Q) {
    if (Y instanceof Array) return
    const q = Y.match(Q)
    if (q) {
      const oe = q[1]
      if (oe.match(x)) return P(oe)
      if (T.test(oe)) return parseInt(oe)
    }
  }
  function P(Y) {
    let Q = 0,
      q = x.exec(Y)
    for (; q !== null; ) {
      const [, oe, _e] = q
      _e === 'h' && (Q += parseInt(oe, 10) * 60 * 60),
        _e === 'm' && (Q += parseInt(oe, 10) * 60),
        _e === 's' && (Q += parseInt(oe, 10)),
        (q = x.exec(Y))
    }
    return Q
  }
  function D(Y) {
    return A(Y, M)
  }
  function O(Y) {
    return A(Y, w)
  }
  function U() {
    return Math.random().toString(36).substr(2, 5)
  }
  function F(Y) {
    return Object.keys(Y)
      .map((Q) => `${Q}=${Y[Q]}`)
      .join('&')
  }
  function N(Y) {
    return window[Y]
      ? window[Y]
      : window.exports && window.exports[Y]
      ? window.exports[Y]
      : window.module && window.module.exports && window.module.exports[Y]
      ? window.module.exports[Y]
      : null
  }
  const k = {},
    z = function (Q, q, oe = null, _e = () => !0, he = g.default) {
      const Ce = N(q)
      return Ce && _e(Ce)
        ? Promise.resolve(Ce)
        : new Promise((Te, Pe) => {
            if (k[Q]) {
              k[Q].push({ resolve: Te, reject: Pe })
              return
            }
            k[Q] = [{ resolve: Te, reject: Pe }]
            const Be = (et) => {
              k[Q].forEach((ft) => ft.resolve(et))
            }
            if (oe) {
              const et = window[oe]
              window[oe] = function () {
                et && et(), Be(N(q))
              }
            }
            he(Q, (et) => {
              et
                ? (k[Q].forEach((ft) => ft.reject(et)), (k[Q] = null))
                : oe || Be(N(q))
            })
          })
    }
  function $(Y, Q) {
    return (0, y.default)(Q.config, Y.config)
  }
  function te(Y, ...Q) {
    const q = [].concat(...Q),
      oe = {},
      _e = Object.keys(Y)
    for (const he of _e) q.indexOf(he) === -1 && (oe[he] = Y[he])
    return oe
  }
  function j(Y, ...Q) {
    if (!this.player || !this.player[Y]) {
      let q = `ReactPlayer: ${this.constructor.displayName} player could not call %c${Y}%c – `
      return (
        this.player
          ? this.player[Y] || (q += 'The method was not available')
          : (q += 'The player was not available'),
        console.warn(q, 'font-weight: bold', ''),
        null
      )
    }
    return this.player[Y](...Q)
  }
  function K(Y) {
    return (
      typeof window < 'u' &&
      typeof window.MediaStream < 'u' &&
      Y instanceof window.MediaStream
    )
  }
  function J(Y) {
    return /^blob:/.test(Y)
  }
  function ne(Y = document.createElement('video')) {
    const Q = /iPhone|iPod/.test(navigator.userAgent) === !1
    return (
      Y.webkitSupportsPresentationMode &&
      typeof Y.webkitSetPresentationMode == 'function' &&
      Q
    )
  }
  function V(Y) {
    return Y
  }
  return gS
}
var vS, uI
function yte() {
  if (uI) return vS
  uI = 1
  var n = Object.defineProperty,
    e = Object.getOwnPropertyDescriptor,
    t = Object.getOwnPropertyNames,
    i = Object.prototype.hasOwnProperty,
    r = (j, K) => {
      for (var J in K) n(j, J, { get: K[J], enumerable: !0 })
    },
    s = (j, K, J, ne) => {
      if (typeof K == 'object' || typeof K == 'function')
        for (let V of t(K))
          !i.call(j, V) &&
            V !== J &&
            n(j, V, {
              get: () => K[V],
              enumerable: !(ne = e(K, V)) || ne.enumerable,
            })
      return j
    },
    o = (j) => s(n({}, '__esModule', { value: !0 }), j),
    a = {}
  r(a, {
    AUDIO_EXTENSIONS: () => U,
    DASH_EXTENSIONS: () => k,
    FLV_EXTENSIONS: () => z,
    HLS_EXTENSIONS: () => N,
    MATCH_URL_DAILYMOTION: () => A,
    MATCH_URL_FACEBOOK: () => y,
    MATCH_URL_FACEBOOK_WATCH: () => _,
    MATCH_URL_KALTURA: () => O,
    MATCH_URL_MIXCLOUD: () => P,
    MATCH_URL_MUX: () => g,
    MATCH_URL_SOUNDCLOUD: () => h,
    MATCH_URL_STREAMABLE: () => M,
    MATCH_URL_TWITCH_CHANNEL: () => T,
    MATCH_URL_TWITCH_VIDEO: () => x,
    MATCH_URL_VIDYARD: () => D,
    MATCH_URL_VIMEO: () => m,
    MATCH_URL_WISTIA: () => w,
    MATCH_URL_YOUTUBE: () => u,
    VIDEO_EXTENSIONS: () => F,
    canPlay: () => te,
  }),
    (vS = o(a))
  var c = z_()
  const u =
      /(?:youtu\.be\/|youtube(?:-nocookie|education)?\.com\/(?:embed\/|v\/|watch\/|watch\?v=|watch\?.+&v=|shorts\/|live\/))((\w|-){11})|youtube\.com\/playlist\?list=|youtube\.com\/user\//,
    h = /(?:soundcloud\.com|snd\.sc)\/[^.]+$/,
    m = /vimeo\.com\/(?!progressive_redirect).+/,
    g = /stream\.mux\.com\/(?!\w+\.m3u8)(\w+)/,
    y =
      /^https?:\/\/(www\.)?facebook\.com.*\/(video(s)?|watch|story)(\.php?|\/).+$/,
    _ = /^https?:\/\/fb\.watch\/.+$/,
    M = /streamable\.com\/([a-z0-9]+)$/,
    w =
      /(?:wistia\.(?:com|net)|wi\.st)\/(?:medias|embed)\/(?:iframe\/)?([^?]+)/,
    x = /(?:www\.|go\.)?twitch\.tv\/videos\/(\d+)($|\?)/,
    T = /(?:www\.|go\.)?twitch\.tv\/([a-zA-Z0-9_]+)($|\?)/,
    A =
      /^(?:(?:https?):)?(?:\/\/)?(?:www\.)?(?:(?:dailymotion\.com(?:\/embed)?\/video)|dai\.ly)\/([a-zA-Z0-9]+)(?:_[\w_-]+)?(?:[\w.#_-]+)?/,
    P = /mixcloud\.com\/([^/]+\/[^/]+)/,
    D = /vidyard.com\/(?:watch\/)?([a-zA-Z0-9-_]+)/,
    O =
      /^https?:\/\/[a-zA-Z]+\.kaltura.(com|org)\/p\/([0-9]+)\/sp\/([0-9]+)00\/embedIframeJs\/uiconf_id\/([0-9]+)\/partner_id\/([0-9]+)(.*)entry_id.([a-zA-Z0-9-_].*)$/,
    U =
      /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i,
    F = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i,
    N = /\.(m3u8)($|\?)/i,
    k = /\.(mpd)($|\?)/i,
    z = /\.(flv)($|\?)/i,
    $ = (j) => {
      if (j instanceof Array) {
        for (const K of j)
          if ((typeof K == 'string' && $(K)) || $(K.src)) return !0
        return !1
      }
      return (0, c.isMediaStream)(j) || (0, c.isBlobUrl)(j)
        ? !0
        : U.test(j) || F.test(j) || N.test(j) || k.test(j) || z.test(j)
    },
    te = {
      youtube: (j) =>
        j instanceof Array ? j.every((K) => u.test(K)) : u.test(j),
      soundcloud: (j) => h.test(j) && !U.test(j),
      vimeo: (j) => m.test(j) && !F.test(j) && !N.test(j),
      mux: (j) => g.test(j),
      facebook: (j) => y.test(j) || _.test(j),
      streamable: (j) => M.test(j),
      wistia: (j) => w.test(j),
      twitch: (j) => x.test(j) || T.test(j),
      dailymotion: (j) => A.test(j),
      mixcloud: (j) => P.test(j),
      vidyard: (j) => D.test(j),
      kaltura: (j) => O.test(j),
      file: $,
    }
  return vS
}
var yS, dI
function xte() {
  if (dI) return yS
  dI = 1
  var n = Object.defineProperty,
    e = Object.getOwnPropertyDescriptor,
    t = Object.getOwnPropertyNames,
    i = Object.prototype.hasOwnProperty,
    r = (m, g) => {
      for (var y in g) n(m, y, { get: g[y], enumerable: !0 })
    },
    s = (m, g, y, _) => {
      if (typeof g == 'object' || typeof g == 'function')
        for (let M of t(g))
          !i.call(m, M) &&
            M !== y &&
            n(m, M, {
              get: () => g[M],
              enumerable: !(_ = e(g, M)) || _.enumerable,
            })
      return m
    },
    o = (m) => s(n({}, '__esModule', { value: !0 }), m),
    a = {}
  r(a, { default: () => h }), (yS = o(a))
  var c = z_(),
    u = yte(),
    h = [
      {
        key: 'youtube',
        name: 'YouTube',
        canPlay: u.canPlay.youtube,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./YouTube-DwKHxhuc.js').then((m) => m.Y), []),
        ),
      },
      {
        key: 'soundcloud',
        name: 'SoundCloud',
        canPlay: u.canPlay.soundcloud,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./SoundCloud-CSR8mvQ6.js').then((m) => m.S), []),
        ),
      },
      {
        key: 'vimeo',
        name: 'Vimeo',
        canPlay: u.canPlay.vimeo,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./Vimeo-DQEFikoD.js').then((m) => m.V), []),
        ),
      },
      {
        key: 'mux',
        name: 'Mux',
        canPlay: u.canPlay.mux,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./Mux-DutQpyXr.js').then((m) => m.M), []),
        ),
      },
      {
        key: 'facebook',
        name: 'Facebook',
        canPlay: u.canPlay.facebook,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./Facebook-DCn6u_DW.js').then((m) => m.F), []),
        ),
      },
      {
        key: 'streamable',
        name: 'Streamable',
        canPlay: u.canPlay.streamable,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./Streamable-BTxMnoQ_.js').then((m) => m.S), []),
        ),
      },
      {
        key: 'wistia',
        name: 'Wistia',
        canPlay: u.canPlay.wistia,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./Wistia-cHg2C41A.js').then((m) => m.W), []),
        ),
      },
      {
        key: 'twitch',
        name: 'Twitch',
        canPlay: u.canPlay.twitch,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./Twitch-DhlM4R2T.js').then((m) => m.T), []),
        ),
      },
      {
        key: 'dailymotion',
        name: 'DailyMotion',
        canPlay: u.canPlay.dailymotion,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./DailyMotion-CwT6PHa5.js').then((m) => m.D), []),
        ),
      },
      {
        key: 'mixcloud',
        name: 'Mixcloud',
        canPlay: u.canPlay.mixcloud,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./Mixcloud-CXmdZnm5.js').then((m) => m.M), []),
        ),
      },
      {
        key: 'vidyard',
        name: 'Vidyard',
        canPlay: u.canPlay.vidyard,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./Vidyard-CaV2wPbT.js').then((m) => m.V), []),
        ),
      },
      {
        key: 'kaltura',
        name: 'Kaltura',
        canPlay: u.canPlay.kaltura,
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./Kaltura-BRFuzEcI.js').then((m) => m.K), []),
        ),
      },
      {
        key: 'file',
        name: 'FilePlayer',
        canPlay: u.canPlay.file,
        canEnablePIP: (m) =>
          u.canPlay.file(m) &&
          (document.pictureInPictureEnabled ||
            (0, c.supportsWebKitPresentationMode)()) &&
          !u.AUDIO_EXTENSIONS.test(m),
        lazyPlayer: (0, c.lazy)(() =>
          vs(() => import('./FilePlayer-DOA8ew2z.js').then((m) => m.F), []),
        ),
      },
    ]
  return yS
}
var fI =
  Number.isNaN ||
  function (e) {
    return typeof e == 'number' && e !== e
  }
function _te(n, e) {
  return !!(n === e || (fI(n) && fI(e)))
}
function wte(n, e) {
  if (n.length !== e.length) return !1
  for (var t = 0; t < n.length; t++) if (!_te(n[t], e[t])) return !1
  return !0
}
function Ste(n, e) {
  e === void 0 && (e = wte)
  var t,
    i = [],
    r,
    s = !1
  function o() {
    for (var a = [], c = 0; c < arguments.length; c++) a[c] = arguments[c]
    return (
      (s && t === this && e(a, i)) ||
        ((r = n.apply(this, a)), (s = !0), (t = this), (i = a)),
      r
    )
  }
  return o
}
const Mte = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: Ste },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Ete = OU(Mte)
var xS, hI
function sU() {
  if (hI) return xS
  hI = 1
  var n = typeof Element < 'u',
    e = typeof Map == 'function',
    t = typeof Set == 'function',
    i = typeof ArrayBuffer == 'function' && !!ArrayBuffer.isView
  function r(s, o) {
    if (s === o) return !0
    if (s && o && typeof s == 'object' && typeof o == 'object') {
      if (s.constructor !== o.constructor) return !1
      var a, c, u
      if (Array.isArray(s)) {
        if (((a = s.length), a != o.length)) return !1
        for (c = a; c-- !== 0; ) if (!r(s[c], o[c])) return !1
        return !0
      }
      var h
      if (e && s instanceof Map && o instanceof Map) {
        if (s.size !== o.size) return !1
        for (h = s.entries(); !(c = h.next()).done; )
          if (!o.has(c.value[0])) return !1
        for (h = s.entries(); !(c = h.next()).done; )
          if (!r(c.value[1], o.get(c.value[0]))) return !1
        return !0
      }
      if (t && s instanceof Set && o instanceof Set) {
        if (s.size !== o.size) return !1
        for (h = s.entries(); !(c = h.next()).done; )
          if (!o.has(c.value[0])) return !1
        return !0
      }
      if (i && ArrayBuffer.isView(s) && ArrayBuffer.isView(o)) {
        if (((a = s.length), a != o.length)) return !1
        for (c = a; c-- !== 0; ) if (s[c] !== o[c]) return !1
        return !0
      }
      if (s.constructor === RegExp)
        return s.source === o.source && s.flags === o.flags
      if (
        s.valueOf !== Object.prototype.valueOf &&
        typeof s.valueOf == 'function' &&
        typeof o.valueOf == 'function'
      )
        return s.valueOf() === o.valueOf()
      if (
        s.toString !== Object.prototype.toString &&
        typeof s.toString == 'function' &&
        typeof o.toString == 'function'
      )
        return s.toString() === o.toString()
      if (((u = Object.keys(s)), (a = u.length), a !== Object.keys(o).length))
        return !1
      for (c = a; c-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(o, u[c])) return !1
      if (n && s instanceof Element) return !1
      for (c = a; c-- !== 0; )
        if (
          !(
            (u[c] === '_owner' || u[c] === '__v' || u[c] === '__o') &&
            s.$$typeof
          ) &&
          !r(s[u[c]], o[u[c]])
        )
          return !1
      return !0
    }
    return s !== s && o !== o
  }
  return (
    (xS = function (o, a) {
      try {
        return r(o, a)
      } catch (c) {
        if ((c.message || '').match(/stack|recursion/i))
          return (
            console.warn('react-fast-compare cannot handle circular refs'), !1
          )
        throw c
      }
    }),
    xS
  )
}
var _S, pI
function oU() {
  if (pI) return _S
  pI = 1
  var n = Object.create,
    e = Object.defineProperty,
    t = Object.getOwnPropertyDescriptor,
    i = Object.getOwnPropertyNames,
    r = Object.getPrototypeOf,
    s = Object.prototype.hasOwnProperty,
    o = (F, N) => {
      for (var k in N) e(F, k, { get: N[k], enumerable: !0 })
    },
    a = (F, N, k, z) => {
      if ((N && typeof N == 'object') || typeof N == 'function')
        for (let $ of i(N))
          !s.call(F, $) &&
            $ !== k &&
            e(F, $, {
              get: () => N[$],
              enumerable: !(z = t(N, $)) || z.enumerable,
            })
      return F
    },
    c = (F, N, k) => (
      (k = F != null ? n(r(F)) : {}),
      a(
        !F || !F.__esModule ? e(k, 'default', { value: F, enumerable: !0 }) : k,
        F,
      )
    ),
    u = (F) => a(e({}, '__esModule', { value: !0 }), F),
    h = {}
  o(h, { defaultProps: () => U, propTypes: () => D }), (_S = u(h))
  var m = c(Xg())
  const {
      string: g,
      bool: y,
      number: _,
      array: M,
      oneOfType: w,
      shape: x,
      object: T,
      func: A,
      node: P,
    } = m.default,
    D = {
      url: w([g, M, T]),
      playing: y,
      loop: y,
      controls: y,
      volume: _,
      muted: y,
      playbackRate: _,
      width: w([g, _]),
      height: w([g, _]),
      style: T,
      progressInterval: _,
      playsinline: y,
      pip: y,
      stopOnUnmount: y,
      light: w([y, g, T]),
      playIcon: P,
      previewTabIndex: _,
      previewAriaLabel: g,
      fallback: P,
      oEmbedUrl: g,
      wrapper: w([g, A, x({ render: A.isRequired })]),
      config: x({
        soundcloud: x({ options: T }),
        youtube: x({ playerVars: T, embedOptions: T, onUnstarted: A }),
        facebook: x({ appId: g, version: g, playerId: g, attributes: T }),
        dailymotion: x({ params: T }),
        vimeo: x({ playerOptions: T, title: g }),
        mux: x({ attributes: T, version: g }),
        file: x({
          attributes: T,
          tracks: M,
          forceVideo: y,
          forceAudio: y,
          forceHLS: y,
          forceSafariHLS: y,
          forceDisableHls: y,
          forceDASH: y,
          forceFLV: y,
          hlsOptions: T,
          hlsVersion: g,
          dashVersion: g,
          flvVersion: g,
        }),
        wistia: x({ options: T, playerId: g, customControls: M }),
        mixcloud: x({ options: T }),
        twitch: x({ options: T, playerId: g }),
        vidyard: x({ options: T }),
      }),
      onReady: A,
      onStart: A,
      onPlay: A,
      onPause: A,
      onBuffer: A,
      onBufferEnd: A,
      onEnded: A,
      onError: A,
      onDuration: A,
      onSeek: A,
      onPlaybackRateChange: A,
      onPlaybackQualityChange: A,
      onProgress: A,
      onClickPreview: A,
      onEnablePIP: A,
      onDisablePIP: A,
    },
    O = () => {},
    U = {
      playing: !1,
      loop: !1,
      controls: !1,
      volume: null,
      muted: !1,
      playbackRate: 1,
      width: '640px',
      height: '360px',
      style: {},
      progressInterval: 1e3,
      playsinline: !1,
      pip: !1,
      stopOnUnmount: !0,
      light: !1,
      fallback: null,
      wrapper: 'div',
      previewTabIndex: 0,
      previewAriaLabel: '',
      oEmbedUrl: 'https://noembed.com/embed?url={url}',
      config: {
        soundcloud: {
          options: {
            visual: !0,
            buying: !1,
            liking: !1,
            download: !1,
            sharing: !1,
            show_comments: !1,
            show_playcount: !1,
          },
        },
        youtube: {
          playerVars: {
            playsinline: 1,
            showinfo: 0,
            rel: 0,
            iv_load_policy: 3,
            modestbranding: 1,
          },
          embedOptions: {},
          onUnstarted: O,
        },
        facebook: {
          appId: '1309697205772819',
          version: 'v3.3',
          playerId: null,
          attributes: {},
        },
        dailymotion: { params: { api: 1, 'endscreen-enable': !1 } },
        vimeo: {
          playerOptions: { autopause: !1, byline: !1, portrait: !1, title: !1 },
          title: null,
        },
        mux: { attributes: {}, version: '2' },
        file: {
          attributes: {},
          tracks: [],
          forceVideo: !1,
          forceAudio: !1,
          forceHLS: !1,
          forceDASH: !1,
          forceFLV: !1,
          hlsOptions: {},
          hlsVersion: '1.1.4',
          dashVersion: '3.1.3',
          flvVersion: '1.5.0',
          forceDisableHls: !1,
        },
        wistia: { options: {}, playerId: null, customControls: null },
        mixcloud: { options: { hide_cover: 1 } },
        twitch: { options: {}, playerId: null },
        vidyard: { options: {} },
      },
      onReady: O,
      onStart: O,
      onPlay: O,
      onPause: O,
      onBuffer: O,
      onBufferEnd: O,
      onEnded: O,
      onError: O,
      onDuration: O,
      onSeek: O,
      onPlaybackRateChange: O,
      onPlaybackQualityChange: O,
      onProgress: O,
      onClickPreview: O,
      onEnablePIP: O,
      onDisablePIP: O,
    }
  return _S
}
var wS, mI
function bte() {
  if (mI) return wS
  mI = 1
  var n = Object.create,
    e = Object.defineProperty,
    t = Object.getOwnPropertyDescriptor,
    i = Object.getOwnPropertyNames,
    r = Object.getPrototypeOf,
    s = Object.prototype.hasOwnProperty,
    o = (A, P, D) =>
      P in A
        ? e(A, P, { enumerable: !0, configurable: !0, writable: !0, value: D })
        : (A[P] = D),
    a = (A, P) => {
      for (var D in P) e(A, D, { get: P[D], enumerable: !0 })
    },
    c = (A, P, D, O) => {
      if ((P && typeof P == 'object') || typeof P == 'function')
        for (let U of i(P))
          !s.call(A, U) &&
            U !== D &&
            e(A, U, {
              get: () => P[U],
              enumerable: !(O = t(P, U)) || O.enumerable,
            })
      return A
    },
    u = (A, P, D) => (
      (D = A != null ? n(r(A)) : {}),
      c(
        !A || !A.__esModule ? e(D, 'default', { value: A, enumerable: !0 }) : D,
        A,
      )
    ),
    h = (A) => c(e({}, '__esModule', { value: !0 }), A),
    m = (A, P, D) => (o(A, typeof P != 'symbol' ? P + '' : P, D), D),
    g = {}
  a(g, { default: () => T }), (wS = h(g))
  var y = u(Vs()),
    _ = u(sU()),
    M = oU(),
    w = z_()
  const x = 5e3
  class T extends y.Component {
    constructor() {
      super(...arguments),
        m(this, 'mounted', !1),
        m(this, 'isReady', !1),
        m(this, 'isPlaying', !1),
        m(this, 'isLoading', !0),
        m(this, 'loadOnReady', null),
        m(this, 'startOnPlay', !0),
        m(this, 'seekOnPlay', null),
        m(this, 'onDurationCalled', !1),
        m(this, 'handlePlayerMount', (P) => {
          if (this.player) {
            this.progress()
            return
          }
          ;(this.player = P), this.player.load(this.props.url), this.progress()
        }),
        m(this, 'getInternalPlayer', (P) =>
          this.player ? this.player[P] : null,
        ),
        m(this, 'progress', () => {
          if (this.props.url && this.player && this.isReady) {
            const P = this.getCurrentTime() || 0,
              D = this.getSecondsLoaded(),
              O = this.getDuration()
            if (O) {
              const U = { playedSeconds: P, played: P / O }
              D !== null && ((U.loadedSeconds = D), (U.loaded = D / O)),
                (U.playedSeconds !== this.prevPlayed ||
                  U.loadedSeconds !== this.prevLoaded) &&
                  this.props.onProgress(U),
                (this.prevPlayed = U.playedSeconds),
                (this.prevLoaded = U.loadedSeconds)
            }
          }
          this.progressTimeout = setTimeout(
            this.progress,
            this.props.progressFrequency || this.props.progressInterval,
          )
        }),
        m(this, 'handleReady', () => {
          if (!this.mounted) return
          ;(this.isReady = !0), (this.isLoading = !1)
          const { onReady: P, playing: D, volume: O, muted: U } = this.props
          P(),
            !U && O !== null && this.player.setVolume(O),
            this.loadOnReady
              ? (this.player.load(this.loadOnReady, !0),
                (this.loadOnReady = null))
              : D && this.player.play(),
            this.handleDurationCheck()
        }),
        m(this, 'handlePlay', () => {
          ;(this.isPlaying = !0), (this.isLoading = !1)
          const { onStart: P, onPlay: D, playbackRate: O } = this.props
          this.startOnPlay &&
            (this.player.setPlaybackRate &&
              O !== 1 &&
              this.player.setPlaybackRate(O),
            P(),
            (this.startOnPlay = !1)),
            D(),
            this.seekOnPlay &&
              (this.seekTo(this.seekOnPlay), (this.seekOnPlay = null)),
            this.handleDurationCheck()
        }),
        m(this, 'handlePause', (P) => {
          ;(this.isPlaying = !1), this.isLoading || this.props.onPause(P)
        }),
        m(this, 'handleEnded', () => {
          const { activePlayer: P, loop: D, onEnded: O } = this.props
          P.loopOnEnded && D && this.seekTo(0),
            D || ((this.isPlaying = !1), O())
        }),
        m(this, 'handleError', (...P) => {
          ;(this.isLoading = !1), this.props.onError(...P)
        }),
        m(this, 'handleDurationCheck', () => {
          clearTimeout(this.durationCheckTimeout)
          const P = this.getDuration()
          P
            ? this.onDurationCalled ||
              (this.props.onDuration(P), (this.onDurationCalled = !0))
            : (this.durationCheckTimeout = setTimeout(
                this.handleDurationCheck,
                100,
              ))
        }),
        m(this, 'handleLoaded', () => {
          this.isLoading = !1
        })
    }
    componentDidMount() {
      this.mounted = !0
    }
    componentWillUnmount() {
      clearTimeout(this.progressTimeout),
        clearTimeout(this.durationCheckTimeout),
        this.isReady &&
          this.props.stopOnUnmount &&
          (this.player.stop(),
          this.player.disablePIP && this.player.disablePIP()),
        (this.mounted = !1)
    }
    componentDidUpdate(P) {
      if (!this.player) return
      const {
        url: D,
        playing: O,
        volume: U,
        muted: F,
        playbackRate: N,
        pip: k,
        loop: z,
        activePlayer: $,
        disableDeferredLoading: te,
      } = this.props
      if (!(0, _.default)(P.url, D)) {
        if (this.isLoading && !$.forceLoad && !te && !(0, w.isMediaStream)(D)) {
          console.warn(
            `ReactPlayer: the attempt to load ${D} is being deferred until the player has loaded`,
          ),
            (this.loadOnReady = D)
          return
        }
        ;(this.isLoading = !0),
          (this.startOnPlay = !0),
          (this.onDurationCalled = !1),
          this.player.load(D, this.isReady)
      }
      !P.playing && O && !this.isPlaying && this.player.play(),
        P.playing && !O && this.isPlaying && this.player.pause(),
        !P.pip && k && this.player.enablePIP && this.player.enablePIP(),
        P.pip && !k && this.player.disablePIP && this.player.disablePIP(),
        P.volume !== U && U !== null && this.player.setVolume(U),
        P.muted !== F &&
          (F
            ? this.player.mute()
            : (this.player.unmute(),
              U !== null && setTimeout(() => this.player.setVolume(U)))),
        P.playbackRate !== N &&
          this.player.setPlaybackRate &&
          this.player.setPlaybackRate(N),
        P.loop !== z && this.player.setLoop && this.player.setLoop(z)
    }
    getDuration() {
      return this.isReady ? this.player.getDuration() : null
    }
    getCurrentTime() {
      return this.isReady ? this.player.getCurrentTime() : null
    }
    getSecondsLoaded() {
      return this.isReady ? this.player.getSecondsLoaded() : null
    }
    seekTo(P, D, O) {
      if (!this.isReady) {
        P !== 0 &&
          ((this.seekOnPlay = P),
          setTimeout(() => {
            this.seekOnPlay = null
          }, x))
        return
      }
      if (D ? D === 'fraction' : P > 0 && P < 1) {
        const F = this.player.getDuration()
        if (!F) {
          console.warn(
            'ReactPlayer: could not seek using fraction – duration not yet available',
          )
          return
        }
        this.player.seekTo(F * P, O)
        return
      }
      this.player.seekTo(P, O)
    }
    render() {
      const P = this.props.activePlayer
      return P
        ? y.default.createElement(P, {
            ...this.props,
            onMount: this.handlePlayerMount,
            onReady: this.handleReady,
            onPlay: this.handlePlay,
            onPause: this.handlePause,
            onEnded: this.handleEnded,
            onLoaded: this.handleLoaded,
            onError: this.handleError,
          })
        : null
    }
  }
  return (
    m(T, 'displayName', 'Player'),
    m(T, 'propTypes', M.propTypes),
    m(T, 'defaultProps', M.defaultProps),
    wS
  )
}
var SS, gI
function Tte() {
  if (gI) return SS
  gI = 1
  var n = Object.create,
    e = Object.defineProperty,
    t = Object.getOwnPropertyDescriptor,
    i = Object.getOwnPropertyNames,
    r = Object.getPrototypeOf,
    s = Object.prototype.hasOwnProperty,
    o = (z, $, te) =>
      $ in z
        ? e(z, $, { enumerable: !0, configurable: !0, writable: !0, value: te })
        : (z[$] = te),
    a = (z, $) => {
      for (var te in $) e(z, te, { get: $[te], enumerable: !0 })
    },
    c = (z, $, te, j) => {
      if (($ && typeof $ == 'object') || typeof $ == 'function')
        for (let K of i($))
          !s.call(z, K) &&
            K !== te &&
            e(z, K, {
              get: () => $[K],
              enumerable: !(j = t($, K)) || j.enumerable,
            })
      return z
    },
    u = (z, $, te) => (
      (te = z != null ? n(r(z)) : {}),
      c(
        !z || !z.__esModule
          ? e(te, 'default', { value: z, enumerable: !0 })
          : te,
        z,
      )
    ),
    h = (z) => c(e({}, '__esModule', { value: !0 }), z),
    m = (z, $, te) => (o(z, typeof $ != 'symbol' ? $ + '' : $, te), te),
    g = {}
  a(g, { createReactPlayer: () => k }), (SS = h(g))
  var y = u(Vs()),
    _ = u(rU()),
    M = u(Ete),
    w = u(sU()),
    x = oU(),
    T = z_(),
    A = u(bte())
  const P = (0, T.lazy)(() =>
      vs(() => import('./Preview-BZxdhn_y.js').then((z) => z.P), []),
    ),
    D = typeof window < 'u' && window.document && typeof document < 'u',
    O = typeof Ku < 'u' && Ku.window && Ku.window.document,
    U = Object.keys(x.propTypes),
    F = D || O ? y.Suspense : () => null,
    N = [],
    k = (z, $) => {
      var te
      return (
        (te = class extends y.Component {
          constructor() {
            super(...arguments),
              m(this, 'state', { showPreview: !!this.props.light }),
              m(this, 'references', {
                wrapper: (j) => {
                  this.wrapper = j
                },
                player: (j) => {
                  this.player = j
                },
              }),
              m(this, 'handleClickPreview', (j) => {
                this.setState({ showPreview: !1 }), this.props.onClickPreview(j)
              }),
              m(this, 'showPreview', () => {
                this.setState({ showPreview: !0 })
              }),
              m(this, 'getDuration', () =>
                this.player ? this.player.getDuration() : null,
              ),
              m(this, 'getCurrentTime', () =>
                this.player ? this.player.getCurrentTime() : null,
              ),
              m(this, 'getSecondsLoaded', () =>
                this.player ? this.player.getSecondsLoaded() : null,
              ),
              m(this, 'getInternalPlayer', (j = 'player') =>
                this.player ? this.player.getInternalPlayer(j) : null,
              ),
              m(this, 'seekTo', (j, K, J) => {
                if (!this.player) return null
                this.player.seekTo(j, K, J)
              }),
              m(this, 'handleReady', () => {
                this.props.onReady(this)
              }),
              m(
                this,
                'getActivePlayer',
                (0, M.default)((j) => {
                  for (const K of [...N, ...z]) if (K.canPlay(j)) return K
                  return $ || null
                }),
              ),
              m(
                this,
                'getConfig',
                (0, M.default)((j, K) => {
                  const { config: J } = this.props
                  return _.default.all([
                    x.defaultProps.config,
                    x.defaultProps.config[K] || {},
                    J,
                    J[K] || {},
                  ])
                }),
              ),
              m(
                this,
                'getAttributes',
                (0, M.default)((j) => (0, T.omit)(this.props, U)),
              ),
              m(this, 'renderActivePlayer', (j) => {
                if (!j) return null
                const K = this.getActivePlayer(j)
                if (!K) return null
                const J = this.getConfig(j, K.key)
                return y.default.createElement(A.default, {
                  ...this.props,
                  key: K.key,
                  ref: this.references.player,
                  config: J,
                  activePlayer: K.lazyPlayer || K,
                  onReady: this.handleReady,
                })
              })
          }
          shouldComponentUpdate(j, K) {
            return (
              !(0, w.default)(this.props, j) || !(0, w.default)(this.state, K)
            )
          }
          componentDidUpdate(j) {
            const { light: K } = this.props
            !j.light && K && this.setState({ showPreview: !0 }),
              j.light && !K && this.setState({ showPreview: !1 })
          }
          renderPreview(j) {
            if (!j) return null
            const {
              light: K,
              playIcon: J,
              previewTabIndex: ne,
              oEmbedUrl: V,
              previewAriaLabel: Y,
            } = this.props
            return y.default.createElement(P, {
              url: j,
              light: K,
              playIcon: J,
              previewTabIndex: ne,
              previewAriaLabel: Y,
              oEmbedUrl: V,
              onClick: this.handleClickPreview,
            })
          }
          render() {
            const {
                url: j,
                style: K,
                width: J,
                height: ne,
                fallback: V,
                wrapper: Y,
              } = this.props,
              { showPreview: Q } = this.state,
              q = this.getAttributes(j),
              oe = typeof Y == 'string' ? this.references.wrapper : void 0
            return y.default.createElement(
              Y,
              { ref: oe, style: { ...K, width: J, height: ne }, ...q },
              y.default.createElement(
                F,
                { fallback: V },
                Q ? this.renderPreview(j) : this.renderActivePlayer(j),
              ),
            )
          }
        }),
        m(te, 'displayName', 'ReactPlayer'),
        m(te, 'propTypes', x.propTypes),
        m(te, 'defaultProps', x.defaultProps),
        m(te, 'addCustomPlayer', (j) => {
          N.push(j)
        }),
        m(te, 'removeCustomPlayers', () => {
          N.length = 0
        }),
        m(te, 'canPlay', (j) => {
          for (const K of [...N, ...z]) if (K.canPlay(j)) return !0
          return !1
        }),
        m(te, 'canEnablePIP', (j) => {
          for (const K of [...N, ...z])
            if (K.canEnablePIP && K.canEnablePIP(j)) return !0
          return !1
        }),
        te
      )
    }
  return SS
}
var MS, vI
function Ate() {
  if (vI) return MS
  vI = 1
  var n = Object.create,
    e = Object.defineProperty,
    t = Object.getOwnPropertyDescriptor,
    i = Object.getOwnPropertyNames,
    r = Object.getPrototypeOf,
    s = Object.prototype.hasOwnProperty,
    o = (M, w) => {
      for (var x in w) e(M, x, { get: w[x], enumerable: !0 })
    },
    a = (M, w, x, T) => {
      if ((w && typeof w == 'object') || typeof w == 'function')
        for (let A of i(w))
          !s.call(M, A) &&
            A !== x &&
            e(M, A, {
              get: () => w[A],
              enumerable: !(T = t(w, A)) || T.enumerable,
            })
      return M
    },
    c = (M, w, x) => (
      (x = M != null ? n(r(M)) : {}),
      a(
        !M || !M.__esModule ? e(x, 'default', { value: M, enumerable: !0 }) : x,
        M,
      )
    ),
    u = (M) => a(e({}, '__esModule', { value: !0 }), M),
    h = {}
  o(h, { default: () => _ }), (MS = u(h))
  var m = c(xte()),
    g = Tte()
  const y = m.default[m.default.length - 1]
  var _ = (0, g.createReactPlayer)(m.default, y)
  return MS
}
var Cte = Ate()
const Pte = Bx(Cte)
var HM = new Map(),
  gy = new WeakMap(),
  yI = 0,
  Rte = void 0
function Ite(n) {
  return n
    ? (gy.has(n) || ((yI += 1), gy.set(n, yI.toString())), gy.get(n))
    : '0'
}
function Lte(n) {
  return Object.keys(n)
    .sort()
    .filter((e) => n[e] !== void 0)
    .map((e) => `${e}_${e === 'root' ? Ite(n.root) : n[e]}`)
    .toString()
}
function Nte(n) {
  const e = Lte(n)
  let t = HM.get(e)
  if (!t) {
    const i = new Map()
    let r
    const s = new IntersectionObserver((o) => {
      o.forEach((a) => {
        var c
        const u = a.isIntersecting && r.some((h) => a.intersectionRatio >= h)
        n.trackVisibility && typeof a.isVisible > 'u' && (a.isVisible = u),
          (c = i.get(a.target)) == null ||
            c.forEach((h) => {
              h(u, a)
            })
      })
    }, n)
    ;(r =
      s.thresholds ||
      (Array.isArray(n.threshold) ? n.threshold : [n.threshold || 0])),
      (t = { id: e, observer: s, elements: i }),
      HM.set(e, t)
  }
  return t
}
function Dte(n, e, t = {}, i = Rte) {
  if (typeof window.IntersectionObserver > 'u' && i !== void 0) {
    const c = n.getBoundingClientRect()
    return (
      e(i, {
        isIntersecting: i,
        target: n,
        intersectionRatio: typeof t.threshold == 'number' ? t.threshold : 0,
        time: 0,
        boundingClientRect: c,
        intersectionRect: c,
        rootBounds: c,
      }),
      () => {}
    )
  }
  const { id: r, observer: s, elements: o } = Nte(t),
    a = o.get(n) || []
  return (
    o.has(n) || o.set(n, a),
    a.push(e),
    s.observe(n),
    function () {
      a.splice(a.indexOf(e), 1),
        a.length === 0 && (o.delete(n), s.unobserve(n)),
        o.size === 0 && (s.disconnect(), HM.delete(r))
    }
  )
}
function aU({
  threshold: n,
  delay: e,
  trackVisibility: t,
  rootMargin: i,
  root: r,
  triggerOnce: s,
  skip: o,
  initialInView: a,
  fallbackInView: c,
  onChange: u,
} = {}) {
  var h
  const [m, g] = X.useState(null),
    y = X.useRef(u),
    [_, M] = X.useState({ inView: !!a, entry: void 0 })
  ;(y.current = u),
    X.useEffect(() => {
      if (o || !m) return
      let A
      return (
        (A = Dte(
          m,
          (P, D) => {
            M({ inView: P, entry: D }),
              y.current && y.current(P, D),
              D.isIntersecting && s && A && (A(), (A = void 0))
          },
          {
            root: r,
            rootMargin: i,
            threshold: n,
            trackVisibility: t,
            delay: e,
          },
          c,
        )),
        () => {
          A && A()
        }
      )
    }, [Array.isArray(n) ? n.toString() : n, m, r, i, s, o, t, c, e])
  const w = (h = _.entry) == null ? void 0 : h.target,
    x = X.useRef(void 0)
  !m &&
    w &&
    !s &&
    !o &&
    x.current !== w &&
    ((x.current = w), M({ inView: !!a, entry: void 0 }))
  const T = [g, _.inView, _.entry]
  return (T.ref = T[0]), (T.inView = T[1]), (T.entry = T[2]), T
}
const lU = (n) => {
  const e = X.useRef(null),
    [t, i] = X.useState(!1),
    [r, s] = X.useState(!1),
    { ref: o, inView: a } = aU({ threshold: 0.5 })
  X.useEffect(() => {
    r || i(a)
  }, [a, r])
  const c = () => {
    s(!0), e.current && e.current.pause()
  }
  return b.jsx('div', {
    className: 'w-auto h-auto group relative rounded-lg overflow-hidden',
    style: { paddingTop: n.pt + '%' },
    ref: o,
    children: b.jsx(Pte, {
      ref: e,
      url: n.videourl,
      controls: !0,
      style: { position: 'absolute', top: '0', left: '0' },
      muted: !0,
      width: '100%',
      height: '100%',
      playing: t,
      playbackRate: 1.25,
      onClick: c,
    }),
  })
}
function Ote({ link: n, bgSrc: e, imgSrc: t, title: i, date: r, theme: s }) {
  return b.jsx(Fs, {
    to: n,
    children: b.jsxs('div', {
      className: `w-full relative top-0 left-0 justify-center overflow-hidden group 
        max-h-[80vh] xl:h-[45vh] z-30 3xl:max-h-[750px]`,
      style: {
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        backgroundRepeat: 'no-repeat',
        backgroundImage: `url(${e})`,
      },
      'data-theme': s,
      children: [
        b.jsxs('div', {
          className:
            'max-h-[45vh] xl:h-[45vh] w-full space-x-6 xl:space-x-10 flex flex-col-reverse items-center justify-center md:flex-row landscape:flex-row md:items-start',
          children: [
            b.jsx('img', {
              src: t,
              className:
                'object-cover object-top pt-10 min-w-[50%] md:max-w-[50%] group-hover:scale-[1.01] easeAnimateStyle',
            }),
            b.jsxs('div', {
              className:
                'flex flex-col my-auto justify-center space-y-4 text-textColor p-10 pb-0 xl:p-0 xl:pt-10 xl:max-w-[35%]',
              children: [
                b.jsxs('div', {
                  className: 'flex items-center space-x-1',
                  children: [
                    b.jsx('p', { children: ' Next project ' }),
                    b.jsx('svg', {
                      xmlns: 'http://www.w3.org/2000/svg',
                      viewBox: '0 0 20 20',
                      fill: 'currentColor',
                      className: 'w-5 h-5 mr-1',
                      children: b.jsx('path', {
                        fillRule: 'evenodd',
                        d: 'M5.22 14.78a.75.75 0 001.06 0l7.22-7.22v5.69a.75.75 0 001.5 0v-7.5a.75.75 0 00-.75-.75h-7.5a.75.75 0 000 1.5h5.69l-7.22 7.22a.75.75 0 000 1.06z',
                        clipRule: 'evenodd',
                      }),
                    }),
                  ],
                }),
                b.jsx('h2', {
                  className: 'text-left text-nextTitle',
                  children: i,
                }),
                b.jsxs('p', { children: [' ', r, ' '] }),
              ],
            }),
          ],
        }),
        b.jsx('div', {
          className:
            'absolute inset-0 top-0 left-0 ml-0 w-full bg-black/20 opacity-0 group-hover:opacity-100 easeAnimateStyle',
        }),
      ],
    }),
  })
}
const kT = (n = 0.1) => {
  const [e, t] = X.useState(!1),
    { ref: i, inView: r } = aU({ threshold: n })
  return (
    X.useEffect(() => {
      t(r)
    }, [r]),
    { ref: i, isInView: e }
  )
}
function im({ geometry: n, materialProps: e, position: t, r: i }) {
  const r = X.useRef()
  return (
    Vg((s) => {
      r.current &&
        ((r.current.rotation.x =
          r.current.rotation.y =
          r.current.rotation.z +=
            0.001 * i),
        (r.current.position.y =
          t[1] +
          Math[i > 0.5 ? 'cos' : 'sin'](s.clock.getElapsedTime() * i) * i))
    }),
    b.jsxs('mesh', {
      ref: r,
      position: t,
      children: [n, b.jsx('meshStandardMaterial', { ...e })],
    })
  )
}
function kte() {
  const n = X.useRef(),
    e = lte(n, { once: !1, amount: 0.3 })
  return b.jsx(Fs, {
    to: '/google',
    children: b.jsxs('div', {
      'data-theme': 'google',
      ref: n,
      className: `w-full relative top-0 left-0 justify-center overflow-hidden group ml-0
        h-[40vh] xl:h-[45vh] z-30 3xl:h-[750px] bg-white flex items-center flex-col-reverse md:flex-row landscape:flex-row`,
      children: [
        b.jsxs('div', {
          className:
            'relative max-h-[20vh] lg:w-[60%] lg:max-h-[45vh] flex items-center md:mr-20',
          children: [
            b.jsx(OT.img, {
              src: '/enso/android.png',
              alt: 'Android',
              className:
                'mt-[80%] mx-auto w-[120vw] xl:w-[80vw] rounded-lg overflow-hidden object-contain',
              initial: { y: 0 },
              animate: e ? { y: -90 } : { y: 0 },
              transition: { type: 'spring', stiffness: 80 },
            }),
            b.jsx('div', {
              className:
                'absolute w-full h-full top-0 left-0 z-50 hidden lg:block',
              children: b.jsxs(HE, {
                camera: { position: [0, 0, 5], fov: 50 },
                children: [
                  b.jsx('ambientLight', { intensity: 4 }),
                  b.jsx('directionalLight', {
                    castShadow: !0,
                    position: [2.5, 12, 12],
                    intensity: 4,
                  }),
                  b.jsx(im, {
                    geometry: b.jsx('coneGeometry', { args: [0.4, 1, 32] }),
                    materialProps: { color: '#FF5733' },
                    position: [-1.5, 1, 0],
                    r: 0.1,
                  }),
                  b.jsx(im, {
                    geometry: b.jsx('sphereGeometry', { args: [0.4, 32, 32] }),
                    materialProps: { color: '#4285F4' },
                    position: [-3, 1.5, 0],
                    r: 0.2,
                  }),
                  b.jsx(im, {
                    geometry: b.jsx('sphereGeometry', { args: [0.3, 32, 32] }),
                    materialProps: { color: '#34A853' },
                    position: [1.5, 1, 0],
                    r: 0.15,
                  }),
                  b.jsx(im, {
                    geometry: b.jsx('coneGeometry', { args: [0.4, 1, 32] }),
                    materialProps: { color: '#FBBC05' },
                    position: [3, 1, 0],
                    r: 0.25,
                  }),
                  b.jsx(im, {
                    geometry: b.jsx('boxGeometry', { args: [0.5, 0.5, 0.5] }),
                    materialProps: { color: '#EA4335' },
                    position: [0, 1.8, 0],
                    r: 0.35,
                  }),
                ],
              }),
            }),
          ],
        }),
        b.jsxs('div', {
          className:
            'flex flex-col my-auto justify-center space-y-4 text-textColor p-10 pb-0 xl:p-0 xl:pt-10 xl:max-w-[35%]',
          children: [
            b.jsxs('div', {
              className: 'flex items-center space-x-1',
              children: [
                b.jsx('p', { children: ' Next project ' }),
                b.jsx('svg', {
                  xmlns: 'http://www.w3.org/2000/svg',
                  viewBox: '0 0 20 20',
                  fill: 'currentColor',
                  className: 'w-5 h-5 mr-1',
                  children: b.jsx('path', {
                    fillRule: 'evenodd',
                    d: 'M5.22 14.78a.75.75 0 001.06 0l7.22-7.22v5.69a.75.75 0 001.5 0v-7.5a.75.75 0 00-.75-.75h-7.5a.75.75 0 000 1.5h5.69l-7.22 7.22a.75.75 0 000 1.06z',
                    clipRule: 'evenodd',
                  }),
                }),
              ],
            }),
            b.jsx('h2', {
              className: 'text-left text-[#00904B]',
              children:
                '[Google Internship] Consumer-facing mobile/web development platform',
            }),
            b.jsx('p', {
              className: '',
              children: ' UX Design Intern, May - Aug 2024 ',
            }),
          ],
        }),
        b.jsx('div', {
          className:
            'absolute inset-0 bg-black/10 opacity-0 group-hover:opacity-100 transition-all duration-500 ease-in-out pointer-events-none z-[100]',
        }),
      ],
    }),
  })
}
function Fte() {
  const n = '/google',
    [e, t] = X.useState(!1),
    { ref: i, isInView: r } = kT(),
    s = X.useRef(null),
    { scrollYProgress: o } = tT({ target: s, offset: ['0.7 1', '1 1'] }),
    a = ih(o, [0, 1], [0, 1]),
    [c, u] = X.useState('/enso/complexity1.png'),
    h = ['/enso/complexity1.png', '/enso/complexity2.png'],
    m = X.useRef([]),
    g = (M) => {
      M.forEach((w) => {
        if (w.isIntersecting) {
          const x = w.target.dataset.index
          u(h[x])
        }
      })
    }
  X.useEffect(() => {
    if (!m.current) return
    const M = new IntersectionObserver(g, { threshold: 0.9 })
    return (
      m.current.forEach((w) => {
        w && M.observe(w)
      }),
      () => {
        m.current.forEach((w) => {
          w && M.unobserve(w)
        })
      }
    )
  }, [])
  const y = [
      { label: 'navigating ambiguity', id: 'enso-ambiguity' },
      { label: 'component library', id: 'enso-component' },
      { label: 'final prototype', id: 'enso-final', offset: 100 },
    ],
    _ = [
      { image: '/enso/screens/1.png', alt: 'Enso screen 1' },
      { image: '/enso/screens/2.png', alt: 'Enso screen 2' },
      { image: '/enso/screens/3.png', alt: 'Enso screen 3' },
      { image: '/enso/screens/4.png', alt: 'Enso screen 4' },
      { image: '/enso/screens/5.png', alt: 'Enso screen 5' },
    ]
  return b.jsxs('div', {
    'data-theme': 'enso',
    className:
      'w-full bg-background whitespace-normal xl:whitespace-pre-line text-textColor',
    children: [
      b.jsxs('div', {
        className: 'w-full relative top-0 left-0',
        children: [
          b.jsx('div', {
            className: 'block xl:hidden',
            children: b.jsx(Ic, { theme: 'enso', color: 'text-titleColor' }),
          }),
          b.jsx('div', {
            className: `hidden xl:block transition-all duration-300 ease-out delay-100
          ${e ? 'opacity-0' : 'opacity-100'} `,
            children: b.jsx(Ic, { theme: 'enso', color: 'text-white' }),
          }),
          b.jsx(Fs, {
            to: n,
            className:
              'hidden xl:block absolute top-4 right-4 xl:top-[3%] xl:right-[2.65%] text-white hover:underline',
            children: b.jsx('p', {
              className: '',
              children: 'Next Project: Google',
            }),
          }),
          b.jsxs('div', {
            className:
              'min-h-[100vh] responsive-lg p-20 xl:p-28 xl:pt-14 lg:pt-10',
            style: {
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              backgroundRepeat: 'no-repeat',
              backgroundImage:
                'linear-gradient(to bottom, rgba(251, 252, 255, 0), rgba(251, 252, 255, 1)), url("/enso/background.jpg")',
            },
            children: [
              b.jsx('img', {
                src: '/enso/screens.png',
                className: 'lg:max-w-[40%] xl:max-w-[60%] my-auto',
              }),
              b.jsxs('div', {
                className: 'space-y-4',
                children: [
                  b.jsxs('div', {
                    className: '',
                    children: [
                      b.jsxs('h2', {
                        className: 'lg:text-left mb-2',
                        children: [
                          ' ',
                          'Enso - An encrypted app for seamless communication',
                          ' ',
                        ],
                      }),
                      b.jsx('p', {
                        children:
                          'Senior Product Designer, First Sprint: May - September 2023',
                      }),
                    ],
                  }),
                  b.jsx(so, {}),
                  b.jsx('p', {
                    children:
                      "As the sole designer on the team, I led the entire design process from start to finish, transforming PeaEm's encryption technology into an app called Enso.",
                  }),
                  b.jsx('p', {
                    children:
                      'I navigated ambiguity, technical complexity, and the pressure of a first sprint, using design to simplify complexity and turn uncertainty into opportunity.',
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      b.jsxs('div', {
        className: 'border-b border-borderColor',
        children: [
          b.jsx(iU, {
            isVisible: e,
            setIsVisible: t,
            sidebarItems: y,
            theme: 'enso',
            isFixed: !1,
            mixBlend: 'mix-blend-multiply',
            isBottom: r,
          }),
          b.jsx('div', {
            className: 'xl:pl-[7%]',
            children: b.jsxs('div', {
              id: 'enso-ambiguity',
              children: [
                b.jsxs('div', {
                  className: 'content-container lg:pt-10 xl:pt-10',
                  children: [
                    b.jsxs('h2', {
                      className: 'md:max-w-[70%]',
                      children: [
                        ' ',
                        'How to design a product from a novel technology ',
                        `
`,
                        ' but with no clear direction?',
                        ' ',
                      ],
                    }),
                    b.jsxs('div', {
                      className:
                        'responsive-lg h-auto lg:h-[40vh] xl:h-[50vh] 2xl:h-[40vh] lg:space-x-4',
                      children: [
                        b.jsxs('div', {
                          className:
                            'flex flex-col lg:flex-col-reverse max-w-[70%] mx-auto lg:max-w-[60%] relative',
                          children: [
                            b.jsxs('p', {
                              className: `text-gray-700 italic text-sm text-center pb-2 
                  lg:pb-0 lg:pt-2 lg:absolute lg:bottom-[-2rem] lg:left-[50%] lg:transform lg:-translate-x-1/2 w-full`,
                              children: [
                                ' ',
                                "Engineers' first prototype",
                                ' ',
                              ],
                            }),
                            b.jsx('img', {
                              src: '/enso/technical_prototype.jpg',
                              alt: 'technical_prototype',
                              className:
                                'lg:h-[40vh] xl:h-[50vh] 2xl:h-[40vh] w-auto',
                            }),
                          ],
                        }),
                        b.jsxs('div', {
                          className:
                            'space-y-6 lg:space-y-0 flex flex-col justify-between h-full flex-1 px-8',
                          children: [
                            b.jsxs('p', {
                              className: '',
                              children: [
                                ' ',
                                'When the engineers first showed me their prototype, I was amazed by the sophistication of the technology but felt the weight of its ambiguity pressing down on me.',
                                ' ',
                              ],
                            }),
                            b.jsxs('div', {
                              className: 'space-y-6 pb-3',
                              children: [
                                b.jsxs('h3', {
                                  className:
                                    'border-t pt-3 text-left border-borderColor',
                                  children: [' ', 'No user problem', ' '],
                                }),
                                b.jsxs('h3', {
                                  className:
                                    'border-t pt-3 text-left border-borderColor',
                                  children: [' ', 'No project direction', ' '],
                                }),
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
                b.jsx(so, {}),
                b.jsxs('div', {
                  className: 'content-container',
                  children: [
                    b.jsxs('div', {
                      className: 'space-y-3 xl:max-w-[90%]',
                      children: [
                        b.jsxs('p', {
                          className: 'text-center',
                          children: [
                            ' ',
                            'To unearth opportunities, I took the initiative to conduct user research.',
                            ' ',
                          ],
                        }),
                        b.jsx('h2', {
                          children:
                            'My interviews and online research revealed that many companies struggled to balance seamless communication with data privacy.',
                        }),
                      ],
                    }),
                    b.jsxs('div', {
                      className:
                        'flex flex-col lg:flex-row space-x-2 justify-center',
                      children: [
                        b.jsxs('div', {
                          className: `flex flex-col justify-center 
          lg:space-x-0 space-y-2 flex-1 lg:max-w-[30%]`,
                          children: [
                            b.jsx('div', {
                              className:
                                'grid place-items-center border border-borderColor py-2 rounded-lg text-center',
                              children: b.jsx('p', {
                                className: 'text-[#6A65A9] font-semibold',
                                children: 'Online research and interview',
                              }),
                            }),
                            b.jsx('div', {
                              className:
                                'grid place-items-center border border-borderColor py-2 px-6 rounded-lg text-center flex-grow',
                              children: b.jsxs('p', {
                                children: [
                                  ' ',
                                  '“Backing up data manually is tedious and prone to errors”',
                                  ' ',
                                ],
                              }),
                            }),
                            b.jsxs('div', {
                              className:
                                'flex flex-col items-center justify-center border border-borderColor py-2 px-6 rounded-lg text-center flex-grow space-y-2',
                              children: [
                                b.jsx('h3', {
                                  className: 'font-bold',
                                  children: ' 96% ',
                                }),
                                b.jsxs('p', {
                                  children: [
                                    ' ',
                                    'of workstations are not ',
                                    `
`,
                                    ' being backed up properly',
                                    ' ',
                                  ],
                                }),
                                b.jsx('p', {
                                  className: 'text-gray-500',
                                  children: ' (Uni Trends) ',
                                }),
                              ],
                            }),
                          ],
                        }),
                        b.jsx('div', {
                          className:
                            'w-auto h-auto flex items-center justify-center',
                          children: b.jsx('img', {
                            src: '/enso/arrow.svg',
                            alt: 'Arrow icon',
                            className:
                              'max-w-[20%] my-8 lg:my-0 lg:max-w-[70%] rotate-90 lg:rotate-0',
                          }),
                        }),
                        b.jsxs('div', {
                          className:
                            'flex flex-col lg:flex-row lg:space-x-2 flex-1',
                          children: [
                            b.jsxs('div', {
                              className: `border border-borderColor p-2 rounded-lg text-center mb-4 lg:mb-0
                      flex flex-col items-center justify-center text-white bg-[#8882D7] space-y-4`,
                              children: [
                                b.jsx('p', {
                                  className: 'font-semibold text-lg',
                                  children: ' Target user ',
                                }),
                                b.jsx('img', {
                                  src: '/enso/company.svg',
                                  alt: 'Company icon',
                                  className: 'w-[15%] lg:w-[40%]',
                                }),
                                b.jsxs('p', {
                                  children: [
                                    ' Small to medium sized ',
                                    `
`,
                                    ' low-tech companies ',
                                  ],
                                }),
                              ],
                            }),
                            b.jsxs('div', {
                              className:
                                'flex flex-col justify-center space-y-2',
                              children: [
                                b.jsxs('div', {
                                  className:
                                    'p-4 rounded-lg text-[#6A65A9] bg-[#DAD8F3]',
                                  children: [
                                    b.jsx('p', {
                                      className: 'font-medium pb-2',
                                      children: ' Pain Points ',
                                    }),
                                    b.jsxs('ul', {
                                      children: [
                                        b.jsx('li', {
                                          children:
                                            ' Manual data backup is tedious. ',
                                        }),
                                        b.jsx('li', {
                                          children:
                                            'Budget limitations for acquiring a reliable cloud server.',
                                        }),
                                        b.jsx('li', {
                                          children:
                                            'Lack of knowledge on how to secure data.',
                                        }),
                                      ],
                                    }),
                                  ],
                                }),
                                b.jsxs('div', {
                                  className: 'p-4 rounded-lg bg-[#E8CA67]',
                                  children: [
                                    b.jsx('p', {
                                      className: 'font-medium pb-2',
                                      children: ' Motivations ',
                                    }),
                                    b.jsxs('ul', {
                                      children: [
                                        b.jsx('li', {
                                          children:
                                            'Automatic data backup to reduce the risk of human error.',
                                        }),
                                        b.jsx('li', {
                                          children:
                                            'Data backup across devices to prevent loss from hardware failure.',
                                        }),
                                        b.jsx('li', {
                                          children:
                                            'Protecting data without relying on a cloud server, which may be more vulnerable to hackers.',
                                        }),
                                        b.jsx('li', {
                                          children:
                                            'Real-time collaboration to facilitate long-distance work.',
                                        }),
                                      ],
                                    }),
                                  ],
                                }),
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
                b.jsx(so, {}),
                b.jsx('div', {
                  className: 'content-container xl:pb-20',
                  children: b.jsxs('div', {
                    className: 'space-y-3 xl:max-w-[90%]',
                    children: [
                      b.jsx('h2', {
                        children:
                          'How to navigate ambiguity in a startup with limited resources?',
                      }),
                      b.jsxs('p', {
                        className: 'text-center',
                        children: [
                          ' ',
                          'To prioritize features, I employed a comparative analysis and crafted a prioritization matrix.',
                        ],
                      }),
                    ],
                  }),
                }),
                b.jsx(so, {}),
                b.jsxs('div', {
                  className:
                    'flex flex-col lg:flex-row xl:max-w-[1080px] mx-auto',
                  children: [
                    b.jsxs('div', {
                      className:
                        'border-b lg:border-b-0 lg:border-r border-borderColor',
                      children: [
                        b.jsxs('p', {
                          className: 'font-semibold text-center pt-6',
                          children: [' ', 'Competitive Analysis', ' '],
                        }),
                        b.jsx('img', {
                          src: '/enso/competitive analysis.png',
                          className: 'responsive-image',
                        }),
                      ],
                    }),
                    b.jsxs('div', {
                      children: [
                        b.jsxs('p', {
                          className: 'font-semibold text-center pt-6',
                          children: [' ', 'Prioritization Matrix', ' '],
                        }),
                        b.jsx('img', {
                          src: '/enso/prioritization.png',
                          className: 'responsive-image',
                        }),
                      ],
                    }),
                  ],
                }),
                b.jsx(so, { pb: 20 }),
                b.jsxs('div', {
                  className: 'content-container xl:space-y-10',
                  children: [
                    b.jsxs('h2', {
                      className: ' xl:max-w-[90%]',
                      children: [
                        'Now, we have a clear understanding of the features users want,',
                        `
`,
                        'which will guide us toward our MVP.',
                        ' ',
                      ],
                    }),
                    b.jsxs('div', {
                      className: 'responsive-lg pb-20 lg:space-x-6 xl:pb-40 ',
                      children: [
                        b.jsxs('span', {
                          className:
                            'text-white bg-[#8882D7] rounded-lg py-4 px-6 font-medium text-lg',
                          children: [' ', 'Backing up data', ' '],
                        }),
                        b.jsxs('span', {
                          className:
                            'text-white bg-[#8882D7] rounded-lg py-4 px-6 font-medium text-lg',
                          children: [' ', 'Sharing files', ' '],
                        }),
                        b.jsxs('span', {
                          className:
                            'text-white bg-[#8882D7] rounded-lg py-4 px-6 font-medium text-lg',
                          children: [' ', 'Real-time collaboration', ' '],
                        }),
                        b.jsxs('span', {
                          className:
                            'text-white bg-[#8882D7] rounded-lg py-4 px-6 font-medium text-lg',
                          children: [' ', 'Multiple Groups', ' '],
                        }),
                      ],
                    }),
                    b.jsxs('h2', {
                      className: 'xl:max-w-[90%]',
                      children: [
                        'Then through brainstorming sessions with the CTO and engineer,',
                        `
`,
                        'I went through several iterations.',
                      ],
                    }),
                    b.jsx('img', {
                      src: '/enso/iterations.png',
                      className: 'responsive-image xl:pb-20',
                    }),
                  ],
                }),
              ],
            }),
          }),
          b.jsxs('div', {
            id: 'enso-component',
            children: [
              b.jsx('div', {
                className: 'w-full',
                style: {
                  backgroundSize: 'cover',
                  backgroundPosition: 'center',
                  backgroundRepeat: 'no-repeat',
                  backgroundImage:
                    'linear-gradient(to bottom, rgba(251, 252, 255, 0), rgba(251, 252, 255, 0), rgba(251, 252, 255, 1)), url("/enso/background.jpg")',
                },
                children: b.jsx('div', {
                  className: 'xl:pl-[7%]',
                  children: b.jsxs('div', {
                    className: 'content-container',
                    children: [
                      b.jsxs('div', {
                        className: 'space-y-6 xl:max-w-[90%]',
                        children: [
                          b.jsx('h2', {
                            className: 'text-white',
                            children:
                              'How to balance speed, scalability, and design consistency?',
                          }),
                          b.jsx('div', {
                            className: 'w-[40%] border-t border-white mx-auto',
                          }),
                          b.jsx('p', {
                            className: 'text-center text-white lg:text-lg',
                            children:
                              'A component library establishes a structured framework that empowers engineers to seamlessly translate designs into code, ensuring consistency and efficiency across the codebase.',
                          }),
                        ],
                      }),
                      b.jsx('img', {
                        src: '/enso/component library.png',
                        className: 'w-auto',
                      }),
                    ],
                  }),
                }),
              }),
              b.jsx('div', {
                className:
                  'hidden xl:block xl:pl-[7%] h-[180vh] w-[85%] xl:max-w-[2000px] mx-auto relative py-10 xl:py-20',
                ref: s,
                children: b.jsxs('div', {
                  className:
                    'flex flex-col items-center justify-center sticky top-10 h-[90vh]',
                  children: [
                    b.jsxs('div', {
                      className: 'absolute top-[10vh]',
                      children: [
                        b.jsx('h2', {
                          className: '',
                          children: ' 8px Margin System ',
                        }),
                        b.jsxs('div', {
                          className:
                            'flex flex-wrap gap-4 py-4 px-8 items-center',
                          children: [
                            b.jsxs('div', {
                              className: 'flex items-center space-x-2',
                              children: [
                                b.jsx('span', {
                                  className:
                                    'w-[60px] h-[30px] bg-[#048BA8] bg-opacity-20 border border-[#048BA8]',
                                }),
                                b.jsx('p', {
                                  className: 'text-[#048BA8]',
                                  children: ' 80px ',
                                }),
                              ],
                            }),
                            b.jsxs('div', {
                              className: 'flex items-center space-x-2',
                              children: [
                                b.jsx('span', {
                                  className:
                                    'w-[60px] h-[30px] bg-[#464D77] bg-opacity-20 border border-[#464D77]',
                                }),
                                b.jsx('p', {
                                  className: 'text-[#464D77]',
                                  children: ' 64px ',
                                }),
                              ],
                            }),
                            b.jsxs('div', {
                              className: 'flex items-center space-x-2',
                              children: [
                                b.jsx('span', {
                                  className:
                                    'w-[60px] h-[30px] bg-[#3772FF] bg-opacity-20 border border-[#3772FF]',
                                }),
                                b.jsx('p', {
                                  className: 'text-[#3772FF]',
                                  children: ' 56px ',
                                }),
                              ],
                            }),
                            b.jsxs('div', {
                              className: 'flex items-center space-x-2',
                              children: [
                                b.jsx('span', {
                                  className:
                                    'w-[60px] h-[30px] bg-[#6B9AC4] bg-opacity-20 border border-[#6B9AC4]',
                                }),
                                b.jsx('p', {
                                  className: 'text-[#1F6BAF]',
                                  children: ' 40px ',
                                }),
                              ],
                            }),
                            b.jsxs('div', {
                              className: 'flex items-center space-x-2',
                              children: [
                                b.jsx('span', {
                                  className:
                                    'w-[60px] h-[30px] bg-[#E8CA67] bg-opacity-20 border border-[#E8CA67]',
                                }),
                                b.jsx('p', {
                                  className: 'text-[#CAA016]',
                                  children: ' 24px ',
                                }),
                              ],
                            }),
                            b.jsxs('div', {
                              className: 'flex items-center space-x-2',
                              children: [
                                b.jsx('span', {
                                  className:
                                    'w-[60px] h-[30px] bg-[#BE28AF] bg-opacity-20 border border-[#BE28AF]',
                                }),
                                b.jsx('p', {
                                  className: 'text-[#BE28AF]',
                                  children: ' 16px ',
                                }),
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                    b.jsx(Ix, {
                      src: '/enso/margin1.png',
                      alt: 'First Image',
                      className:
                        'absolute top-[20vh] responsive-image object-contain',
                    }),
                    b.jsx(Ix, {
                      src: '/enso/margin2.png',
                      alt: 'Second Image',
                      className:
                        'absolute top-[20vh] responsive-image object-contain',
                      style: { opacity: a },
                    }),
                  ],
                }),
              }),
              b.jsxs('div', {
                className:
                  'flex xl:hidden relative w-[90%] mx-auto flex-col items-center justify-center space-y-4',
                children: [
                  b.jsxs('div', {
                    className: 'space-y-6',
                    children: [
                      b.jsx('h2', {
                        className: '',
                        children: ' 8px Margin System ',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[40%] border-t border-borderColor mx-auto',
                      }),
                    ],
                  }),
                  b.jsx('img', {
                    src: '/enso/margin1.png',
                    alt: 'Margin Image',
                    className: 'responsive-image object-contain',
                  }),
                  b.jsxs('div', {
                    className:
                      ' flex-wrap gap-4 py-4 px-8 items-center hidden md:flex',
                    children: [
                      b.jsxs('div', {
                        className: 'flex items-center space-x-2',
                        children: [
                          b.jsx('span', {
                            className:
                              'w-[60px] h-[30px] bg-[#048BA8] bg-opacity-20 border border-[#048BA8]',
                          }),
                          b.jsx('p', {
                            className: 'text-[#048BA8]',
                            children: ' 80px ',
                          }),
                        ],
                      }),
                      b.jsxs('div', {
                        className: 'flex items-center space-x-2',
                        children: [
                          b.jsx('span', {
                            className:
                              'w-[60px] h-[30px] bg-[#464D77] bg-opacity-20 border border-[#464D77]',
                          }),
                          b.jsx('p', {
                            className: 'text-[#464D77]',
                            children: ' 64px ',
                          }),
                        ],
                      }),
                      b.jsxs('div', {
                        className: 'flex items-center space-x-2',
                        children: [
                          b.jsx('span', {
                            className:
                              'w-[60px] h-[30px] bg-[#3772FF] bg-opacity-20 border border-[#3772FF]',
                          }),
                          b.jsx('p', {
                            className: 'text-[#3772FF]',
                            children: ' 56px ',
                          }),
                        ],
                      }),
                      b.jsxs('div', {
                        className: 'flex items-center space-x-2',
                        children: [
                          b.jsx('span', {
                            className:
                              'w-[60px] h-[30px] bg-[#6B9AC4] bg-opacity-20 border border-[#6B9AC4]',
                          }),
                          b.jsx('p', {
                            className: 'text-[#1F6BAF]',
                            children: ' 40px ',
                          }),
                        ],
                      }),
                      b.jsxs('div', {
                        className: 'flex items-center space-x-2',
                        children: [
                          b.jsx('span', {
                            className:
                              'w-[60px] h-[30px] bg-[#E8CA67] bg-opacity-20 border border-[#E8CA67]',
                          }),
                          b.jsx('p', {
                            className: 'text-[#CAA016]',
                            children: ' 24px ',
                          }),
                        ],
                      }),
                      b.jsxs('div', {
                        className: 'flex items-center space-x-2',
                        children: [
                          b.jsx('span', {
                            className:
                              'w-[60px] h-[30px] bg-[#BE28AF] bg-opacity-20 border border-[#BE28AF]',
                          }),
                          b.jsx('p', {
                            className: 'text-[#BE28AF]',
                            children: ' 16px ',
                          }),
                        ],
                      }),
                    ],
                  }),
                  b.jsx('img', {
                    src: '/enso/margin2.png',
                    alt: 'Margin Image',
                    className: 'responsive-image object-contain',
                  }),
                ],
              }),
            ],
          }),
          b.jsxs('div', {
            className: 'xl:pl-[7%] w-full',
            children: [
              b.jsxs('div', {
                className:
                  'hidden xl:flex flex-col content-container xl:max-w-[90%] xl:pb-10 xl:pt-0',
                children: [
                  b.jsxs('div', {
                    className:
                      'space-y-6 sticky top-0 z-20 bg-background w-full pt-28',
                    style: {
                      backgroundImage:
                        'linear-gradient(to top, rgba(251, 252, 255, 0.2), rgba(251, 252, 255, 0.8), rgba(251, 252, 255, 1), rgba(251, 252, 255, 1), rgba(251, 252, 255, 1))',
                    },
                    children: [
                      b.jsx('h2', {
                        className: '',
                        children:
                          'How to hide complexity without compromising user control?',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[40%] border-t border-borderColor mx-auto',
                      }),
                      b.jsx('p', {
                        className: 'text-center',
                        children:
                          'One of the major challenges was translating a highly technical system into a simple user experience.',
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className:
                      'flex mx-auto max-w-[90%] xl:max-w-[1080px] 3xl:max-w-[1440px]',
                    children: [
                      b.jsx(
                        dm,
                        {
                          className:
                            'sticky top-48 h-[70vh] flex items-center justify-center pl-14',
                          children: b.jsx('img', {
                            src: c,
                            alt: 'Dynamic content',
                            className: 'object-contain',
                          }),
                        },
                        c,
                      ),
                      b.jsxs('div', {
                        className: 'space-y-20 w-[55%]',
                        children: [
                          b.jsx(
                            'div',
                            {
                              className:
                                'flex flex-col space-y-4 pl-6 pr-20 h-[60vh] justify-center items-center pb-8',
                              'data-index': 0,
                              ref: (M) => (m.current[0] = M),
                              children: b.jsxs('p', {
                                className:
                                  'text-lg leading-relaxed h-auto pt-14',
                                children: [
                                  'P2P file sharing, one of the main features in this product, while powerful,',
                                  ' ',
                                  b.jsxs('strong', {
                                    children: [
                                      ' ',
                                      'often intimidates users with jargon and complicated steps',
                                      ' ',
                                    ],
                                  }),
                                  ' ',
                                  'that involves decrypting files and connecting devices.',
                                ],
                              }),
                            },
                            0,
                          ),
                          b.jsxs(
                            'div',
                            {
                              className:
                                'flex flex-col space-y-8 pl-6 pr-20 h-[60vh] justify-center pb-28',
                              'data-index': 1,
                              ref: (M) => (m.current[1] = M),
                              children: [
                                b.jsx('p', {
                                  className: 'text-lg leading-relaxed h-auto',
                                  children:
                                    'Consolidating into 2 steps that are familiar to people:',
                                }),
                                b.jsx('h3', {
                                  className: 'pb-8',
                                  children: ' 1. AirDrop ',
                                }),
                                b.jsx('h3', {
                                  className: '',
                                  children: ' 2. Unzipping a file ',
                                }),
                              ],
                            },
                            1,
                          ),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              b.jsxs('div', {
                className: 'flex xl:hidden flex-col content-container xl:pt-20',
                children: [
                  b.jsxs('div', {
                    className: 'space-y-6',
                    children: [
                      b.jsx('h2', {
                        className: '',
                        children:
                          'How to hide complexity without compromising user control?',
                      }),
                      b.jsx('div', {
                        className:
                          'w-[40%] border-t border-borderColor mx-auto',
                      }),
                      b.jsx('p', {
                        className: 'text-center',
                        children:
                          'One of the major challenges was translating a highly technical system into a simple user experience.',
                      }),
                    ],
                  }),
                  b.jsx('div', {
                    className: 'content-container pt-10 pb-0',
                    children: b.jsxs('div', {
                      className: 'responsive-xl h-auto',
                      children: [
                        b.jsx('div', {
                          className: '',
                          children: b.jsx('img', {
                            src: '/enso/complexity-mobile.png',
                            alt: 'git image showing file download',
                            className: 'responsive-image w-[90%] md:w-[70%]',
                          }),
                        }),
                        b.jsxs('div', {
                          className:
                            'space-y-6 flex flex-col justify-between px-8',
                          children: [
                            b.jsxs('p', {
                              className: '',
                              children: [
                                'P2P file sharing, one of the main features in this product, while powerful, often',
                                ' ',
                                b.jsxs('strong', {
                                  children: [
                                    ' ',
                                    'intimidates users with jargon and complicated steps',
                                    ' ',
                                  ],
                                }),
                                'that involves decrypting files and connecting devices.',
                              ],
                            }),
                            b.jsx('p', {
                              children:
                                'I simplified the process by using words and controls similar to technologies that people are familiar with (in this case, AirDrop and unzipping a file).',
                            }),
                          ],
                        }),
                      ],
                    }),
                  }),
                ],
              }),
              b.jsx('div', {
                className: 'content-container pt-0 xl:pt-10',
                children: b.jsxs('div', {
                  className:
                    'responsive-lg h-auto lg:h-[40vh] xl:h-[50vh] 2xl:h-[40vh] lg:space-x-4',
                  children: [
                    b.jsx('div', {
                      className: '',
                      children: b.jsx('img', {
                        src: '/enso/file_download.gif',
                        alt: 'git image showing file download',
                        className:
                          'responsive-image lg:h-[40vh] xl:h-[50vh] 2xl:h-[40vh] w-auto',
                      }),
                    }),
                    b.jsxs('div', {
                      className:
                        'space-y-6 lg:space-y-0 flex flex-col justify-between h-full flex-1 px-8',
                      children: [
                        b.jsx('p', {
                          className: '',
                          children:
                            'The final design reflected the thought process and was tested with three early users, successfully validating its ease of understanding.',
                        }),
                        b.jsxs('div', {
                          className: 'space-y-6',
                          children: [
                            b.jsx('h3', {
                              className:
                                'border-t pt-3 text-left border-borderColor',
                              children: 'Clear system status',
                            }),
                            b.jsx('h3', {
                              className:
                                'border-t pt-3 text-left border-borderColor',
                              children: 'Micro-interactions',
                            }),
                            b.jsx('h3', {
                              className:
                                'border-t pt-3 text-left border-borderColor',
                              children: 'No jargon',
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              }),
              b.jsx(so, {}),
              b.jsxs('div', {
                id: 'enso-final',
                children: [
                  b.jsx('div', {
                    className: 'content-container xl:pb-20',
                    children: b.jsxs('div', {
                      className: 'space-y-3',
                      children: [
                        b.jsx('h2', {
                          children:
                            'The final product: turning uncertainty to opportunity',
                        }),
                        b.jsx('div', {
                          className:
                            'w-[40%] border-t border-borderColor mx-auto',
                        }),
                        b.jsx('p', {
                          className: 'text-center',
                          children:
                            'Tested with five early users, refined the user flow, and removed jargon.',
                        }),
                      ],
                    }),
                  }),
                  b.jsxs('div', {
                    className: 'flex items-center justify-center lg:px-28',
                    children: [
                      b.jsxs('div', {
                        className: 'hidden lg:block relative w-[60%] xl:pb-40',
                        children: [
                          b.jsx('img', {
                            src: '/laptop.png',
                            alt: 'laptop',
                            className:
                              'lg:absolute top-[11%] right-0 scale-y-[1.45] scale-x-[1.4] 3xl:hidden',
                          }),
                          b.jsx(lU, {
                            videourl: '/enso/prototype.mp4',
                            pt: '71.3',
                          }),
                        ],
                      }),
                      b.jsx('div', {
                        className:
                          'flex lg:hidden relative w-[80%] flex-col items-center justify-center space-y-10',
                        children: _.map((M, w) =>
                          b.jsx(
                            'div',
                            {
                              className: '',
                              children: b.jsx('img', {
                                src: M.image,
                                alt: M.alt,
                                className: 'shadow-md responsive-image',
                              }),
                            },
                            w,
                          ),
                        ),
                      }),
                    ],
                  }),
                  b.jsx('div', {
                    className: 'content-container',
                    children: b.jsxs('div', {
                      className: 'responsive-lg lg:items-start',
                      children: [
                        b.jsx('h2', { children: 'Takeaways' }),
                        b.jsxs('div', {
                          className: 'space-y-6 w-[80%] xl:w-[70%]',
                          children: [
                            b.jsxs('p', {
                              children: [
                                ' ',
                                'Taking full responsibility for designing a new product was daunting, but I learned to embrace the unknown. I discovered that curiosity and an open mind are as important as technical skills.',
                                ' ',
                              ],
                            }),
                            b.jsx('p', {
                              children:
                                'This project reminded me that behind every challenge lies an opportunity to build clarity, not just for users, but for the team and myself.',
                            }),
                          ],
                        }),
                      ],
                    }),
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      b.jsx('div', { ref: i, children: b.jsx(kte, {}) }),
    ],
  })
}
const Ute = ({ url: n, width: e, pt: t }) =>
  b.jsx(b.Fragment, {
    children: b.jsx('div', {
      className: 'hidden lg:block relative overflow-hidden',
      style: { paddingTop: t + '%', width: e },
      children: b.jsx('iframe', {
        src: n,
        width: '100%',
        height: '100%',
        allowFullScreen: !0,
        title: 'Figma Embed',
        className: 'absolute top-0 left-0 bottom-0 right-0',
        loading: 'lazy',
      }),
    }),
  })
function Bte() {
  const [n, e] = X.useState(!1),
    { ref: t, isInView: i } = kT(),
    r = [
      { label: 'research', id: 'restyle-research' },
      { label: 'design decisions', id: 'restyle-design' },
      { label: 'final prototype', id: 'restyle-final', offset: 100 },
    ],
    s = X.useRef(null),
    { scrollYProgress: o } = tT({ target: s }),
    a = ih(o, [0, 0.25], ['#50AD81', '#292929']),
    c = ih(o, [0.1, 0.25, 0.5], ['#292929', '#50AD81', '#292929']),
    u = ih(o, [0.3, 0.5, 0.75], ['#292929', '#50AD81', '#292929']),
    h = ih(o, [0.6, 0.75], ['#292929', '#50AD81'])
  return b.jsxs('div', {
    'data-theme': 'restyle',
    className:
      'w-full bg-background whitespace-normal xl:whitespace-pre-line text-textColor',
    children: [
      b.jsxs('div', {
        className: 'w-full relative top-0 left-0 py-10',
        children: [
          b.jsx('div', {
            className: 'block xl:hidden',
            children: b.jsx(Ic, { theme: 'restyle', color: 'text-titleColor' }),
          }),
          b.jsx('div', {
            className: `hidden xl:block transition-all duration-300 ease-out delay-100
          ${n ? 'opacity-0' : 'opacity-100'} `,
            children: b.jsx(Ic, { theme: 'restyle', color: 'text-white' }),
          }),
          b.jsx('img', {
            src: '/restyle/radial_circle.png',
            className:
              'hidden xl:inline w-full left-0 top-[30%] xl:max-w-[60%] absolute xl:top-[-35%] xl:left-[-10%] z-0',
          }),
          b.jsxs('div', {
            className:
              'h-[100vh] responsive-lg p-10 md:my-20 lg:my-0 xl:p-40 xl:pt-0 z-20',
            children: [
              b.jsxs('div', {
                className: 'space-y-4',
                children: [
                  b.jsxs('div', {
                    className: '',
                    children: [
                      b.jsx('h2', {
                        className: 'lg:text-left mb-2',
                        children:
                          'Restyle - redesigning the way we recycle fashion',
                      }),
                      b.jsx('p', {
                        children: ' UX School Project, Oct - Nov 2022',
                      }),
                    ],
                  }),
                  b.jsx(so, {}),
                  b.jsx('p', {
                    children:
                      'As a school project, ReStyle set out to solve a pressing problem: the growing issue of clothing waste.',
                  }),
                  b.jsx('p', {
                    children:
                      'In a group of 4, our goal was to design an app that made it effortless for users to buy, sell, and repurpose secondhand clothing while promoting sustainability.',
                  }),
                  b.jsx('p', {
                    children:
                      'The process was a journey of discovery, iteration, and innovation, shaped by a deep understanding of user behaviors and needs.',
                  }),
                ],
              }),
              b.jsx('img', {
                src: '/restyle/screens.png',
                className:
                  'max-w-[60%] xl:max-h-[100vh] z-20 landscape:hidden lg:landscape:block',
              }),
            ],
          }),
        ],
      }),
      b.jsxs('div', {
        className: '',
        children: [
          b.jsx(iU, {
            isVisible: n,
            setIsVisible: e,
            sidebarItems: r,
            theme: 'restyle',
            isFixed: !1,
            isBottom: i,
          }),
          b.jsxs('div', {
            className: 'xl:pl-[7%]',
            children: [
              b.jsxs('div', {
                className:
                  'content-container pt-0 pb-10 lg:py-14 xl:py-20 lg:pt-10 xl:pt-10',
                children: [
                  b.jsx('img', {
                    src: '/restyle/timeline.png',
                    className: 'responsive-image hidden md:block',
                  }),
                  b.jsx('img', {
                    src: '/restyle/timeline-mobile.png',
                    className: 'max-w-[70%] mx-auto md:hidden',
                  }),
                ],
              }),
              b.jsxs('div', {
                id: 'restyle-research',
                children: [
                  b.jsxs('div', {
                    className: 'content-container lg:pb-20',
                    children: [
                      b.jsxs('div', {
                        className: 'space-y-3 xl:max-w-[90%]',
                        children: [
                          b.jsx('h2', {
                            children:
                              "How can we design a platform that's both affordable and user-friendly, while minimizing time and effort?",
                          }),
                          b.jsx('div', {
                            className:
                              'w-[40%] border-t border-borderColor mx-auto',
                          }),
                          b.jsx('p', {
                            className: 'text-center',
                            children:
                              'To answer this, we conducted eight interviews to uncover three key aspects of user behavior: their shopping habits, methods for disposing of clothes, and the challenges they faced.',
                          }),
                        ],
                      }),
                      b.jsxs('div', {
                        className:
                          'flex flex-col items-center lg:flex-row space-x-2 justify-center lg:items-stretch',
                        children: [
                          b.jsxs('div', {
                            className: `flex flex-col justify-center 
          lg:space-x-0 space-y-2 flex-1 lg:max-w-[30%]`,
                            children: [
                              b.jsx('div', {
                                className:
                                  'w-[80vw] lg:w-auto grid place-items-center border border-borderColor py-2 px-2 rounded-full text-center flex-grow font-medium bg-titleColor text-background ',
                                children: b.jsx('p', {
                                  children: 'Themes from our 8 interviews:',
                                }),
                              }),
                              b.jsx('div', {
                                className:
                                  'grid place-items-center border border-borderColor py-2 px-2 rounded-full text-center flex-grow font-medium',
                                children: b.jsx('p', {
                                  children: 'Time and effort',
                                }),
                              }),
                              b.jsx('div', {
                                className:
                                  'grid place-items-center border border-borderColor py-2 px-2 rounded-full text-center flex-grow font-medium',
                                children: b.jsx('p', {
                                  children: 'Price Sensitivity',
                                }),
                              }),
                              b.jsx('div', {
                                className:
                                  'grid place-items-center border border-borderColor py-2 px-2 rounded-full text-center flex-grow font-medium',
                                children: b.jsx('p', {
                                  children: 'Fashion Consciousness',
                                }),
                              }),
                            ],
                          }),
                          b.jsx('div', {
                            className:
                              'max-w-[20%] my-8 lg:my-auto lg:max-w-[70%] rotate-90 lg:rotate-0 text-primary',
                            children: b.jsx('svg', {
                              width: '58',
                              height: '19',
                              viewBox: '0 0 58 19',
                              fill: 'currentColor',
                              xmlns: 'http://www.w3.org/2000/svg',
                              children: b.jsx('path', {
                                d: 'M57.5 9.5L42.5 0.83975L42.5 18.1603L57.5 9.5ZM0.5 11L2.875 11L2.875 8L0.5 8L0.5 11ZM7.625 11L12.375 11L12.375 8L7.625 8L7.625 11ZM17.125 11L21.875 11L21.875 8L17.125 8L17.125 11ZM26.625 11L31.375 11L31.375 8L26.625 8L26.625 11ZM36.125 11L40.875 11L40.875 8L36.125 8L36.125 11ZM45.625 11L50.375 11L50.375 8L45.625 8L45.625 11ZM57.5 9.5L42.5 0.83975L42.5 18.1603L57.5 9.5ZM0.5 11L2.875 11L2.875 8L0.5 8L0.5 11ZM7.625 11L12.375 11L12.375 8L7.625 8L7.625 11ZM17.125 11L21.875 11L21.875 8L17.125 8L17.125 11ZM26.625 11L31.375 11L31.375 8L26.625 8L26.625 11ZM36.125 11L40.875 11L40.875 8L36.125 8L36.125 11ZM45.625 11L50.375 11L50.375 8L45.625 8L45.625 11Z',
                                fill: 'currentColor',
                              }),
                            }),
                          }),
                          b.jsx('div', {
                            className:
                              'flex flex-col lg:flex-row lg:space-x-2 flex-1',
                            children: b.jsx('img', {
                              src: '/restyle/persona.png',
                            }),
                          }),
                        ],
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className:
                      'content-container 2xl:pb-20 xl:pb-0 lg:py-14 2xl:pt-24',
                    children: [
                      b.jsxs('div', {
                        className: 'space-y-3 xl:max-w-[90%]',
                        children: [
                          b.jsx('h2', {
                            children:
                              'How to translate user needs into actionable solutions?',
                          }),
                          b.jsx('div', {
                            className:
                              'w-[40%] border-t border-borderColor mx-auto',
                          }),
                          b.jsx('p', {
                            className: 'text-center',
                            children:
                              'With these insights, we created storyboards to illustrate how ReStyle could make buying and selling clothes effortless. This led us to brainstorm a user flow that defined the essential features and screens.',
                          }),
                        ],
                      }),
                      b.jsxs('div', {
                        className: 'responsive-lg lg:space-x-6',
                        children: [
                          b.jsxs('div', {
                            className: '',
                            children: [
                              b.jsx('p', {
                                className: 'text-center pb-4',
                                children:
                                  ' A storyboard to highlight the user journey and pain points ',
                              }),
                              b.jsx('img', {
                                src: '/restyle/storyboard.jpg',
                                className: 'responsive-image lg:h-[40vh]',
                              }),
                            ],
                          }),
                          b.jsxs('div', {
                            children: [
                              b.jsx('p', {
                                className: 'text-center pb-4',
                                children:
                                  " A wireframe flow to define the app's architecture ",
                              }),
                              b.jsx('img', {
                                src: '/restyle/wireflow.jpg',
                                className: 'responsive-image lg:h-[40vh]',
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className: 'textImgStyle xl:pb-28',
                    children: [
                      b.jsx('img', {
                        src: '/restyle/low_fi.png',
                        className: 'responsive-image lg:max-w-[40%]',
                      }),
                      b.jsxs('div', {
                        className: 'space-y-3 my-auto xl:max-w-[50%]',
                        children: [
                          b.jsx('h2', {
                            className: 'lg:text-left',
                            children: 'Our breakthrough idea? A points system.',
                          }),
                          b.jsx('p', {
                            className: 'lg:text-left',
                            children:
                              'Instead of complicating the process with monetary transactions, users could earn points for selling clothes and use them to make purchases.',
                          }),
                          b.jsx('p', {
                            className: 'lg:text-left',
                            children:
                              'This not only catered to price-conscious users but also eliminated authentication hurdles, making the process seamless.',
                          }),
                        ],
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className: 'content-container xl:pb-40 lg:py-14',
                    children: [
                      b.jsxs('div', {
                        className: 'space-y-3',
                        children: [
                          b.jsxs('h2', {
                            children: [
                              'Saying is one thing, but doing is another. ',
                              `
`,
                              'What do usability tests uncover about the reality of our designs?',
                            ],
                          }),
                          b.jsx('p', {
                            className: 'text-center',
                            children:
                              'After prototyping our mid-fi wireframes, we conducted two rounds of usability testing with 10 participants.',
                          }),
                        ],
                      }),
                      b.jsxs('div', {
                        className:
                          'flex flex-col lg:flex-row items-stretch w-full',
                        children: [
                          b.jsxs('div', {
                            className:
                              'border border-borderColor border-b-0 lg:border-r-0 lg:border-b px-6 py-3 lg:py-8 lg:space-y-2 grow rounded-t-lg lg:rounded-tr-none lg:rounded-l-lg lg:w-[20%]',
                            children: [
                              b.jsxs('p', {
                                className: 'font-medium text-titleColor',
                                children: [' ', 'Confusion about status', ' '],
                              }),
                              b.jsx('p', {
                                children:
                                  'Users were unclear if actions were completed or in progress.',
                              }),
                            ],
                          }),
                          b.jsxs('div', {
                            className:
                              'border border-borderColor border-b-0 lg:border-r-0 lg:border-b px-6 py-3 lg:py-8 grow lg:space-y-2 lg:w-[20%]',
                            children: [
                              b.jsxs('p', {
                                className: 'font-medium text-titleColor',
                                children: [' ', 'Shopping cart needs', ' '],
                              }),
                              b.jsx('p', {
                                children:
                                  'Participants wanted to save and compare items.',
                              }),
                            ],
                          }),
                          b.jsxs('div', {
                            className:
                              'border border-borderColor border-b-0 lg:border-r-0 lg:border-b px-6 py-3 lg:py-8 grow lg:space-y-2 lg:w-[20%]',
                            children: [
                              b.jsxs('p', {
                                className: 'font-medium text-titleColor',
                                children: [' ', 'Navigation issues', ' '],
                              }),
                              b.jsx('p', {
                                children:
                                  'Users struggled to return to previously viewed items.',
                              }),
                            ],
                          }),
                          b.jsxs('div', {
                            className:
                              'border border-borderColor border-b-0 lg:border-r-0 lg:border-b px-6 py-3 lg:py-8 grow lg:space-y-2 lg:w-[20%]',
                            children: [
                              b.jsxs('p', {
                                className: 'font-medium text-titleColor',
                                children: [
                                  ' ',
                                  'Filter & Sort challenges',
                                  ' ',
                                ],
                              }),
                              b.jsx('p', {
                                children:
                                  "Sorting and filtering options weren't intuitive.",
                              }),
                            ],
                          }),
                          b.jsxs('div', {
                            className:
                              'border border-borderColor px-6 py-3 lg:py-8 lg:space-y-2 grow rounded-b-lg lg:rounded-bl-none lg:rounded-r-lg lg:w-[20%]',
                            children: [
                              b.jsx('p', {
                                className: 'font-medium text-titleColor',
                                children: ' Unclear icons ',
                              }),
                              b.jsx('p', {
                                children:
                                  'Icons caused confusion, and users often felt lost.',
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              b.jsx(so, {}),
              b.jsxs('div', {
                id: 'restyle-design',
                children: [
                  b.jsxs('div', {
                    className: 'content-container',
                    children: [
                      b.jsx('h2', {
                        className: 'xl:max-w-[80%]',
                        children:
                          'Unfortunately, the class ended after the usability test, so I decided to go solo to solve the problems found.',
                      }),
                      b.jsxs('div', {
                        className: 'responsive-lg lg:space-x-4',
                        children: [
                          b.jsxs('div', {
                            className: 'w-[80%] lg:w-auto',
                            children: [
                              b.jsx('p', {
                                className: 'text-center pb-2',
                                children: ' Sketch ',
                              }),
                              b.jsx('img', {
                                src: '/restyle/sketch.jpg',
                                className:
                                  'responsive-image w-[80%] lg:w-auto lg:h-[30vh] 3xl:h-[20vh]',
                              }),
                            ],
                          }),
                          b.jsxs('div', {
                            className: 'w-[80%] lg:w-auto',
                            children: [
                              b.jsx('p', {
                                className: 'text-center pb-2',
                                children: ' Mid-fi ',
                              }),
                              b.jsx('img', {
                                src: '/restyle/mid-fi.jpg',
                                className:
                                  'responsive-image w-[80%] lg:w-auto lg:h-[30vh] 3xl:h-[20vh]',
                              }),
                            ],
                          }),
                          b.jsxs('div', {
                            className: 'w-[80%] lg:w-auto',
                            children: [
                              b.jsx('p', {
                                className: 'text-center pb-2',
                                children: ' High-fi ',
                              }),
                              b.jsx('img', {
                                src: '/restyle/high-fi.jpg',
                                className:
                                  'responsive-image w-[80%] lg:w-auto lg:h-[30vh] 3xl:h-[20vh]',
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  b.jsxs('div', {
                    className: 'flex flex-row pb-20 xl:pb-0',
                    children: [
                      b.jsxs('div', {
                        className:
                          'hidden xl:flex sticky top-0 pt-[35vh] ml-auto h-full w-20 flex-col items-center pb-[45vh]',
                        children: [
                          b.jsx(dm, {
                            className:
                              'w-[20px] h-[20px] rounded-full border border-borderColor my-4',
                            style: { backgroundColor: a },
                          }),
                          b.jsx(dm, {
                            className:
                              'w-[20px] h-[20px] rounded-full border border-borderColor my-4',
                            style: { backgroundColor: c },
                          }),
                          b.jsx(dm, {
                            className:
                              'w-[20px] h-[20px] rounded-full border border-borderColor my-4',
                            style: { backgroundColor: u },
                          }),
                          b.jsx(dm, {
                            className:
                              'w-[20px] h-[20px] rounded-full border border-borderColor my-4',
                            style: { backgroundColor: h },
                          }),
                        ],
                      }),
                      b.jsxs('div', {
                        ref: s,
                        className:
                          'space-y-14 xl:space-y-20 flex-1 max-w-[80%] lg:max-w-[60%] mx-auto xl:max-w-[80%] 2xl:max-w-[1400px] xl:ml-6 xl:mr-auto',
                        children: [
                          b.jsxs('section', {
                            className:
                              'xl:h-[90vh] flex flex-col xl:flex-row-reverse items-center',
                            children: [
                              b.jsx('h3', {
                                className:
                                  'pb-10 text-center xl:text-left xl:pb-0 pt-4 xl:pl-8 xl:max-w-[40%]',
                                children:
                                  'I spent time to build the information structure and groupings.',
                              }),
                              b.jsx('img', {
                                src: '/restyle/hierarchy_margin.png',
                                alt: 'Section 1',
                                className: 'w-auto max-h-[70vh] object-contain',
                              }),
                            ],
                          }),
                          b.jsxs('section', {
                            className:
                              'xl:h-[90vh] flex flex-col xl:flex-row-reverse items-center',
                            children: [
                              b.jsx('h3', {
                                className:
                                  'pb-10 text-center xl:text-left xl:pb-0 pt-4 xl:pl-8 xl:max-w-[40%]',
                                children:
                                  'An improved shopping cart to help users save and compare items.',
                              }),
                              b.jsx('img', {
                                src: '/restyle/decision_3.png',
                                alt: 'Section 2',
                                className: 'w-auto max-h-[55vh] object-contain',
                              }),
                            ],
                          }),
                          b.jsxs('section', {
                            className: 'xl:h-[90vh] flex flex-col items-center',
                            children: [
                              b.jsx('h3', {
                                className: 'text-center xl:text-left pb-4',
                                children:
                                  'A search page with personalized suggestions, high-level categories, and filters.',
                              }),
                              b.jsx('img', {
                                src: '/restyle/decision_1.png',
                                alt: 'Section 2',
                                className: 'w-auto max-h-[60vh] object-contain',
                              }),
                            ],
                          }),
                          b.jsxs('section', {
                            className:
                              'xl:pb-0 xl:h-[90vh] flex flex-col items-center',
                            children: [
                              b.jsx('h3', {
                                className: 'text-center xl:text-left pb-4',
                                children:
                                  'Clear feedback that informed users about their actions and suggested next steps.',
                              }),
                              b.jsx('img', {
                                src: '/restyle/decision_2.png',
                                alt: 'Section 2',
                                className: 'w-auto max-h-[60vh] object-contain',
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              b.jsx(so, {}),
              b.jsxs('div', {
                id: 'restyle-final',
                children: [
                  b.jsx('div', {
                    className: 'content-container xl:pb-20',
                    children: b.jsx('h2', { children: ' Final Prototype ' }),
                  }),
                  b.jsx('div', {
                    className: '',
                    children: b.jsxs('div', {
                      className: `w-full h-[auto] space-y-8 px-8 flex flex-col justify-center items-center mx-auto
            lg:space-y-0 lg:w-full lg:flex-row-reverse lg:space-x-8`,
                      children: [
                        b.jsx(Ute, {
                          url: 'https://www.figma.com/embed?embed_host=share&url=https%3A%2F%2Fwww.figma.com%2Fproto%2FNEIVKQpPgySjJMv6Cr1mqf%2FThrifting-App%3Fpage-id%3D18%253A3116%26node-id%3D36%253A3967%26viewport%3D-362%252C281%252C0.16%26scaling%3Dscale-down%26starting-point-node-id%3D36%253A3967',
                          width: '40%',
                          pt: '43',
                        }),
                        b.jsx('div', {
                          className: 'w-[70%] lg:w-[26%] lg:pr-14',
                          children: b.jsx(lU, {
                            videourl: '/restyle/prototype.mov',
                            pt: '199',
                          }),
                        }),
                      ],
                    }),
                  }),
                  b.jsx('div', {
                    className: 'content-container',
                    children: b.jsxs('div', {
                      className: 'responsive-lg lg:items-start',
                      children: [
                        b.jsx('h2', { children: 'Takeaways' }),
                        b.jsx('div', {
                          className: 'space-y-6 w-[80%] xl:w-[70%]',
                          children: b.jsx('p', {
                            children:
                              'While the project ended, the possibilities for ReStyle remain exciting. Exploring the points system from a business perspective could unlock new opportunities, and emerging technologies like VR try-ons or AI-driven personalized suggestions could take the user experience to the next level.',
                          }),
                        }),
                      ],
                    }),
                  }),
                ],
              }),
            ],
          }),
          b.jsx('div', {
            className: 'xl:ml-[7%]',
            children: b.jsx(nT, { theme: 'restyle', goBackHome: 'true' }),
          }),
        ],
      }),
    ],
  })
}
function ju({ geometry: n, materialProps: e, position: t, r: i }) {
  const r = X.useRef()
  return (
    Vg((s) => {
      r.current &&
        ((r.current.rotation.x =
          r.current.rotation.y =
          r.current.rotation.z +=
            0.004 * i),
        (r.current.position.y =
          t[1] +
          Math[i > 0.5 ? 'cos' : 'sin'](s.clock.getElapsedTime() * i) * i))
    }),
    b.jsxs('mesh', {
      ref: r,
      position: t,
      children: [n, b.jsx('meshStandardMaterial', { ...e })],
    })
  )
}
function zte() {
  const { camera: n, viewport: e } = yh(),
    t = new re(),
    i = { x: 1, y: 1 }
  return Vg((r) => {
    const { pointer: s } = r
    let o = s.x * (e.width / 2),
      a = s.y * (e.height / 2)
    ;(o = Math.max(-i.x / 2, Math.min(i.x / 3, o / 3))),
      (a = Math.max(-i.y / 2, Math.min(i.y / 3, a / 3))),
      n.position.lerp(t.set(o, a, n.position.z), 0.01)
  })
}
function Vte() {
  return b.jsxs(HE, {
    style: { height: '100vh', width: '100%' },
    camera: { position: [0, 0, 17], fov: 30 },
    children: [
      b.jsx('ambientLight', { intensity: 4 }),
      b.jsx('directionalLight', {
        castShadow: !0,
        position: [2.5, 12, 12],
        intensity: 4,
      }),
      window.innerWidth >= 1280 && b.jsx(zte, {}),
      b.jsx(ju, {
        geometry: b.jsx('icosahedronGeometry', { args: [1.2, 0] }),
        materialProps: { color: '#34A853' },
        position: [-6.5, -2.8, 0],
        r: 0.3,
      }),
      b.jsx(ju, {
        geometry: b.jsx('sphereGeometry', { args: [2, 32, 32] }),
        materialProps: { color: '#EA4335' },
        position: [-6.5, 3, -4],
        r: 0.2,
      }),
      b.jsx(ju, {
        geometry: b.jsx('coneGeometry', { args: [0.8, 1.3, 32] }),
        materialProps: { color: '#EA4335' },
        position: [-2, -3, 0],
        r: 0.1,
      }),
      b.jsx(ju, {
        geometry: b.jsx('sphereGeometry', { args: [1.2, 32, 32] }),
        materialProps: { color: '#34A853' },
        position: [5.5, 3.5, 0],
        r: 0.4,
      }),
      b.jsx(ju, {
        geometry: b.jsx('boxGeometry', { args: [1, 1.3, 1] }),
        materialProps: { color: '#FBBC05' },
        position: [-4.3, 0.5, 3],
        r: 0.2,
      }),
      b.jsx(ju, {
        geometry: b.jsx('icosahedronGeometry', { args: [1.2, 0] }),
        materialProps: { color: '#FBBC05' },
        position: [3, 3, -6],
        r: 0.3,
      }),
      b.jsx(ju, {
        geometry: b.jsx('boxGeometry', { args: [2, 3, 1] }),
        materialProps: { color: '#4285F4' },
        position: [5, -1, 3],
        r: 0.2,
      }),
    ],
  })
}
const jte = ({ imageSrc: n }) => {
  const [e, t] = X.useState({ x: 0, y: 0 })
  return (
    X.useEffect(() => {
      const i = (s) => {
          t({ x: s.clientX, y: s.clientY })
        },
        r = () => {
          t((s) => ({ x: s.x, y: s.y }))
        }
      return (
        window.addEventListener('mousemove', i),
        window.addEventListener('scroll', r),
        () => {
          window.removeEventListener('mousemove', i),
            window.removeEventListener('scroll', r)
        }
      )
    }, []),
    b.jsx('div', {
      style: { position: 'fixed', top: e.y, left: e.x, pointerEvents: 'none' },
      className: 'z-50 w-[80px] h-[80px] hidden xl:block',
      children: b.jsx('img', {
        src: n,
        alt: 'Cursor Follower',
        className: 'w-full h-full object-contain mt-2',
      }),
    })
  )
}
function Hte() {
  const n = '/restyle',
    [e, t] = X.useState(!1)
  kT()
  const i = X.useRef(null),
    { scrollYProgress: r } = tT({ target: i, offset: ['0.7 1', '1 1'] }),
    s = ih(r, [0, 1], [0, 1])
  return b.jsxs('div', {
    'data-theme': 'google',
    children: [
      b.jsx(jte, { imageSrc: '/google/android.png' }),
      b.jsx('div', {
        className: 'block xl:hidden',
        children: b.jsx(Ic, { theme: 'enso', color: 'text-titleColor' }),
      }),
      b.jsx('div', {
        className: `hidden xl:block transition-all duration-300 ease-out delay-100
          ${e ? 'opacity-0' : 'opacity-100'} `,
        children: b.jsx(Ic, { theme: 'google', color: 'text-[#FF9100]' }),
      }),
      b.jsx(Fs, {
        to: n,
        className:
          'hidden xl:block absolute top-4 right-4 xl:top-[3%] xl:right-[2.65%] text-black hover:underline z-10',
        children: b.jsx('p', {
          className: '',
          children: ' Next Project: Restyle ',
        }),
      }),
      b.jsxs('div', {
        className: 'w-screen h-screen relative',
        children: [
          b.jsx(Vte, {}),
          b.jsxs('div', {
            className: `absolute z-10 top-[5%] left-0 m-4 mt-20 md:m-0 md:mt-0 md:w-[90%] md:top-[50%] md:left-[50%] md:transform md:-translate-x-1/2 md:-translate-y-1/2 
        xl:max-w-[800px] space-y-4 p-20 bg-white/40 rounded-2xl shadow-lg backdrop-blur-sm`,
            children: [
              b.jsxs('div', {
                className: 'space-y-4',
                children: [
                  b.jsxs('div', {
                    className: 'flex space-x-2 text-gray-400',
                    children: [
                      b.jsx('img', {
                        src: '/google/google.png',
                        className: 'h-[30px] object-contain',
                      }),
                      b.jsx('svg', {
                        xmlns: 'http://www.w3.org/2000/svg',
                        fill: 'none',
                        viewBox: '0 0 24 24',
                        strokeWidth: 1.5,
                        stroke: 'currentColor',
                        className: 'size-6 hidden lg:inline-block',
                        children: b.jsx('path', {
                          strokeLinecap: 'round',
                          strokeLinejoin: 'round',
                          d: 'M6 18 18 6M6 6l12 12',
                        }),
                      }),
                      b.jsx('img', {
                        src: '/google/firebase.svg',
                        className: 'h-[30px] object-contain hidden lg:block',
                      }),
                    ],
                  }),
                  b.jsx('h2', {
                    className: 'text-left mb-2 text-black',
                    children: 'UX Design Intern - Summer 2024',
                  }),
                ],
              }),
              b.jsx(so, {}),
              b.jsx('p', {
                children:
                  'I delivered high-quality results across three diverse projects within a 12-week timeframe, all approved by leadership.',
              }),
              b.jsx('p', {
                className: 'landscape:hidden lg:landscape:inline-block',
                children:
                  'I collaborated with designers, engineers, and PMs to ensure that designs were business-oriented, technically feasible, and aligned with the broader roadmap.',
              }),
              b.jsx('p', {
                children:
                  'Due to confidentiality, I cannot share the details of the projects, but I will give you an overview.',
              }),
            ],
          }),
        ],
      }),
      b.jsxs('div', {
        className:
          'pb-20 pt-0 xl:pt-0 xl:pb-40 content-container space-y-4 lg:space-y-8 xl:space-y-14',
        children: [
          b.jsx('div', {
            className: 'space-y-6 max-w-[90%] pb-10 md:pb-0',
            children: b.jsx('h2', {
              className: '',
              children:
                'I was lucky to receive a lot of support from my team. Here are some comments from those I worked with.',
            }),
          }),
          b.jsxs('div', {
            className:
              'relative bg-[#F8F8F8] py-16 px-6 xl:px-20 xl:py-20 xl:max-w-[1080px] rounded-lg shadow-sm hover:shadow-lg easeAnimateStyle',
            children: [
              b.jsx('span', {
                className: 'absolute top-4 left-4 text-6xl text-gray-400',
                children: b.jsx('img', { src: '/google/left_quote.svg' }),
              }),
              b.jsx('div', {
                className: 'text-center pb-4',
                children: b.jsxs('h2', {
                  className: 'text-xl font-bold',
                  children: [
                    ' ',
                    'Przemek Abratowski, Staff UX Designer @ Google',
                    ' ',
                  ],
                }),
              }),
              b.jsx('p', {
                className: 'text-center xl:text-left text-gray-700',
                children:
                  "Ember immediately proved herself to be a valuable asset to our team. Her design skills are excellent, and she's always open to feedback. She also possesses exceptional problem-solving skills and a strong focus on addressing user pain points. These qualities, along with her ability to manage ambiguity, enabled her to successfully own complex projects.",
              }),
              b.jsx('span', {
                className: 'absolute bottom-4 right-4 text-6xl text-gray-400',
                children: b.jsx('img', { src: '/google/right_quote.svg' }),
              }),
            ],
          }),
          b.jsxs('div', {
            className:
              'relative bg-[#F8F8F8] py-16 px-6 xl:px-20 xl:py-20 xl:max-w-[1080px] rounded-lg shadow-sm hover:shadow-lg easeAnimateStyle',
            children: [
              b.jsx('span', {
                className: 'absolute top-4 left-4 text-6xl text-gray-400',
                children: b.jsx('img', { src: '/google/left_quote.svg' }),
              }),
              b.jsx('div', {
                className: 'text-center pb-4',
                children: b.jsxs('h2', {
                  className: 'text-xl font-bold',
                  children: [
                    ' ',
                    'Roman Nurik, Staff UX Designer @ Google',
                    ' ',
                  ],
                }),
              }),
              b.jsxs('div', {
                className: 'text-center xl:text-left text-gray-700 space-y-4',
                children: [
                  b.jsx('p', {
                    children:
                      'Ember has a remarkable ability to quickly ramp up on a highly technical space. She successfully built an understanding and empathy for a userbase and problem space she was otherwise not super familiar with. She utilized a balanced, pragmatic, and effective discovery and research process, resisting the urge to jump directly into solutions. For example, she conducted quick and effective desk research, identifying high-value public developer communities to quickly grok, rather than embarking on a more extensive research initiative.',
                  }),
                  b.jsx('p', {
                    children:
                      'Ember also excelled at exploring the solution space. Perhaps even more importantly, she effectively identified key stakeholders and communicated her design ideas to them, actively seeking and iterating on feedback, and embodying a collaborative work ethic along the way.',
                  }),
                  b.jsx('p', {
                    className: 'hidden xl:inline-block',
                    children:
                      "Ember's communication skills, ownership and accountability for her work, and balanced design process are particularly noteworthy. These qualities are exemplary of someone who will someday soon be a strong design leader. I have no hesitation in recommending Ember for a UX design position. She is a talented and dedicated designer who will be a valuable asset to any team.",
                  }),
                ],
              }),
              b.jsx('span', {
                className: 'absolute bottom-4 right-4 text-6xl text-gray-400',
                children: b.jsx('img', { src: '/google/right_quote.svg' }),
              }),
            ],
          }),
        ],
      }),
      b.jsxs('div', {
        className:
          'content-container pt-0 lg:pt-10 xl:pt-10 landscape:pt-40 lg:landscape:pt-10',
        children: [
          b.jsxs('div', {
            className: 'space-y-2 xl:space-y-6',
            children: [
              b.jsx('h2', {
                className: '',
                children:
                  'Project 1: Revamping the Onboarding Flow for a new Developer Tool',
              }),
              b.jsx('div', {
                className: 'w-[40%] border-t border-borderColor mx-auto',
              }),
              b.jsx('p', {
                className: 'text-center lg:text-lg',
                children:
                  'I took ownership by conducting deep dives into user pain points through past research and user reviews.',
              }),
            ],
          }),
          b.jsx('div', {
            className: 'pt-10 pb-20 hidden lg:block',
            children: b.jsx('img', {
              src: '/google/process.png',
              alt: 'process diagram',
            }),
          }),
          b.jsxs('div', {
            className:
              'responsive-lg h-auto lg:h-[40vh] lg:space-x-4 lg:max-w-[1080px] 3xl:h-[20vh]',
            children: [
              b.jsxs('div', {
                className:
                  'flex flex-col lg:flex-col-reverse max-w-[70%] mx-auto lg:max-w-[60%] lg:h-[40vh] 3xl:h-[20vh] relative',
                children: [
                  b.jsx('p', {
                    className: `text-gray-700 italic text-sm text-center lg:pb-0 lg:pt-2 
            lg:absolute lg:bottom-[-2rem] lg:left-[50%] lg:transform lg:-translate-x-1/2 w-full`,
                    children: 'Product image hidden for confidentiality',
                  }),
                  b.jsx('img', {
                    src: '/google/p1.png',
                    alt: 'project 1',
                    className: 'lg:h-[40vh] 3xl:h-[20vh] w-auto',
                  }),
                ],
              }),
              b.jsxs('div', {
                className:
                  'space-y-6 lg:space-y-0 flex flex-col justify-between h-full flex-1 px-8',
                children: [
                  b.jsx('p', {
                    className: '',
                    children:
                      'Communicated with cross-functional teams to ensure alignment across stakeholders and clarity in the project vision.',
                  }),
                  b.jsxs('div', {
                    className: 'space-y-6',
                    children: [
                      b.jsx('h3', {
                        className: 'border-t pt-3 text-left border-borderColor',
                        children: 'A design system',
                      }),
                      b.jsx('h3', {
                        className: 'border-t pt-3 text-left border-borderColor',
                        children: 'An interactive hi-fi prototype',
                      }),
                      b.jsx('h3', {
                        className: 'border-t pt-3 text-left border-borderColor',
                        children:
                          'Hassle-free, easy-to-troubleshoot, and forgiving',
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
      b.jsxs('div', {
        className: `w-[80%] mx-auto flex flex-col xl:flex-row xl:my-10 bg-[#292929] 
      rounded-[20px] xl:rounded-[55px] p-6 mb-28
      xl:p-10 xl:space-x-10 xl:mb-0 3xl:max-w-[1440px]`,
        children: [
          b.jsx('img', {
            src: '/google/visual.jpg',
            className:
              'h-[30vh] mb-10 xl:mb-0 xl:w-[40%] rounded-[16px] xl:rounded-[40px] xl:h-[60vh] 3xl:h-[25vh]',
          }),
          b.jsxs('div', {
            className: 'space-y-6 my-auto p-2 pb-4 xl:pb-0 xl:p-0',
            children: [
              b.jsx('h2', {
                className: 'text-white xl:text-left',
                children: 'Project 2: Webpage Redesign for Brand Alignment',
              }),
              b.jsx('div', { className: 'w-full border-t border-[#7F7F7F]' }),
              b.jsx('p', {
                className: 'text-center xl:text-left lg:text-lg text-white',
                children:
                  'Tasked with a complete visual overhaul, I redesigned four web pages to ensure consistency and clarity, aligning them with updated branding guidelines while preserving usability.',
              }),
            ],
          }),
        ],
      }),
      b.jsxs('div', {
        className:
          'hidden xl:block h-[180vh] w-[85%] xl:max-w-[1200px] mx-auto relative py-10 xl:pb-20',
        ref: i,
        children: [
          b.jsx('svg', {
            xmlns: 'http://www.w3.org/2000/svg',
            fill: 'none',
            viewBox: '0 0 24 24',
            strokeWidth: 1,
            stroke: '#BBBBBB',
            className:
              'size-14 absolute top-[10vh] left-1/2 transform -translate-x-1/2',
            children: b.jsx('path', {
              strokeLinecap: 'round',
              strokeLinejoin: 'round',
              d: 'm4.5 5.25 7.5 7.5 7.5-7.5m-15 6 7.5 7.5 7.5-7.5',
            }),
          }),
          b.jsxs('div', {
            className:
              'flex flex-col items-center justify-center sticky top-10 h-[60vh]',
            children: [
              b.jsxs('div', {
                className:
                  'absolute top-[25vh] space-y-6 h-auto xl:max-w-[90%]',
                children: [
                  b.jsxs('h2', {
                    className: '',
                    children: [
                      ' ',
                      'Project 3: Minimizing Context Switching in User Workflows',
                      ' ',
                    ],
                  }),
                  b.jsx('div', {
                    className: 'w-[40%] border-t border-borderColor mx-auto',
                  }),
                  b.jsxs('p', {
                    className: 'text-center max-w-[1080px]',
                    children: [
                      ' ',
                      'In this project, I worked to identify current user pain points and designed wireframes to address them. My proposal introduced changes to reduce context switching. Design discussions with designers and PMs led to near-term and long-term solutions.',
                      ' ',
                    ],
                  }),
                ],
              }),
              b.jsx(Ix, {
                src: '/google/1.png',
                alt: 'First Image',
                className:
                  'absolute top-[50vh] responsive-image object-contain',
              }),
              b.jsx(Ix, {
                src: '/google/2.png',
                alt: 'Second Image',
                className:
                  'absolute top-[50vh] responsive-image object-contain',
                style: { opacity: s },
              }),
              b.jsx('svg', {
                xmlns: 'http://www.w3.org/2000/svg',
                fill: 'none',
                viewBox: '0 0 24 24',
                strokeWidth: 1,
                stroke: '#BBBBBB',
                className:
                  'size-14 absolute top-[80vh] left-1/2 transform -translate-x-1/2',
                children: b.jsx('path', {
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  d: 'm4.5 5.25 7.5 7.5 7.5-7.5m-15 6 7.5 7.5 7.5-7.5',
                }),
              }),
            ],
          }),
        ],
      }),
      b.jsxs('div', {
        className:
          'flex xl:hidden relative w-[90%] mx-auto flex-col lg:flex-row-reverse items-center justify-center space-y-10',
        children: [
          b.jsxs('div', {
            className: 'space-y-6 lg:ml-20',
            children: [
              b.jsxs('h2', {
                className: '',
                children: [
                  ' ',
                  'Project 3: Minimizing Context Switching in User Workflows',
                  ' ',
                ],
              }),
              b.jsx('div', {
                className: 'w-[40%] border-t border-borderColor mx-auto',
              }),
              b.jsxs('p', {
                className: 'text-center max-w-[1080px]',
                children: [
                  ' ',
                  'In this project, I worked to identify current user pain points and designed wireframes to address them. My proposal introduced changes to reduce context switching, which had been a significant friction point in the user experience. Design discussions with designers and PMs led to near-term and long-term solutions.',
                  ' ',
                ],
              }),
            ],
          }),
          b.jsx('img', {
            src: '/google/mobile-workflow.jpg',
            alt: 'Margin Image',
            className: 'responsive-image object-contain lg:max-w-[20vw]',
          }),
        ],
      }),
      b.jsx('div', {
        children: b.jsx(Ote, {
          link: n,
          bgSrc: '/enso/next-bg.jpg',
          imgSrc: '/enso/restyle-next.png',
          title: 'Restyle - a solution for clothing dump',
          date: 'School Project, May 2023 - May 2024',
          theme: 'restyle',
        }),
      }),
    ],
  })
}
function Gte() {
  return b.jsxs(r5, {
    children: [
      b.jsx(p5, {}),
      b.jsxs(D4, {
        children: [
          b.jsx(Hf, { path: '/', element: b.jsx(mte, {}) }),
          b.jsx(Hf, { path: '/google', element: b.jsx(Hte, {}) }),
          b.jsx(Hf, { path: '/resume', element: b.jsx(gte, {}) }),
          b.jsx(Hf, { path: '/enso', element: b.jsx(Fte, {}) }),
          b.jsx(Hf, { path: '/restyle', element: b.jsx(Bte, {}) }),
        ],
      }),
    ],
  })
}
var ES = {},
  bS = {},
  TS = {},
  xI
function Wte() {
  return (
    xI ||
      ((xI = 1),
      (function (n) {
        Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.default = void 0)
        var e = function () {
            for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
              s[o] = arguments[o]
            if (typeof window < 'u') {
              var a
              typeof window.gtag > 'u' &&
                ((window.dataLayer = window.dataLayer || []),
                (window.gtag = function () {
                  window.dataLayer.push(arguments)
                })),
                (a = window).gtag.apply(a, s)
            }
          },
          t = e
        n.default = t
      })(TS)),
    TS
  )
}
var AS = {},
  _I
function $te() {
  return (
    _I ||
      ((_I = 1),
      (function (n) {
        Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = o)
        var e =
          /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|vs?\.?|via)$/i
        function t(a) {
          return a
            .toString()
            .trim()
            .replace(/[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g, function (c, u, h) {
              return u > 0 &&
                u + c.length !== h.length &&
                c.search(e) > -1 &&
                h.charAt(u - 2) !== ':' &&
                (h.charAt(u + c.length) !== '-' || h.charAt(u - 1) === '-') &&
                h.charAt(u - 1).search(/[^\s-]/) < 0
                ? c.toLowerCase()
                : c.substr(1).search(/[A-Z]|\../) > -1
                ? c
                : c.charAt(0).toUpperCase() + c.substr(1)
            })
        }
        function i(a) {
          return typeof a == 'string' && a.indexOf('@') !== -1
        }
        var r = 'REDACTED (Potential Email Address)'
        function s(a) {
          return i(a)
            ? (console.warn('This arg looks like an email address, redacting.'),
              r)
            : a
        }
        function o() {
          var a =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : '',
            c =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : !0,
            u =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : !0,
            h = a || ''
          return c && (h = t(a)), u && (h = s(h)), h
        }
      })(AS)),
    AS
  )
}
var wI
function Xte() {
  return (
    wI ||
      ((wI = 1),
      (function (n) {
        Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.default = n.GA4 = void 0)
        var e = o(Wte()),
          t = o($te()),
          i = [
            'eventCategory',
            'eventAction',
            'eventLabel',
            'eventValue',
            'hitType',
          ],
          r = ['title', 'location'],
          s = ['page', 'hitType']
        function o(j) {
          return j && j.__esModule ? j : { default: j }
        }
        function a(j, K) {
          if (j == null) return {}
          var J = c(j, K),
            ne,
            V
          if (Object.getOwnPropertySymbols) {
            var Y = Object.getOwnPropertySymbols(j)
            for (V = 0; V < Y.length; V++)
              (ne = Y[V]),
                !(K.indexOf(ne) >= 0) &&
                  Object.prototype.propertyIsEnumerable.call(j, ne) &&
                  (J[ne] = j[ne])
          }
          return J
        }
        function c(j, K) {
          if (j == null) return {}
          var J = {},
            ne = Object.keys(j),
            V,
            Y
          for (Y = 0; Y < ne.length; Y++)
            (V = ne[Y]), !(K.indexOf(V) >= 0) && (J[V] = j[V])
          return J
        }
        function u(j) {
          '@babel/helpers - typeof'
          return (
            (u =
              typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (K) {
                    return typeof K
                  }
                : function (K) {
                    return K &&
                      typeof Symbol == 'function' &&
                      K.constructor === Symbol &&
                      K !== Symbol.prototype
                      ? 'symbol'
                      : typeof K
                  }),
            u(j)
          )
        }
        function h(j) {
          return y(j) || g(j) || T(j) || m()
        }
        function m() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        function g(j) {
          if (
            (typeof Symbol < 'u' && j[Symbol.iterator] != null) ||
            j['@@iterator'] != null
          )
            return Array.from(j)
        }
        function y(j) {
          if (Array.isArray(j)) return A(j)
        }
        function _(j, K) {
          var J = Object.keys(j)
          if (Object.getOwnPropertySymbols) {
            var ne = Object.getOwnPropertySymbols(j)
            K &&
              (ne = ne.filter(function (V) {
                return Object.getOwnPropertyDescriptor(j, V).enumerable
              })),
              J.push.apply(J, ne)
          }
          return J
        }
        function M(j) {
          for (var K = 1; K < arguments.length; K++) {
            var J = arguments[K] != null ? arguments[K] : {}
            K % 2
              ? _(Object(J), !0).forEach(function (ne) {
                  N(j, ne, J[ne])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(j, Object.getOwnPropertyDescriptors(J))
              : _(Object(J)).forEach(function (ne) {
                  Object.defineProperty(
                    j,
                    ne,
                    Object.getOwnPropertyDescriptor(J, ne),
                  )
                })
          }
          return j
        }
        function w(j, K) {
          return D(j) || P(j, K) || T(j, K) || x()
        }
        function x() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        function T(j, K) {
          if (j) {
            if (typeof j == 'string') return A(j, K)
            var J = Object.prototype.toString.call(j).slice(8, -1)
            if (
              (J === 'Object' && j.constructor && (J = j.constructor.name),
              J === 'Map' || J === 'Set')
            )
              return Array.from(j)
            if (
              J === 'Arguments' ||
              /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(J)
            )
              return A(j, K)
          }
        }
        function A(j, K) {
          ;(K == null || K > j.length) && (K = j.length)
          for (var J = 0, ne = new Array(K); J < K; J++) ne[J] = j[J]
          return ne
        }
        function P(j, K) {
          var J =
            j == null
              ? null
              : (typeof Symbol < 'u' && j[Symbol.iterator]) || j['@@iterator']
          if (J != null) {
            var ne,
              V,
              Y,
              Q,
              q = [],
              oe = !0,
              _e = !1
            try {
              if (((Y = (J = J.call(j)).next), K !== 0))
                for (
                  ;
                  !(oe = (ne = Y.call(J)).done) &&
                  (q.push(ne.value), q.length !== K);
                  oe = !0
                );
            } catch (he) {
              ;(_e = !0), (V = he)
            } finally {
              try {
                if (
                  !oe &&
                  J.return != null &&
                  ((Q = J.return()), Object(Q) !== Q)
                )
                  return
              } finally {
                if (_e) throw V
              }
            }
            return q
          }
        }
        function D(j) {
          if (Array.isArray(j)) return j
        }
        function O(j, K) {
          if (!(j instanceof K))
            throw new TypeError('Cannot call a class as a function')
        }
        function U(j, K) {
          for (var J = 0; J < K.length; J++) {
            var ne = K[J]
            ;(ne.enumerable = ne.enumerable || !1),
              (ne.configurable = !0),
              'value' in ne && (ne.writable = !0),
              Object.defineProperty(j, k(ne.key), ne)
          }
        }
        function F(j, K, J) {
          return (
            U(j.prototype, K),
            Object.defineProperty(j, 'prototype', { writable: !1 }),
            j
          )
        }
        function N(j, K, J) {
          return (
            (K = k(K)),
            K in j
              ? Object.defineProperty(j, K, {
                  value: J,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (j[K] = J),
            j
          )
        }
        function k(j) {
          var K = z(j, 'string')
          return u(K) === 'symbol' ? K : String(K)
        }
        function z(j, K) {
          if (u(j) !== 'object' || j === null) return j
          var J = j[Symbol.toPrimitive]
          if (J !== void 0) {
            var ne = J.call(j, K || 'default')
            if (u(ne) !== 'object') return ne
            throw new TypeError('@@toPrimitive must return a primitive value.')
          }
          return (K === 'string' ? String : Number)(j)
        }
        var $ = (function () {
          function j() {
            var K = this
            O(this, j),
              N(this, 'reset', function () {
                ;(K.isInitialized = !1),
                  (K._testMode = !1),
                  K._currentMeasurementId,
                  (K._hasLoadedGA = !1),
                  (K._isQueuing = !1),
                  (K._queueGtag = [])
              }),
              N(this, '_gtag', function () {
                for (
                  var J = arguments.length, ne = new Array(J), V = 0;
                  V < J;
                  V++
                )
                  ne[V] = arguments[V]
                K._testMode || K._isQueuing
                  ? K._queueGtag.push(ne)
                  : e.default.apply(void 0, ne)
              }),
              N(this, '_loadGA', function (J, ne) {
                var V =
                  arguments.length > 2 && arguments[2] !== void 0
                    ? arguments[2]
                    : 'https://www.googletagmanager.com/gtag/js'
                if (
                  !(typeof window > 'u' || typeof document > 'u') &&
                  !K._hasLoadedGA
                ) {
                  var Y = document.createElement('script')
                  ;(Y.async = !0),
                    (Y.src = ''.concat(V, '?id=').concat(J)),
                    ne && Y.setAttribute('nonce', ne),
                    document.body.appendChild(Y),
                    (window.dataLayer = window.dataLayer || []),
                    (window.gtag = function () {
                      window.dataLayer.push(arguments)
                    }),
                    (K._hasLoadedGA = !0)
                }
              }),
              N(this, '_toGtagOptions', function (J) {
                if (J) {
                  var ne = {
                      cookieUpdate: 'cookie_update',
                      cookieExpires: 'cookie_expires',
                      cookieDomain: 'cookie_domain',
                      cookieFlags: 'cookie_flags',
                      userId: 'user_id',
                      clientId: 'client_id',
                      anonymizeIp: 'anonymize_ip',
                      contentGroup1: 'content_group1',
                      contentGroup2: 'content_group2',
                      contentGroup3: 'content_group3',
                      contentGroup4: 'content_group4',
                      contentGroup5: 'content_group5',
                      allowAdFeatures: 'allow_google_signals',
                      allowAdPersonalizationSignals:
                        'allow_ad_personalization_signals',
                      nonInteraction: 'non_interaction',
                      page: 'page_path',
                      hitCallback: 'event_callback',
                    },
                    V = Object.entries(J).reduce(function (Y, Q) {
                      var q = w(Q, 2),
                        oe = q[0],
                        _e = q[1]
                      return ne[oe] ? (Y[ne[oe]] = _e) : (Y[oe] = _e), Y
                    }, {})
                  return V
                }
              }),
              N(this, 'initialize', function (J) {
                var ne =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {}
                if (!J) throw new Error('Require GA_MEASUREMENT_ID')
                var V = typeof J == 'string' ? [{ trackingId: J }] : J
                K._currentMeasurementId = V[0].trackingId
                var Y = ne.gaOptions,
                  Q = ne.gtagOptions,
                  q = ne.nonce,
                  oe = ne.testMode,
                  _e = oe === void 0 ? !1 : oe,
                  he = ne.gtagUrl
                if (
                  ((K._testMode = _e),
                  _e || K._loadGA(K._currentMeasurementId, q, he),
                  K.isInitialized ||
                    (K._gtag('js', new Date()),
                    V.forEach(function (Pe) {
                      var Be = M(
                        M(
                          M({}, K._toGtagOptions(M(M({}, Y), Pe.gaOptions))),
                          Q,
                        ),
                        Pe.gtagOptions,
                      )
                      Object.keys(Be).length
                        ? K._gtag('config', Pe.trackingId, Be)
                        : K._gtag('config', Pe.trackingId)
                    })),
                  (K.isInitialized = !0),
                  !_e)
                ) {
                  var Ce = h(K._queueGtag)
                  for (K._queueGtag = [], K._isQueuing = !1; Ce.length; ) {
                    var Te = Ce.shift()
                    K._gtag.apply(K, h(Te)),
                      Te[0] === 'get' && (K._isQueuing = !0)
                  }
                }
              }),
              N(this, 'set', function (J) {
                if (!J) {
                  console.warn('`fieldsObject` is required in .set()')
                  return
                }
                if (u(J) !== 'object') {
                  console.warn('Expected `fieldsObject` arg to be an Object')
                  return
                }
                Object.keys(J).length === 0 &&
                  console.warn('empty `fieldsObject` given to .set()'),
                  K._gaCommand('set', J)
              }),
              N(this, '_gaCommandSendEvent', function (J, ne, V, Y, Q) {
                K._gtag(
                  'event',
                  ne,
                  M(
                    M(
                      { event_category: J, event_label: V, value: Y },
                      Q && { non_interaction: Q.nonInteraction },
                    ),
                    K._toGtagOptions(Q),
                  ),
                )
              }),
              N(this, '_gaCommandSendEventParameters', function () {
                for (
                  var J = arguments.length, ne = new Array(J), V = 0;
                  V < J;
                  V++
                )
                  ne[V] = arguments[V]
                if (typeof ne[0] == 'string')
                  K._gaCommandSendEvent.apply(K, h(ne.slice(1)))
                else {
                  var Y = ne[0],
                    Q = Y.eventCategory,
                    q = Y.eventAction,
                    oe = Y.eventLabel,
                    _e = Y.eventValue
                  Y.hitType
                  var he = a(Y, i)
                  K._gaCommandSendEvent(Q, q, oe, _e, he)
                }
              }),
              N(this, '_gaCommandSendTiming', function (J, ne, V, Y) {
                K._gtag('event', 'timing_complete', {
                  name: ne,
                  value: V,
                  event_category: J,
                  event_label: Y,
                })
              }),
              N(this, '_gaCommandSendPageview', function (J, ne) {
                if (ne && Object.keys(ne).length) {
                  var V = K._toGtagOptions(ne),
                    Y = V.title,
                    Q = V.location,
                    q = a(V, r)
                  K._gtag(
                    'event',
                    'page_view',
                    M(
                      M(
                        M(M({}, J && { page_path: J }), Y && { page_title: Y }),
                        Q && { page_location: Q },
                      ),
                      q,
                    ),
                  )
                } else J ? K._gtag('event', 'page_view', { page_path: J }) : K._gtag('event', 'page_view')
              }),
              N(this, '_gaCommandSendPageviewParameters', function () {
                for (
                  var J = arguments.length, ne = new Array(J), V = 0;
                  V < J;
                  V++
                )
                  ne[V] = arguments[V]
                if (typeof ne[0] == 'string')
                  K._gaCommandSendPageview.apply(K, h(ne.slice(1)))
                else {
                  var Y = ne[0],
                    Q = Y.page
                  Y.hitType
                  var q = a(Y, s)
                  K._gaCommandSendPageview(Q, q)
                }
              }),
              N(this, '_gaCommandSend', function () {
                for (
                  var J = arguments.length, ne = new Array(J), V = 0;
                  V < J;
                  V++
                )
                  ne[V] = arguments[V]
                var Y = typeof ne[0] == 'string' ? ne[0] : ne[0].hitType
                switch (Y) {
                  case 'event':
                    K._gaCommandSendEventParameters.apply(K, ne)
                    break
                  case 'pageview':
                    K._gaCommandSendPageviewParameters.apply(K, ne)
                    break
                  case 'timing':
                    K._gaCommandSendTiming.apply(K, h(ne.slice(1)))
                    break
                  case 'screenview':
                  case 'transaction':
                  case 'item':
                  case 'social':
                  case 'exception':
                    console.warn('Unsupported send command: '.concat(Y))
                    break
                  default:
                    console.warn("Send command doesn't exist: ".concat(Y))
                }
              }),
              N(this, '_gaCommandSet', function () {
                for (
                  var J = arguments.length, ne = new Array(J), V = 0;
                  V < J;
                  V++
                )
                  ne[V] = arguments[V]
                typeof ne[0] == 'string' && (ne[0] = N({}, ne[0], ne[1])),
                  K._gtag('set', K._toGtagOptions(ne[0]))
              }),
              N(this, '_gaCommand', function (J) {
                for (
                  var ne = arguments.length,
                    V = new Array(ne > 1 ? ne - 1 : 0),
                    Y = 1;
                  Y < ne;
                  Y++
                )
                  V[Y - 1] = arguments[Y]
                switch (J) {
                  case 'send':
                    K._gaCommandSend.apply(K, V)
                    break
                  case 'set':
                    K._gaCommandSet.apply(K, V)
                    break
                  default:
                    console.warn("Command doesn't exist: ".concat(J))
                }
              }),
              N(this, 'ga', function () {
                for (
                  var J = arguments.length, ne = new Array(J), V = 0;
                  V < J;
                  V++
                )
                  ne[V] = arguments[V]
                if (typeof ne[0] == 'string') K._gaCommand.apply(K, ne)
                else {
                  var Y = ne[0]
                  K._gtag(
                    'get',
                    K._currentMeasurementId,
                    'client_id',
                    function (Q) {
                      K._isQueuing = !1
                      var q = K._queueGtag
                      for (
                        Y({
                          get: function (he) {
                            return he === 'clientId'
                              ? Q
                              : he === 'trackingId'
                              ? K._currentMeasurementId
                              : he === 'apiVersion'
                              ? '1'
                              : void 0
                          },
                        });
                        q.length;

                      ) {
                        var oe = q.shift()
                        K._gtag.apply(K, h(oe))
                      }
                    },
                  ),
                    (K._isQueuing = !0)
                }
                return K.ga
              }),
              N(this, 'event', function (J, ne) {
                if (typeof J == 'string')
                  K._gtag('event', J, K._toGtagOptions(ne))
                else {
                  var V = J.action,
                    Y = J.category,
                    Q = J.label,
                    q = J.value,
                    oe = J.nonInteraction,
                    _e = J.transport
                  if (!Y || !V) {
                    console.warn(
                      'args.category AND args.action are required in event()',
                    )
                    return
                  }
                  var he = {
                    hitType: 'event',
                    eventCategory: (0, t.default)(Y),
                    eventAction: (0, t.default)(V),
                  }
                  Q && (he.eventLabel = (0, t.default)(Q)),
                    typeof q < 'u' &&
                      (typeof q != 'number'
                        ? console.warn(
                            'Expected `args.value` arg to be a Number.',
                          )
                        : (he.eventValue = q)),
                    typeof oe < 'u' &&
                      (typeof oe != 'boolean'
                        ? console.warn(
                            '`args.nonInteraction` must be a boolean.',
                          )
                        : (he.nonInteraction = oe)),
                    typeof _e < 'u' &&
                      (typeof _e != 'string'
                        ? console.warn('`args.transport` must be a string.')
                        : (['beacon', 'xhr', 'image'].indexOf(_e) === -1 &&
                            console.warn(
                              '`args.transport` must be either one of these values: `beacon`, `xhr` or `image`',
                            ),
                          (he.transport = _e))),
                    K._gaCommand('send', he)
                }
              }),
              N(this, 'send', function (J) {
                K._gaCommand('send', J)
              }),
              this.reset()
          }
          return (
            F(j, [
              {
                key: 'gtag',
                value: function () {
                  this._gtag.apply(this, arguments)
                },
              },
            ]),
            j
          )
        })()
        n.GA4 = $
        var te = new $()
        n.default = te
      })(bS)),
    bS
  )
}
var SI
function qte() {
  return (
    SI ||
      ((SI = 1),
      (function (n) {
        function e(a) {
          '@babel/helpers - typeof'
          return (
            (e =
              typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function (c) {
                    return typeof c
                  }
                : function (c) {
                    return c &&
                      typeof Symbol == 'function' &&
                      c.constructor === Symbol &&
                      c !== Symbol.prototype
                      ? 'symbol'
                      : typeof c
                  }),
            e(a)
          )
        }
        Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.default = n.ReactGAImplementation = void 0)
        var t = r(Xte())
        function i(a) {
          if (typeof WeakMap != 'function') return null
          var c = new WeakMap(),
            u = new WeakMap()
          return (i = function (m) {
            return m ? u : c
          })(a)
        }
        function r(a, c) {
          if (a && a.__esModule) return a
          if (a === null || (e(a) !== 'object' && typeof a != 'function'))
            return { default: a }
          var u = i(c)
          if (u && u.has(a)) return u.get(a)
          var h = {},
            m = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var g in a)
            if (g !== 'default' && Object.prototype.hasOwnProperty.call(a, g)) {
              var y = m ? Object.getOwnPropertyDescriptor(a, g) : null
              y && (y.get || y.set)
                ? Object.defineProperty(h, g, y)
                : (h[g] = a[g])
            }
          return (h.default = a), u && u.set(a, h), h
        }
        var s = t.GA4
        n.ReactGAImplementation = s
        var o = t.default
        n.default = o
      })(ES)),
    ES
  )
}
var Yte = qte()
const Zte = Bx(Yte)
var Kte = '@vercel/analytics',
  Qte = '1.4.1',
  Jte = () => {
    window.va ||
      (window.va = function (...e) {
        ;(window.vaq = window.vaq || []).push(e)
      })
  }
function cU() {
  return typeof window < 'u'
}
function uU() {
  try {
    const n = 'production'
  } catch {}
  return 'production'
}
function ene(n = 'auto') {
  if (n === 'auto') {
    window.vam = uU()
    return
  }
  window.vam = n
}
function tne() {
  return (cU() ? window.vam : uU()) || 'production'
}
function CS() {
  return tne() === 'development'
}
var nne = 'https://va.vercel-scripts.com/v1/script.debug.js',
  ine = '/_vercel/insights/script.js'
function rne(n = { debug: !0 }) {
  var e
  if (!cU()) return
  ene(n.mode),
    Jte(),
    n.beforeSend &&
      ((e = window.va) == null || e.call(window, 'beforeSend', n.beforeSend))
  const t = n.scriptSrc || (CS() ? nne : ine)
  if (document.head.querySelector(`script[src*="${t}"]`)) return
  const i = document.createElement('script')
  ;(i.src = t),
    (i.defer = !0),
    (i.dataset.sdkn = Kte + (n.framework ? `/${n.framework}` : '')),
    (i.dataset.sdkv = Qte),
    n.disableAutoTrack && (i.dataset.disableAutoTrack = '1'),
    n.endpoint && (i.dataset.endpoint = n.endpoint),
    n.dsn && (i.dataset.dsn = n.dsn),
    (i.onerror = () => {
      const r = CS()
        ? 'Please check if any ad blockers are enabled and try again.'
        : 'Be sure to enable Web Analytics for your project and deploy again. See https://vercel.com/docs/analytics/quickstart for more information.'
      console.log(
        `[Vercel Web Analytics] Failed to load script from ${t}. ${r}`,
      )
    }),
    CS() && n.debug === !1 && (i.dataset.debug = 'false'),
    document.head.appendChild(i)
}
function sne({ route: n, path: e }) {
  var t
  ;(t = window.va) == null || t.call(window, 'pageview', { route: n, path: e })
}
function one(n) {
  return (
    X.useEffect(() => {
      var e
      n.beforeSend &&
        ((e = window.va) == null || e.call(window, 'beforeSend', n.beforeSend))
    }, [n.beforeSend]),
    X.useEffect(() => {
      rne({
        framework: n.framework || 'react',
        ...(n.route !== void 0 && { disableAutoTrack: !0 }),
        ...n,
      })
    }, []),
    X.useEffect(() => {
      n.route && n.path && sne({ route: n.route, path: n.path })
    }, [n.route, n.path]),
    null
  )
}
var ane = '@vercel/speed-insights',
  lne = '1.1.0',
  cne = () => {
    window.si ||
      (window.si = function (...e) {
        ;(window.siq = window.siq || []).push(e)
      })
  }
function une() {
  return typeof window < 'u'
}
function dne() {
  try {
    const n = 'production'
  } catch {}
  return 'production'
}
function MI() {
  return dne() === 'development'
}
var dU = 'https://va.vercel-scripts.com/v1/speed-insights',
  fne = `${dU}/script.js`,
  hne = `${dU}/script.debug.js`,
  pne = '/_vercel/speed-insights/script.js'
function mne(n = {}) {
  var e
  if (!une() || n.route === null) return null
  cne()
  const i = !!n.dsn ? fne : pne,
    r = n.scriptSrc || (MI() ? hne : i)
  if (document.head.querySelector(`script[src*="${r}"]`)) return null
  n.beforeSend &&
    ((e = window.si) == null || e.call(window, 'beforeSend', n.beforeSend))
  const s = document.createElement('script')
  return (
    (s.src = r),
    (s.defer = !0),
    (s.dataset.sdkn = ane + (n.framework ? `/${n.framework}` : '')),
    (s.dataset.sdkv = lne),
    n.sampleRate && (s.dataset.sampleRate = n.sampleRate.toString()),
    n.route && (s.dataset.route = n.route),
    n.endpoint && (s.dataset.endpoint = n.endpoint),
    n.dsn && (s.dataset.dsn = n.dsn),
    MI() && n.debug === !1 && (s.dataset.debug = 'false'),
    (s.onerror = () => {
      console.log(
        `[Vercel Speed Insights] Failed to load script from ${r}. Please check if any content blockers are enabled and try again.`,
      )
    }),
    document.head.appendChild(s),
    {
      setRoute: (o) => {
        s.dataset.route = o ?? void 0
      },
    }
  )
}
function gne(n) {
  X.useEffect(() => {
    var t
    n.beforeSend &&
      ((t = window.si) == null || t.call(window, 'beforeSend', n.beforeSend))
  }, [n.beforeSend])
  const e = X.useRef(null)
  return (
    X.useEffect(() => {
      if (e.current) n.route && e.current(n.route)
      else {
        const t = mne({ framework: n.framework || 'react', ...n })
        t && (e.current = t.setRoute)
      }
    }, [n.route]),
    null
  )
}
Zte.initialize('G-BW3Q70VFFN')
HU.createRoot(document.getElementById('root')).render(
  b.jsxs(X.StrictMode, {
    children: [b.jsx(one, {}), b.jsx(gne, {}), b.jsx(Gte, {})],
  }),
)
export { vs as _, z_ as a, yte as b, Bx as g, Vs as r }
